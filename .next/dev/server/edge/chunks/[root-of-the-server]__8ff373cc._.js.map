{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/sentry.ts"],"sourcesContent":["// src/lib/sentry.ts\r\n\r\n// Temporary no-op Sentry shim to avoid module errors during dev\r\nconst Sentry = null as any;\r\n\r\nexport const sentry = {\r\n  captureException: (..._args: any[]) => {},\r\n  captureMessage: (..._args: any[]) => {},\r\n  withScope: (fn: (scope: any) => void) => fn({}),\r\n};\r\n\r\n// No-op functions for compatibility\r\nexport function initSentry() {}\r\nexport function setSentryUser(_userId?: string, _apiKeyId?: string) {}\r\nexport function setSentryContext(_context: any) {}\r\nexport function captureException(_error: Error, _context?: any) {}\r\nexport function captureMessage(_message: string, _level: any = 'info', _context?: any) {}\r\n"],"names":[],"mappings":"AAAA,oBAAoB;AAEpB,gEAAgE;;;;;;;;;;;;;;;AAChE,MAAM,SAAS;AAER,MAAM,SAAS;IACpB,kBAAkB,CAAC,GAAG,SAAkB;IACxC,gBAAgB,CAAC,GAAG,SAAkB;IACtC,WAAW,CAAC,KAA6B,GAAG,CAAC;AAC/C;AAGO,SAAS,cAAc;AACvB,SAAS,cAAc,OAAgB,EAAE,SAAkB,GAAG;AAC9D,SAAS,iBAAiB,QAAa,GAAG;AAC1C,SAAS,iBAAiB,MAAa,EAAE,QAAc,GAAG;AAC1D,SAAS,eAAe,QAAgB,EAAE,SAAc,MAAM,EAAE,QAAc,GAAG"}},
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/logger.ts"],"sourcesContent":["// =============================================================================\r\n// Structured Logging\r\n// =============================================================================\r\n// Uses Pino for fast, structured logging\r\n// Supports request ID tracking and different log levels\r\n// All logs include standard fields: timestamp, level, message, requestId, etc.\r\n\r\nimport pino from 'pino';\r\n\r\n// Determine log level from environment\r\nconst logLevel = process.env.LOG_LEVEL || (process.env.NODE_ENV === 'production' ? 'info' : 'debug');\r\n\r\n// Create logger instance with structured output\r\n// In Next.js dev mode, disable pino-pretty transport to avoid worker thread issues\r\n// Use simple JSON output instead (can be prettified by other tools)\r\nconst isNextDev = process.env.NODE_ENV === 'development' && process.env.NEXT_RUNTIME;\r\nconst usePrettyTransport = process.env.NODE_ENV !== 'production' && !isNextDev;\r\n\r\nconst logger = pino({\r\n  level: logLevel,\r\n  transport: usePrettyTransport ? {\r\n    target: 'pino-pretty',\r\n    options: {\r\n      colorize: true,\r\n      translateTime: 'SYS:standard',\r\n      ignore: 'pid,hostname',\r\n    },\r\n  } : undefined,\r\n  formatters: {\r\n    level: (label) => {\r\n      return { level: label.toUpperCase() };\r\n    },\r\n  },\r\n  base: {\r\n    env: process.env.NODE_ENV || 'development',\r\n    service: 'nexflow-api',\r\n  },\r\n  // Ensure timestamps are included\r\n  timestamp: pino.stdTimeFunctions.isoTime,\r\n});\r\n\r\nexport type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';\r\n\r\n/**\r\n * Standard log context fields\r\n */\r\nexport interface LogContext {\r\n  // Request tracking\r\n  requestId?: string;\r\n  apiKeyId?: string;\r\n  endpoint?: string;\r\n  method?: string;\r\n  statusCode?: number;\r\n  durationMs?: number;\r\n  ip?: string;\r\n  \r\n  // Error context\r\n  errorCode?: string;\r\n  error?: Error | any;\r\n  stack?: string;\r\n  \r\n  // CDP/x402 context\r\n  cdpStatus?: string;\r\n  cdpErrorId?: string;\r\n  paymentIntentId?: string;\r\n  x402HeaderId?: string;\r\n  \r\n  // Rate limiting\r\n  rateLimitKey?: string;\r\n  rateLimitRemaining?: number;\r\n  \r\n  // Additional context\r\n  [key: string]: any;\r\n}\r\n\r\n/**\r\n * Create a child logger with additional context\r\n * Useful for request-scoped logging with request IDs\r\n */\r\nexport function createLogger(context?: LogContext | Record<string, any>) {\r\n  return context ? logger.child(context) : logger;\r\n}\r\n\r\n/**\r\n * Get the default logger instance\r\n */\r\nexport function getLogger() {\r\n  return logger;\r\n}\r\n\r\n/**\r\n * Sanitize sensitive data from log context\r\n * Removes API keys, tokens, payment headers, and PII\r\n */\r\nfunction sanitizeContext(context: LogContext): LogContext {\r\n  const sanitized = { ...context };\r\n  \r\n  // Remove sensitive fields\r\n  const sensitiveKeys = [\r\n    'apiKey', 'token', 'authorization', 'x-payment', 'paymentHeader',\r\n    'cardNumber', 'cvv', 'ssn', 'password', 'secret',\r\n  ];\r\n  \r\n  sensitiveKeys.forEach(key => {\r\n    if (key in sanitized) {\r\n      delete sanitized[key];\r\n    }\r\n  });\r\n  \r\n  // Truncate long strings that might contain sensitive data\r\n  Object.keys(sanitized).forEach(key => {\r\n    const value = sanitized[key];\r\n    if (typeof value === 'string' && value.length > 200) {\r\n      sanitized[key] = value.substring(0, 200) + '... [truncated]';\r\n    }\r\n  });\r\n  \r\n  return sanitized;\r\n}\r\n\r\n/**\r\n * Log levels with structured context\r\n */\r\nexport const log = {\r\n  trace: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.trace(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  debug: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.debug(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  info: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.info(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  warn: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.warn(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  error: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.error(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry if error object exists\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'UNKNOWN_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n  fatal: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.fatal(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry for fatal errors\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'FATAL_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n            severity: 'fatal',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport default logger;\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,qBAAqB;AACrB,gFAAgF;AAChF,yCAAyC;AACzC,wDAAwD;AACxD,+EAA+E;;;;;;;;;;;AAE/E;;AAEA,uCAAuC;AACvC,MAAM,WAAW,QAAQ,GAAG,CAAC,SAAS,IAAI,CAAC,sCAAwC,0BAAS,OAAO;AAEnG,gDAAgD;AAChD,mFAAmF;AACnF,oEAAoE;AACpE,MAAM,YAAY,oDAAyB;AAC3C,MAAM,qBAAqB,oDAAyB,gBAAgB,CAAC;AAErE,MAAM,SAAS,IAAA,kJAAI,EAAC;IAClB,OAAO;IACP,WAAW,sCAAqB,0BAO5B;IACJ,YAAY;QACV,OAAO,CAAC;YACN,OAAO;gBAAE,OAAO,MAAM,WAAW;YAAG;QACtC;IACF;IACA,MAAM;QACJ,KAAK,mDAAwB;QAC7B,SAAS;IACX;IACA,iCAAiC;IACjC,WAAW,kJAAI,CAAC,gBAAgB,CAAC,OAAO;AAC1C;AAwCO,SAAS,aAAa,OAA0C;IACrE,OAAO,UAAU,OAAO,KAAK,CAAC,WAAW;AAC3C;AAKO,SAAS;IACd,OAAO;AACT;AAEA;;;CAGC,GACD,SAAS,gBAAgB,OAAmB;IAC1C,MAAM,YAAY;QAAE,GAAG,OAAO;IAAC;IAE/B,0BAA0B;IAC1B,MAAM,gBAAgB;QACpB;QAAU;QAAS;QAAiB;QAAa;QACjD;QAAc;QAAO;QAAO;QAAY;KACzC;IAED,cAAc,OAAO,CAAC,CAAA;QACpB,IAAI,OAAO,WAAW;YACpB,OAAO,SAAS,CAAC,IAAI;QACvB;IACF;IAEA,0DAA0D;IAC1D,OAAO,IAAI,CAAC,WAAW,OAAO,CAAC,CAAA;QAC7B,MAAM,QAAQ,SAAS,CAAC,IAAI;QAC5B,IAAI,OAAO,UAAU,YAAY,MAAM,MAAM,GAAG,KAAK;YACnD,SAAS,CAAC,IAAI,GAAG,MAAM,SAAS,CAAC,GAAG,OAAO;QAC7C;IACF;IAEA,OAAO;AACT;AAKO,MAAM,MAAM;IACjB,OAAO,CAAC,KAAa,SAAsB,GAAG;QAC5C,OAAO,KAAK,CAAC,gBAAgB,WAAW,CAAC,IAAI,QAAQ;IACvD;IACA,OAAO,CAAC,KAAa,SAAsB,GAAG;QAC5C,OAAO,KAAK,CAAC,gBAAgB,WAAW,CAAC,IAAI,QAAQ;IACvD;IACA,MAAM,CAAC,KAAa,SAAsB,GAAG;QAC3C,OAAO,IAAI,CAAC,gBAAgB,WAAW,CAAC,IAAI,QAAQ;IACtD;IACA,MAAM,CAAC,KAAa,SAAsB,GAAG;QAC3C,OAAO,IAAI,CAAC,gBAAgB,WAAW,CAAC,IAAI,QAAQ;IACtD;IACA,OAAO,CAAC,KAAa,SAA8B,GAAG;QACpD,IAAI,aAAyB,CAAC;QAC9B,IAAI;QAEJ,IAAI,mBAAmB,OAAO;YAC5B,WAAW;YACX,aAAa;gBACX,OAAO;gBACP,WAAW,AAAC,QAAgB,IAAI,IAAI;gBACpC,OAAO,QAAQ,KAAK;YACtB;QACF,OAAO,IAAI,WAAW,OAAO,YAAY,UAAU;YACjD,aAAa;YACb,IAAI,WAAW,KAAK,YAAY,OAAO;gBACrC,WAAW,WAAW,KAAK;gBAC3B,WAAW,KAAK,GAAG,WAAW,KAAK,CAAC,KAAK;YAC3C;QACF;QAEA,MAAM,mBAAmB,gBAAgB;QACzC,OAAO,KAAK,CAAC,kBAAkB,QAAQ;QAEvC,yDAAyD;QACzD,IAAI,UAAU;YACZ,IAAI;gBACF,MAAM,EAAE,gBAAgB,EAAE;gBAC1B,iBAAiB,UAAU;oBACzB,WAAW,WAAW,SAAS;oBAC/B,UAAU,WAAW,QAAQ;oBAC7B,UAAU,WAAW,QAAQ;oBAC7B,YAAY,AAAC,WAAmB,UAAU;oBAC1C,QAAQ,WAAW,MAAM;oBACzB,YAAY,WAAW,UAAU;oBACjC,IAAI,WAAW,EAAE;oBACjB,WAAW,AAAC,WAAmB,SAAS;oBACxC,MAAM;wBACJ,WAAW,WAAW,SAAS,IAAI;wBACnC,WAAW,AAAC,WAAmB,SAAS,IAAI;oBAC9C;oBACA,OAAO;wBACL,GAAG,gBAAgB;oBACrB;gBACF;YACF,EAAE,OAAO,aAAa;YACpB,wCAAwC;YAC1C;QACF;IACF;IACA,OAAO,CAAC,KAAa,SAA8B,GAAG;QACpD,IAAI,aAAyB,CAAC;QAC9B,IAAI;QAEJ,IAAI,mBAAmB,OAAO;YAC5B,WAAW;YACX,aAAa;gBACX,OAAO;gBACP,WAAW,AAAC,QAAgB,IAAI,IAAI;gBACpC,OAAO,QAAQ,KAAK;YACtB;QACF,OAAO,IAAI,WAAW,OAAO,YAAY,UAAU;YACjD,aAAa;YACb,IAAI,WAAW,KAAK,YAAY,OAAO;gBACrC,WAAW,WAAW,KAAK;gBAC3B,WAAW,KAAK,GAAG,WAAW,KAAK,CAAC,KAAK;YAC3C;QACF;QAEA,MAAM,mBAAmB,gBAAgB;QACzC,OAAO,KAAK,CAAC,kBAAkB,QAAQ;QAEvC,mDAAmD;QACnD,IAAI,UAAU;YACZ,IAAI;gBACF,MAAM,EAAE,gBAAgB,EAAE;gBAC1B,iBAAiB,UAAU;oBACzB,WAAW,WAAW,SAAS;oBAC/B,UAAU,WAAW,QAAQ;oBAC7B,UAAU,WAAW,QAAQ;oBAC7B,YAAY,AAAC,WAAmB,UAAU;oBAC1C,QAAQ,WAAW,MAAM;oBACzB,YAAY,WAAW,UAAU;oBACjC,IAAI,WAAW,EAAE;oBACjB,WAAW,AAAC,WAAmB,SAAS;oBACxC,MAAM;wBACJ,WAAW,WAAW,SAAS,IAAI;wBACnC,WAAW,AAAC,WAAmB,SAAS,IAAI;wBAC5C,UAAU;oBACZ;oBACA,OAAO;wBACL,GAAG,gBAAgB;oBACrB;gBACF;YACF,EAAE,OAAO,aAAa;YACpB,wCAAwC;YAC1C;QACF;IACF;AACF;uCAEe"}},
    {"offset": {"line": 239, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/request-id.ts"],"sourcesContent":["// =============================================================================\r\n// Request ID Tracking\r\n// =============================================================================\r\n// Generates and tracks request IDs for request correlation\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { createLogger, type LogContext } from './logger';\r\n\r\nconst REQUEST_ID_HEADER = 'x-request-id';\r\nconst REQUEST_ID_CONTEXT_KEY = 'requestId';\r\n\r\n/**\r\n * Generate a unique request ID (UUID v4 format)\r\n * Edge-compatible using Web Crypto API\r\n */\r\nexport function generateRequestId(): string {\r\n  // Generate UUID v4 format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\r\n  const array = new Uint8Array(16);\r\n  crypto.getRandomValues(array);\r\n  \r\n  // Set version (4) and variant bits\r\n  array[6] = (array[6] & 0x0f) | 0x40; // Version 4\r\n  array[8] = (array[8] & 0x3f) | 0x80; // Variant 10\r\n  \r\n  // Convert to UUID string format\r\n  const hex = Array.from(array)\r\n    .map(b => b.toString(16).padStart(2, '0'))\r\n    .join('');\r\n  \r\n  return [\r\n    hex.substring(0, 8),\r\n    hex.substring(8, 12),\r\n    hex.substring(12, 16),\r\n    hex.substring(16, 20),\r\n    hex.substring(20, 32),\r\n  ].join('-');\r\n}\r\n\r\n/**\r\n * Extract request ID from headers or generate a new one\r\n * \r\n * Trusts x-request-id from trusted sources (configurable via TRUSTED_REQUEST_ID_SOURCES env var)\r\n * Default: trusts all sources (can be restricted to specific IPs/domains)\r\n */\r\nexport function getOrCreateRequestId(request: NextRequest): string {\r\n  const existingId = request.headers.get(REQUEST_ID_HEADER);\r\n  \r\n  if (existingId) {\r\n    // Check if we should trust this request ID\r\n    const trustedSources = process.env.TRUSTED_REQUEST_ID_SOURCES?.split(',') || [];\r\n    const shouldTrust = trustedSources.length === 0 || \r\n      trustedSources.some(source => {\r\n        const origin = request.headers.get('origin') || '';\r\n        const referer = request.headers.get('referer') || '';\r\n        return origin.includes(source) || referer.includes(source);\r\n      });\r\n    \r\n    if (shouldTrust) {\r\n      return existingId;\r\n    }\r\n  }\r\n  \r\n  return generateRequestId();\r\n}\r\n\r\n/**\r\n * Add request ID to response headers\r\n */\r\nexport function addRequestIdToResponse(\r\n  response: NextResponse,\r\n  requestId: string\r\n): NextResponse {\r\n  response.headers.set(REQUEST_ID_HEADER, requestId);\r\n  return response;\r\n}\r\n\r\n/**\r\n * Get request ID from AsyncLocalStorage (if available)\r\n */\r\nexport function getRequestId(): string | undefined {\r\n  // In Next.js, we'll use headers instead of AsyncLocalStorage\r\n  // This is simpler and works with the serverless model\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Create a logger with request ID context\r\n * Uses full Pino logger for structured logging\r\n * Works in both Node.js and Edge runtime (Pino handles Edge compatibility)\r\n */\r\nexport function createRequestLogger(requestId: string, additionalContext?: Record<string, any>) {\r\n  const context: LogContext = { requestId, ...additionalContext };\r\n  const logger = createLogger(context);\r\n  \r\n  return {\r\n    info: (message: string, meta?: LogContext) => {\r\n      logger.info({ ...context, ...meta }, message);\r\n    },\r\n    warn: (message: string, meta?: LogContext) => {\r\n      logger.warn({ ...context, ...meta }, message);\r\n    },\r\n    error: (message: string, meta?: LogContext) => {\r\n      logger.error({ ...context, ...meta }, message);\r\n    },\r\n    debug: (message: string, meta?: LogContext) => {\r\n      logger.debug({ ...context, ...meta }, message);\r\n    },\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,sBAAsB;AACtB,gFAAgF;AAChF,2DAA2D;;;;;;;;;;;;;AAG3D;;AAEA,MAAM,oBAAoB;AAC1B,MAAM,yBAAyB;AAMxB,SAAS;IACd,gEAAgE;IAChE,MAAM,QAAQ,IAAI,WAAW;IAC7B,OAAO,eAAe,CAAC;IAEvB,mCAAmC;IACnC,KAAK,CAAC,EAAE,GAAG,AAAC,KAAK,CAAC,EAAE,GAAG,OAAQ,MAAM,YAAY;IACjD,KAAK,CAAC,EAAE,GAAG,AAAC,KAAK,CAAC,EAAE,GAAG,OAAQ,MAAM,aAAa;IAElD,gCAAgC;IAChC,MAAM,MAAM,MAAM,IAAI,CAAC,OACpB,GAAG,CAAC,CAAA,IAAK,EAAE,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG,MACpC,IAAI,CAAC;IAER,OAAO;QACL,IAAI,SAAS,CAAC,GAAG;QACjB,IAAI,SAAS,CAAC,GAAG;QACjB,IAAI,SAAS,CAAC,IAAI;QAClB,IAAI,SAAS,CAAC,IAAI;QAClB,IAAI,SAAS,CAAC,IAAI;KACnB,CAAC,IAAI,CAAC;AACT;AAQO,SAAS,qBAAqB,OAAoB;IACvD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IAEvC,IAAI,YAAY;QACd,2CAA2C;QAC3C,MAAM,iBAAiB,QAAQ,GAAG,CAAC,0BAA0B,EAAE,MAAM,QAAQ,EAAE;QAC/E,MAAM,cAAc,eAAe,MAAM,KAAK,KAC5C,eAAe,IAAI,CAAC,CAAA;YAClB,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC,aAAa;YAChD,MAAM,UAAU,QAAQ,OAAO,CAAC,GAAG,CAAC,cAAc;YAClD,OAAO,OAAO,QAAQ,CAAC,WAAW,QAAQ,QAAQ,CAAC;QACrD;QAEF,IAAI,aAAa;YACf,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAKO,SAAS,uBACd,QAAsB,EACtB,SAAiB;IAEjB,SAAS,OAAO,CAAC,GAAG,CAAC,mBAAmB;IACxC,OAAO;AACT;AAKO,SAAS;IACd,6DAA6D;IAC7D,sDAAsD;IACtD,OAAO;AACT;AAOO,SAAS,oBAAoB,SAAiB,EAAE,iBAAuC;IAC5F,MAAM,UAAsB;QAAE;QAAW,GAAG,iBAAiB;IAAC;IAC9D,MAAM,SAAS,IAAA,4IAAY,EAAC;IAE5B,OAAO;QACL,MAAM,CAAC,SAAiB;YACtB,OAAO,IAAI,CAAC;gBAAE,GAAG,OAAO;gBAAE,GAAG,IAAI;YAAC,GAAG;QACvC;QACA,MAAM,CAAC,SAAiB;YACtB,OAAO,IAAI,CAAC;gBAAE,GAAG,OAAO;gBAAE,GAAG,IAAI;YAAC,GAAG;QACvC;QACA,OAAO,CAAC,SAAiB;YACvB,OAAO,KAAK,CAAC;gBAAE,GAAG,OAAO;gBAAE,GAAG,IAAI;YAAC,GAAG;QACxC;QACA,OAAO,CAAC,SAAiB;YACvB,OAAO,KAAK,CAAC;gBAAE,GAAG,OAAO;gBAAE,GAAG,IAAI;YAAC,GAAG;QACxC;IACF;AACF"}},
    {"offset": {"line": 355, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/ (unsupported edge import 'fs')"],"sourcesContent":["__turbopack_context__.n(__import_unsupported(`fs`));\n"],"names":[],"mappings":"AAAA,sBAAsB,CAAC,CAAC,qBAAqB,CAAC,EAAE,CAAC"}},
    {"offset": {"line": 359, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/ (unsupported edge import 'path')"],"sourcesContent":["__turbopack_context__.n(__import_unsupported(`path`));\n"],"names":[],"mappings":"AAAA,sBAAsB,CAAC,CAAC,qBAAqB,CAAC,IAAI,CAAC"}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/ (unsupported edge import 'stream')"],"sourcesContent":["__turbopack_context__.n(__import_unsupported(`stream`));\n"],"names":[],"mappings":"AAAA,sBAAsB,CAAC,CAAC,qBAAqB,CAAC,MAAM,CAAC"}},
    {"offset": {"line": 367, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/ (unsupported edge import 'crypto')"],"sourcesContent":["__turbopack_context__.n(__import_unsupported(`crypto`));\n"],"names":[],"mappings":"AAAA,sBAAsB,CAAC,CAAC,qBAAqB,CAAC,MAAM,CAAC"}},
    {"offset": {"line": 371, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/ (unsupported edge import 'dns')"],"sourcesContent":["__turbopack_context__.n(__import_unsupported(`dns`));\n"],"names":[],"mappings":"AAAA,sBAAsB,CAAC,CAAC,qBAAqB,CAAC,GAAG,CAAC"}},
    {"offset": {"line": 375, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/ (unsupported edge import 'net')"],"sourcesContent":["__turbopack_context__.n(__import_unsupported(`net`));\n"],"names":[],"mappings":"AAAA,sBAAsB,CAAC,CAAC,qBAAqB,CAAC,GAAG,CAAC"}},
    {"offset": {"line": 379, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/ (unsupported edge import 'tls')"],"sourcesContent":["__turbopack_context__.n(__import_unsupported(`tls`));\n"],"names":[],"mappings":"AAAA,sBAAsB,CAAC,CAAC,qBAAqB,CAAC,GAAG,CAAC"}},
    {"offset": {"line": 383, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/ (unsupported edge import 'string_decoder')"],"sourcesContent":["__turbopack_context__.n(__import_unsupported(`string_decoder`));\n"],"names":[],"mappings":"AAAA,sBAAsB,CAAC,CAAC,qBAAqB,CAAC,cAAc,CAAC"}},
    {"offset": {"line": 388, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/rate-limit-store.ts"],"sourcesContent":["// =============================================================================\r\n// RATE LIMIT STORE\r\n// =============================================================================\r\n// Pluggable backing store for rate limiting with Upstash Redis support and in-memory fallback.\r\n// Supports distributed rate limiting across serverless instances.\r\n//\r\n// Environment Variables:\r\n// - UPSTASH_REDIS_REST_URL: Upstash Redis REST URL (from Vercel integration)\r\n// - UPSTASH_REDIS_REST_TOKEN: Upstash Redis REST token (from Vercel integration)\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'RateLimitStore' });\r\n\r\nexport interface RateLimitEntry {\r\n  count: number;\r\n  resetAt: number;\r\n}\r\n\r\nexport interface RateLimitStore {\r\n  get(key: string): Promise<RateLimitEntry | null>;\r\n  set(key: string, entry: RateLimitEntry): Promise<void>;\r\n  increment(key: string, windowMs: number): Promise<RateLimitEntry>;\r\n}\r\n\r\n// =============================================================================\r\n// IN-MEMORY STORE (fallback)\r\n// =============================================================================\r\n\r\nclass InMemoryStore implements RateLimitStore {\r\n  private store = new Map<string, RateLimitEntry>();\r\n  private cleanupInterval: ReturnType<typeof setInterval> | null = null;\r\n\r\n  constructor() {\r\n    // Cleanup every 5 minutes\r\n    if (typeof setInterval !== 'undefined') {\r\n      this.cleanupInterval = setInterval(() => this.cleanup(), 5 * 60 * 1000);\r\n    }\r\n  }\r\n\r\n  private cleanup(): void {\r\n    const now = Date.now();\r\n    const keysToDelete: string[] = [];\r\n    this.store.forEach((value, key) => {\r\n      if (value.resetAt < now) {\r\n        keysToDelete.push(key);\r\n      }\r\n    });\r\n    keysToDelete.forEach(key => this.store.delete(key));\r\n  }\r\n\r\n  async get(key: string): Promise<RateLimitEntry | null> {\r\n    const entry = this.store.get(key);\r\n    if (!entry || entry.resetAt < Date.now()) {\r\n      return null;\r\n    }\r\n    return entry;\r\n  }\r\n\r\n  async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n    this.store.set(key, entry);\r\n  }\r\n\r\n  async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n    const now = Date.now();\r\n    const existing = this.store.get(key);\r\n\r\n    if (!existing || existing.resetAt < now) {\r\n      const entry = { count: 1, resetAt: now + windowMs };\r\n      this.store.set(key, entry);\r\n      return entry;\r\n    }\r\n\r\n    existing.count++;\r\n    this.store.set(key, existing);\r\n    return existing;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// UPSTASH REDIS STORE (distributed)\r\n// =============================================================================\r\n\r\nclass UpstashRedisStore implements RateLimitStore {\r\n  private redis: any;\r\n\r\n  constructor(redisClient: any) {\r\n    this.redis = redisClient;\r\n  }\r\n\r\n  async get(key: string): Promise<RateLimitEntry | null> {\r\n    try {\r\n      const data = await this.redis.get(`ratelimit:${key}`);\r\n      if (!data) return null;\r\n      \r\n      // Upstash returns parsed JSON automatically if it's a JSON string\r\n      const entry = typeof data === 'string' ? JSON.parse(data) : data;\r\n      if (entry.resetAt < Date.now()) return null;\r\n      return entry as RateLimitEntry;\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis GET failed');\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n    try {\r\n      const ttlMs = Math.max(entry.resetAt - Date.now(), 1000);\r\n      const ttlSeconds = Math.ceil(ttlMs / 1000);\r\n      \r\n      await this.redis.set(\r\n        `ratelimit:${key}`,\r\n        JSON.stringify(entry),\r\n        { ex: ttlSeconds }\r\n      );\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis SET failed');\r\n    }\r\n  }\r\n\r\n  async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n    try {\r\n      const redisKey = `ratelimit:${key}`;\r\n      const now = Date.now();\r\n\r\n      // Get current entry\r\n      const data = await this.redis.get(redisKey);\r\n      \r\n      let count = 1;\r\n      let resetAt = now + windowMs;\r\n      \r\n      if (data) {\r\n        const entry = typeof data === 'string' ? JSON.parse(data) : data;\r\n        if (entry.resetAt > now) {\r\n          count = entry.count + 1;\r\n          resetAt = entry.resetAt;\r\n        }\r\n      }\r\n      \r\n      const newEntry = { count, resetAt };\r\n      const ttlMs = resetAt - now;\r\n      const ttlSeconds = Math.ceil(ttlMs / 1000);\r\n      \r\n      await this.redis.set(redisKey, JSON.stringify(newEntry), { ex: ttlSeconds });\r\n      \r\n      return newEntry;\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis INCR failed');\r\n      // Fallback: return a permissive entry\r\n      return { count: 1, resetAt: Date.now() + windowMs };\r\n    }\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// STORE FACTORY\r\n// =============================================================================\r\n\r\nlet storeInstance: RateLimitStore | null = null;\r\n\r\n/**\r\n * Get the rate limit store singleton.\r\n * Uses Upstash Redis if configured, otherwise falls back to in-memory.\r\n */\r\nexport async function getRateLimitStore(): Promise<RateLimitStore> {\r\n  if (storeInstance) {\r\n    return storeInstance;\r\n  }\r\n\r\n  // Check for Upstash Redis environment variables (set by Vercel integration)\r\n  const upstashUrl = process.env.UPSTASH_REDIS_REST_URL;\r\n  const upstashToken = process.env.UPSTASH_REDIS_REST_TOKEN;\r\n\r\n  if (upstashUrl && upstashToken) {\r\n    try {\r\n      // Dynamic import to avoid build issues\r\n      const { Redis } = await import('@upstash/redis');\r\n      const redis = new Redis({\r\n        url: upstashUrl,\r\n        token: upstashToken,\r\n      });\r\n\r\n      // Test connection\r\n      await redis.ping();\r\n      \r\n      logger.info('Rate limit store using Upstash Redis');\r\n      storeInstance = new UpstashRedisStore(redis);\r\n      return storeInstance;\r\n    } catch (error) {\r\n      logger.warn({ error }, 'Upstash Redis connection failed, falling back to in-memory');\r\n    }\r\n  }\r\n\r\n  // Legacy support: check for REDIS_URL (ioredis)\r\n  const redisUrl = process.env.REDIS_URL;\r\n  if (redisUrl) {\r\n    try {\r\n      const { Redis } = await import('ioredis');\r\n      const redis = new Redis(redisUrl, {\r\n        maxRetriesPerRequest: 3,\r\n        enableReadyCheck: true,\r\n        connectTimeout: 5000,\r\n        lazyConnect: true,\r\n      });\r\n\r\n      await redis.connect();\r\n      logger.info('Rate limit store using Redis (ioredis)');\r\n      \r\n      // Use a simple wrapper that matches UpstashRedisStore behavior\r\n      storeInstance = {\r\n        async get(key: string): Promise<RateLimitEntry | null> {\r\n          const data = await redis.get(`ratelimit:${key}`);\r\n          if (!data) return null;\r\n          const entry = JSON.parse(data) as RateLimitEntry;\r\n          if (entry.resetAt < Date.now()) return null;\r\n          return entry;\r\n        },\r\n        async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n          const ttlMs = Math.max(entry.resetAt - Date.now(), 1000);\r\n          await redis.set(`ratelimit:${key}`, JSON.stringify(entry), 'PX', ttlMs);\r\n        },\r\n        async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n          const now = Date.now();\r\n          const redisKey = `ratelimit:${key}`;\r\n          const data = await redis.get(redisKey);\r\n          \r\n          let count = 1;\r\n          let resetAt = now + windowMs;\r\n          \r\n          if (data) {\r\n            const entry = JSON.parse(data);\r\n            if (entry.resetAt > now) {\r\n              count = entry.count + 1;\r\n              resetAt = entry.resetAt;\r\n            }\r\n          }\r\n          \r\n          const newEntry = { count, resetAt };\r\n          const ttlMs = resetAt - now;\r\n          await redis.set(redisKey, JSON.stringify(newEntry), 'PX', ttlMs);\r\n          return newEntry;\r\n        }\r\n      };\r\n      return storeInstance;\r\n    } catch (error) {\r\n      logger.warn({ error }, 'Redis connection failed, falling back to in-memory');\r\n    }\r\n  }\r\n\r\n  logger.info('Rate limit store using in-memory (non-distributed)');\r\n  storeInstance = new InMemoryStore();\r\n  return storeInstance;\r\n}\r\n\r\n/**\r\n * Synchronous in-memory store for Edge runtime.\r\n * Edge runtime can use Upstash but requires async initialization.\r\n */\r\nexport function getEdgeRateLimitStore(): RateLimitStore {\r\n  // Edge runtime uses in-memory for sync access\r\n  // For async Edge operations, use getRateLimitStore()\r\n  if (!storeInstance) {\r\n    storeInstance = new InMemoryStore();\r\n  }\r\n  return storeInstance;\r\n}\r\n\r\n/**\r\n * Reset the store singleton (for testing)\r\n */\r\nexport function resetRateLimitStore(): void {\r\n  storeInstance = null;\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 638, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/rate-limit-unified.ts"],"sourcesContent":["// =============================================================================\r\n// UNIFIED RATE LIMITING\r\n// =============================================================================\r\n// Single implementation for both Edge and Node.js environments.\r\n// Supports distributed rate limiting via Redis with in-memory fallback.\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { getRateLimitStore, getEdgeRateLimitStore, type RateLimitStore } from './rate-limit-store';\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface RateLimitConfig {\r\n  windowMs: number;\r\n  maxRequests: number;\r\n  identifier: string;\r\n}\r\n\r\nexport interface RateLimitResult {\r\n  allowed: boolean;\r\n  remaining: number;\r\n  resetAt: number;\r\n  limit: number;\r\n}\r\n\r\nexport interface RateLimitTier {\r\n  name: string;\r\n  windowMs: number;\r\n  maxRequests: number;\r\n}\r\n\r\n// =============================================================================\r\n// DEFAULT TIERS\r\n// =============================================================================\r\n\r\nexport const RATE_LIMIT_TIERS: Record<string, RateLimitTier> = {\r\n  // Per-IP global limits\r\n  global: { name: 'global', windowMs: 60 * 60 * 1000, maxRequests: 1000 },\r\n  \r\n  // Per-endpoint limits (per IP, per minute)\r\n  endpoint: { name: 'endpoint', windowMs: 60 * 1000, maxRequests: 100 },\r\n  \r\n  // API key tiers (per hour)\r\n  free: { name: 'free', windowMs: 60 * 60 * 1000, maxRequests: 100 },\r\n  starter: { name: 'starter', windowMs: 60 * 60 * 1000, maxRequests: 1000 },\r\n  pro: { name: 'pro', windowMs: 60 * 60 * 1000, maxRequests: 5000 },\r\n  enterprise: { name: 'enterprise', windowMs: 60 * 60 * 1000, maxRequests: 50000 },\r\n  \r\n  // Cron job rate limiting (per minute)\r\n  cron: { name: 'cron', windowMs: 60 * 1000, maxRequests: 1 },\r\n};\r\n\r\n// =============================================================================\r\n// METRICS TRACKING\r\n// =============================================================================\r\n\r\ninterface RateLimitMetrics {\r\n  requests: Map<string, number>;      // tier:type -> total requests\r\n  blocked: Map<string, number>;       // tier:type -> blocked requests\r\n  latencies: Map<string, number[]>;   // tier:type -> latencies (last 100)\r\n  lastReset: number;\r\n}\r\n\r\nconst metrics: RateLimitMetrics = {\r\n  requests: new Map(),\r\n  blocked: new Map(),\r\n  latencies: new Map(),\r\n  lastReset: Date.now(),\r\n};\r\n\r\nconst MAX_LATENCY_SAMPLES = 100;\r\nconst METRICS_RESET_INTERVAL_MS = 60 * 60 * 1000; // 1 hour\r\n\r\n/**\r\n * Record a rate limit check\r\n */\r\nfunction recordMetric(\r\n  type: string,\r\n  allowed: boolean,\r\n  latencyMs: number\r\n): void {\r\n  // Reset metrics hourly\r\n  const now = Date.now();\r\n  if (now - metrics.lastReset > METRICS_RESET_INTERVAL_MS) {\r\n    metrics.requests.clear();\r\n    metrics.blocked.clear();\r\n    metrics.latencies.clear();\r\n    metrics.lastReset = now;\r\n  }\r\n  \r\n  // Record request\r\n  const key = type;\r\n  metrics.requests.set(key, (metrics.requests.get(key) || 0) + 1);\r\n  \r\n  // Record blocked\r\n  if (!allowed) {\r\n    metrics.blocked.set(key, (metrics.blocked.get(key) || 0) + 1);\r\n  }\r\n  \r\n  // Record latency (keep last N samples)\r\n  let latencies = metrics.latencies.get(key);\r\n  if (!latencies) {\r\n    latencies = [];\r\n    metrics.latencies.set(key, latencies);\r\n  }\r\n  latencies.push(latencyMs);\r\n  if (latencies.length > MAX_LATENCY_SAMPLES) {\r\n    latencies.shift();\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate percentile from sorted array\r\n */\r\nfunction percentile(sorted: number[], p: number): number {\r\n  if (sorted.length === 0) return 0;\r\n  const idx = Math.ceil(sorted.length * p) - 1;\r\n  return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];\r\n}\r\n\r\n/**\r\n * Get rate limit metrics for observability\r\n */\r\nexport function getRateLimitMetrics(): {\r\n  byType: Record<string, {\r\n    total: number;\r\n    blocked: number;\r\n    blockRate: string;\r\n    latency: { p50: number; p95: number; p99: number };\r\n  }>;\r\n  totals: {\r\n    requests: number;\r\n    blocked: number;\r\n    blockRate: string;\r\n  };\r\n  lastReset: string;\r\n} {\r\n  const byType: Record<string, any> = {};\r\n  let totalRequests = 0;\r\n  let totalBlocked = 0;\r\n  \r\n  const types = new Set([\r\n    ...metrics.requests.keys(),\r\n    ...metrics.blocked.keys(),\r\n  ]);\r\n  \r\n  for (const type of types) {\r\n    const requests = metrics.requests.get(type) || 0;\r\n    const blocked = metrics.blocked.get(type) || 0;\r\n    const latencies = metrics.latencies.get(type) || [];\r\n    \r\n    totalRequests += requests;\r\n    totalBlocked += blocked;\r\n    \r\n    // Calculate latency percentiles\r\n    const sorted = [...latencies].sort((a, b) => a - b);\r\n    \r\n    byType[type] = {\r\n      total: requests,\r\n      blocked,\r\n      blockRate: requests > 0 ? ((blocked / requests) * 100).toFixed(2) + '%' : '0%',\r\n      latency: {\r\n        p50: Math.round(percentile(sorted, 0.5)),\r\n        p95: Math.round(percentile(sorted, 0.95)),\r\n        p99: Math.round(percentile(sorted, 0.99)),\r\n      },\r\n    };\r\n  }\r\n  \r\n  return {\r\n    byType,\r\n    totals: {\r\n      requests: totalRequests,\r\n      blocked: totalBlocked,\r\n      blockRate: totalRequests > 0 \r\n        ? ((totalBlocked / totalRequests) * 100).toFixed(2) + '%' \r\n        : '0%',\r\n    },\r\n    lastReset: new Date(metrics.lastReset).toISOString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Reset rate limit metrics (for testing)\r\n */\r\nexport function resetRateLimitMetrics(): void {\r\n  metrics.requests.clear();\r\n  metrics.blocked.clear();\r\n  metrics.latencies.clear();\r\n  metrics.lastReset = Date.now();\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Extract API key from Authorization header\r\n */\r\nexport function extractApiKey(request: NextRequest): string | null {\r\n  const authHeader = request.headers.get('authorization');\r\n  if (!authHeader) return null;\r\n  \r\n  if (authHeader.startsWith('Bearer ')) {\r\n    return authHeader.substring(7).trim();\r\n  }\r\n  return authHeader.trim();\r\n}\r\n\r\n/**\r\n * Get client IP address\r\n */\r\nexport function getClientIp(request: NextRequest): string {\r\n  return (\r\n    request.ip ||\r\n    request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() ||\r\n    request.headers.get('x-real-ip') ||\r\n    'unknown'\r\n  );\r\n}\r\n\r\n/**\r\n * Hash a string for use as rate limit key (don't store full API keys)\r\n */\r\nfunction hashKey(key: string): string {\r\n  // Use first 16 chars as identifier (safe for rate limiting)\r\n  return key.substring(0, 16);\r\n}\r\n\r\n// =============================================================================\r\n// CORE RATE LIMIT CHECK\r\n// =============================================================================\r\n\r\n/**\r\n * Check rate limit against a store\r\n */\r\nasync function checkRateLimitAsync(\r\n  store: RateLimitStore,\r\n  config: RateLimitConfig,\r\n  metricType?: string\r\n): Promise<RateLimitResult> {\r\n  const start = Date.now();\r\n  const entry = await store.increment(config.identifier, config.windowMs);\r\n  \r\n  const allowed = entry.count <= config.maxRequests;\r\n  const remaining = Math.max(0, config.maxRequests - entry.count);\r\n  \r\n  // Record metrics if type provided\r\n  if (metricType) {\r\n    recordMetric(metricType, allowed, Date.now() - start);\r\n  }\r\n  \r\n  return {\r\n    allowed,\r\n    remaining,\r\n    resetAt: entry.resetAt,\r\n    limit: config.maxRequests,\r\n  };\r\n}\r\n\r\n/**\r\n * Synchronous check for Edge runtime\r\n */\r\nfunction checkRateLimitSync(\r\n  store: RateLimitStore,\r\n  config: RateLimitConfig\r\n): RateLimitResult {\r\n  const now = Date.now();\r\n  const key = config.identifier;\r\n  \r\n  // Note: This is a simplified sync version that may not be perfectly accurate\r\n  // but works for Edge runtime where we can't await\r\n  const resetAt = now + config.windowMs;\r\n  \r\n  return {\r\n    allowed: true, // Edge allows through, Node enforces\r\n    remaining: config.maxRequests,\r\n    resetAt,\r\n    limit: config.maxRequests,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API - ASYNC (Node.js)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by API key (Node.js - database lookup)\r\n */\r\nexport async function rateLimitByApiKey(\r\n  request: NextRequest,\r\n  apiKeyRateLimit?: number\r\n): Promise<RateLimitResult | null> {\r\n  const token = extractApiKey(request);\r\n  if (!token) return null;\r\n  \r\n  const store = await getRateLimitStore();\r\n  const limit = apiKeyRateLimit || RATE_LIMIT_TIERS.starter.maxRequests;\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.starter.windowMs,\r\n    maxRequests: limit,\r\n    identifier: `api_key:${hashKey(token)}`,\r\n  }, 'api_key');\r\n}\r\n\r\n/**\r\n * Rate limit by endpoint (Node.js)\r\n */\r\nexport async function rateLimitByEndpoint(\r\n  request: NextRequest,\r\n  endpointId: string,\r\n  maxRequests?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.endpoint.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.endpoint.maxRequests,\r\n    identifier: `endpoint:${endpointId}:${ip}`,\r\n  }, `endpoint:${endpointId}`);\r\n}\r\n\r\n/**\r\n * Rate limit by IP (Node.js)\r\n */\r\nexport async function rateLimitByIp(\r\n  request: NextRequest,\r\n  maxRequests?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.global.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.global.maxRequests,\r\n    identifier: `global:${ip}`,\r\n  }, 'global');\r\n}\r\n\r\n/**\r\n * Rate limit cron job (prevent concurrent runs)\r\n */\r\nexport async function rateLimitCronJob(\r\n  cronId: string,\r\n  intervalMs?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: intervalMs || RATE_LIMIT_TIERS.cron.windowMs,\r\n    maxRequests: RATE_LIMIT_TIERS.cron.maxRequests,\r\n    identifier: `cron:${cronId}`,\r\n  }, `cron:${cronId}`);\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API - SYNC (Edge Runtime)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by IP (Edge - sync, in-memory only)\r\n */\r\nexport function rateLimitByIpEdge(\r\n  request: NextRequest,\r\n  maxRequests?: number\r\n): RateLimitResult {\r\n  const store = getEdgeRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.global.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.global.maxRequests,\r\n    identifier: `global:${ip}`,\r\n  });\r\n}\r\n\r\n/**\r\n * Rate limit by API key (Edge - sync, default limit only)\r\n */\r\nexport function rateLimitByApiKeyEdge(\r\n  request: NextRequest,\r\n  defaultLimit?: number\r\n): RateLimitResult | null {\r\n  const token = extractApiKey(request);\r\n  if (!token) return null;\r\n  \r\n  const store = getEdgeRateLimitStore();\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.starter.windowMs,\r\n    maxRequests: defaultLimit || RATE_LIMIT_TIERS.starter.maxRequests,\r\n    identifier: `api_key:${hashKey(token)}`,\r\n  });\r\n}\r\n\r\n// =============================================================================\r\n// RESPONSE HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Add rate limit headers to response\r\n */\r\nexport function addRateLimitHeaders(\r\n  response: NextResponse,\r\n  result: RateLimitResult\r\n): NextResponse {\r\n  response.headers.set('X-RateLimit-Limit', result.limit.toString());\r\n  response.headers.set('X-RateLimit-Remaining', result.remaining.toString());\r\n  response.headers.set('X-RateLimit-Reset', new Date(result.resetAt).toISOString());\r\n  return response;\r\n}\r\n\r\n/**\r\n * Create rate limit error response\r\n */\r\nexport function createRateLimitResponse(result: RateLimitResult): NextResponse {\r\n  const resetDate = new Date(result.resetAt).toISOString();\r\n  const retryAfter = Math.ceil((result.resetAt - Date.now()) / 1000);\r\n  \r\n  const response = NextResponse.json(\r\n    {\r\n      error: 'Rate limit exceeded',\r\n      code: 'RATE_LIMIT_EXCEEDED',\r\n      message: `Too many requests. Limit: ${result.limit} per hour. Try again after ${resetDate}`,\r\n      retryAfter,\r\n    },\r\n    { status: 429 }\r\n  );\r\n  \r\n  response.headers.set('Retry-After', retryAfter.toString());\r\n  return addRateLimitHeaders(response, result);\r\n}\r\n\r\n// =============================================================================\r\n// COMPOSITE CHECKS\r\n// =============================================================================\r\n\r\n/**\r\n * Check all rate limits (API key + endpoint + global)\r\n * Returns first exceeded limit, or null if all pass\r\n */\r\nexport async function checkAllRateLimits(\r\n  request: NextRequest,\r\n  options?: {\r\n    endpointId?: string;\r\n    apiKeyRateLimit?: number;\r\n  }\r\n): Promise<{ result: RateLimitResult; type: string } | null> {\r\n  // 1. Global IP limit\r\n  const globalResult = await rateLimitByIp(request);\r\n  if (!globalResult.allowed) {\r\n    return { result: globalResult, type: 'global' };\r\n  }\r\n  \r\n  // 2. API key limit (if authenticated)\r\n  const apiKeyResult = await rateLimitByApiKey(request, options?.apiKeyRateLimit);\r\n  if (apiKeyResult && !apiKeyResult.allowed) {\r\n    return { result: apiKeyResult, type: 'api_key' };\r\n  }\r\n  \r\n  // 3. Endpoint limit (if specified)\r\n  if (options?.endpointId) {\r\n    const endpointResult = await rateLimitByEndpoint(request, options.endpointId);\r\n    if (!endpointResult.allowed) {\r\n      return { result: endpointResult, type: 'endpoint' };\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * Get rate limit info for response headers (async version)\r\n * Returns the most restrictive limit for informational headers\r\n */\r\nexport async function getRateLimitHeaders(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): Promise<RateLimitResult | null> {\r\n  const results: RateLimitResult[] = [];\r\n\r\n  // Global IP limit\r\n  const globalResult = await rateLimitByIp(request);\r\n  results.push(globalResult);\r\n\r\n  // API key limit\r\n  const apiKeyResult = await rateLimitByApiKey(request);\r\n  if (apiKeyResult) {\r\n    results.push(apiKeyResult);\r\n  }\r\n\r\n  // Endpoint limit\r\n  if (endpointId) {\r\n    const endpointResult = await rateLimitByEndpoint(request, endpointId);\r\n    results.push(endpointResult);\r\n  }\r\n\r\n  // Return the most restrictive (lowest remaining)\r\n  if (results.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return results.reduce((min, current) =>\r\n    current.remaining < min.remaining ? current : min\r\n  );\r\n}\r\n\r\n// =============================================================================\r\n// EDGE-COMPATIBLE FUNCTIONS (Sync)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by endpoint (Edge - sync, in-memory only)\r\n */\r\nexport function rateLimitByEndpointEdge(\r\n  request: NextRequest,\r\n  endpointId: string,\r\n  maxRequests?: number\r\n): RateLimitResult {\r\n  const store = getEdgeRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.endpoint.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.endpoint.maxRequests,\r\n    identifier: `endpoint:${endpointId}:${ip}`,\r\n  });\r\n}\r\n\r\n/**\r\n * Check all rate limits (Edge-compatible, sync version)\r\n * Returns first exceeded limit, or null if all pass\r\n */\r\nexport function checkAllRateLimitsEdge(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): { result: RateLimitResult; type: string } | null {\r\n  // 1. Global IP limit\r\n  const globalResult = rateLimitByIpEdge(request);\r\n  if (!globalResult.allowed) {\r\n    return { result: globalResult, type: 'global' };\r\n  }\r\n  \r\n  // 2. API key limit (Edge uses default limit)\r\n  const apiKeyResult = rateLimitByApiKeyEdge(request);\r\n  if (apiKeyResult && !apiKeyResult.allowed) {\r\n    return { result: apiKeyResult, type: 'api_key' };\r\n  }\r\n  \r\n  // 3. Endpoint limit (if specified)\r\n  if (endpointId) {\r\n    const endpointResult = rateLimitByEndpointEdge(request, endpointId);\r\n    if (!endpointResult.allowed) {\r\n      return { result: endpointResult, type: 'endpoint' };\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * Get rate limit info for response headers (Edge-compatible, sync version)\r\n */\r\nexport function getRateLimitHeadersEdge(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): RateLimitResult | null {\r\n  const results: RateLimitResult[] = [];\r\n\r\n  // Global IP limit\r\n  results.push(rateLimitByIpEdge(request));\r\n\r\n  // API key limit\r\n  const apiKeyResult = rateLimitByApiKeyEdge(request);\r\n  if (apiKeyResult) {\r\n    results.push(apiKeyResult);\r\n  }\r\n\r\n  // Endpoint limit\r\n  if (endpointId) {\r\n    results.push(rateLimitByEndpointEdge(request, endpointId));\r\n  }\r\n\r\n  // Return the most restrictive (lowest remaining)\r\n  if (results.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return results.reduce((min, current) =>\r\n    current.remaining < min.remaining ? current : min\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1056, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/security-monitor.ts"],"sourcesContent":["// =============================================================================\r\n// SECURITY MONITORING & THREAT DETECTION\r\n// =============================================================================\r\n// Real-time security monitoring and threat detection for all requests\r\n// Implements agent-based security scanning for all in/out traffic\r\n//\r\n// Configuration (environment variables):\r\n// - SECURITY_SHADOW_MODE: 'true' (default) = log-only, 'false' = enforce\r\n// - SECURITY_ENFORCE_SQL_INJECTION: 'true' = block SQL injection attempts\r\n// - SECURITY_ENFORCE_XSS: 'true' = block XSS attempts\r\n// - SECURITY_ENFORCE_PATH_TRAVERSAL: 'true' = block path traversal\r\n// - SECURITY_ENFORCE_COMMAND_INJECTION: 'true' = block command injection\r\n// - SECURITY_ENFORCE_AUTH_BYPASS: 'true' = block auth bypass attempts\r\n// - SECURITY_VIOLATION_THRESHOLD: Number of violations before auto-block (default: 10)\r\n// - SECURITY_VIOLATION_WINDOW_MS: Time window for violations (default: 300000 = 5min)\r\n// - SECURITY_MAX_BLOCKS_PER_HOUR: Safety cap (default: 100)\r\n// - SECURITY_MAX_BLOCKS_PER_DAY: Safety cap (default: 1000)\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'SecurityMonitor' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface SecurityEvent {\r\n  type: 'threat' | 'suspicious' | 'anomaly' | 'violation';\r\n  severity: 'critical' | 'high' | 'medium' | 'low';\r\n  category: string;\r\n  description: string;\r\n  requestId: string;\r\n  ip: string;\r\n  path: string;\r\n  method: string;\r\n  userAgent?: string;\r\n  details?: Record<string, any>;\r\n  timestamp: string;\r\n  // Correlation fields for full traceability\r\n  conversationId?: string;\r\n  agentId?: string;\r\n  x402TxHash?: string;\r\n  failureCode?: string;\r\n  // Shadow mode tracking\r\n  wouldHaveBlocked?: boolean;\r\n}\r\n\r\nexport interface SecurityScanResult {\r\n  safe: boolean;\r\n  threats: SecurityEvent[];\r\n  riskScore: number; // 0-100\r\n  recommendations: string[];\r\n  // Shadow mode info\r\n  shadowMode: boolean;\r\n  wouldBlock: boolean;\r\n}\r\n\r\nexport interface SecurityMetrics {\r\n  // Threat counts by category\r\n  threatsByCategory: Record<string, number>;\r\n  // Shadow mode metrics\r\n  shadowModeStats: {\r\n    enabled: boolean;\r\n    wouldHaveBlocked: number;\r\n    totalScanned: number;\r\n    blockedCategories: Record<string, number>;\r\n  };\r\n  // Enforcement stats\r\n  enforcementStats: {\r\n    blocked: number;\r\n    allowed: number;\r\n    byCategory: Record<string, { blocked: number; allowed: number }>;\r\n  };\r\n  // Violation rate limiting\r\n  violationRateLimiting: {\r\n    ipsRateLimited: number;\r\n    violationsInWindow: number;\r\n  };\r\n  // Time period\r\n  since: string;\r\n}\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\n// Global shadow mode (master switch)\r\nconst SHADOW_MODE_ENABLED = process.env.SECURITY_SHADOW_MODE !== 'false'; // Default to true for safety\r\n\r\n// Per-category enforcement flags (granular control)\r\nconst ENFORCEMENT_FLAGS = {\r\n  sql_injection: process.env.SECURITY_ENFORCE_SQL_INJECTION === 'true',\r\n  xss: process.env.SECURITY_ENFORCE_XSS === 'true',\r\n  path_traversal: process.env.SECURITY_ENFORCE_PATH_TRAVERSAL === 'true',\r\n  command_injection: process.env.SECURITY_ENFORCE_COMMAND_INJECTION === 'true',\r\n  auth_bypass: process.env.SECURITY_ENFORCE_AUTH_BYPASS === 'true',\r\n  suspicious_user_agent: process.env.SECURITY_ENFORCE_SUSPICIOUS_UA === 'true',\r\n  suspicious_path: process.env.SECURITY_ENFORCE_SUSPICIOUS_PATH === 'true',\r\n  missing_auth: false, // Always shadow mode - too many false positives\r\n};\r\n\r\n// Violation-based rate limiting\r\nconst VIOLATION_THRESHOLD = parseInt(process.env.SECURITY_VIOLATION_THRESHOLD || '10', 10);\r\nconst VIOLATION_WINDOW_MS = parseInt(process.env.SECURITY_VIOLATION_WINDOW_MS || '300000', 10); // 5 minutes\r\n\r\n// Safety caps to prevent mass blocking\r\nconst MAX_BLOCKS_PER_HOUR = parseInt(process.env.SECURITY_MAX_BLOCKS_PER_HOUR || '100', 10);\r\nconst MAX_BLOCKS_PER_DAY = parseInt(process.env.SECURITY_MAX_BLOCKS_PER_DAY || '1000', 10);\r\n\r\n// =============================================================================\r\n// IN-MEMORY STORES\r\n// =============================================================================\r\n\r\n// Threat store (upgrade to Redis in production)\r\nconst threatStore = new Map<string, {\r\n  count: number;\r\n  firstSeen: number;\r\n  lastSeen: number;\r\n  events: SecurityEvent[];\r\n}>();\r\n\r\n// Violation rate limiting store\r\nconst violationStore = new Map<string, {\r\n  violations: number;\r\n  windowStart: number;\r\n  blocked: boolean;\r\n}>();\r\n\r\n// Track blocks per time window\r\nconst blocksThisHour = new Map<string, number>();\r\nconst blocksThisDay = new Map<string, number>();\r\n\r\n// Shadow mode metrics\r\nconst shadowModeMetrics = {\r\n  startTime: Date.now(),\r\n  totalScanned: 0,\r\n  wouldHaveBlocked: 0,\r\n  blockedByCategory: new Map<string, number>(),\r\n  actuallyBlocked: 0,\r\n  actuallyAllowed: 0,\r\n  threatsByCategory: new Map<string, number>(),\r\n};\r\n\r\n// =============================================================================\r\n// CLEANUP INTERVALS\r\n// =============================================================================\r\n\r\n// Cleanup block counters every hour\r\nsetInterval(() => {\r\n  blocksThisHour.clear();\r\n}, 60 * 60 * 1000);\r\n\r\n// Cleanup daily block counters every day\r\nsetInterval(() => {\r\n  blocksThisDay.clear();\r\n}, 24 * 60 * 60 * 1000);\r\n\r\n// Cleanup old threats every 10 minutes\r\nsetInterval(() => {\r\n  const now = Date.now();\r\n  const maxAge = 24 * 60 * 60 * 1000; // 24 hours\r\n  const keysToDelete: string[] = [];\r\n  \r\n  threatStore.forEach((value, key) => {\r\n    if (now - value.lastSeen > maxAge) {\r\n      keysToDelete.push(key);\r\n    }\r\n  });\r\n  \r\n  keysToDelete.forEach(key => threatStore.delete(key));\r\n}, 10 * 60 * 1000);\r\n\r\n// Cleanup violation store every 10 minutes\r\nsetInterval(() => {\r\n  const now = Date.now();\r\n  const keysToDelete: string[] = [];\r\n  \r\n  violationStore.forEach((value, key) => {\r\n    if (now - value.windowStart > VIOLATION_WINDOW_MS * 2) {\r\n      keysToDelete.push(key);\r\n    }\r\n  });\r\n  \r\n  keysToDelete.forEach(key => violationStore.delete(key));\r\n}, 10 * 60 * 1000);\r\n\r\n/**\r\n * SQL Injection Detection Patterns\r\n */\r\nconst SQL_INJECTION_PATTERNS = [\r\n  /(\\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|EXECUTE|UNION|SCRIPT)\\b)/i,\r\n  /('|\\\\'|;|--|\\/\\*|\\*\\/|\\+|%)/i,\r\n  /(\\bOR\\b.*=.*)/i,\r\n  /(\\bAND\\b.*=.*)/i,\r\n  /(\\bUNION\\b.*SELECT)/i,\r\n];\r\n\r\n/**\r\n * XSS Detection Patterns\r\n */\r\nconst XSS_PATTERNS = [\r\n  /<script[^>]*>.*?<\\/script>/gi,\r\n  /javascript:/i,\r\n  /on\\w+\\s*=/i, // onclick=, onerror=, etc.\r\n  /<iframe[^>]*>/gi,\r\n  /<img[^>]*src[^>]*javascript:/i,\r\n  /<svg[^>]*onload/i,\r\n];\r\n\r\n/**\r\n * Path Traversal Patterns\r\n */\r\nconst PATH_TRAVERSAL_PATTERNS = [\r\n  /\\.\\.\\//g,\r\n  /\\.\\.\\\\/g,\r\n  /\\.\\.%2F/i,\r\n  /\\.\\.%5C/i,\r\n  /%2e%2e%2f/i,\r\n  /%2e%2e%5c/i,\r\n];\r\n\r\n/**\r\n * Command Injection Patterns\r\n */\r\nconst COMMAND_INJECTION_PATTERNS = [\r\n  /[;&|`$(){}[\\]]/,\r\n  /\\b(cat|ls|pwd|whoami|id|uname|ps|kill|rm|mv|cp)\\b/i,\r\n  /\\|\\s*(nc|netcat|wget|curl|bash|sh)/i,\r\n];\r\n\r\n/**\r\n * Suspicious User Agent Patterns\r\n */\r\nconst SUSPICIOUS_USER_AGENTS = [\r\n  /sqlmap/i,\r\n  /nikto/i,\r\n  /nmap/i,\r\n  /masscan/i,\r\n  /zap/i,\r\n  /burp/i,\r\n  /scanner/i,\r\n  /bot.*crawler/i,\r\n];\r\n\r\n/**\r\n * Rate Limit Violation Thresholds\r\n */\r\nconst RATE_LIMIT_THRESHOLDS = {\r\n  critical: 100, // requests per minute\r\n  high: 50,\r\n  medium: 20,\r\n};\r\n\r\n/**\r\n * Scan request for security threats\r\n * Extracts correlation fields (conversation_id, agent_id, x402_tx_hash) from headers\r\n */\r\nexport function scanRequest(request: NextRequest, requestId: string): SecurityScanResult {\r\n  const path = request.nextUrl.pathname;\r\n  \r\n  // Whitelist internal/system endpoints that should not be scanned\r\n  // These are trusted internal endpoints (Vercel cron, health checks, x402 endpoints)\r\n  // x402 endpoints are whitelisted because payment headers contain base64/JSON\r\n  // that triggers false positives for command injection patterns\r\n  const whitelistedPaths = [\r\n    // Vercel cron job endpoints (all internal)\r\n    '/api/cron/', // All cron endpoints (dogfood, scout, probes, pull-metrics, etc.)\r\n    \r\n    // x402 router and verification endpoints\r\n    '/api/x402/router/', // Router execute endpoint (used by agents)\r\n    '/api/x402/verify', // x402 verification endpoint\r\n    '/api/x402/health', // x402 health check\r\n    \r\n    // Health checks\r\n    '/api/health', // Health check endpoint\r\n    \r\n    // Metered and demo x402 endpoints\r\n    '/api/v1/metered/', // All metered x402 endpoints (url-enrich, etc.)\r\n    '/api/v1/x402/', // x402 demo endpoints\r\n    '/api/test/hello-world', // Test endpoint with x402\r\n    \r\n    // Debug endpoints (internal)\r\n    '/api/debug/', // Debug endpoints (smf-facilitators, etc.)\r\n  ];\r\n  \r\n  // Check if path matches any whitelisted path (exact match or prefix match)\r\n  const isWhitelisted = whitelistedPaths.some(whitelisted => \r\n    path === whitelisted || \r\n    path.startsWith(whitelisted) ||  // Handles /api/v1/metered/url-enrich matching /api/v1/metered/\r\n    (whitelisted.endsWith('/') ? path.startsWith(whitelisted) : path.startsWith(whitelisted + '/'))\r\n  );\r\n  \r\n  if (isWhitelisted) {\r\n    // Skip all security scanning for whitelisted paths\r\n    return {\r\n      safe: true,\r\n      threats: [],\r\n      riskScore: 0,\r\n      recommendations: [],\r\n    };\r\n  }\r\n  \r\n  const threats: SecurityEvent[] = [];\r\n  const ip = request.ip || request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';\r\n  const method = request.method;\r\n  const userAgent = request.headers.get('user-agent') || undefined;\r\n  const url = request.nextUrl.toString();\r\n  const queryParams = Object.fromEntries(request.nextUrl.searchParams);\r\n  \r\n  // Extract correlation fields for full traceability\r\n  const conversationId = request.headers.get('x-conversation-id') || \r\n                         request.headers.get('x-request-id') || \r\n                         undefined;\r\n  const agentId = request.headers.get('x-agent-id') || undefined;\r\n  const x402TxHash = request.headers.get('x-x402-tx-hash') || undefined;\r\n  \r\n  // Get request body if available (for POST/PUT/PATCH)\r\n  let bodyText = '';\r\n  try {\r\n    // Note: Body can only be read once, so this is a best-effort scan\r\n    // In production, consider cloning the request for scanning\r\n  } catch {\r\n    // Body not available for scanning\r\n  }\r\n\r\n  // 1. SQL Injection Detection\r\n  const sqlInjectionThreats = detectSQLInjection(url, queryParams, bodyText);\r\n  // Add correlation fields to all threats\r\n  sqlInjectionThreats.forEach(threat => {\r\n    threat.requestId = requestId;\r\n    threat.ip = ip;\r\n    threat.path = path;\r\n    threat.method = method;\r\n    threat.userAgent = userAgent;\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...sqlInjectionThreats);\r\n\r\n  // 2. XSS Detection\r\n  const xssThreats = detectXSS(url, queryParams, bodyText);\r\n  xssThreats.forEach(threat => {\r\n    threat.requestId = requestId;\r\n    threat.ip = ip;\r\n    threat.path = path;\r\n    threat.method = method;\r\n    threat.userAgent = userAgent;\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...xssThreats);\r\n\r\n  // 3. Path Traversal Detection\r\n  const pathTraversalThreats = detectPathTraversal(path, queryParams);\r\n  pathTraversalThreats.forEach(threat => {\r\n    threat.requestId = requestId;\r\n    threat.ip = ip;\r\n    threat.path = path;\r\n    threat.method = method;\r\n    threat.userAgent = userAgent;\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...pathTraversalThreats);\r\n\r\n  // 4. Command Injection Detection\r\n  const commandInjectionThreats = detectCommandInjection(url, queryParams, bodyText);\r\n  commandInjectionThreats.forEach(threat => {\r\n    threat.requestId = requestId;\r\n    threat.ip = ip;\r\n    threat.path = path;\r\n    threat.method = method;\r\n    threat.userAgent = userAgent;\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...commandInjectionThreats);\r\n\r\n  // 5. Suspicious User Agent Detection\r\n  if (userAgent && isSuspiciousUserAgent(userAgent)) {\r\n    threats.push({\r\n      type: 'suspicious',\r\n      severity: 'medium',\r\n      category: 'suspicious_user_agent',\r\n      description: `Suspicious user agent detected: ${userAgent.substring(0, 100)}`,\r\n      requestId,\r\n      ip,\r\n      path,\r\n      method,\r\n      userAgent,\r\n      conversationId,\r\n      agentId,\r\n      x402TxHash,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  }\r\n\r\n  // 6. Unusual Request Pattern Detection\r\n  const anomalyThreats = detectAnomalies(request, requestId);\r\n  anomalyThreats.forEach(threat => {\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...anomalyThreats);\r\n\r\n  // 7. Authentication Bypass Attempts\r\n  const authBypassThreats = detectAuthBypass(request, requestId);\r\n  authBypassThreats.forEach(threat => {\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...authBypassThreats);\r\n\r\n  // Calculate risk score\r\n  const riskScore = calculateRiskScore(threats);\r\n\r\n  // Generate recommendations\r\n  const recommendations = generateRecommendations(threats, riskScore);\r\n\r\n  // Update metrics\r\n  shadowModeMetrics.totalScanned++;\r\n  \r\n  // Track threats by category\r\n  for (const threat of threats) {\r\n    const currentCount = shadowModeMetrics.threatsByCategory.get(threat.category) || 0;\r\n    shadowModeMetrics.threatsByCategory.set(threat.category, currentCount + 1);\r\n  }\r\n\r\n  // Determine if we would block this request\r\n  const wouldBlock = shouldBlockRequest(threats, ip);\r\n  \r\n  // Track shadow mode \"would have blocked\" metrics\r\n  if (wouldBlock && SHADOW_MODE_ENABLED) {\r\n    shadowModeMetrics.wouldHaveBlocked++;\r\n    for (const threat of threats) {\r\n      const currentCount = shadowModeMetrics.blockedByCategory.get(threat.category) || 0;\r\n      shadowModeMetrics.blockedByCategory.set(threat.category, currentCount + 1);\r\n      threat.wouldHaveBlocked = true;\r\n    }\r\n  }\r\n\r\n  // Log threats\r\n  if (threats.length > 0) {\r\n    logger.warn({\r\n      requestId,\r\n      ip,\r\n      path,\r\n      method,\r\n      threatCount: threats.length,\r\n      riskScore,\r\n      wouldBlock,\r\n      shadowMode: SHADOW_MODE_ENABLED,\r\n      threats: threats.map(t => ({\r\n        type: t.type,\r\n        severity: t.severity,\r\n        category: t.category,\r\n        wouldHaveBlocked: t.wouldHaveBlocked,\r\n      })),\r\n    }, SHADOW_MODE_ENABLED && wouldBlock \r\n      ? 'Security threats detected (SHADOW MODE - would have blocked)' \r\n      : 'Security threats detected');\r\n  }\r\n\r\n  // Store threats for IP tracking\r\n  if (threats.length > 0) {\r\n    storeThreat(ip, threats);\r\n    \r\n    // Track violations for rate limiting\r\n    trackViolation(ip, threats.length);\r\n  }\r\n\r\n  // Track enforcement stats\r\n  if (!SHADOW_MODE_ENABLED && wouldBlock) {\r\n    shadowModeMetrics.actuallyBlocked++;\r\n  } else {\r\n    shadowModeMetrics.actuallyAllowed++;\r\n  }\r\n\r\n  return {\r\n    safe: threats.length === 0,\r\n    threats,\r\n    riskScore,\r\n    recommendations,\r\n    shadowMode: SHADOW_MODE_ENABLED,\r\n    wouldBlock,\r\n  };\r\n}\r\n\r\n/**\r\n * Detect SQL injection attempts\r\n */\r\nfunction detectSQLInjection(url: string, queryParams: Record<string, string>, body: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const textToScan = `${url} ${JSON.stringify(queryParams)} ${body}`;\r\n\r\n  for (const pattern of SQL_INJECTION_PATTERNS) {\r\n    if (pattern.test(textToScan)) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'critical',\r\n        category: 'sql_injection',\r\n        description: 'Potential SQL injection attempt detected',\r\n        requestId: '', // Will be set by caller\r\n        ip: '', // Will be set by caller\r\n        path: '', // Will be set by caller\r\n        method: '', // Will be set by caller\r\n        details: { pattern: pattern.toString(), matched: textToScan.substring(0, 200) },\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Detect XSS attempts\r\n */\r\nfunction detectXSS(url: string, queryParams: Record<string, string>, body: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const textToScan = `${url} ${JSON.stringify(queryParams)} ${body}`;\r\n\r\n  for (const pattern of XSS_PATTERNS) {\r\n    if (pattern.test(textToScan)) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'high',\r\n        category: 'xss',\r\n        description: 'Potential XSS attempt detected',\r\n        requestId: '', // Will be set by caller\r\n        ip: '', // Will be set by caller\r\n        path: '', // Will be set by caller\r\n        method: '', // Will be set by caller\r\n        details: { pattern: pattern.toString() },\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Detect path traversal attempts\r\n */\r\nfunction detectPathTraversal(path: string, queryParams: Record<string, string>): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const textToScan = `${path} ${JSON.stringify(queryParams)}`;\r\n\r\n  for (const pattern of PATH_TRAVERSAL_PATTERNS) {\r\n    if (pattern.test(textToScan)) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'high',\r\n        category: 'path_traversal',\r\n        description: 'Potential path traversal attempt detected',\r\n        requestId: '', // Will be set by caller\r\n        ip: '', // Will be set by caller\r\n        path: '', // Will be set by caller\r\n        method: '', // Will be set by caller\r\n        details: { pattern: pattern.toString() },\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Detect command injection attempts\r\n */\r\nfunction detectCommandInjection(url: string, queryParams: Record<string, string>, body: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const textToScan = `${url} ${JSON.stringify(queryParams)} ${body}`;\r\n\r\n  for (const pattern of COMMAND_INJECTION_PATTERNS) {\r\n    if (pattern.test(textToScan)) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'critical',\r\n        category: 'command_injection',\r\n        description: 'Potential command injection attempt detected',\r\n        requestId: '', // Will be set by caller\r\n        ip: '', // Will be set by caller\r\n        path: '', // Will be set by caller\r\n        method: '', // Will be set by caller\r\n        details: { pattern: pattern.toString() },\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Check if user agent is suspicious\r\n */\r\nfunction isSuspiciousUserAgent(userAgent: string): boolean {\r\n  return SUSPICIOUS_USER_AGENTS.some(pattern => pattern.test(userAgent));\r\n}\r\n\r\n/**\r\n * Detect anomalies in request patterns\r\n */\r\nfunction detectAnomalies(request: NextRequest, requestId: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const ip = request.ip || request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';\r\n  const path = request.nextUrl.pathname;\r\n\r\n  // Check for unusual path patterns\r\n  if (path.includes('admin') || path.includes('config') || path.includes('.env')) {\r\n    threats.push({\r\n      type: 'suspicious',\r\n      severity: 'medium',\r\n      category: 'suspicious_path',\r\n      description: `Suspicious path accessed: ${path}`,\r\n      requestId,\r\n      ip,\r\n      path,\r\n      method: request.method,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  }\r\n\r\n  // Check for missing required headers on sensitive endpoints\r\n  if (path.startsWith('/api/v1/') && !request.headers.get('authorization')) {\r\n    threats.push({\r\n      type: 'violation',\r\n      severity: 'medium',\r\n      category: 'missing_auth',\r\n      description: 'Unauthenticated request to protected endpoint',\r\n      requestId,\r\n      ip,\r\n      path,\r\n      method: request.method,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Detect authentication bypass attempts\r\n */\r\nfunction detectAuthBypass(request: NextRequest, requestId: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const authHeader = request.headers.get('authorization');\r\n\r\n  // Check for common bypass attempts\r\n  if (authHeader) {\r\n    // Empty token\r\n    if (authHeader.trim() === 'Bearer' || authHeader.trim() === '') {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'high',\r\n        category: 'auth_bypass',\r\n        description: 'Empty authorization token detected',\r\n        requestId,\r\n        ip: request.ip || 'unknown',\r\n        path: request.nextUrl.pathname,\r\n        method: request.method,\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n\r\n    // Suspicious token patterns\r\n    if (authHeader.includes('null') || authHeader.includes('undefined') || authHeader.includes('true')) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'medium',\r\n        category: 'auth_bypass',\r\n        description: 'Suspicious authorization token pattern',\r\n        requestId,\r\n        ip: request.ip || 'unknown',\r\n        path: request.nextUrl.pathname,\r\n        method: request.method,\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Calculate risk score (0-100)\r\n */\r\nfunction calculateRiskScore(threats: SecurityEvent[]): number {\r\n  if (threats.length === 0) return 0;\r\n\r\n  const severityWeights = {\r\n    critical: 25,\r\n    high: 15,\r\n    medium: 8,\r\n    low: 3,\r\n  };\r\n\r\n  let score = 0;\r\n  for (const threat of threats) {\r\n    score += severityWeights[threat.severity];\r\n  }\r\n\r\n  // Cap at 100\r\n  return Math.min(100, score);\r\n}\r\n\r\n/**\r\n * Generate security recommendations\r\n */\r\nfunction generateRecommendations(threats: SecurityEvent[], riskScore: number): string[] {\r\n  const recommendations: string[] = [];\r\n\r\n  if (riskScore >= 50) {\r\n    recommendations.push('Consider blocking this IP address');\r\n    recommendations.push('Review security logs immediately');\r\n  }\r\n\r\n  if (threats.some(t => t.category === 'sql_injection')) {\r\n    recommendations.push('SQL injection attempt detected - ensure parameterized queries are used');\r\n  }\r\n\r\n  if (threats.some(t => t.category === 'xss')) {\r\n    recommendations.push('XSS attempt detected - ensure input sanitization is enabled');\r\n  }\r\n\r\n  if (threats.some(t => t.category === 'command_injection')) {\r\n    recommendations.push('Command injection attempt detected - review system commands');\r\n  }\r\n\r\n  if (threats.some(t => t.category === 'auth_bypass')) {\r\n    recommendations.push('Authentication bypass attempt - review auth middleware');\r\n  }\r\n\r\n  return recommendations;\r\n}\r\n\r\n/**\r\n * Store threat for IP tracking\r\n */\r\nfunction storeThreat(ip: string, threats: SecurityEvent[]): void {\r\n  const existing = threatStore.get(ip);\r\n  const now = Date.now();\r\n\r\n  if (existing) {\r\n    existing.count += threats.length;\r\n    existing.lastSeen = now;\r\n    existing.events.push(...threats);\r\n    // Keep last 100 events per IP\r\n    if (existing.events.length > 100) {\r\n      existing.events = existing.events.slice(-100);\r\n    }\r\n  } else {\r\n    threatStore.set(ip, {\r\n      count: threats.length,\r\n      firstSeen: now,\r\n      lastSeen: now,\r\n      events: [...threats],\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Determine if a request should be blocked based on threats and enforcement settings\r\n */\r\nfunction shouldBlockRequest(threats: SecurityEvent[], ip: string): boolean {\r\n  if (threats.length === 0) return false;\r\n  \r\n  // Check if IP is rate limited due to violations\r\n  if (isIpViolationRateLimited(ip)) {\r\n    return true;\r\n  }\r\n  \r\n  // Check global shadow mode\r\n  if (SHADOW_MODE_ENABLED) {\r\n    // In shadow mode, check if ANY category would have blocked\r\n    // This is for metrics - we won't actually block\r\n    for (const threat of threats) {\r\n      const categoryKey = threat.category as keyof typeof ENFORCEMENT_FLAGS;\r\n      if (ENFORCEMENT_FLAGS[categoryKey]) {\r\n        return true; // Would have blocked\r\n      }\r\n    }\r\n    \r\n    // Also check severity-based blocking\r\n    if (threats.some(t => t.severity === 'critical')) {\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n  \r\n  // Enforcement mode - check per-category flags\r\n  for (const threat of threats) {\r\n    const categoryKey = threat.category as keyof typeof ENFORCEMENT_FLAGS;\r\n    if (ENFORCEMENT_FLAGS[categoryKey]) {\r\n      return true;\r\n    }\r\n  }\r\n  \r\n  // Block on critical severity\r\n  if (threats.some(t => t.severity === 'critical')) {\r\n    return true;\r\n  }\r\n  \r\n  return false;\r\n}\r\n\r\n/**\r\n * Track a violation for rate limiting purposes\r\n */\r\nfunction trackViolation(ip: string, count: number): void {\r\n  const now = Date.now();\r\n  const existing = violationStore.get(ip);\r\n  \r\n  if (existing) {\r\n    // Check if we're still in the same window\r\n    if (now - existing.windowStart < VIOLATION_WINDOW_MS) {\r\n      existing.violations += count;\r\n      \r\n      // Check if threshold exceeded\r\n      if (existing.violations >= VIOLATION_THRESHOLD && !existing.blocked) {\r\n        existing.blocked = true;\r\n        logger.warn({\r\n          ip,\r\n          violations: existing.violations,\r\n          threshold: VIOLATION_THRESHOLD,\r\n          windowMs: VIOLATION_WINDOW_MS,\r\n        }, 'IP rate limited due to security violations');\r\n      }\r\n    } else {\r\n      // Start new window\r\n      violationStore.set(ip, {\r\n        violations: count,\r\n        windowStart: now,\r\n        blocked: false,\r\n      });\r\n    }\r\n  } else {\r\n    violationStore.set(ip, {\r\n      violations: count,\r\n      windowStart: now,\r\n      blocked: false,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Check if an IP is rate limited due to violations\r\n */\r\nfunction isIpViolationRateLimited(ip: string): boolean {\r\n  const record = violationStore.get(ip);\r\n  if (!record) return false;\r\n  \r\n  const now = Date.now();\r\n  \r\n  // Check if still in the rate limit window\r\n  if (now - record.windowStart > VIOLATION_WINDOW_MS) {\r\n    // Window expired, reset\r\n    record.blocked = false;\r\n    record.violations = 0;\r\n    record.windowStart = now;\r\n    return false;\r\n  }\r\n  \r\n  return record.blocked;\r\n}\r\n\r\n/**\r\n * Check if a specific category should be enforced (not in shadow mode)\r\n */\r\nexport function isCategoryEnforced(category: string): boolean {\r\n  if (SHADOW_MODE_ENABLED) return false;\r\n  \r\n  const categoryKey = category as keyof typeof ENFORCEMENT_FLAGS;\r\n  return ENFORCEMENT_FLAGS[categoryKey] ?? false;\r\n}\r\n\r\n/**\r\n * Get current security configuration status\r\n */\r\nexport function getSecurityConfig(): {\r\n  shadowMode: boolean;\r\n  enforcementFlags: Record<string, boolean>;\r\n  violationThreshold: number;\r\n  violationWindowMs: number;\r\n  maxBlocksPerHour: number;\r\n  maxBlocksPerDay: number;\r\n} {\r\n  return {\r\n    shadowMode: SHADOW_MODE_ENABLED,\r\n    enforcementFlags: { ...ENFORCEMENT_FLAGS },\r\n    violationThreshold: VIOLATION_THRESHOLD,\r\n    violationWindowMs: VIOLATION_WINDOW_MS,\r\n    maxBlocksPerHour: MAX_BLOCKS_PER_HOUR,\r\n    maxBlocksPerDay: MAX_BLOCKS_PER_DAY,\r\n  };\r\n}\r\n\r\n/**\r\n * Get threat history for an IP\r\n */\r\nexport function getThreatHistory(ip: string): {\r\n  count: number;\r\n  firstSeen: number;\r\n  lastSeen: number;\r\n  events: SecurityEvent[];\r\n} | null {\r\n  return threatStore.get(ip) || null;\r\n}\r\n\r\n/**\r\n * Check if IP should be blocked\r\n * Implements shadow mode, violation rate limiting, and safety caps\r\n */\r\nexport function shouldBlockIp(ip: string): boolean {\r\n  // Check violation-based rate limiting first (works even in shadow mode if violation threshold exceeded)\r\n  if (isIpViolationRateLimited(ip)) {\r\n    // Still respect shadow mode for actual blocking\r\n    if (SHADOW_MODE_ENABLED) {\r\n      logger.info({ ip }, 'IP would be blocked (violation rate limit) - SHADOW MODE');\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // Shadow mode: log-only, don't block\r\n  if (SHADOW_MODE_ENABLED) {\r\n    return false; // Log-only mode\r\n  }\r\n\r\n  // Safety caps: prevent mass blocking\r\n  const hourCount = blocksThisHour.get(ip) || 0;\r\n  const dayCount = blocksThisDay.get(ip) || 0;\r\n  \r\n  if (hourCount >= MAX_BLOCKS_PER_HOUR) {\r\n    logger.warn({ ip, hourCount }, 'Block cap reached for hour');\r\n    return false; // Cap reached, don't block more\r\n  }\r\n  \r\n  if (dayCount >= MAX_BLOCKS_PER_DAY) {\r\n    logger.warn({ ip, dayCount }, 'Block cap reached for day');\r\n    return false; // Cap reached, don't block more\r\n  }\r\n\r\n  const history = threatStore.get(ip);\r\n  if (!history) return false;\r\n\r\n  // Block if:\r\n  // - More than 10 threats in last hour\r\n  // - Any critical severity threat with enforcement enabled\r\n  const oneHourAgo = Date.now() - 60 * 60 * 1000;\r\n  const recentThreats = history.events.filter(e => \r\n    new Date(e.timestamp).getTime() > oneHourAgo\r\n  );\r\n\r\n  if (recentThreats.length > 10) {\r\n    blocksThisHour.set(ip, hourCount + 1);\r\n    blocksThisDay.set(ip, dayCount + 1);\r\n    return true;\r\n  }\r\n  \r\n  // Check for critical threats with enforcement\r\n  const criticalEnforcedThreats = recentThreats.filter(e => {\r\n    if (e.severity !== 'critical') return false;\r\n    const categoryKey = e.category as keyof typeof ENFORCEMENT_FLAGS;\r\n    return ENFORCEMENT_FLAGS[categoryKey] ?? false;\r\n  });\r\n  \r\n  if (criticalEnforcedThreats.length > 0) {\r\n    blocksThisHour.set(ip, hourCount + 1);\r\n    blocksThisDay.set(ip, dayCount + 1);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Get all blocked IPs\r\n */\r\nexport function getBlockedIps(): string[] {\r\n  const blocked: string[] = [];\r\n  threatStore.forEach((_, ip) => {\r\n    if (shouldBlockIp(ip)) {\r\n      blocked.push(ip);\r\n    }\r\n  });\r\n  return blocked;\r\n}\r\n\r\n/**\r\n * Get IPs that are violation rate-limited\r\n */\r\nexport function getViolationRateLimitedIps(): Array<{\r\n  ip: string;\r\n  violations: number;\r\n  windowStart: number;\r\n}> {\r\n  const rateLimited: Array<{ ip: string; violations: number; windowStart: number }> = [];\r\n  const now = Date.now();\r\n  \r\n  violationStore.forEach((record, ip) => {\r\n    if (record.blocked && now - record.windowStart < VIOLATION_WINDOW_MS) {\r\n      rateLimited.push({\r\n        ip,\r\n        violations: record.violations,\r\n        windowStart: record.windowStart,\r\n      });\r\n    }\r\n  });\r\n  \r\n  return rateLimited;\r\n}\r\n\r\n/**\r\n * Get security metrics for monitoring dashboards\r\n */\r\nexport function getSecurityMetrics(): SecurityMetrics {\r\n  // Convert Map to object for threatsByCategory\r\n  const threatsByCategory: Record<string, number> = {};\r\n  shadowModeMetrics.threatsByCategory.forEach((count, category) => {\r\n    threatsByCategory[category] = count;\r\n  });\r\n  \r\n  // Convert Map to object for blockedByCategory\r\n  const blockedCategories: Record<string, number> = {};\r\n  shadowModeMetrics.blockedByCategory.forEach((count, category) => {\r\n    blockedCategories[category] = count;\r\n  });\r\n  \r\n  // Build per-category enforcement stats\r\n  const byCategory: Record<string, { blocked: number; allowed: number }> = {};\r\n  Object.keys(ENFORCEMENT_FLAGS).forEach(category => {\r\n    const totalForCategory = threatsByCategory[category] || 0;\r\n    const blockedForCategory = blockedCategories[category] || 0;\r\n    byCategory[category] = {\r\n      blocked: blockedForCategory,\r\n      allowed: totalForCategory - blockedForCategory,\r\n    };\r\n  });\r\n  \r\n  // Count rate-limited IPs\r\n  let ipsRateLimited = 0;\r\n  let violationsInWindow = 0;\r\n  const now = Date.now();\r\n  \r\n  violationStore.forEach((record) => {\r\n    if (record.blocked && now - record.windowStart < VIOLATION_WINDOW_MS) {\r\n      ipsRateLimited++;\r\n    }\r\n    if (now - record.windowStart < VIOLATION_WINDOW_MS) {\r\n      violationsInWindow += record.violations;\r\n    }\r\n  });\r\n  \r\n  return {\r\n    threatsByCategory,\r\n    shadowModeStats: {\r\n      enabled: SHADOW_MODE_ENABLED,\r\n      wouldHaveBlocked: shadowModeMetrics.wouldHaveBlocked,\r\n      totalScanned: shadowModeMetrics.totalScanned,\r\n      blockedCategories,\r\n    },\r\n    enforcementStats: {\r\n      blocked: shadowModeMetrics.actuallyBlocked,\r\n      allowed: shadowModeMetrics.actuallyAllowed,\r\n      byCategory,\r\n    },\r\n    violationRateLimiting: {\r\n      ipsRateLimited,\r\n      violationsInWindow,\r\n    },\r\n    since: new Date(shadowModeMetrics.startTime).toISOString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Reset security metrics (for testing)\r\n */\r\nexport function resetSecurityMetrics(): void {\r\n  shadowModeMetrics.startTime = Date.now();\r\n  shadowModeMetrics.totalScanned = 0;\r\n  shadowModeMetrics.wouldHaveBlocked = 0;\r\n  shadowModeMetrics.blockedByCategory.clear();\r\n  shadowModeMetrics.actuallyBlocked = 0;\r\n  shadowModeMetrics.actuallyAllowed = 0;\r\n  shadowModeMetrics.threatsByCategory.clear();\r\n  violationStore.clear();\r\n  threatStore.clear();\r\n  blocksThisHour.clear();\r\n  blocksThisDay.clear();\r\n  logger.info('Security metrics reset');\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1933, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport type { NextRequest } from 'next/server';\r\nimport { getOrCreateRequestId, addRequestIdToResponse } from '@/lib/request-id';\r\nimport { createRequestLogger } from '@/lib/request-id';\r\nimport { checkAllRateLimitsEdge, addRateLimitHeaders, createRateLimitResponse, getRateLimitHeadersEdge } from '@/lib/rate-limit-unified';\r\nimport { scanRequest, shouldBlockIp, type SecurityScanResult } from '@/lib/security-monitor';\r\nimport { setSentryContext } from '@/lib/sentry';\r\n\r\n/**\r\n * Middleware to handle:\r\n * - Discovery subdomain redirect (minimal API-only landing)\r\n * - Request ID tracking\r\n * - Rate limiting\r\n * - x402 payment headers\r\n * - Request logging\r\n */\r\nexport async function middleware(request: NextRequest) {\r\n  // Allow .well-known paths to pass through without processing (for verification files)\r\n  // These are served from public folder and should not be processed\r\n  if (request.nextUrl.pathname.startsWith('/.well-known')) {\r\n    return NextResponse.next();\r\n  }\r\n  \r\n  // API SUBDOMAINS: Make landing pages \"invisible\" - show minimal API info instead\r\n  const hostname = request.headers.get('host') || '';\r\n  \r\n  if (request.nextUrl.pathname === '/') {\r\n    // discovery.nexflowapp.app  minimal discovery API page\r\n    if (hostname.startsWith('discovery.')) {\r\n      return NextResponse.rewrite(new URL('/discovery-api', request.url));\r\n    }\r\n    // api.nexflowapp.app  minimal main API page\r\n    if (hostname.startsWith('api.')) {\r\n      return NextResponse.rewrite(new URL('/api-landing', request.url));\r\n    }\r\n  }\r\n  \r\n  // Only process API routes for the rest of the middleware\r\n  if (!request.nextUrl.pathname.startsWith('/api')) {\r\n    return NextResponse.next();\r\n  }\r\n\r\n  // Generate or extract request ID\r\n  const requestId = getOrCreateRequestId(request);\r\n  const ip = request.ip || request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';\r\n  const logger = createRequestLogger(requestId, {\r\n    method: request.method,\r\n    path: request.nextUrl.pathname,\r\n    ip,\r\n  });\r\n\r\n  // SECURITY: Check if IP is blocked\r\n  if (shouldBlockIp(ip)) {\r\n    logger.warn('Blocked request', { ip, reason: 'IP blocked due to security threats' });\r\n    return NextResponse.json(\r\n      {\r\n        error: 'Access denied',\r\n        code: 'IP_BLOCKED',\r\n        message: 'Your IP address has been blocked due to security violations',\r\n      },\r\n      { status: 403 }\r\n    );\r\n  }\r\n\r\n  // SECURITY: Scan request for threats\r\n  // Note: Agents are advisors only - all enforcement is deterministic\r\n  const securityScan = scanRequest(request, requestId);\r\n  if (!securityScan.safe) {\r\n    logger.warn('Security threats detected', {\r\n      threatCount: securityScan.threats.length,\r\n      riskScore: securityScan.riskScore,\r\n      threats: securityScan.threats.map(t => ({ \r\n        type: t.type, \r\n        severity: t.severity, \r\n        category: t.category,\r\n        conversationId: t.conversationId,\r\n        agentId: t.agentId,\r\n        x402TxHash: t.x402TxHash,\r\n      })),\r\n    });\r\n\r\n    // Block if critical threats detected (only if shadow mode is disabled)\r\n    // Shadow mode: new rules start in log-only mode for review\r\n    if (securityScan.threats.some(t => t.severity === 'critical')) {\r\n      // In shadow mode, we log but don't block\r\n      // Set SECURITY_SHADOW_MODE=false to enable blocking\r\n      const shadowMode = process.env.SECURITY_SHADOW_MODE !== 'false';\r\n      if (!shadowMode) {\r\n        return NextResponse.json(\r\n          {\r\n            error: 'Security violation detected',\r\n            code: 'SECURITY_VIOLATION',\r\n            message: 'Request blocked due to security threats',\r\n          },\r\n          { status: 403 }\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Log request\r\n  logger.info('Incoming request');\r\n\r\n  // Extract endpoint ID from path if it's a metered endpoint\r\n  const pathMatch = request.nextUrl.pathname.match(/\\/api\\/v1\\/metered\\/([^/]+)/);\r\n  const endpointId = pathMatch ? pathMatch[1] : undefined;\r\n\r\n  // Check rate limits (Edge-compatible, no database access)\r\n  const rateLimitCheck = checkAllRateLimitsEdge(request, endpointId);\r\n  if (rateLimitCheck && !rateLimitCheck.result.allowed) {\r\n    logger.warn('Rate limit exceeded', {\r\n      rateLimitType: rateLimitCheck.type,\r\n      limit: rateLimitCheck.result.limit,\r\n      remaining: rateLimitCheck.result.remaining,\r\n    });\r\n    \r\n    const response = createRateLimitResponse(rateLimitCheck.result);\r\n    addRequestIdToResponse(response, requestId);\r\n    return response;\r\n  }\r\n\r\n  // Extract x-payment header if present\r\n  const paymentHeader = request.headers.get('x-payment') || request.headers.get('X-Payment');\r\n\r\n  // Create request headers with payment header forwarded\r\n  // This ensures the x-payment header reaches the route handler\r\n  const requestHeaders = new Headers(request.headers);\r\n  \r\n  // Log payment header presence for debugging\r\n  if (paymentHeader) {\r\n    logger.debug('Payment header detected', { \r\n      headerLength: paymentHeader.length,\r\n      hasX402Prefix: paymentHeader.startsWith('x402 '),\r\n    });\r\n    // Ensure payment header is in the forwarded headers\r\n    requestHeaders.set('x-payment', paymentHeader);\r\n  }\r\n\r\n  // Add payment header to request headers for API routes to access\r\n  const response = NextResponse.next({\r\n    request: {\r\n      headers: requestHeaders,\r\n    },\r\n  });\r\n  \r\n  // Add request ID to response\r\n  addRequestIdToResponse(response, requestId);\r\n  \r\n  // Add rate limit headers (even if not exceeded)\r\n  const rateLimitHeaders = getRateLimitHeadersEdge(request, endpointId);\r\n  if (rateLimitHeaders) {\r\n    addRateLimitHeaders(response, rateLimitHeaders);\r\n  }\r\n\r\n  return response;\r\n}\r\n\r\n// Configure which routes to run middleware on\r\n// Match: root path (for discovery subdomain redirect) + API routes\r\nexport const config = {\r\n  matcher: [\r\n    '/',           // Root path (for discovery subdomain redirect)\r\n    '/api/:path*', // API routes\r\n  ],\r\n};\r\n\r\n"],"names":[],"mappings":"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"}}]
}