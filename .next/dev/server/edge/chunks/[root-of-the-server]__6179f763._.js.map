{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/sentry.ts"],"sourcesContent":["// src/lib/sentry.ts\r\n\r\n// Temporary no-op Sentry shim to avoid module errors during dev\r\nconst Sentry = null as any;\r\n\r\nexport const sentry = {\r\n  captureException: (..._args: any[]) => {},\r\n  captureMessage: (..._args: any[]) => {},\r\n  withScope: (fn: (scope: any) => void) => fn({}),\r\n};\r\n\r\n// No-op functions for compatibility\r\nexport function initSentry() {}\r\nexport function setSentryUser(_userId?: string, _apiKeyId?: string) {}\r\nexport function setSentryContext(_context: any) {}\r\nexport function captureException(_error: Error, _context?: any) {}\r\nexport function captureMessage(_message: string, _level: any = 'info', _context?: any) {}\r\n"],"names":[],"mappings":"AAAA,oBAAoB;AAEpB,gEAAgE;;;;;;;;;;;;;;;AAChE,MAAM,SAAS;AAER,MAAM,SAAS;IACpB,kBAAkB,CAAC,GAAG,SAAkB;IACxC,gBAAgB,CAAC,GAAG,SAAkB;IACtC,WAAW,CAAC,KAA6B,GAAG,CAAC;AAC/C;AAGO,SAAS,cAAc;AACvB,SAAS,cAAc,OAAgB,EAAE,SAAkB,GAAG;AAC9D,SAAS,iBAAiB,QAAa,GAAG;AAC1C,SAAS,iBAAiB,MAAa,EAAE,QAAc,GAAG;AAC1D,SAAS,eAAe,QAAgB,EAAE,SAAc,MAAM,EAAE,QAAc,GAAG"}},
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/logger.ts"],"sourcesContent":["// =============================================================================\r\n// Structured Logging\r\n// =============================================================================\r\n// Uses Pino for fast, structured logging\r\n// Supports request ID tracking and different log levels\r\n// All logs include standard fields: timestamp, level, message, requestId, etc.\r\n\r\nimport pino from 'pino';\r\n\r\n// Determine log level from environment\r\nconst logLevel = process.env.LOG_LEVEL || (process.env.NODE_ENV === 'production' ? 'info' : 'debug');\r\n\r\n// Create logger instance with structured output\r\n// In Next.js dev mode, disable pino-pretty transport to avoid worker thread issues\r\n// Use simple JSON output instead (can be prettified by other tools)\r\nconst isNextDev = process.env.NODE_ENV === 'development' && process.env.NEXT_RUNTIME;\r\nconst usePrettyTransport = process.env.NODE_ENV !== 'production' && !isNextDev;\r\n\r\nconst logger = pino({\r\n  level: logLevel,\r\n  transport: usePrettyTransport ? {\r\n    target: 'pino-pretty',\r\n    options: {\r\n      colorize: true,\r\n      translateTime: 'SYS:standard',\r\n      ignore: 'pid,hostname',\r\n    },\r\n  } : undefined,\r\n  formatters: {\r\n    level: (label) => {\r\n      return { level: label.toUpperCase() };\r\n    },\r\n  },\r\n  base: {\r\n    env: process.env.NODE_ENV || 'development',\r\n    service: 'nexflow-api',\r\n  },\r\n  // Ensure timestamps are included\r\n  timestamp: pino.stdTimeFunctions.isoTime,\r\n});\r\n\r\nexport type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';\r\n\r\n/**\r\n * Standard log context fields\r\n */\r\nexport interface LogContext {\r\n  // Request tracking\r\n  requestId?: string;\r\n  apiKeyId?: string;\r\n  endpoint?: string;\r\n  method?: string;\r\n  statusCode?: number;\r\n  durationMs?: number;\r\n  ip?: string;\r\n  \r\n  // Error context\r\n  errorCode?: string;\r\n  error?: Error | any;\r\n  stack?: string;\r\n  \r\n  // CDP/x402 context\r\n  cdpStatus?: string;\r\n  cdpErrorId?: string;\r\n  paymentIntentId?: string;\r\n  x402HeaderId?: string;\r\n  \r\n  // Rate limiting\r\n  rateLimitKey?: string;\r\n  rateLimitRemaining?: number;\r\n  \r\n  // Additional context\r\n  [key: string]: any;\r\n}\r\n\r\n/**\r\n * Create a child logger with additional context\r\n * Useful for request-scoped logging with request IDs\r\n */\r\nexport function createLogger(context?: LogContext | Record<string, any>) {\r\n  return context ? logger.child(context) : logger;\r\n}\r\n\r\n/**\r\n * Get the default logger instance\r\n */\r\nexport function getLogger() {\r\n  return logger;\r\n}\r\n\r\n/**\r\n * Sanitize sensitive data from log context\r\n * Removes API keys, tokens, payment headers, and PII\r\n */\r\nfunction sanitizeContext(context: LogContext): LogContext {\r\n  const sanitized = { ...context };\r\n  \r\n  // Remove sensitive fields\r\n  const sensitiveKeys = [\r\n    'apiKey', 'token', 'authorization', 'x-payment', 'paymentHeader',\r\n    'cardNumber', 'cvv', 'ssn', 'password', 'secret',\r\n  ];\r\n  \r\n  sensitiveKeys.forEach(key => {\r\n    if (key in sanitized) {\r\n      delete sanitized[key];\r\n    }\r\n  });\r\n  \r\n  // Truncate long strings that might contain sensitive data\r\n  Object.keys(sanitized).forEach(key => {\r\n    const value = sanitized[key];\r\n    if (typeof value === 'string' && value.length > 200) {\r\n      sanitized[key] = value.substring(0, 200) + '... [truncated]';\r\n    }\r\n  });\r\n  \r\n  return sanitized;\r\n}\r\n\r\n/**\r\n * Log levels with structured context\r\n */\r\nexport const log = {\r\n  trace: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.trace(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  debug: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.debug(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  info: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.info(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  warn: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.warn(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  error: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.error(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry if error object exists\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'UNKNOWN_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n  fatal: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.fatal(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry for fatal errors\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'FATAL_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n            severity: 'fatal',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport default logger;\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 239, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/request-id.ts"],"sourcesContent":["// =============================================================================\r\n// Request ID Tracking\r\n// =============================================================================\r\n// Generates and tracks request IDs for request correlation\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { createLogger, type LogContext } from './logger';\r\n\r\nconst REQUEST_ID_HEADER = 'x-request-id';\r\nconst REQUEST_ID_CONTEXT_KEY = 'requestId';\r\n\r\n/**\r\n * Generate a unique request ID (UUID v4 format)\r\n * Edge-compatible using Web Crypto API\r\n */\r\nexport function generateRequestId(): string {\r\n  // Generate UUID v4 format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\r\n  const array = new Uint8Array(16);\r\n  crypto.getRandomValues(array);\r\n  \r\n  // Set version (4) and variant bits\r\n  array[6] = (array[6] & 0x0f) | 0x40; // Version 4\r\n  array[8] = (array[8] & 0x3f) | 0x80; // Variant 10\r\n  \r\n  // Convert to UUID string format\r\n  const hex = Array.from(array)\r\n    .map(b => b.toString(16).padStart(2, '0'))\r\n    .join('');\r\n  \r\n  return [\r\n    hex.substring(0, 8),\r\n    hex.substring(8, 12),\r\n    hex.substring(12, 16),\r\n    hex.substring(16, 20),\r\n    hex.substring(20, 32),\r\n  ].join('-');\r\n}\r\n\r\n/**\r\n * Extract request ID from headers or generate a new one\r\n * \r\n * Trusts x-request-id from trusted sources (configurable via TRUSTED_REQUEST_ID_SOURCES env var)\r\n * Default: trusts all sources (can be restricted to specific IPs/domains)\r\n */\r\nexport function getOrCreateRequestId(request: NextRequest): string {\r\n  const existingId = request.headers.get(REQUEST_ID_HEADER);\r\n  \r\n  if (existingId) {\r\n    // Check if we should trust this request ID\r\n    const trustedSources = process.env.TRUSTED_REQUEST_ID_SOURCES?.split(',') || [];\r\n    const shouldTrust = trustedSources.length === 0 || \r\n      trustedSources.some(source => {\r\n        const origin = request.headers.get('origin') || '';\r\n        const referer = request.headers.get('referer') || '';\r\n        return origin.includes(source) || referer.includes(source);\r\n      });\r\n    \r\n    if (shouldTrust) {\r\n      return existingId;\r\n    }\r\n  }\r\n  \r\n  return generateRequestId();\r\n}\r\n\r\n/**\r\n * Add request ID to response headers\r\n */\r\nexport function addRequestIdToResponse(\r\n  response: NextResponse,\r\n  requestId: string\r\n): NextResponse {\r\n  response.headers.set(REQUEST_ID_HEADER, requestId);\r\n  return response;\r\n}\r\n\r\n/**\r\n * Get request ID from AsyncLocalStorage (if available)\r\n */\r\nexport function getRequestId(): string | undefined {\r\n  // In Next.js, we'll use headers instead of AsyncLocalStorage\r\n  // This is simpler and works with the serverless model\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Create a logger with request ID context\r\n * Uses full Pino logger for structured logging\r\n * Works in both Node.js and Edge runtime (Pino handles Edge compatibility)\r\n */\r\nexport function createRequestLogger(requestId: string, additionalContext?: Record<string, any>) {\r\n  const context: LogContext = { requestId, ...additionalContext };\r\n  const logger = createLogger(context);\r\n  \r\n  return {\r\n    info: (message: string, meta?: LogContext) => {\r\n      logger.info({ ...context, ...meta }, message);\r\n    },\r\n    warn: (message: string, meta?: LogContext) => {\r\n      logger.warn({ ...context, ...meta }, message);\r\n    },\r\n    error: (message: string, meta?: LogContext) => {\r\n      logger.error({ ...context, ...meta }, message);\r\n    },\r\n    debug: (message: string, meta?: LogContext) => {\r\n      logger.debug({ ...context, ...meta }, message);\r\n    },\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,sBAAsB;AACtB,gFAAgF;AAChF,2DAA2D;;;;;;;;;;;;;AAG3D;;AAEA,MAAM,oBAAoB;AAC1B,MAAM,yBAAyB;AAMxB,SAAS;IACd,gEAAgE;IAChE,MAAM,QAAQ,IAAI,WAAW;IAC7B,OAAO,eAAe,CAAC;IAEvB,mCAAmC;IACnC,KAAK,CAAC,EAAE,GAAG,AAAC,KAAK,CAAC,EAAE,GAAG,OAAQ,MAAM,YAAY;IACjD,KAAK,CAAC,EAAE,GAAG,AAAC,KAAK,CAAC,EAAE,GAAG,OAAQ,MAAM,aAAa;IAElD,gCAAgC;IAChC,MAAM,MAAM,MAAM,IAAI,CAAC,OACpB,GAAG,CAAC,CAAA,IAAK,EAAE,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG,MACpC,IAAI,CAAC;IAER,OAAO;QACL,IAAI,SAAS,CAAC,GAAG;QACjB,IAAI,SAAS,CAAC,GAAG;QACjB,IAAI,SAAS,CAAC,IAAI;QAClB,IAAI,SAAS,CAAC,IAAI;QAClB,IAAI,SAAS,CAAC,IAAI;KACnB,CAAC,IAAI,CAAC;AACT;AAQO,SAAS,qBAAqB,OAAoB;IACvD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IAEvC,IAAI,YAAY;QACd,2CAA2C;QAC3C,MAAM,iBAAiB,QAAQ,GAAG,CAAC,0BAA0B,EAAE,MAAM,QAAQ,EAAE;QAC/E,MAAM,cAAc,eAAe,MAAM,KAAK,KAC5C,eAAe,IAAI,CAAC,CAAA;YAClB,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC,aAAa;YAChD,MAAM,UAAU,QAAQ,OAAO,CAAC,GAAG,CAAC,cAAc;YAClD,OAAO,OAAO,QAAQ,CAAC,WAAW,QAAQ,QAAQ,CAAC;QACrD;QAEF,IAAI,aAAa;YACf,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAKO,SAAS,uBACd,QAAsB,EACtB,SAAiB;IAEjB,SAAS,OAAO,CAAC,GAAG,CAAC,mBAAmB;IACxC,OAAO;AACT;AAKO,SAAS;IACd,6DAA6D;IAC7D,sDAAsD;IACtD,OAAO;AACT;AAOO,SAAS,oBAAoB,SAAiB,EAAE,iBAAuC;IAC5F,MAAM,UAAsB;QAAE;QAAW,GAAG,iBAAiB;IAAC;IAC9D,MAAM,SAAS,IAAA,4IAAY,EAAC;IAE5B,OAAO;QACL,MAAM,CAAC,SAAiB;YACtB,OAAO,IAAI,CAAC;gBAAE,GAAG,OAAO;gBAAE,GAAG,IAAI;YAAC,GAAG;QACvC;QACA,MAAM,CAAC,SAAiB;YACtB,OAAO,IAAI,CAAC;gBAAE,GAAG,OAAO;gBAAE,GAAG,IAAI;YAAC,GAAG;QACvC;QACA,OAAO,CAAC,SAAiB;YACvB,OAAO,KAAK,CAAC;gBAAE,GAAG,OAAO;gBAAE,GAAG,IAAI;YAAC,GAAG;QACxC;QACA,OAAO,CAAC,SAAiB;YACvB,OAAO,KAAK,CAAC;gBAAE,GAAG,OAAO;gBAAE,GAAG,IAAI;YAAC,GAAG;QACxC;IACF;AACF"}},
    {"offset": {"line": 338, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/rate-limit.ts"],"sourcesContent":["// =============================================================================\r\n// Rate Limiting\r\n// =============================================================================\r\n// Implements rate limiting with multiple strategies:\r\n// - Per API key (from database)\r\n// - Per endpoint\r\n// - Global (IP-based)\r\n// - In-memory storage (can upgrade to Redis later)\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\n\r\n/**\r\n * Extract API key from Authorization header (Edge-compatible)\r\n * Supports: Bearer <token> or <token>\r\n */\r\nfunction extractApiKey(request: NextRequest): string | null {\r\n  const authHeader = request.headers.get('authorization');\r\n  if (!authHeader) return null;\r\n\r\n  // Support both \"Bearer <token>\" and \"<token>\" formats\r\n  if (authHeader.startsWith('Bearer ')) {\r\n    return authHeader.substring(7).trim();\r\n  }\r\n  return authHeader.trim();\r\n}\r\n\r\n// Note: Database imports removed to support Edge runtime\r\n// API key rate limits are checked in API routes (Node.js runtime)\r\n\r\n// In-memory rate limit store\r\n// Format: { key: { count: number, resetAt: number } }\r\nconst rateLimitStore = new Map<string, { count: number; resetAt: number }>();\r\n\r\n// Cleanup old entries every 5 minutes\r\nsetInterval(() => {\r\n  const now = Date.now();\r\n  const keysToDelete: string[] = [];\r\n  rateLimitStore.forEach((value, key) => {\r\n    if (value.resetAt < now) {\r\n      keysToDelete.push(key);\r\n    }\r\n  });\r\n  keysToDelete.forEach(key => rateLimitStore.delete(key));\r\n}, 5 * 60 * 1000);\r\n\r\nexport interface RateLimitConfig {\r\n  windowMs: number; // Time window in milliseconds\r\n  maxRequests: number; // Maximum requests per window\r\n  identifier: string; // Unique identifier for this limit\r\n}\r\n\r\nexport interface RateLimitResult {\r\n  allowed: boolean;\r\n  remaining: number;\r\n  resetAt: number;\r\n  limit: number;\r\n}\r\n\r\n/**\r\n * Check rate limit for a given identifier\r\n */\r\nfunction checkRateLimit(config: RateLimitConfig): RateLimitResult {\r\n  const now = Date.now();\r\n  const key = config.identifier;\r\n  const stored = rateLimitStore.get(key);\r\n\r\n  // If no stored data or window expired, create new entry\r\n  if (!stored || stored.resetAt < now) {\r\n    const resetAt = now + config.windowMs;\r\n    rateLimitStore.set(key, { count: 1, resetAt });\r\n    return {\r\n      allowed: true,\r\n      remaining: config.maxRequests - 1,\r\n      resetAt,\r\n      limit: config.maxRequests,\r\n    };\r\n  }\r\n\r\n  // Check if limit exceeded\r\n  if (stored.count >= config.maxRequests) {\r\n    return {\r\n      allowed: false,\r\n      remaining: 0,\r\n      resetAt: stored.resetAt,\r\n      limit: config.maxRequests,\r\n    };\r\n  }\r\n\r\n  // Increment count\r\n  stored.count++;\r\n  rateLimitStore.set(key, stored);\r\n\r\n  return {\r\n    allowed: true,\r\n    remaining: config.maxRequests - stored.count,\r\n    resetAt: stored.resetAt,\r\n    limit: config.maxRequests,\r\n  };\r\n}\r\n\r\n/**\r\n * Get client IP address\r\n */\r\nfunction getClientIp(request: NextRequest): string {\r\n  return (\r\n    request.ip ||\r\n    request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() ||\r\n    request.headers.get('x-real-ip') ||\r\n    'unknown'\r\n  );\r\n}\r\n\r\n/**\r\n * Rate limit by API key (Edge-compatible version)\r\n * Note: This uses a default limit since we can't access the database in Edge runtime.\r\n * API routes should check API key-specific limits using the Node.js version.\r\n */\r\nexport function rateLimitByApiKeyEdge(\r\n  request: NextRequest,\r\n  defaultLimit: number = 1000\r\n): RateLimitResult | null {\r\n  const token = extractApiKey(request);\r\n  if (!token) {\r\n    return null; // No API key, skip API key rate limiting\r\n  }\r\n\r\n  // Use token hash as identifier (don't store full token)\r\n  const tokenHash = token.substring(0, 16); // Use first 16 chars as identifier\r\n  const config: RateLimitConfig = {\r\n    windowMs: 60 * 60 * 1000, // 1 hour\r\n    maxRequests: defaultLimit,\r\n    identifier: `api_key:${tokenHash}`,\r\n  };\r\n\r\n  return checkRateLimit(config);\r\n}\r\n\r\n/**\r\n * Rate limit by endpoint\r\n */\r\nexport function rateLimitByEndpoint(\r\n  request: NextRequest,\r\n  endpointId: string,\r\n  maxRequests: number = 100\r\n): RateLimitResult {\r\n  const ip = getClientIp(request);\r\n  const config: RateLimitConfig = {\r\n    windowMs: 60 * 1000, // 1 minute\r\n    maxRequests,\r\n    identifier: `endpoint:${endpointId}:${ip}`,\r\n  };\r\n\r\n  return checkRateLimit(config);\r\n}\r\n\r\n/**\r\n * Global rate limit by IP\r\n */\r\nexport function rateLimitByIp(\r\n  request: NextRequest,\r\n  maxRequests: number = 1000\r\n): RateLimitResult {\r\n  const ip = getClientIp(request);\r\n  const config: RateLimitConfig = {\r\n    windowMs: 60 * 60 * 1000, // 1 hour\r\n    maxRequests,\r\n    identifier: `global:${ip}`,\r\n  };\r\n\r\n  return checkRateLimit(config);\r\n}\r\n\r\n/**\r\n * Add rate limit headers to response\r\n */\r\nexport function addRateLimitHeaders(\r\n  response: NextResponse,\r\n  result: RateLimitResult\r\n): NextResponse {\r\n  response.headers.set('X-RateLimit-Limit', result.limit.toString());\r\n  response.headers.set('X-RateLimit-Remaining', result.remaining.toString());\r\n  response.headers.set(\r\n    'X-RateLimit-Reset',\r\n    new Date(result.resetAt).toISOString()\r\n  );\r\n  return response;\r\n}\r\n\r\n/**\r\n * Create rate limit error response\r\n */\r\nexport function createRateLimitResponse(result: RateLimitResult): NextResponse {\r\n  const resetDate = new Date(result.resetAt).toISOString();\r\n  const response = NextResponse.json(\r\n    {\r\n      error: 'Rate limit exceeded',\r\n      code: 'RATE_LIMIT_EXCEEDED',\r\n      message: `Too many requests. Limit: ${result.limit} per hour. Try again after ${resetDate}`,\r\n      retryAfter: Math.ceil((result.resetAt - Date.now()) / 1000),\r\n    },\r\n    { status: 429 }\r\n  );\r\n\r\n  return addRateLimitHeaders(response, result);\r\n}\r\n\r\n/**\r\n * Check all rate limits (API key, endpoint, global) - Edge-compatible version\r\n * Returns the first limit that is exceeded, or null if all pass\r\n * Note: API key limits use default values in Edge runtime\r\n */\r\nexport function checkAllRateLimits(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): { result: RateLimitResult; type: string } | null {\r\n  // 1. Check global IP limit\r\n  const globalResult = rateLimitByIp(request, 1000);\r\n  if (!globalResult.allowed) {\r\n    return { result: globalResult, type: 'global' };\r\n  }\r\n\r\n  // 2. Check API key limit (if authenticated) - uses default limit in Edge runtime\r\n  const apiKeyResult = rateLimitByApiKeyEdge(request, 1000);\r\n  if (apiKeyResult && !apiKeyResult.allowed) {\r\n    return { result: apiKeyResult, type: 'api_key' };\r\n  }\r\n\r\n  // 3. Check endpoint limit (if endpoint specified)\r\n  if (endpointId) {\r\n    const endpointResult = rateLimitByEndpoint(request, endpointId, 100);\r\n    if (!endpointResult.allowed) {\r\n      return { result: endpointResult, type: 'endpoint' };\r\n    }\r\n  }\r\n\r\n  return null; // All limits passed\r\n}\r\n\r\n/**\r\n * Get the most restrictive rate limit result for headers - Edge-compatible version\r\n */\r\nexport function getRateLimitHeaders(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): RateLimitResult | null {\r\n  const results: RateLimitResult[] = [];\r\n\r\n  // Global limit\r\n  results.push(rateLimitByIp(request, 1000));\r\n\r\n  // API key limit (Edge-compatible)\r\n  const apiKeyResult = rateLimitByApiKeyEdge(request, 1000);\r\n  if (apiKeyResult) {\r\n    results.push(apiKeyResult);\r\n  }\r\n\r\n  // Endpoint limit\r\n  if (endpointId) {\r\n    results.push(rateLimitByEndpoint(request, endpointId, 100));\r\n  }\r\n\r\n  // Return the most restrictive (lowest remaining)\r\n  if (results.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return results.reduce((min, current) =>\r\n    current.remaining < min.remaining ? current : min\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 539, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/security-monitor.ts"],"sourcesContent":["// =============================================================================\r\n// SECURITY MONITORING & THREAT DETECTION\r\n// =============================================================================\r\n// Real-time security monitoring and threat detection for all requests\r\n// Implements agent-based security scanning for all in/out traffic\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'SecurityMonitor' });\r\n\r\nexport interface SecurityEvent {\r\n  type: 'threat' | 'suspicious' | 'anomaly' | 'violation';\r\n  severity: 'critical' | 'high' | 'medium' | 'low';\r\n  category: string;\r\n  description: string;\r\n  requestId: string;\r\n  ip: string;\r\n  path: string;\r\n  method: string;\r\n  userAgent?: string;\r\n  details?: Record<string, any>;\r\n  timestamp: string;\r\n  // Correlation fields for full traceability\r\n  conversationId?: string;\r\n  agentId?: string;\r\n  x402TxHash?: string;\r\n  failureCode?: string;\r\n}\r\n\r\nexport interface SecurityScanResult {\r\n  safe: boolean;\r\n  threats: SecurityEvent[];\r\n  riskScore: number; // 0-100\r\n  recommendations: string[];\r\n}\r\n\r\n// In-memory threat store (upgrade to Redis in production)\r\nconst threatStore = new Map<string, {\r\n  count: number;\r\n  firstSeen: number;\r\n  lastSeen: number;\r\n  events: SecurityEvent[];\r\n}>();\r\n\r\n// Shadow mode: new rules start in log-only mode\r\nconst SHADOW_MODE_ENABLED = process.env.SECURITY_SHADOW_MODE === 'true' || true; // Default to true for safety\r\nconst SHADOW_MODE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in shadow mode\r\n\r\n// Safety caps to prevent mass blocking\r\nconst MAX_BLOCKS_PER_HOUR = parseInt(process.env.SECURITY_MAX_BLOCKS_PER_HOUR || '100', 10);\r\nconst MAX_BLOCKS_PER_DAY = parseInt(process.env.SECURITY_MAX_BLOCKS_PER_DAY || '1000', 10);\r\n\r\n// Track blocks per time window\r\nconst blocksThisHour = new Map<string, number>();\r\nconst blocksThisDay = new Map<string, number>();\r\n\r\n// Cleanup block counters every hour\r\nsetInterval(() => {\r\n  blocksThisHour.clear();\r\n}, 60 * 60 * 1000);\r\n\r\n// Cleanup daily block counters every day\r\nsetInterval(() => {\r\n  blocksThisDay.clear();\r\n}, 24 * 60 * 60 * 1000);\r\n\r\n// Cleanup old threats every 10 minutes\r\nsetInterval(() => {\r\n  const now = Date.now();\r\n  const maxAge = 24 * 60 * 60 * 1000; // 24 hours\r\n  const keysToDelete: string[] = [];\r\n  \r\n  threatStore.forEach((value, key) => {\r\n    if (now - value.lastSeen > maxAge) {\r\n      keysToDelete.push(key);\r\n    }\r\n  });\r\n  \r\n  keysToDelete.forEach(key => threatStore.delete(key));\r\n}, 10 * 60 * 1000);\r\n\r\n/**\r\n * SQL Injection Detection Patterns\r\n */\r\nconst SQL_INJECTION_PATTERNS = [\r\n  /(\\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|EXECUTE|UNION|SCRIPT)\\b)/i,\r\n  /('|\\\\'|;|--|\\/\\*|\\*\\/|\\+|%)/i,\r\n  /(\\bOR\\b.*=.*)/i,\r\n  /(\\bAND\\b.*=.*)/i,\r\n  /(\\bUNION\\b.*SELECT)/i,\r\n];\r\n\r\n/**\r\n * XSS Detection Patterns\r\n */\r\nconst XSS_PATTERNS = [\r\n  /<script[^>]*>.*?<\\/script>/gi,\r\n  /javascript:/i,\r\n  /on\\w+\\s*=/i, // onclick=, onerror=, etc.\r\n  /<iframe[^>]*>/gi,\r\n  /<img[^>]*src[^>]*javascript:/i,\r\n  /<svg[^>]*onload/i,\r\n];\r\n\r\n/**\r\n * Path Traversal Patterns\r\n */\r\nconst PATH_TRAVERSAL_PATTERNS = [\r\n  /\\.\\.\\//g,\r\n  /\\.\\.\\\\/g,\r\n  /\\.\\.%2F/i,\r\n  /\\.\\.%5C/i,\r\n  /%2e%2e%2f/i,\r\n  /%2e%2e%5c/i,\r\n];\r\n\r\n/**\r\n * Command Injection Patterns\r\n */\r\nconst COMMAND_INJECTION_PATTERNS = [\r\n  /[;&|`$(){}[\\]]/,\r\n  /\\b(cat|ls|pwd|whoami|id|uname|ps|kill|rm|mv|cp)\\b/i,\r\n  /\\|\\s*(nc|netcat|wget|curl|bash|sh)/i,\r\n];\r\n\r\n/**\r\n * Suspicious User Agent Patterns\r\n */\r\nconst SUSPICIOUS_USER_AGENTS = [\r\n  /sqlmap/i,\r\n  /nikto/i,\r\n  /nmap/i,\r\n  /masscan/i,\r\n  /zap/i,\r\n  /burp/i,\r\n  /scanner/i,\r\n  /bot.*crawler/i,\r\n];\r\n\r\n/**\r\n * Rate Limit Violation Thresholds\r\n */\r\nconst RATE_LIMIT_THRESHOLDS = {\r\n  critical: 100, // requests per minute\r\n  high: 50,\r\n  medium: 20,\r\n};\r\n\r\n/**\r\n * Scan request for security threats\r\n * Extracts correlation fields (conversation_id, agent_id, x402_tx_hash) from headers\r\n */\r\nexport function scanRequest(request: NextRequest, requestId: string): SecurityScanResult {\r\n  const path = request.nextUrl.pathname;\r\n  \r\n  // Whitelist internal/system endpoints that should not be scanned\r\n  // These are trusted internal endpoints (Vercel cron, health checks, x402 endpoints)\r\n  // x402 endpoints are whitelisted because payment headers contain base64/JSON\r\n  // that triggers false positives for command injection patterns\r\n  const whitelistedPaths = [\r\n    // Vercel cron job endpoints (all internal)\r\n    '/api/cron/', // All cron endpoints (dogfood, scout, probes, pull-metrics, etc.)\r\n    \r\n    // x402 router and verification endpoints\r\n    '/api/x402/router/', // Router execute endpoint (used by agents)\r\n    '/api/x402/verify', // x402 verification endpoint\r\n    '/api/x402/health', // x402 health check\r\n    \r\n    // Health checks\r\n    '/api/health', // Health check endpoint\r\n    \r\n    // Metered and demo x402 endpoints\r\n    '/api/v1/metered/', // All metered x402 endpoints (url-enrich, etc.)\r\n    '/api/v1/x402/', // x402 demo endpoints\r\n    '/api/test/hello-world', // Test endpoint with x402\r\n    \r\n    // Debug endpoints (internal)\r\n    '/api/debug/', // Debug endpoints (smf-facilitators, etc.)\r\n  ];\r\n  \r\n  // Check if path matches any whitelisted path (exact match or prefix match)\r\n  const isWhitelisted = whitelistedPaths.some(whitelisted => \r\n    path === whitelisted || \r\n    path.startsWith(whitelisted) ||  // Handles /api/v1/metered/url-enrich matching /api/v1/metered/\r\n    (whitelisted.endsWith('/') ? path.startsWith(whitelisted) : path.startsWith(whitelisted + '/'))\r\n  );\r\n  \r\n  if (isWhitelisted) {\r\n    // Skip all security scanning for whitelisted paths\r\n    return {\r\n      safe: true,\r\n      threats: [],\r\n      riskScore: 0,\r\n      recommendations: [],\r\n    };\r\n  }\r\n  \r\n  const threats: SecurityEvent[] = [];\r\n  const ip = request.ip || request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';\r\n  const method = request.method;\r\n  const userAgent = request.headers.get('user-agent') || undefined;\r\n  const url = request.nextUrl.toString();\r\n  const queryParams = Object.fromEntries(request.nextUrl.searchParams);\r\n  \r\n  // Extract correlation fields for full traceability\r\n  const conversationId = request.headers.get('x-conversation-id') || \r\n                         request.headers.get('x-request-id') || \r\n                         undefined;\r\n  const agentId = request.headers.get('x-agent-id') || undefined;\r\n  const x402TxHash = request.headers.get('x-x402-tx-hash') || undefined;\r\n  \r\n  // Get request body if available (for POST/PUT/PATCH)\r\n  let bodyText = '';\r\n  try {\r\n    // Note: Body can only be read once, so this is a best-effort scan\r\n    // In production, consider cloning the request for scanning\r\n  } catch {\r\n    // Body not available for scanning\r\n  }\r\n\r\n  // 1. SQL Injection Detection\r\n  const sqlInjectionThreats = detectSQLInjection(url, queryParams, bodyText);\r\n  // Add correlation fields to all threats\r\n  sqlInjectionThreats.forEach(threat => {\r\n    threat.requestId = requestId;\r\n    threat.ip = ip;\r\n    threat.path = path;\r\n    threat.method = method;\r\n    threat.userAgent = userAgent;\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...sqlInjectionThreats);\r\n\r\n  // 2. XSS Detection\r\n  const xssThreats = detectXSS(url, queryParams, bodyText);\r\n  xssThreats.forEach(threat => {\r\n    threat.requestId = requestId;\r\n    threat.ip = ip;\r\n    threat.path = path;\r\n    threat.method = method;\r\n    threat.userAgent = userAgent;\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...xssThreats);\r\n\r\n  // 3. Path Traversal Detection\r\n  const pathTraversalThreats = detectPathTraversal(path, queryParams);\r\n  pathTraversalThreats.forEach(threat => {\r\n    threat.requestId = requestId;\r\n    threat.ip = ip;\r\n    threat.path = path;\r\n    threat.method = method;\r\n    threat.userAgent = userAgent;\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...pathTraversalThreats);\r\n\r\n  // 4. Command Injection Detection\r\n  const commandInjectionThreats = detectCommandInjection(url, queryParams, bodyText);\r\n  commandInjectionThreats.forEach(threat => {\r\n    threat.requestId = requestId;\r\n    threat.ip = ip;\r\n    threat.path = path;\r\n    threat.method = method;\r\n    threat.userAgent = userAgent;\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...commandInjectionThreats);\r\n\r\n  // 5. Suspicious User Agent Detection\r\n  if (userAgent && isSuspiciousUserAgent(userAgent)) {\r\n    threats.push({\r\n      type: 'suspicious',\r\n      severity: 'medium',\r\n      category: 'suspicious_user_agent',\r\n      description: `Suspicious user agent detected: ${userAgent.substring(0, 100)}`,\r\n      requestId,\r\n      ip,\r\n      path,\r\n      method,\r\n      userAgent,\r\n      conversationId,\r\n      agentId,\r\n      x402TxHash,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  }\r\n\r\n  // 6. Unusual Request Pattern Detection\r\n  const anomalyThreats = detectAnomalies(request, requestId);\r\n  anomalyThreats.forEach(threat => {\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...anomalyThreats);\r\n\r\n  // 7. Authentication Bypass Attempts\r\n  const authBypassThreats = detectAuthBypass(request, requestId);\r\n  authBypassThreats.forEach(threat => {\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...authBypassThreats);\r\n\r\n  // Calculate risk score\r\n  const riskScore = calculateRiskScore(threats);\r\n\r\n  // Generate recommendations\r\n  const recommendations = generateRecommendations(threats, riskScore);\r\n\r\n  // Log threats\r\n  if (threats.length > 0) {\r\n    logger.warn({\r\n      requestId,\r\n      ip,\r\n      path,\r\n      method,\r\n      threatCount: threats.length,\r\n      riskScore,\r\n      threats: threats.map(t => ({\r\n        type: t.type,\r\n        severity: t.severity,\r\n        category: t.category,\r\n      })),\r\n    }, 'Security threats detected');\r\n  }\r\n\r\n  // Store threats for IP tracking\r\n  if (threats.length > 0) {\r\n    storeThreat(ip, threats);\r\n  }\r\n\r\n  return {\r\n    safe: threats.length === 0,\r\n    threats,\r\n    riskScore,\r\n    recommendations,\r\n  };\r\n}\r\n\r\n/**\r\n * Detect SQL injection attempts\r\n */\r\nfunction detectSQLInjection(url: string, queryParams: Record<string, string>, body: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const textToScan = `${url} ${JSON.stringify(queryParams)} ${body}`;\r\n\r\n  for (const pattern of SQL_INJECTION_PATTERNS) {\r\n    if (pattern.test(textToScan)) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'critical',\r\n        category: 'sql_injection',\r\n        description: 'Potential SQL injection attempt detected',\r\n        requestId: '', // Will be set by caller\r\n        ip: '', // Will be set by caller\r\n        path: '', // Will be set by caller\r\n        method: '', // Will be set by caller\r\n        details: { pattern: pattern.toString(), matched: textToScan.substring(0, 200) },\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Detect XSS attempts\r\n */\r\nfunction detectXSS(url: string, queryParams: Record<string, string>, body: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const textToScan = `${url} ${JSON.stringify(queryParams)} ${body}`;\r\n\r\n  for (const pattern of XSS_PATTERNS) {\r\n    if (pattern.test(textToScan)) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'high',\r\n        category: 'xss',\r\n        description: 'Potential XSS attempt detected',\r\n        requestId: '', // Will be set by caller\r\n        ip: '', // Will be set by caller\r\n        path: '', // Will be set by caller\r\n        method: '', // Will be set by caller\r\n        details: { pattern: pattern.toString() },\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Detect path traversal attempts\r\n */\r\nfunction detectPathTraversal(path: string, queryParams: Record<string, string>): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const textToScan = `${path} ${JSON.stringify(queryParams)}`;\r\n\r\n  for (const pattern of PATH_TRAVERSAL_PATTERNS) {\r\n    if (pattern.test(textToScan)) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'high',\r\n        category: 'path_traversal',\r\n        description: 'Potential path traversal attempt detected',\r\n        requestId: '', // Will be set by caller\r\n        ip: '', // Will be set by caller\r\n        path: '', // Will be set by caller\r\n        method: '', // Will be set by caller\r\n        details: { pattern: pattern.toString() },\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Detect command injection attempts\r\n */\r\nfunction detectCommandInjection(url: string, queryParams: Record<string, string>, body: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const textToScan = `${url} ${JSON.stringify(queryParams)} ${body}`;\r\n\r\n  for (const pattern of COMMAND_INJECTION_PATTERNS) {\r\n    if (pattern.test(textToScan)) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'critical',\r\n        category: 'command_injection',\r\n        description: 'Potential command injection attempt detected',\r\n        requestId: '', // Will be set by caller\r\n        ip: '', // Will be set by caller\r\n        path: '', // Will be set by caller\r\n        method: '', // Will be set by caller\r\n        details: { pattern: pattern.toString() },\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Check if user agent is suspicious\r\n */\r\nfunction isSuspiciousUserAgent(userAgent: string): boolean {\r\n  return SUSPICIOUS_USER_AGENTS.some(pattern => pattern.test(userAgent));\r\n}\r\n\r\n/**\r\n * Detect anomalies in request patterns\r\n */\r\nfunction detectAnomalies(request: NextRequest, requestId: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const ip = request.ip || request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';\r\n  const path = request.nextUrl.pathname;\r\n\r\n  // Check for unusual path patterns\r\n  if (path.includes('admin') || path.includes('config') || path.includes('.env')) {\r\n    threats.push({\r\n      type: 'suspicious',\r\n      severity: 'medium',\r\n      category: 'suspicious_path',\r\n      description: `Suspicious path accessed: ${path}`,\r\n      requestId,\r\n      ip,\r\n      path,\r\n      method: request.method,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  }\r\n\r\n  // Check for missing required headers on sensitive endpoints\r\n  if (path.startsWith('/api/v1/') && !request.headers.get('authorization')) {\r\n    threats.push({\r\n      type: 'violation',\r\n      severity: 'medium',\r\n      category: 'missing_auth',\r\n      description: 'Unauthenticated request to protected endpoint',\r\n      requestId,\r\n      ip,\r\n      path,\r\n      method: request.method,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Detect authentication bypass attempts\r\n */\r\nfunction detectAuthBypass(request: NextRequest, requestId: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const authHeader = request.headers.get('authorization');\r\n\r\n  // Check for common bypass attempts\r\n  if (authHeader) {\r\n    // Empty token\r\n    if (authHeader.trim() === 'Bearer' || authHeader.trim() === '') {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'high',\r\n        category: 'auth_bypass',\r\n        description: 'Empty authorization token detected',\r\n        requestId,\r\n        ip: request.ip || 'unknown',\r\n        path: request.nextUrl.pathname,\r\n        method: request.method,\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n\r\n    // Suspicious token patterns\r\n    if (authHeader.includes('null') || authHeader.includes('undefined') || authHeader.includes('true')) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'medium',\r\n        category: 'auth_bypass',\r\n        description: 'Suspicious authorization token pattern',\r\n        requestId,\r\n        ip: request.ip || 'unknown',\r\n        path: request.nextUrl.pathname,\r\n        method: request.method,\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Calculate risk score (0-100)\r\n */\r\nfunction calculateRiskScore(threats: SecurityEvent[]): number {\r\n  if (threats.length === 0) return 0;\r\n\r\n  const severityWeights = {\r\n    critical: 25,\r\n    high: 15,\r\n    medium: 8,\r\n    low: 3,\r\n  };\r\n\r\n  let score = 0;\r\n  for (const threat of threats) {\r\n    score += severityWeights[threat.severity];\r\n  }\r\n\r\n  // Cap at 100\r\n  return Math.min(100, score);\r\n}\r\n\r\n/**\r\n * Generate security recommendations\r\n */\r\nfunction generateRecommendations(threats: SecurityEvent[], riskScore: number): string[] {\r\n  const recommendations: string[] = [];\r\n\r\n  if (riskScore >= 50) {\r\n    recommendations.push('Consider blocking this IP address');\r\n    recommendations.push('Review security logs immediately');\r\n  }\r\n\r\n  if (threats.some(t => t.category === 'sql_injection')) {\r\n    recommendations.push('SQL injection attempt detected - ensure parameterized queries are used');\r\n  }\r\n\r\n  if (threats.some(t => t.category === 'xss')) {\r\n    recommendations.push('XSS attempt detected - ensure input sanitization is enabled');\r\n  }\r\n\r\n  if (threats.some(t => t.category === 'command_injection')) {\r\n    recommendations.push('Command injection attempt detected - review system commands');\r\n  }\r\n\r\n  if (threats.some(t => t.category === 'auth_bypass')) {\r\n    recommendations.push('Authentication bypass attempt - review auth middleware');\r\n  }\r\n\r\n  return recommendations;\r\n}\r\n\r\n/**\r\n * Store threat for IP tracking\r\n */\r\nfunction storeThreat(ip: string, threats: SecurityEvent[]): void {\r\n  const existing = threatStore.get(ip);\r\n  const now = Date.now();\r\n\r\n  if (existing) {\r\n    existing.count += threats.length;\r\n    existing.lastSeen = now;\r\n    existing.events.push(...threats);\r\n    // Keep last 100 events per IP\r\n    if (existing.events.length > 100) {\r\n      existing.events = existing.events.slice(-100);\r\n    }\r\n  } else {\r\n    threatStore.set(ip, {\r\n      count: threats.length,\r\n      firstSeen: now,\r\n      lastSeen: now,\r\n      events: [...threats],\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Get threat history for an IP\r\n */\r\nexport function getThreatHistory(ip: string): {\r\n  count: number;\r\n  firstSeen: number;\r\n  lastSeen: number;\r\n  events: SecurityEvent[];\r\n} | null {\r\n  return threatStore.get(ip) || null;\r\n}\r\n\r\n/**\r\n * Check if IP should be blocked\r\n * Implements shadow mode and safety caps\r\n */\r\nexport function shouldBlockIp(ip: string): boolean {\r\n  // Shadow mode: log-only, don't block\r\n  if (SHADOW_MODE_ENABLED) {\r\n    return false; // Log-only mode\r\n  }\r\n\r\n  // Safety caps: prevent mass blocking\r\n  const hourCount = blocksThisHour.get(ip) || 0;\r\n  const dayCount = blocksThisDay.get(ip) || 0;\r\n  \r\n  if (hourCount >= MAX_BLOCKS_PER_HOUR) {\r\n    logger.warn({ ip, hourCount }, 'Block cap reached for hour');\r\n    return false; // Cap reached, don't block more\r\n  }\r\n  \r\n  if (dayCount >= MAX_BLOCKS_PER_DAY) {\r\n    logger.warn({ ip, dayCount }, 'Block cap reached for day');\r\n    return false; // Cap reached, don't block more\r\n  }\r\n\r\n  const history = threatStore.get(ip);\r\n  if (!history) return false;\r\n\r\n  // Block if:\r\n  // - More than 10 threats in last hour\r\n  // - Any critical severity threat (after shadow mode review)\r\n  const oneHourAgo = Date.now() - 60 * 60 * 1000;\r\n  const recentThreats = history.events.filter(e => \r\n    new Date(e.timestamp).getTime() > oneHourAgo\r\n  );\r\n\r\n  if (recentThreats.length > 10) {\r\n    blocksThisHour.set(ip, hourCount + 1);\r\n    blocksThisDay.set(ip, dayCount + 1);\r\n    return true;\r\n  }\r\n  \r\n  if (recentThreats.some(e => e.severity === 'critical')) {\r\n    blocksThisHour.set(ip, hourCount + 1);\r\n    blocksThisDay.set(ip, dayCount + 1);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Get all blocked IPs\r\n */\r\nexport function getBlockedIps(): string[] {\r\n  const blocked: string[] = [];\r\n  threatStore.forEach((_, ip) => {\r\n    if (shouldBlockIp(ip)) {\r\n      blocked.push(ip);\r\n    }\r\n  });\r\n  return blocked;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1091, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport type { NextRequest } from 'next/server';\r\nimport { getOrCreateRequestId, addRequestIdToResponse } from '@/lib/request-id';\r\nimport { createRequestLogger } from '@/lib/request-id';\r\nimport { checkAllRateLimits, addRateLimitHeaders, createRateLimitResponse, getRateLimitHeaders } from '@/lib/rate-limit';\r\nimport { scanRequest, shouldBlockIp, type SecurityScanResult } from '@/lib/security-monitor';\r\nimport { setSentryContext } from '@/lib/sentry';\r\n\r\n/**\r\n * Middleware to handle:\r\n * - Request ID tracking\r\n * - Rate limiting\r\n * - x402 payment headers\r\n * - Request logging\r\n */\r\nexport async function middleware(request: NextRequest) {\r\n  // Allow .well-known paths to pass through without processing (for verification files)\r\n  // These are served from public folder and should not be processed\r\n  if (request.nextUrl.pathname.startsWith('/.well-known')) {\r\n    return NextResponse.next();\r\n  }\r\n  \r\n  // Only process API routes\r\n  if (!request.nextUrl.pathname.startsWith('/api')) {\r\n    return NextResponse.next();\r\n  }\r\n\r\n  // Generate or extract request ID\r\n  const requestId = getOrCreateRequestId(request);\r\n  const ip = request.ip || request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';\r\n  const logger = createRequestLogger(requestId, {\r\n    method: request.method,\r\n    path: request.nextUrl.pathname,\r\n    ip,\r\n  });\r\n\r\n  // SECURITY: Check if IP is blocked\r\n  if (shouldBlockIp(ip)) {\r\n    logger.warn('Blocked request', { ip, reason: 'IP blocked due to security threats' });\r\n    return NextResponse.json(\r\n      {\r\n        error: 'Access denied',\r\n        code: 'IP_BLOCKED',\r\n        message: 'Your IP address has been blocked due to security violations',\r\n      },\r\n      { status: 403 }\r\n    );\r\n  }\r\n\r\n  // SECURITY: Scan request for threats\r\n  // Note: Agents are advisors only - all enforcement is deterministic\r\n  const securityScan = scanRequest(request, requestId);\r\n  if (!securityScan.safe) {\r\n    logger.warn('Security threats detected', {\r\n      threatCount: securityScan.threats.length,\r\n      riskScore: securityScan.riskScore,\r\n      threats: securityScan.threats.map(t => ({ \r\n        type: t.type, \r\n        severity: t.severity, \r\n        category: t.category,\r\n        conversationId: t.conversationId,\r\n        agentId: t.agentId,\r\n        x402TxHash: t.x402TxHash,\r\n      })),\r\n    });\r\n\r\n    // Block if critical threats detected (only if shadow mode is disabled)\r\n    // Shadow mode: new rules start in log-only mode for review\r\n    if (securityScan.threats.some(t => t.severity === 'critical')) {\r\n      // In shadow mode, we log but don't block\r\n      // Set SECURITY_SHADOW_MODE=false to enable blocking\r\n      const shadowMode = process.env.SECURITY_SHADOW_MODE !== 'false';\r\n      if (!shadowMode) {\r\n        return NextResponse.json(\r\n          {\r\n            error: 'Security violation detected',\r\n            code: 'SECURITY_VIOLATION',\r\n            message: 'Request blocked due to security threats',\r\n          },\r\n          { status: 403 }\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Log request\r\n  logger.info('Incoming request');\r\n\r\n  // Extract endpoint ID from path if it's a metered endpoint\r\n  const pathMatch = request.nextUrl.pathname.match(/\\/api\\/v1\\/metered\\/([^/]+)/);\r\n  const endpointId = pathMatch ? pathMatch[1] : undefined;\r\n\r\n  // Check rate limits (Edge-compatible, no database access)\r\n  const rateLimitCheck = checkAllRateLimits(request, endpointId);\r\n  if (rateLimitCheck && !rateLimitCheck.result.allowed) {\r\n    logger.warn('Rate limit exceeded', {\r\n      rateLimitType: rateLimitCheck.type,\r\n      limit: rateLimitCheck.result.limit,\r\n      remaining: rateLimitCheck.result.remaining,\r\n    });\r\n    \r\n    const response = createRateLimitResponse(rateLimitCheck.result);\r\n    addRequestIdToResponse(response, requestId);\r\n    return response;\r\n  }\r\n\r\n  // Extract x-payment header if present\r\n  const paymentHeader = request.headers.get('x-payment') || request.headers.get('X-Payment');\r\n\r\n  // Create request headers with payment header forwarded\r\n  // This ensures the x-payment header reaches the route handler\r\n  const requestHeaders = new Headers(request.headers);\r\n  \r\n  // Log payment header presence for debugging\r\n  if (paymentHeader) {\r\n    logger.debug('Payment header detected', { \r\n      headerLength: paymentHeader.length,\r\n      hasX402Prefix: paymentHeader.startsWith('x402 '),\r\n    });\r\n    // Ensure payment header is in the forwarded headers\r\n    requestHeaders.set('x-payment', paymentHeader);\r\n  }\r\n\r\n  // Add payment header to request headers for API routes to access\r\n  const response = NextResponse.next({\r\n    request: {\r\n      headers: requestHeaders,\r\n    },\r\n  });\r\n  \r\n  // Add request ID to response\r\n  addRequestIdToResponse(response, requestId);\r\n  \r\n  // Add rate limit headers (even if not exceeded)\r\n  const rateLimitHeaders = getRateLimitHeaders(request, endpointId);\r\n  if (rateLimitHeaders) {\r\n    addRateLimitHeaders(response, rateLimitHeaders);\r\n  }\r\n\r\n  return response;\r\n}\r\n\r\n// Configure which routes to run middleware on\r\n// Only match API routes - .well-known paths are served from public folder\r\nexport const config = {\r\n  matcher: [\r\n    '/api/:path*',\r\n  ],\r\n};\r\n\r\n"],"names":[],"mappings":"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"}}]
}