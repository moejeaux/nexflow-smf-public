{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/adapters/sqlite-adapter.ts"],"sourcesContent":["// =============================================================================\n// SQLITE ADAPTER\n// =============================================================================\n// SQLite implementation of DatabaseAdapter\n// Wraps existing better-sqlite3 code for adapter pattern\n\nimport Database from 'better-sqlite3';\nimport path from 'path';\nimport fs from 'fs';\nimport type { DatabaseAdapter } from './base-adapter';\nimport type { MeteredEndpoint, Payment, UsageLog } from '../metered-endpoints';\n\n// Re-export the schema initialization from metered-endpoints\nfunction initializeSchema(db: Database.Database) {\n  // Endpoints table\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS endpoints (\n      id TEXT PRIMARY KEY,\n      name TEXT NOT NULL,\n      description TEXT,\n      upstream_url TEXT NOT NULL,\n      price TEXT NOT NULL,\n      network TEXT NOT NULL DEFAULT 'base',\n      token_address TEXT NOT NULL,\n      token_symbol TEXT NOT NULL DEFAULT 'USDC',\n      chain_id INTEGER NOT NULL DEFAULT 8453,\n      recipient_address TEXT,\n      status TEXT NOT NULL DEFAULT 'active',\n      created_at TEXT NOT NULL,\n      updated_at TEXT NOT NULL,\n      created_by TEXT\n    )\n  `);\n\n  // Migration: Add recipient_address column if it doesn't exist\n  try {\n    const tableInfo = db.prepare(\"PRAGMA table_info(endpoints)\").all() as Array<{ name: string }>;\n    const hasRecipientAddress = tableInfo.some(col => col.name === 'recipient_address');\n    \n    if (!hasRecipientAddress) {\n      db.exec(`ALTER TABLE endpoints ADD COLUMN recipient_address TEXT`);\n      console.log('[db] Added recipient_address column');\n    }\n  } catch (error: any) {\n    if (!error.message?.includes('duplicate column name') && !error.message?.includes('no such column')) {\n      console.warn('[db] Migration warning:', error.message);\n    }\n  }\n\n  // Payments table\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS payments (\n      id TEXT PRIMARY KEY,\n      endpoint_id TEXT NOT NULL,\n      tx_hash TEXT NOT NULL UNIQUE,\n      from_address TEXT NOT NULL,\n      to_address TEXT NOT NULL,\n      amount TEXT NOT NULL,\n      token_address TEXT NOT NULL,\n      network TEXT NOT NULL,\n      verified_at TEXT NOT NULL,\n      kyt_status TEXT,\n      ofac_status TEXT,\n      facilitator TEXT NOT NULL DEFAULT 'cdp',\n      FOREIGN KEY (endpoint_id) REFERENCES endpoints(id)\n    )\n  `);\n\n  // Usage logs table\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS usage_logs (\n      id TEXT PRIMARY KEY,\n      endpoint_id TEXT NOT NULL,\n      payment_id TEXT,\n      timestamp TEXT NOT NULL,\n      method TEXT NOT NULL,\n      path TEXT NOT NULL,\n      status_code INTEGER NOT NULL,\n      response_time INTEGER NOT NULL,\n      units INTEGER NOT NULL DEFAULT 1,\n      ip_address TEXT,\n      user_agent TEXT,\n      FOREIGN KEY (endpoint_id) REFERENCES endpoints(id),\n      FOREIGN KEY (payment_id) REFERENCES payments(id)\n    )\n  `);\n\n  // API keys table\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS api_keys (\n      id TEXT PRIMARY KEY,\n      key_hash TEXT UNIQUE NOT NULL,\n      name TEXT NOT NULL,\n      role TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('admin', 'user', 'read-only')),\n      user_id TEXT,\n      rate_limit INTEGER DEFAULT 1000,\n      last_used_at TEXT,\n      last_used_ip TEXT,\n      expires_at TEXT,\n      x402_demo_calls_used INTEGER DEFAULT 0,\n      x402_demo_calls_limit INTEGER DEFAULT 200,\n      x402_demo_amount_used TEXT DEFAULT '0',\n      x402_demo_amount_limit TEXT DEFAULT '1000000',\n      created_at TEXT NOT NULL,\n      updated_at TEXT NOT NULL,\n      revoked_at TEXT\n    )\n  `);\n\n  // Indexes\n  db.exec(`\n    CREATE INDEX IF NOT EXISTS idx_payments_endpoint_id ON payments(endpoint_id);\n    CREATE INDEX IF NOT EXISTS idx_payments_tx_hash ON payments(tx_hash);\n    CREATE INDEX IF NOT EXISTS idx_payments_verified_at ON payments(verified_at);\n    CREATE INDEX IF NOT EXISTS idx_usage_logs_endpoint_id ON usage_logs(endpoint_id);\n    CREATE INDEX IF NOT EXISTS idx_usage_logs_timestamp ON usage_logs(timestamp);\n    CREATE INDEX IF NOT EXISTS idx_usage_logs_payment_id ON usage_logs(payment_id);\n    CREATE INDEX IF NOT EXISTS idx_endpoints_status ON endpoints(status);\n    CREATE UNIQUE INDEX IF NOT EXISTS idx_api_keys_key_hash ON api_keys(key_hash);\n    CREATE INDEX IF NOT EXISTS idx_api_keys_user_id ON api_keys(user_id);\n    CREATE INDEX IF NOT EXISTS idx_api_keys_role ON api_keys(role);\n    CREATE INDEX IF NOT EXISTS idx_api_keys_revoked_at ON api_keys(revoked_at);\n  `);\n\n  // Plans table - subscription plans\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS plans (\n      id TEXT PRIMARY KEY,\n      name TEXT NOT NULL UNIQUE,\n      description TEXT,\n      daily_limit INTEGER NOT NULL DEFAULT 1000,\n      monthly_limit INTEGER NOT NULL DEFAULT 10000,\n      price_cents INTEGER NOT NULL DEFAULT 0,\n      features TEXT,\n      created_at TEXT NOT NULL DEFAULT (datetime('now')),\n      updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n    )\n  `);\n\n  // Accounts table - user accounts\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS accounts (\n      id TEXT PRIMARY KEY,\n      email TEXT NOT NULL UNIQUE,\n      password_hash TEXT NOT NULL,\n      name TEXT,\n      status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'suspended', 'deleted')),\n      email_verified INTEGER NOT NULL DEFAULT 0,\n      created_at TEXT NOT NULL DEFAULT (datetime('now')),\n      updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n    )\n  `);\n\n  // Account plans table - links accounts to their current plan\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS account_plans (\n      id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),\n      account_id TEXT NOT NULL REFERENCES accounts(id),\n      plan_id TEXT NOT NULL REFERENCES plans(id),\n      daily_limit INTEGER NOT NULL DEFAULT 1000,\n      monthly_limit INTEGER NOT NULL DEFAULT 10000,\n      started_at TEXT NOT NULL DEFAULT (datetime('now')),\n      ends_at TEXT,\n      is_current INTEGER NOT NULL DEFAULT 1,\n      created_at TEXT NOT NULL DEFAULT (datetime('now'))\n    )\n  `);\n\n  // Account indexes\n  db.exec(`\n    CREATE INDEX IF NOT EXISTS idx_accounts_email ON accounts(email);\n    CREATE INDEX IF NOT EXISTS idx_accounts_status ON accounts(status);\n    CREATE INDEX IF NOT EXISTS idx_account_plans_account_id ON account_plans(account_id);\n  `);\n\n  // Seed default plans if empty\n  const planCount = db.prepare('SELECT COUNT(*) as count FROM plans').get() as { count: number };\n  if (planCount.count === 0) {\n    db.exec(`\n      INSERT INTO plans (id, name, description, daily_limit, monthly_limit, price_cents, features) VALUES\n      ('free', 'Free', 'Free tier for getting started', 1000, 10000, 0, '[\"1,000 API calls/day\",\"10,000 API calls/month\",\"Basic analytics\",\"Community support\"]'),\n      ('starter', 'Starter', 'For small projects', 10000, 100000, 2900, '[\"10,000 API calls/day\",\"100,000 API calls/month\",\"Full analytics\",\"Email support\",\"Webhook notifications\"]'),\n      ('pro', 'Pro', 'For growing businesses', 100000, 1000000, 9900, '[\"100,000 API calls/day\",\"1,000,000 API calls/month\",\"Advanced analytics\",\"Priority support\",\"Custom webhooks\",\"API key management\"]'),\n      ('enterprise', 'Enterprise', 'Custom solutions', 999999999, 999999999, 0, '[\"Unlimited API calls\",\"Custom SLAs\",\"Dedicated support\",\"Custom integrations\",\"On-premise deployment\"]')\n    `);\n  }\n\n  // Cron job runs table - tracks execution of scheduled jobs\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS cron_job_runs (\n      id TEXT PRIMARY KEY,\n      job_id TEXT NOT NULL,\n      status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'running', 'completed', 'failed', 'timeout')),\n      started_at TEXT NOT NULL DEFAULT (datetime('now')),\n      completed_at TEXT,\n      duration_ms INTEGER,\n      trigger_source TEXT NOT NULL DEFAULT 'cron' CHECK (trigger_source IN ('cron', 'manual', 'retry')),\n      attempt_number INTEGER NOT NULL DEFAULT 1,\n      input_params TEXT,\n      output_summary TEXT,\n      error_message TEXT,\n      error_stack TEXT,\n      metadata TEXT,\n      created_at TEXT NOT NULL DEFAULT (datetime('now'))\n    )\n  `);\n\n  // Cron job config table - configuration for each job\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS cron_job_config (\n      job_id TEXT PRIMARY KEY,\n      display_name TEXT NOT NULL,\n      description TEXT,\n      schedule TEXT,\n      enabled INTEGER NOT NULL DEFAULT 1,\n      timeout_ms INTEGER NOT NULL DEFAULT 60000,\n      max_retries INTEGER NOT NULL DEFAULT 0,\n      retry_delay_ms INTEGER NOT NULL DEFAULT 5000,\n      alert_on_failure INTEGER NOT NULL DEFAULT 1,\n      consecutive_failures INTEGER NOT NULL DEFAULT 0,\n      last_success_at TEXT,\n      last_failure_at TEXT,\n      created_at TEXT NOT NULL DEFAULT (datetime('now')),\n      updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n    )\n  `);\n\n  // Indexes for cron job tables\n  db.exec(`\n    CREATE INDEX IF NOT EXISTS idx_cron_job_runs_job_id ON cron_job_runs(job_id);\n    CREATE INDEX IF NOT EXISTS idx_cron_job_runs_status ON cron_job_runs(status);\n    CREATE INDEX IF NOT EXISTS idx_cron_job_runs_started_at ON cron_job_runs(started_at);\n    CREATE INDEX IF NOT EXISTS idx_cron_job_runs_job_status ON cron_job_runs(job_id, status);\n    CREATE INDEX IF NOT EXISTS idx_cron_job_runs_created_at ON cron_job_runs(created_at);\n  `);\n\n  // Seed default job configurations if table is empty\n  const configCount = db.prepare('SELECT COUNT(*) as count FROM cron_job_config').get() as { count: number };\n  if (configCount.count === 0) {\n    db.exec(`\n      INSERT INTO cron_job_config (job_id, display_name, description, schedule, timeout_ms, max_retries, alert_on_failure) VALUES\n      ('dogfood', 'Dogfood Agent', 'Exercises NexFlow routes end-to-end', '*/5 * * * *', 30000, 0, 1),\n      ('scout', 'Scout Agent', 'Tests under-used facilitator routes', '*/15 * * * *', 60000, 0, 1),\n      ('coord', 'Coordinator Agent', 'Runs AI optimization loop', '0 */2 * * *', 120000, 1, 1),\n      ('recommendation-applier', 'Recommendation Applier', 'Applies agent recommendations', '*/10 * * * *', 60000, 1, 1),\n      ('pull-metrics', 'Metrics Puller', 'Fetches external metrics', '0 */4 * * *', 120000, 2, 1),\n      ('social-reply', 'Social Reply', 'Processes social reply queue', '*/15 * * * *', 60000, 0, 1),\n      ('house-x402-job', 'House x402', 'Internal x402 traffic', '*/10 * * * *', 30000, 0, 0),\n      ('crawl-actions', 'Action Crawler', 'Crawls discovery actions', '0 */6 * * *', 300000, 1, 1),\n      ('x402-discovery', 'x402 Discovery', 'Discovers new x402 resources', '0 0 * * *', 600000, 1, 1),\n      ('facilitator-probes', 'Facilitator Probes', 'Health checks for payment facilitators', '*/5 * * * *', 30000, 0, 1)\n    `);\n  }\n}\n\nexport class SqliteAdapter implements DatabaseAdapter {\n  private db: Database.Database;\n\n  constructor(dbPath?: string) {\n    const DB_PATH = dbPath || path.join(process.cwd(), 'data', 'metered-endpoints.db');\n    \n    // Ensure data directory exists\n    if (!fs.existsSync(path.dirname(DB_PATH))) {\n      fs.mkdirSync(path.dirname(DB_PATH), { recursive: true });\n    }\n    \n    this.db = new Database(DB_PATH);\n    this.db.pragma('journal_mode = WAL');\n    \n    // Initialize schema\n    initializeSchema(this.db);\n  }\n\n  async healthCheck(): Promise<boolean> {\n    try {\n      this.db.prepare('SELECT 1').get();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Generic query method for raw SQL\n   * SQLite implementation using better-sqlite3\n   */\n  async query<T = any>(text: string, params?: any[]): Promise<{ rows: T[]; rowCount: number | null }> {\n    // Convert PostgreSQL-style $1, $2 placeholders to SQLite-style ?\n    let sqliteQuery = text;\n    if (params && params.length > 0) {\n      sqliteQuery = text.replace(/\\$(\\d+)/g, () => '?');\n    }\n\n    // Determine if this is a SELECT query or a modification query\n    const isSelect = /^\\s*SELECT/i.test(sqliteQuery.trim());\n    \n    try {\n      if (isSelect) {\n        const rows = this.db.prepare(sqliteQuery).all(...(params || [])) as T[];\n        return { rows, rowCount: rows.length };\n      } else {\n        const result = this.db.prepare(sqliteQuery).run(...(params || []));\n        return { rows: [] as T[], rowCount: result.changes };\n      }\n    } catch (error: any) {\n      console.error('[SQLite] Query error:', error.message);\n      console.error('[SQLite] Original query:', text);\n      console.error('[SQLite] Converted query:', sqliteQuery);\n      throw error;\n    }\n  }\n\n  // =============================================================================\n  // ENDPOINTS\n  // =============================================================================\n\n  async createEndpoint(endpoint: Omit<MeteredEndpoint, 'id' | 'createdAt' | 'updatedAt'> & { id?: string }): Promise<MeteredEndpoint> {\n    const id = endpoint.id || `ep_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n    const now = new Date().toISOString();\n\n    this.db.prepare(`\n      INSERT INTO endpoints (\n        id, name, description, upstream_url, price, network, token_address,\n        token_symbol, chain_id, recipient_address, status, created_at, updated_at, created_by\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `).run(\n      id,\n      endpoint.name,\n      endpoint.description || null,\n      endpoint.upstreamUrl,\n      endpoint.price,\n      endpoint.network,\n      endpoint.tokenAddress,\n      endpoint.tokenSymbol,\n      endpoint.chainId,\n      endpoint.recipientAddress,\n      endpoint.status,\n      now,\n      now,\n      endpoint.createdBy || null\n    );\n\n    return Promise.resolve({\n      ...endpoint,\n      id,\n      createdAt: now,\n      updatedAt: now,\n    });\n  }\n\n  async getEndpoint(endpointId: string): Promise<MeteredEndpoint | null> {\n    const row = this.db.prepare('SELECT * FROM endpoints WHERE id = ? AND status != ?').get(endpointId, 'deleted') as any;\n    if (!row) return Promise.resolve(null);\n    return Promise.resolve(this.mapRowToEndpoint(row));\n  }\n\n  async listEndpoints(filters?: { status?: string; createdBy?: string }): Promise<MeteredEndpoint[]> {\n    let query = 'SELECT * FROM endpoints WHERE status != ?';\n    const params: any[] = ['deleted'];\n\n    if (filters?.status) {\n      query += ' AND status = ?';\n      params.push(filters.status);\n    }\n\n    if (filters?.createdBy) {\n      query += ' AND created_by = ?';\n      params.push(filters.createdBy);\n    }\n\n    query += ' ORDER BY created_at DESC';\n\n    const rows = this.db.prepare(query).all(...params) as any[];\n    return Promise.resolve(rows.map(row => this.mapRowToEndpoint(row)));\n  }\n\n  async updateEndpoint(endpointId: string, updates: Partial<MeteredEndpoint>): Promise<MeteredEndpoint | null> {\n    const allowedFields = [\n      'name', 'description', 'upstreamUrl', 'price', 'network',\n      'tokenAddress', 'tokenSymbol', 'chainId', 'recipientAddress', 'status'\n    ];\n\n    const setClauses: string[] = [];\n    const values: any[] = [];\n\n    for (const [key, value] of Object.entries(updates)) {\n      if (allowedFields.includes(key) && value !== undefined) {\n        const dbKey = key === 'upstreamUrl' ? 'upstream_url' :\n                     key === 'tokenAddress' ? 'token_address' :\n                     key === 'tokenSymbol' ? 'token_symbol' :\n                     key === 'chainId' ? 'chain_id' :\n                     key === 'recipientAddress' ? 'recipient_address' :\n                     key === 'createdAt' ? 'created_at' :\n                     key === 'updatedAt' ? 'updated_at' :\n                     key === 'createdBy' ? 'created_by' : key;\n        setClauses.push(`${dbKey} = ?`);\n        values.push(value);\n      }\n    }\n\n    if (setClauses.length === 0) {\n      return this.getEndpoint(endpointId);\n    }\n\n    setClauses.push('updated_at = ?');\n    values.push(new Date().toISOString());\n    values.push(endpointId);\n\n    this.db.prepare(`UPDATE endpoints SET ${setClauses.join(', ')} WHERE id = ?`).run(...values);\n    return this.getEndpoint(endpointId);\n  }\n\n  async deleteEndpoint(endpointId: string): Promise<boolean> {\n    const result = this.db.prepare('UPDATE endpoints SET status = ?, updated_at = ? WHERE id = ?').run(\n      'deleted',\n      new Date().toISOString(),\n      endpointId\n    );\n    return Promise.resolve(result.changes > 0);\n  }\n\n  // =============================================================================\n  // PAYMENTS\n  // =============================================================================\n\n  async createPayment(payment: Omit<Payment, 'id' | 'verifiedAt'>): Promise<Payment> {\n    const id = `pay_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n    const verifiedAt = new Date().toISOString();\n\n    this.db.prepare(`\n      INSERT INTO payments (\n        id, endpoint_id, tx_hash, from_address, to_address, amount,\n        token_address, network, verified_at, kyt_status, ofac_status, facilitator\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `).run(\n      id,\n      payment.endpointId,\n      payment.txHash,\n      payment.fromAddress,\n      payment.toAddress,\n      payment.amount,\n      payment.tokenAddress,\n      payment.network,\n      verifiedAt,\n      payment.kytStatus || null,\n      payment.ofacStatus || null,\n      payment.facilitator\n    );\n\n    return Promise.resolve({\n      ...payment,\n      id,\n      verifiedAt,\n    });\n  }\n\n  async getPayment(paymentId: string): Promise<Payment | null> {\n    const row = this.db.prepare('SELECT * FROM payments WHERE id = ?').get(paymentId) as any;\n    if (!row) return Promise.resolve(null);\n    return Promise.resolve(this.mapRowToPayment(row));\n  }\n\n  async getPaymentByTxHash(txHash: string): Promise<Payment | null> {\n    const row = this.db.prepare('SELECT * FROM payments WHERE tx_hash = ?').get(txHash) as any;\n    if (!row) return Promise.resolve(null);\n    return Promise.resolve(this.mapRowToPayment(row));\n  }\n\n  async listPayments(filters?: { endpointId?: string; fromAddress?: string }): Promise<Payment[]> {\n    let query = 'SELECT * FROM payments WHERE 1=1';\n    const params: any[] = [];\n\n    if (filters?.endpointId) {\n      query += ' AND endpoint_id = ?';\n      params.push(filters.endpointId);\n    }\n\n    if (filters?.fromAddress) {\n      query += ' AND from_address = ?';\n      params.push(filters.fromAddress);\n    }\n\n    query += ' ORDER BY verified_at DESC';\n\n    const rows = this.db.prepare(query).all(...params) as any[];\n    return Promise.resolve(rows.map(row => this.mapRowToPayment(row)));\n  }\n\n  async getPaymentsForEndpoint(endpointId: string, limit: number = 100): Promise<Payment[]> {\n    const rows = this.db.prepare(\n      'SELECT * FROM payments WHERE endpoint_id = ? ORDER BY verified_at DESC LIMIT ?'\n    ).all(endpointId, limit) as any[];\n    return Promise.resolve(rows.map(row => this.mapRowToPayment(row)));\n  }\n\n  // =============================================================================\n  // USAGE LOGS\n  // =============================================================================\n\n  async createUsageLog(log: Omit<UsageLog, 'id' | 'timestamp'>): Promise<UsageLog> {\n    const id = `log_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n    const timestamp = new Date().toISOString();\n\n    // Add tracing columns if they don't exist (migration support)\n    try {\n      this.db.exec(`\n        ALTER TABLE usage_logs ADD COLUMN conversation_id TEXT;\n        ALTER TABLE usage_logs ADD COLUMN agent_id TEXT;\n        ALTER TABLE usage_logs ADD COLUMN x402_tx_hash TEXT;\n        ALTER TABLE usage_logs ADD COLUMN failure_code TEXT;\n      `);\n    } catch (e: any) {\n      // Columns may already exist, ignore error\n      if (!e.message?.includes('duplicate column')) {\n        console.warn('[SQLite] Migration warning:', e.message);\n      }\n    }\n\n    try {\n      this.db.prepare(`\n        INSERT INTO usage_logs (\n          id, endpoint_id, payment_id, timestamp, method, path,\n          status_code, response_time, units, ip_address, user_agent,\n          conversation_id, agent_id, x402_tx_hash, failure_code\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `).run(\n        id,\n        log.endpointId,\n        log.paymentId || null,\n        timestamp,\n        log.method,\n        log.path,\n        log.statusCode,\n        log.responseTime,\n        log.units,\n        log.ipAddress || null,\n        log.userAgent || null,\n        log.conversationId || null,\n        log.agentId || null,\n        log.x402TxHash || null,\n        log.failureCode || null\n      );\n    } catch (dbError: any) {\n      // Log full error details for debugging\n      const errorInfo = {\n        message: dbError.message || String(dbError),\n        code: dbError.code || 'unknown',\n        errno: dbError.errno,\n        sql: dbError.sql,\n        endpointId: log.endpointId,\n        table: 'usage_logs',\n      };\n      \n      console.error('[SQLite] Insert error details:', JSON.stringify(errorInfo, null, 2));\n      \n      // Re-throw with more context\n      throw new Error(\n        `SQLite insert failed: ${dbError.message || String(dbError)}. ` +\n        `Table: usage_logs, EndpointId: ${log.endpointId}, ` +\n        `Error code: ${dbError.code || 'unknown'}, ` +\n        `SQL: ${dbError.sql || 'N/A'}`\n      );\n    }\n\n    return Promise.resolve({\n      ...log,\n      id,\n      timestamp,\n    });\n  }\n\n  async listUsageLogs(filters?: { endpointId?: string; paymentId?: string }): Promise<UsageLog[]> {\n    let query = 'SELECT * FROM usage_logs WHERE 1=1';\n    const params: any[] = [];\n\n    if (filters?.endpointId) {\n      query += ' AND endpoint_id = ?';\n      params.push(filters.endpointId);\n    }\n\n    if (filters?.paymentId) {\n      query += ' AND payment_id = ?';\n      params.push(filters.paymentId);\n    }\n\n    query += ' ORDER BY timestamp DESC LIMIT 1000';\n\n    const rows = this.db.prepare(query).all(...params) as any[];\n    return Promise.resolve(rows.map(row => this.mapRowToUsageLog(row)));\n  }\n\n  async getUsageStats(endpointId: string, startDate?: string, endDate?: string): Promise<{\n    totalRequests: number;\n    totalPayments: number;\n    totalRevenue: string;\n    averageResponseTime: number;\n  }> {\n    let query = `\n      SELECT\n        COUNT(*) as total_requests,\n        COUNT(DISTINCT payment_id) as total_payments,\n        COALESCE(SUM(CAST(p.amount AS INTEGER)), 0) as total_revenue,\n        COALESCE(AVG(response_time), 0) as avg_response_time\n      FROM usage_logs ul\n      LEFT JOIN payments p ON ul.payment_id = p.id\n      WHERE ul.endpoint_id = ?\n    `;\n    const params: any[] = [endpointId];\n\n    if (startDate) {\n      query += ' AND ul.timestamp >= ?';\n      params.push(startDate);\n    }\n\n    if (endDate) {\n      query += ' AND ul.timestamp <= ?';\n      params.push(endDate);\n    }\n\n    const row = this.db.prepare(query).get(...params) as any;\n\n    return Promise.resolve({\n      totalRequests: row.total_requests || 0,\n      totalPayments: row.total_payments || 0,\n      totalRevenue: row.total_revenue?.toString() || '0',\n      averageResponseTime: row.avg_response_time || 0,\n    });\n  }\n\n  // =============================================================================\n  // HELPERS\n  // =============================================================================\n\n  private mapRowToEndpoint(row: any): MeteredEndpoint {\n    return {\n      id: row.id,\n      name: row.name,\n      description: row.description,\n      upstreamUrl: row.upstream_url,\n      price: row.price,\n      network: row.network,\n      tokenAddress: row.token_address,\n      tokenSymbol: row.token_symbol,\n      chainId: row.chain_id,\n      recipientAddress: row.recipient_address,\n      status: row.status,\n      createdAt: row.created_at,\n      updatedAt: row.updated_at,\n      createdBy: row.created_by,\n    };\n  }\n\n  private mapRowToPayment(row: any): Payment {\n    return {\n      id: row.id,\n      endpointId: row.endpoint_id,\n      txHash: row.tx_hash,\n      fromAddress: row.from_address,\n      toAddress: row.to_address,\n      amount: row.amount,\n      tokenAddress: row.token_address,\n      network: row.network,\n      verifiedAt: row.verified_at,\n      kytStatus: row.kyt_status,\n      ofacStatus: row.ofac_status,\n      facilitator: row.facilitator,\n    };\n  }\n\n  private mapRowToUsageLog(row: any): UsageLog {\n    return {\n      id: row.id,\n      endpointId: row.endpoint_id,\n      paymentId: row.payment_id,\n      timestamp: row.timestamp,\n      method: row.method,\n      path: row.path,\n      statusCode: row.status_code,\n      responseTime: row.response_time,\n      units: row.units,\n      ipAddress: row.ip_address,\n      userAgent: row.user_agent,\n      conversationId: row.conversation_id,\n      agentId: row.agent_id,\n      x402TxHash: row.x402_tx_hash,\n      failureCode: row.failure_code,\n    };\n  }\n\n  // =============================================================================\n  // API KEYS\n  // =============================================================================\n\n  async createApiKey(apiKey: { id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; expiresAt?: string; createdAt: string; updatedAt: string }): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }> {\n    this.db.prepare(\n      `INSERT INTO api_keys (id, key_hash, name, role, user_id, rate_limit, expires_at, x402_demo_calls_used, x402_demo_calls_limit, x402_demo_amount_used, x402_demo_amount_limit, created_at, updated_at)\n       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\n    ).run(\n      apiKey.id, apiKey.keyHash, apiKey.name, apiKey.role, apiKey.userId || null,\n      apiKey.rateLimit, apiKey.expiresAt || null,\n      apiKey.x402DemoCallsUsed || 0, apiKey.x402DemoCallsLimit || 200,\n      apiKey.x402DemoAmountUsed || '0', apiKey.x402DemoAmountLimit || '1000000',\n      apiKey.createdAt, apiKey.updatedAt\n    );\n    return this.findApiKeyByHash(apiKey.keyHash) as Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }>;\n  }\n\n  async findApiKeyByHash(keyHash: string): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string } | null> {\n    const row = this.db.prepare(\n      `SELECT * FROM api_keys WHERE key_hash = ? AND revoked_at IS NULL`\n    ).get(keyHash) as any;\n    if (!row) return null;\n    return {\n      id: row.id,\n      keyHash: row.key_hash,\n      name: row.name,\n      role: row.role,\n      userId: row.user_id,\n      rateLimit: row.rate_limit,\n      lastUsedAt: row.last_used_at,\n      lastUsedIp: row.last_used_ip,\n      expiresAt: row.expires_at,\n      x402DemoCallsUsed: row.x402_demo_calls_used || 0,\n      x402DemoCallsLimit: row.x402_demo_calls_limit || 200,\n      x402DemoAmountUsed: row.x402_demo_amount_used || '0',\n      x402DemoAmountLimit: row.x402_demo_amount_limit || '1000000',\n      createdAt: row.created_at,\n      updatedAt: row.updated_at,\n      revokedAt: row.revoked_at,\n    };\n  }\n\n  async updateApiKeyLastUsed(keyId: string, ipAddress?: string): Promise<void> {\n    const now = new Date().toISOString();\n    this.db.prepare(\n      `UPDATE api_keys SET last_used_at = ?, last_used_ip = ?, updated_at = ? WHERE id = ?`\n    ).run(now, ipAddress || null, now, keyId);\n  }\n\n  async updateApiKeyX402DemoAllowance(keyId: string, callsUsed: number, amountUsed: string): Promise<void> {\n    const now = new Date().toISOString();\n    this.db.prepare(\n      `UPDATE api_keys SET x402_demo_calls_used = ?, x402_demo_amount_used = ?, updated_at = ? WHERE id = ?`\n    ).run(callsUsed, amountUsed, now, keyId);\n  }\n\n  async updateApiKeyX402DemoLimits(keyId: string, callsLimit?: number, amountLimit?: string): Promise<void> {\n    const now = new Date().toISOString();\n    if (callsLimit !== undefined && amountLimit !== undefined) {\n      this.db.prepare(\n        `UPDATE api_keys SET x402_demo_calls_limit = ?, x402_demo_amount_limit = ?, updated_at = ? WHERE id = ?`\n      ).run(callsLimit, amountLimit, now, keyId);\n    } else if (callsLimit !== undefined) {\n      this.db.prepare(\n        `UPDATE api_keys SET x402_demo_calls_limit = ?, updated_at = ? WHERE id = ?`\n      ).run(callsLimit, now, keyId);\n    } else if (amountLimit !== undefined) {\n      this.db.prepare(\n        `UPDATE api_keys SET x402_demo_amount_limit = ?, updated_at = ? WHERE id = ?`\n      ).run(amountLimit, now, keyId);\n    }\n  }\n\n  async revokeApiKey(keyId: string): Promise<boolean> {\n    const now = new Date().toISOString();\n    const result = this.db.prepare(\n      `UPDATE api_keys SET revoked_at = ?, updated_at = ? WHERE id = ? AND revoked_at IS NULL`\n    ).run(now, now, keyId);\n    return result.changes > 0;\n  }\n\n  async listApiKeys(userId?: string): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }[]> {\n    let query = `SELECT * FROM api_keys WHERE revoked_at IS NULL`;\n    const params: any[] = [];\n    if (userId) {\n      query += ` AND user_id = ?`;\n      params.push(userId);\n    }\n    query += ` ORDER BY created_at DESC`;\n    const rows = this.db.prepare(query).all(...params) as any[];\n    return Promise.resolve(rows.map((row) => ({\n      id: row.id,\n      keyHash: row.key_hash,\n      name: row.name,\n      role: row.role,\n      userId: row.user_id,\n      rateLimit: row.rate_limit,\n      lastUsedAt: row.last_used_at,\n      lastUsedIp: row.last_used_ip,\n      expiresAt: row.expires_at,\n      x402DemoCallsUsed: row.x402_demo_calls_used || 0,\n      x402DemoCallsLimit: row.x402_demo_calls_limit || 200,\n      x402DemoAmountUsed: row.x402_demo_amount_used || '0',\n      x402DemoAmountLimit: row.x402_demo_amount_limit || '1000000',\n      createdAt: row.created_at,\n      updatedAt: row.updated_at,\n      revokedAt: row.revoked_at,\n    })));\n  }\n\n  close(): void {\n    this.db.close();\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 734, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/adapters/postgres-adapter.ts"],"sourcesContent":["// =============================================================================\r\n// POSTGRESQL ADAPTER\r\n// =============================================================================\r\n// PostgreSQL implementation of DatabaseAdapter\r\n// Uses pg (node-postgres) with connection pooling\r\n\r\nimport { Pool, PoolClient, QueryResult } from 'pg';\r\nimport type { DatabaseAdapter } from './base-adapter';\r\nimport type { MeteredEndpoint, Payment, UsageLog } from '../metered-endpoints';\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\n/**\r\n * Database configuration with sensible defaults\r\n * Can be overridden via environment variables\r\n */\r\nconst DB_CONFIG = {\r\n  // Pool settings\r\n  maxPoolSize: parseInt(process.env.DB_POOL_MAX || '20', 10),\r\n  minPoolSize: parseInt(process.env.DB_POOL_MIN || '2', 10),\r\n  idleTimeoutMs: parseInt(process.env.DB_IDLE_TIMEOUT_MS || '30000', 10),\r\n  connectionTimeoutMs: parseInt(process.env.DB_CONNECTION_TIMEOUT_MS || '5000', 10),\r\n  maxLifetimeMs: parseInt(process.env.DB_MAX_LIFETIME_MS || '1800000', 10), // 30 minutes\r\n  \r\n  // Query settings\r\n  statementTimeoutMs: parseInt(process.env.DB_STATEMENT_TIMEOUT_MS || '30000', 10), // 30 seconds\r\n  queryTimeoutMs: parseInt(process.env.DB_QUERY_TIMEOUT_MS || '30000', 10),\r\n  \r\n  // Retry settings\r\n  acquireRetries: parseInt(process.env.DB_ACQUIRE_RETRIES || '3', 10),\r\n  acquireRetryDelayMs: parseInt(process.env.DB_ACQUIRE_RETRY_DELAY_MS || '100', 10),\r\n};\r\n\r\nexport class PostgresAdapter implements DatabaseAdapter {\r\n  private pool: Pool;\r\n  private readonly statementTimeoutMs: number;\r\n\r\n  constructor(connectionString: string) {\r\n    this.statementTimeoutMs = DB_CONFIG.statementTimeoutMs;\r\n    \r\n    this.pool = new Pool({\r\n      connectionString,\r\n      \r\n      // Pool size configuration\r\n      max: DB_CONFIG.maxPoolSize,\r\n      min: DB_CONFIG.minPoolSize,\r\n      \r\n      // Timeout configuration\r\n      idleTimeoutMillis: DB_CONFIG.idleTimeoutMs,\r\n      connectionTimeoutMillis: DB_CONFIG.connectionTimeoutMs,\r\n      \r\n      // Connection lifetime (prevents stale connections)\r\n      maxLifetimeSeconds: Math.floor(DB_CONFIG.maxLifetimeMs / 1000),\r\n      \r\n      // Enable keep-alive to detect dead connections\r\n      keepAlive: true,\r\n      keepAliveInitialDelayMillis: 10000,\r\n      \r\n      // Application name for monitoring\r\n      application_name: process.env.APP_NAME || 'nexflow-api',\r\n    });\r\n\r\n    // Handle pool errors\r\n    this.pool.on('error', (err) => {\r\n      console.error('[PostgresAdapter] Unexpected pool error:', err);\r\n    });\r\n\r\n    // Log pool connection events in development\r\n    if (process.env.NODE_ENV === 'development') {\r\n      this.pool.on('connect', (client) => {\r\n        console.log('[PostgresAdapter] New client connected to pool');\r\n      });\r\n      \r\n      this.pool.on('remove', (client) => {\r\n        console.log('[PostgresAdapter] Client removed from pool');\r\n      });\r\n    }\r\n\r\n    console.log('[PostgresAdapter] Pool initialized:', {\r\n      maxSize: DB_CONFIG.maxPoolSize,\r\n      minSize: DB_CONFIG.minPoolSize,\r\n      statementTimeoutMs: this.statementTimeoutMs,\r\n      maxLifetimeMs: DB_CONFIG.maxLifetimeMs,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute a query with statement timeout\r\n   * This wraps all queries to ensure they don't run forever\r\n   */\r\n  private async queryWithTimeout<T extends QueryResult = QueryResult>(\r\n    text: string,\r\n    params?: any[],\r\n    timeoutMs?: number\r\n  ): Promise<T> {\r\n    const timeout = timeoutMs || this.statementTimeoutMs;\r\n    const client = await this.pool.connect();\r\n    \r\n    try {\r\n      // Set statement timeout for this session\r\n      await client.query(`SET statement_timeout = ${timeout}`);\r\n      \r\n      // Execute the actual query\r\n      const result = await client.query(text, params);\r\n      \r\n      return result as T;\r\n    } finally {\r\n      // Always release the client back to the pool\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pool statistics for monitoring\r\n   */\r\n  getPoolStats(): {\r\n    totalCount: number;\r\n    idleCount: number;\r\n    waitingCount: number;\r\n  } {\r\n    return {\r\n      totalCount: this.pool.totalCount,\r\n      idleCount: this.pool.idleCount,\r\n      waitingCount: this.pool.waitingCount,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Simple query method that uses default timeout\r\n   * For most queries, this is all you need\r\n   * Public interface for raw SQL queries\r\n   */\r\n  async query<T = any>(\r\n    text: string,\r\n    params?: any[]\r\n  ): Promise<{ rows: T[]; rowCount: number | null }> {\r\n    const result = await this.queryWithTimeout(text, params);\r\n    return {\r\n      rows: result.rows as T[],\r\n      rowCount: result.rowCount,\r\n    };\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    try {\r\n      // Use a short timeout for health checks (5 seconds)\r\n      const result = await this.queryWithTimeout('SELECT 1', [], 5000);\r\n      return result.rows.length > 0;\r\n    } catch (error) {\r\n      console.error('[PostgresAdapter] Health check failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // =============================================================================\r\n  // ENDPOINTS\r\n  // =============================================================================\r\n\r\n  async createEndpoint(endpoint: Omit<MeteredEndpoint, 'id' | 'createdAt' | 'updatedAt'> & { id?: string }): Promise<MeteredEndpoint> {\r\n    const id = endpoint.id || `ep_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const now = new Date().toISOString();\r\n\r\n    const result = await this.query(\r\n      `INSERT INTO endpoints (\r\n        id, name, description, upstream_url, price, network, token_address,\r\n        token_symbol, chain_id, recipient_address, status, created_at, updated_at, created_by\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        endpoint.name,\r\n        endpoint.description || null,\r\n        endpoint.upstreamUrl,\r\n        endpoint.price,\r\n        endpoint.network,\r\n        endpoint.tokenAddress,\r\n        endpoint.tokenSymbol,\r\n        endpoint.chainId,\r\n        endpoint.recipientAddress,\r\n        endpoint.status,\r\n        now,\r\n        now,\r\n        endpoint.createdBy || null,\r\n      ]\r\n    );\r\n\r\n    return this.mapRowToEndpoint(result.rows[0]);\r\n  }\r\n\r\n  async getEndpoint(endpointId: string): Promise<MeteredEndpoint | null> {\r\n    const result = await this.query(\r\n      'SELECT * FROM endpoints WHERE id = $1 AND status != $2',\r\n      [endpointId, 'deleted']\r\n    );\r\n\r\n    if (result.rows.length === 0) return null;\r\n    return this.mapRowToEndpoint(result.rows[0]);\r\n  }\r\n\r\n  async listEndpoints(filters?: { status?: string; createdBy?: string }): Promise<MeteredEndpoint[]> {\r\n    let query = 'SELECT * FROM endpoints WHERE status != $1';\r\n    const params: any[] = ['deleted'];\r\n    let paramIndex = 2;\r\n\r\n    if (filters?.status) {\r\n      query += ` AND status = $${paramIndex}`;\r\n      params.push(filters.status);\r\n      paramIndex++;\r\n    }\r\n\r\n    if (filters?.createdBy) {\r\n      query += ` AND created_by = $${paramIndex}`;\r\n      params.push(filters.createdBy);\r\n      paramIndex++;\r\n    }\r\n\r\n    query += ' ORDER BY created_at DESC';\r\n\r\n    try {\r\n      const result = await this.query(query, params);\r\n      return result.rows.map(row => this.mapRowToEndpoint(row));\r\n    } catch (error) {\r\n      console.error('[PostgresAdapter] listEndpoints error:', error);\r\n      console.error('[PostgresAdapter] Query:', query);\r\n      console.error('[PostgresAdapter] Params:', params);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async updateEndpoint(endpointId: string, updates: Partial<MeteredEndpoint>): Promise<MeteredEndpoint | null> {\r\n    const allowedFields = [\r\n      'name', 'description', 'upstreamUrl', 'price', 'network',\r\n      'tokenAddress', 'tokenSymbol', 'chainId', 'recipientAddress', 'status'\r\n    ];\r\n\r\n    const setClauses: string[] = [];\r\n    const values: any[] = [];\r\n    let paramIndex = 1;\r\n\r\n    for (const [key, value] of Object.entries(updates)) {\r\n      if (allowedFields.includes(key) && value !== undefined) {\r\n        const dbKey = key === 'upstreamUrl' ? 'upstream_url' :\r\n                     key === 'tokenAddress' ? 'token_address' :\r\n                     key === 'tokenSymbol' ? 'token_symbol' :\r\n                     key === 'chainId' ? 'chain_id' :\r\n                     key === 'recipientAddress' ? 'recipient_address' :\r\n                     key === 'createdAt' ? 'created_at' :\r\n                     key === 'updatedAt' ? 'updated_at' :\r\n                     key === 'createdBy' ? 'created_by' : key;\r\n        setClauses.push(`${dbKey} = $${paramIndex}`);\r\n        values.push(value);\r\n        paramIndex++;\r\n      }\r\n    }\r\n\r\n    if (setClauses.length === 0) {\r\n      return this.getEndpoint(endpointId);\r\n    }\r\n\r\n    setClauses.push(`updated_at = $${paramIndex}`);\r\n    values.push(new Date().toISOString());\r\n    paramIndex++;\r\n\r\n    values.push(endpointId);\r\n\r\n    const result = await this.query(\r\n      `UPDATE endpoints SET ${setClauses.join(', ')} WHERE id = $${paramIndex} RETURNING *`,\r\n      values\r\n    );\r\n\r\n    if (result.rows.length === 0) return null;\r\n    return this.mapRowToEndpoint(result.rows[0]);\r\n  }\r\n\r\n  async deleteEndpoint(endpointId: string): Promise<boolean> {\r\n    const result = await this.query(\r\n      'UPDATE endpoints SET status = $1, updated_at = $2 WHERE id = $3',\r\n      ['deleted', new Date().toISOString(), endpointId]\r\n    );\r\n    return result.rowCount !== null && result.rowCount > 0;\r\n  }\r\n\r\n  // =============================================================================\r\n  // PAYMENTS\r\n  // =============================================================================\r\n\r\n  async createPayment(payment: Omit<Payment, 'id' | 'verifiedAt'>): Promise<Payment> {\r\n    const id = `pay_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const now = new Date().toISOString();\r\n    const verifiedAt = now;\r\n    // Generate invoice_id if not provided (required by schema)\r\n    const invoiceId = `inv_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Determine currency and token symbol from token address or default to USDC\r\n    // For USDC on Base: 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\r\n    const currency = payment.tokenAddress === '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' ? 'USDC' : 'USDC';\r\n    const token = payment.tokenAddress; // token column stores the token address\r\n\r\n    // Set default status for verified payments\r\n    const status = 'verified'; // Payment is verified and completed\r\n\r\n    const result = await this.query(\r\n      `INSERT INTO payments (\r\n        id, endpoint_id, invoice_id, tx_hash, from_address, to_address, amount,\r\n        currency, token, token_address, network, status, created_at, verified_at, kyt_status, ofac_status, facilitator\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        payment.endpointId,\r\n        invoiceId,\r\n        payment.txHash,\r\n        payment.fromAddress,\r\n        payment.toAddress,\r\n        payment.amount,\r\n        currency,\r\n        token,\r\n        payment.tokenAddress,\r\n        payment.network,\r\n        status,\r\n        now, // created_at\r\n        verifiedAt,\r\n        payment.kytStatus || null,\r\n        payment.ofacStatus || null,\r\n        payment.facilitator,\r\n      ]\r\n    );\r\n\r\n    return this.mapRowToPayment(result.rows[0]);\r\n  }\r\n\r\n  async getPayment(paymentId: string): Promise<Payment | null> {\r\n    const result = await this.query('SELECT * FROM payments WHERE id = $1', [paymentId]);\r\n    if (result.rows.length === 0) return null;\r\n    return this.mapRowToPayment(result.rows[0]);\r\n  }\r\n\r\n  async getPaymentByTxHash(txHash: string): Promise<Payment | null> {\r\n    const result = await this.query('SELECT * FROM payments WHERE tx_hash = $1', [txHash]);\r\n    if (result.rows.length === 0) return null;\r\n    return this.mapRowToPayment(result.rows[0]);\r\n  }\r\n\r\n  async listPayments(filters?: { endpointId?: string; fromAddress?: string }): Promise<Payment[]> {\r\n    let query = 'SELECT * FROM payments WHERE 1=1';\r\n    const params: any[] = [];\r\n    let paramIndex = 1;\r\n\r\n    if (filters?.endpointId) {\r\n      query += ` AND endpoint_id = $${paramIndex}`;\r\n      params.push(filters.endpointId);\r\n      paramIndex++;\r\n    }\r\n\r\n    if (filters?.fromAddress) {\r\n      query += ` AND from_address = $${paramIndex}`;\r\n      params.push(filters.fromAddress);\r\n      paramIndex++;\r\n    }\r\n\r\n    query += ' ORDER BY verified_at DESC';\r\n\r\n    const result = await this.query(query, params);\r\n    return result.rows.map(row => this.mapRowToPayment(row));\r\n  }\r\n\r\n  async getPaymentsForEndpoint(endpointId: string, limit: number = 100): Promise<Payment[]> {\r\n    const result = await this.query(\r\n      'SELECT * FROM payments WHERE endpoint_id = $1 ORDER BY verified_at DESC LIMIT $2',\r\n      [endpointId, limit]\r\n    );\r\n    return result.rows.map(row => this.mapRowToPayment(row));\r\n  }\r\n\r\n  // =============================================================================\r\n  // USAGE LOGS\r\n  // =============================================================================\r\n\r\n  async createUsageLog(log: Omit<UsageLog, 'id' | 'timestamp'>): Promise<UsageLog> {\r\n    const id = `log_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const timestamp = new Date().toISOString();\r\n\r\n    const result = await this.query(\r\n      `INSERT INTO usage_logs (\r\n        id, endpoint_id, payment_id, timestamp, method, path,\r\n        status_code, response_time, units, ip_address, user_agent,\r\n        conversation_id, agent_id, x402_tx_hash, failure_code\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        log.endpointId,\r\n        log.paymentId || null,\r\n        timestamp,\r\n        log.method,\r\n        log.path,\r\n        log.statusCode,\r\n        log.responseTime,\r\n        log.units,\r\n        log.ipAddress || null,\r\n        log.userAgent || null,\r\n        log.conversationId || null,\r\n        log.agentId || null,\r\n        log.x402TxHash || null,\r\n        log.failureCode || null,\r\n      ]\r\n    );\r\n\r\n    return this.mapRowToUsageLog(result.rows[0]);\r\n  }\r\n\r\n  async listUsageLogs(filters?: { endpointId?: string; paymentId?: string }): Promise<UsageLog[]> {\r\n    let query = 'SELECT * FROM usage_logs WHERE 1=1';\r\n    const params: any[] = [];\r\n    let paramIndex = 1;\r\n\r\n    if (filters?.endpointId) {\r\n      query += ` AND endpoint_id = $${paramIndex}`;\r\n      params.push(filters.endpointId);\r\n      paramIndex++;\r\n    }\r\n\r\n    if (filters?.paymentId) {\r\n      query += ` AND payment_id = $${paramIndex}`;\r\n      params.push(filters.paymentId);\r\n      paramIndex++;\r\n    }\r\n\r\n    query += ' ORDER BY timestamp DESC LIMIT 1000';\r\n\r\n    const result = await this.query(query, params);\r\n    return result.rows.map(row => this.mapRowToUsageLog(row));\r\n  }\r\n\r\n  async getUsageStats(endpointId: string, startDate?: string, endDate?: string): Promise<{\r\n    totalRequests: number;\r\n    totalPayments: number;\r\n    totalRevenue: string;\r\n    averageResponseTime: number;\r\n  }> {\r\n    let query = `\r\n      SELECT\r\n        COUNT(*) as total_requests,\r\n        COUNT(DISTINCT payment_id) as total_payments,\r\n        COALESCE(SUM(p.amount), '0') as total_revenue,\r\n        COALESCE(AVG(response_time), 0) as avg_response_time\r\n      FROM usage_logs ul\r\n      LEFT JOIN payments p ON ul.payment_id = p.id\r\n      WHERE ul.endpoint_id = $1\r\n    `;\r\n    const params: any[] = [endpointId];\r\n    let paramIndex = 2;\r\n\r\n    if (startDate) {\r\n      query += ` AND ul.timestamp >= $${paramIndex}`;\r\n      params.push(startDate);\r\n      paramIndex++;\r\n    }\r\n\r\n    if (endDate) {\r\n      query += ` AND ul.timestamp <= $${paramIndex}`;\r\n      params.push(endDate);\r\n      paramIndex++;\r\n    }\r\n\r\n    const result = await this.query(query, params);\r\n    const row = result.rows[0];\r\n\r\n    return {\r\n      totalRequests: parseInt(row.total_requests) || 0,\r\n      totalPayments: parseInt(row.total_payments) || 0,\r\n      totalRevenue: row.total_revenue || '0',\r\n      averageResponseTime: parseFloat(row.avg_response_time) || 0,\r\n    };\r\n  }\r\n\r\n  // =============================================================================\r\n  // HELPERS\r\n  // =============================================================================\r\n\r\n  private mapRowToEndpoint(row: any): MeteredEndpoint {\r\n    return {\r\n      id: row.id,\r\n      name: row.name,\r\n      description: row.description,\r\n      upstreamUrl: row.upstream_url,\r\n      price: row.price,\r\n      network: row.network,\r\n      tokenAddress: row.token_address,\r\n      tokenSymbol: row.token_symbol,\r\n      chainId: row.chain_id,\r\n      recipientAddress: row.recipient_address,\r\n      status: row.status,\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      createdBy: row.created_by,\r\n    };\r\n  }\r\n\r\n  private mapRowToPayment(row: any): Payment {\r\n    return {\r\n      id: row.id,\r\n      endpointId: row.endpoint_id,\r\n      txHash: row.tx_hash,\r\n      fromAddress: row.from_address,\r\n      toAddress: row.to_address,\r\n      amount: row.amount,\r\n      tokenAddress: row.token_address,\r\n      network: row.network,\r\n      verifiedAt: row.verified_at,\r\n      kytStatus: row.kyt_status,\r\n      ofacStatus: row.ofac_status,\r\n      facilitator: row.facilitator,\r\n    };\r\n  }\r\n\r\n  private mapRowToUsageLog(row: any): UsageLog {\r\n    return {\r\n      id: row.id,\r\n      endpointId: row.endpoint_id,\r\n      paymentId: row.payment_id,\r\n      timestamp: row.timestamp,\r\n      method: row.method,\r\n      path: row.path,\r\n      statusCode: row.status_code,\r\n      responseTime: row.response_time,\r\n      units: row.units,\r\n      ipAddress: row.ip_address,\r\n      userAgent: row.user_agent,\r\n      conversationId: row.conversation_id,\r\n      agentId: row.agent_id,\r\n      x402TxHash: row.x402_tx_hash,\r\n      failureCode: row.failure_code,\r\n    };\r\n  }\r\n\r\n  // =============================================================================\r\n  // API KEYS\r\n  // =============================================================================\r\n\r\n  async createApiKey(apiKey: { id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; expiresAt?: string; createdAt: string; updatedAt: string }): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }> {\r\n    await this.query(\r\n      `INSERT INTO api_keys (id, key_hash, name, role, user_id, rate_limit, expires_at, created_at, updated_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,\r\n      [\r\n        apiKey.id, apiKey.keyHash, apiKey.name, apiKey.role, apiKey.userId || null,\r\n        apiKey.rateLimit, apiKey.expiresAt || null, apiKey.createdAt, apiKey.updatedAt,\r\n      ]\r\n    );\r\n    return this.findApiKeyByHash(apiKey.keyHash) as Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }>;\r\n  }\r\n\r\n  async findApiKeyByHash(keyHash: string): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string } | null> {\r\n    const result = await this.query(\r\n      `SELECT * FROM api_keys WHERE key_hash = $1 AND revoked_at IS NULL`,\r\n      [keyHash]\r\n    );\r\n    if (result.rows.length === 0) return null;\r\n    const row = result.rows[0];\r\n    return {\r\n      id: row.id,\r\n      keyHash: row.key_hash,\r\n      name: row.name,\r\n      role: row.role,\r\n      userId: row.user_id,\r\n      rateLimit: row.rate_limit,\r\n      lastUsedAt: row.last_used_at,\r\n      lastUsedIp: row.last_used_ip,\r\n      expiresAt: row.expires_at,\r\n      x402DemoCallsUsed: row.x402_demo_calls_used || 0,\r\n      x402DemoCallsLimit: row.x402_demo_calls_limit || 200,\r\n      x402DemoAmountUsed: row.x402_demo_amount_used || '0',\r\n      x402DemoAmountLimit: row.x402_demo_amount_limit || '1000000',\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      revokedAt: row.revoked_at,\r\n    };\r\n  }\r\n\r\n  async updateApiKeyLastUsed(keyId: string, ipAddress?: string): Promise<void> {\r\n    await this.query(\r\n      `UPDATE api_keys SET last_used_at = NOW(), last_used_ip = $2, updated_at = NOW() WHERE id = $1`,\r\n      [keyId, ipAddress || null]\r\n    );\r\n  }\r\n\r\n  async updateApiKeyX402DemoAllowance(keyId: string, callsUsed: number, amountUsed: string): Promise<void> {\r\n    await this.query(\r\n      `UPDATE api_keys SET x402_demo_calls_used = $2, x402_demo_amount_used = $3, updated_at = NOW() WHERE id = $1`,\r\n      [keyId, callsUsed, amountUsed]\r\n    );\r\n  }\r\n\r\n  async updateApiKeyX402DemoLimits(keyId: string, callsLimit?: number, amountLimit?: string): Promise<void> {\r\n    if (callsLimit !== undefined && amountLimit !== undefined) {\r\n      await this.query(\r\n        `UPDATE api_keys SET x402_demo_calls_limit = $2, x402_demo_amount_limit = $3, updated_at = NOW() WHERE id = $1`,\r\n        [keyId, callsLimit, amountLimit]\r\n      );\r\n    } else if (callsLimit !== undefined) {\r\n      await this.query(\r\n        `UPDATE api_keys SET x402_demo_calls_limit = $2, updated_at = NOW() WHERE id = $1`,\r\n        [keyId, callsLimit]\r\n      );\r\n    } else if (amountLimit !== undefined) {\r\n      await this.query(\r\n        `UPDATE api_keys SET x402_demo_amount_limit = $2, updated_at = NOW() WHERE id = $1`,\r\n        [keyId, amountLimit]\r\n      );\r\n    }\r\n  }\r\n\r\n  async revokeApiKey(keyId: string): Promise<boolean> {\r\n    const result = await this.query(\r\n      `UPDATE api_keys SET revoked_at = NOW(), updated_at = NOW() WHERE id = $1 AND revoked_at IS NULL`,\r\n      [keyId]\r\n    );\r\n    return result.rowCount > 0;\r\n  }\r\n\r\n  async listApiKeys(userId?: string): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }[]> {\r\n    let query = `SELECT * FROM api_keys WHERE revoked_at IS NULL`;\r\n    const params: any[] = [];\r\n    if (userId) {\r\n      query += ` AND user_id = $1`;\r\n      params.push(userId);\r\n    }\r\n    query += ` ORDER BY created_at DESC`;\r\n    const result = await this.query(query, params);\r\n    return result.rows.map((row) => ({\r\n      id: row.id,\r\n      keyHash: row.key_hash,\r\n      name: row.name,\r\n      role: row.role,\r\n      userId: row.user_id,\r\n      rateLimit: row.rate_limit,\r\n      lastUsedAt: row.last_used_at,\r\n      lastUsedIp: row.last_used_ip,\r\n      expiresAt: row.expires_at,\r\n      x402DemoCallsUsed: row.x402_demo_calls_used || 0,\r\n      x402DemoCallsLimit: row.x402_demo_calls_limit || 200,\r\n      x402DemoAmountUsed: row.x402_demo_amount_used || '0',\r\n      x402DemoAmountLimit: row.x402_demo_amount_limit || '1000000',\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      revokedAt: row.revoked_at,\r\n    }));\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    await this.pool.end();\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1300, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/client.ts"],"sourcesContent":["// =============================================================================\r\n// DATABASE CLIENT FACTORY\r\n// =============================================================================\r\n// Automatically selects SQLite (dev) or PostgreSQL (prod) based on environment\r\n//\r\n// Configuration (environment variables):\r\n// - DATABASE_URL: PostgreSQL connection string (required for prod)\r\n//\r\n// PostgreSQL Pool Settings:\r\n// - DB_POOL_MAX: Maximum pool size (default: 20)\r\n// - DB_POOL_MIN: Minimum pool size (default: 2)\r\n// - DB_IDLE_TIMEOUT_MS: Idle connection timeout (default: 30000)\r\n// - DB_CONNECTION_TIMEOUT_MS: Connection acquisition timeout (default: 5000)\r\n// - DB_MAX_LIFETIME_MS: Max connection lifetime (default: 1800000 = 30min)\r\n//\r\n// Query Settings:\r\n// - DB_STATEMENT_TIMEOUT_MS: Query timeout (default: 30000)\r\n\r\nimport type { DatabaseAdapter } from './adapters/base-adapter';\r\nimport { SqliteAdapter } from './adapters/sqlite-adapter';\r\nimport { PostgresAdapter } from './adapters/postgres-adapter';\r\n\r\nlet dbAdapter: DatabaseAdapter | null = null;\r\n\r\n/**\r\n * Get the database adapter instance\r\n * Uses PostgreSQL if DATABASE_URL is set, otherwise falls back to SQLite\r\n */\r\nexport function getDb(): DatabaseAdapter {\r\n  if (dbAdapter) {\r\n    return dbAdapter;\r\n  }\r\n\r\n  const databaseUrl = process.env.DATABASE_URL;\r\n\r\n  if (databaseUrl && databaseUrl.startsWith('postgresql://')) {\r\n    // Production: Use PostgreSQL\r\n    console.log('[db] Using PostgreSQL adapter');\r\n    dbAdapter = new PostgresAdapter(databaseUrl);\r\n  } else {\r\n    // Development: Use SQLite\r\n    console.log('[db] Using SQLite adapter (development mode)');\r\n    dbAdapter = new SqliteAdapter();\r\n  }\r\n\r\n  return dbAdapter;\r\n}\r\n\r\n/**\r\n * Get PostgreSQL pool statistics (for monitoring)\r\n * Returns null if using SQLite\r\n */\r\nexport function getPoolStats(): { totalCount: number; idleCount: number; waitingCount: number } | null {\r\n  if (!dbAdapter) {\r\n    return null;\r\n  }\r\n  \r\n  if (dbAdapter instanceof PostgresAdapter) {\r\n    return dbAdapter.getPoolStats();\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * Close database connections (useful for cleanup in tests)\r\n */\r\nexport async function closeDb(): Promise<void> {\r\n  if (dbAdapter) {\r\n    if ('close' in dbAdapter && typeof dbAdapter.close === 'function') {\r\n      await dbAdapter.close();\r\n    }\r\n    dbAdapter = null;\r\n  }\r\n}\r\n\r\n/**\r\n * Check if the database adapter is PostgreSQL\r\n */\r\nexport function isPostgres(db: any): boolean {\r\n  return db && (db instanceof PostgresAdapter || 'pool' in db || typeof db?.pool?.query === 'function');\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;AAC1B,gFAAgF;AAChF,+EAA+E;AAC/E,EAAE;AACF,yCAAyC;AACzC,mEAAmE;AACnE,EAAE;AACF,4BAA4B;AAC5B,iDAAiD;AACjD,gDAAgD;AAChD,iEAAiE;AACjE,6EAA6E;AAC7E,2EAA2E;AAC3E,EAAE;AACF,kBAAkB;AAClB,4DAA4D;;;;;;;;;;;AAG5D;AACA;;;;;;;AAEA,IAAI,YAAoC;AAMjC,SAAS;IACd,IAAI,WAAW;QACb,OAAO;IACT;IAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY;IAE5C,IAAI,eAAe,YAAY,UAAU,CAAC,kBAAkB;QAC1D,6BAA6B;QAC7B,QAAQ,GAAG,CAAC;QACZ,YAAY,IAAI,iKAAe,CAAC;IAClC,OAAO;QACL,0BAA0B;QAC1B,QAAQ,GAAG,CAAC;QACZ,YAAY,IAAI,6JAAa;IAC/B;IAEA,OAAO;AACT;AAMO,SAAS;IACd,IAAI,CAAC,WAAW;QACd,OAAO;IACT;IAEA,IAAI,qBAAqB,iKAAe,EAAE;QACxC,OAAO,UAAU,YAAY;IAC/B;IAEA,OAAO;AACT;AAKO,eAAe;IACpB,IAAI,WAAW;QACb,IAAI,WAAW,aAAa,OAAO,UAAU,KAAK,KAAK,YAAY;YACjE,MAAM,UAAU,KAAK;QACvB;QACA,YAAY;IACd;AACF;AAKO,SAAS,WAAW,EAAO;IAChC,OAAO,MAAM,CAAC,cAAc,iKAAe,IAAI,UAAU,MAAM,OAAO,IAAI,MAAM,UAAU,UAAU;AACtG"}},
    {"offset": {"line": 1379, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/metered-endpoints.ts"],"sourcesContent":["// =============================================================================\r\n// METERED ENDPOINTS DATABASE\r\n// =============================================================================\r\n// Database layer for metered endpoints, payments, and usage tracking\r\n// Uses adapter pattern: SQLite (dev) or PostgreSQL (prod)\r\n\r\nimport { getDb } from './client';\r\nimport type { DatabaseAdapter } from './adapters/base-adapter';\r\n\r\n// Types\r\nexport interface MeteredEndpoint {\r\n  id: string;\r\n  name: string;\r\n  description?: string;\r\n  upstreamUrl: string;\r\n  price: string; // Price in smallest unit (e.g., 1000000 for 1 USDC)\r\n  network: string; // 'base', 'base-sepolia', etc.\r\n  tokenAddress: string; // USDC address\r\n  tokenSymbol: string; // 'USDC'\r\n  chainId: number;\r\n  recipientAddress: string; // Address that receives payments (must not be blacklisted)\r\n  status: 'active' | 'paused' | 'deleted';\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  createdBy?: string; // User/API key that created it\r\n}\r\n\r\nexport interface Payment {\r\n  id: string;\r\n  endpointId: string;\r\n  txHash: string;\r\n  fromAddress: string;\r\n  toAddress: string;\r\n  amount: string;\r\n  tokenAddress: string;\r\n  network: string;\r\n  verifiedAt: string;\r\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\r\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\r\n  facilitator: string; // 'cdp', 'payai', etc.\r\n}\r\n\r\nexport interface UsageLog {\r\n  id: string;\r\n  endpointId: string;\r\n  paymentId?: string; // Link to payment if payment was required\r\n  timestamp: string;\r\n  method: string; // HTTP method\r\n  path: string;\r\n  statusCode: number;\r\n  responseTime: number; // milliseconds\r\n  units: number; // Usage units (could be 1 per call, or based on response size, etc.)\r\n  ipAddress?: string;\r\n  userAgent?: string;\r\n  // Observability fields\r\n  conversationId?: string; // Conversation/request ID for tracing\r\n  agentId?: string; // Agent ID that made the request\r\n  x402TxHash?: string; // x402 transaction hash\r\n  failureCode?: string; // Error code if request failed\r\n}\r\n\r\n// =============================================================================\r\n// ENDPOINTS CRUD\r\n// =============================================================================\r\n\r\nexport async function createEndpoint(\r\n  endpoint: Omit<MeteredEndpoint, 'id' | 'createdAt' | 'updatedAt'> & { id?: string }\r\n): Promise<MeteredEndpoint> {\r\n  const db = getDb();\r\n  return await db.createEndpoint(endpoint);\r\n}\r\n\r\nexport async function getEndpoint(endpointId: string): Promise<MeteredEndpoint | null> {\r\n  const db = getDb();\r\n  return await db.getEndpoint(endpointId);\r\n}\r\n\r\nexport async function listEndpoints(filters?: { status?: string; createdBy?: string }): Promise<MeteredEndpoint[]> {\r\n  const db = getDb();\r\n  return await db.listEndpoints(filters);\r\n}\r\n\r\nexport async function updateEndpoint(\r\n  endpointId: string,\r\n  updates: Partial<MeteredEndpoint>\r\n): Promise<MeteredEndpoint | null> {\r\n  const db = getDb();\r\n  return await db.updateEndpoint(endpointId, updates);\r\n}\r\n\r\nexport async function deleteEndpoint(endpointId: string): Promise<boolean> {\r\n  const db = getDb();\r\n  return await db.deleteEndpoint(endpointId);\r\n}\r\n\r\n// =============================================================================\r\n// PAYMENTS CRUD\r\n// =============================================================================\r\n\r\nexport async function createPayment(payment: Omit<Payment, 'id' | 'verifiedAt'>): Promise<Payment> {\r\n  const db = getDb();\r\n  return await db.createPayment(payment);\r\n}\r\n\r\nexport async function getPayment(paymentId: string): Promise<Payment | null> {\r\n  const db = getDb();\r\n  return await db.getPayment(paymentId);\r\n}\r\n\r\nexport async function getPaymentByTxHash(txHash: string): Promise<Payment | null> {\r\n  const db = getDb();\r\n  return await db.getPaymentByTxHash(txHash);\r\n}\r\n\r\nexport async function listPayments(filters?: { endpointId?: string; fromAddress?: string }): Promise<Payment[]> {\r\n  const db = getDb();\r\n  return await db.listPayments(filters);\r\n}\r\n\r\nexport async function getPaymentsForEndpoint(endpointId: string, limit: number = 100): Promise<Payment[]> {\r\n  const db = getDb();\r\n  return await db.getPaymentsForEndpoint(endpointId, limit);\r\n}\r\n\r\n// =============================================================================\r\n// USAGE LOGS CRUD\r\n// =============================================================================\r\n\r\nexport async function createUsageLog(log: Omit<UsageLog, 'id' | 'timestamp'>): Promise<UsageLog> {\r\n  const db = getDb();\r\n  return await db.createUsageLog(log);\r\n}\r\n\r\nexport async function listUsageLogs(filters?: { endpointId?: string; paymentId?: string }): Promise<UsageLog[]> {\r\n  const db = getDb();\r\n  return await db.listUsageLogs(filters);\r\n}\r\n\r\nexport async function getUsageStats(\r\n  endpointId: string,\r\n  startDate?: string,\r\n  endDate?: string\r\n): Promise<{\r\n  totalRequests: number;\r\n  totalPayments: number;\r\n  totalRevenue: string;\r\n  averageResponseTime: number;\r\n}> {\r\n  const db = getDb();\r\n  return await db.getUsageStats(endpointId, startDate, endDate);\r\n}\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,6BAA6B;AAC7B,gFAAgF;AAChF,qEAAqE;AACrE,0DAA0D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE1D;;;;;;AA2DO,eAAe,eACpB,QAAmF;IAEnF,MAAM,KAAK,IAAA,8HAAK;IAChB,OAAO,MAAM,GAAG,cAAc,CAAC;AACjC;AAEO,eAAe,YAAY,UAAkB;IAClD,MAAM,KAAK,IAAA,8HAAK;IAChB,OAAO,MAAM,GAAG,WAAW,CAAC;AAC9B;AAEO,eAAe,cAAc,OAAiD;IACnF,MAAM,KAAK,IAAA,8HAAK;IAChB,OAAO,MAAM,GAAG,aAAa,CAAC;AAChC;AAEO,eAAe,eACpB,UAAkB,EAClB,OAAiC;IAEjC,MAAM,KAAK,IAAA,8HAAK;IAChB,OAAO,MAAM,GAAG,cAAc,CAAC,YAAY;AAC7C;AAEO,eAAe,eAAe,UAAkB;IACrD,MAAM,KAAK,IAAA,8HAAK;IAChB,OAAO,MAAM,GAAG,cAAc,CAAC;AACjC;AAMO,eAAe,cAAc,OAA2C;IAC7E,MAAM,KAAK,IAAA,8HAAK;IAChB,OAAO,MAAM,GAAG,aAAa,CAAC;AAChC;AAEO,eAAe,WAAW,SAAiB;IAChD,MAAM,KAAK,IAAA,8HAAK;IAChB,OAAO,MAAM,GAAG,UAAU,CAAC;AAC7B;AAEO,eAAe,mBAAmB,MAAc;IACrD,MAAM,KAAK,IAAA,8HAAK;IAChB,OAAO,MAAM,GAAG,kBAAkB,CAAC;AACrC;AAEO,eAAe,aAAa,OAAuD;IACxF,MAAM,KAAK,IAAA,8HAAK;IAChB,OAAO,MAAM,GAAG,YAAY,CAAC;AAC/B;AAEO,eAAe,uBAAuB,UAAkB,EAAE,QAAgB,GAAG;IAClF,MAAM,KAAK,IAAA,8HAAK;IAChB,OAAO,MAAM,GAAG,sBAAsB,CAAC,YAAY;AACrD;AAMO,eAAe,eAAe,GAAuC;IAC1E,MAAM,KAAK,IAAA,8HAAK;IAChB,OAAO,MAAM,GAAG,cAAc,CAAC;AACjC;AAEO,eAAe,cAAc,OAAqD;IACvF,MAAM,KAAK,IAAA,8HAAK;IAChB,OAAO,MAAM,GAAG,aAAa,CAAC;AAChC;AAEO,eAAe,cACpB,UAAkB,EAClB,SAAkB,EAClB,OAAgB;IAOhB,MAAM,KAAK,IAAA,8HAAK;IAChB,OAAO,MAAM,GAAG,aAAa,CAAC,YAAY,WAAW;AACvD"}},
    {"offset": {"line": 1475, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/upstream-proxy.ts"],"sourcesContent":["/**\r\n * Upstream Proxy\r\n * \r\n * Forwards requests to customer upstream URLs after payment verification\r\n */\r\n\r\nexport interface ProxyOptions {\r\n  upstreamUrl: string;\r\n  method: string;\r\n  headers: Headers;\r\n  body?: string | null;\r\n  timeout?: number;\r\n}\r\n\r\nexport interface ProxyResult {\r\n  success: boolean;\r\n  statusCode: number;\r\n  headers: Record<string, string>;\r\n  body: string;\r\n  responseTime: number;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Proxy a request to the upstream URL\r\n */\r\nexport async function proxyRequest(options: ProxyOptions): Promise<ProxyResult> {\r\n  const startTime = Date.now();\r\n  const timeout = options.timeout || 30000; // 30 second default timeout\r\n\r\n  try {\r\n    // Prepare headers (exclude host and connection headers)\r\n    const proxyHeaders: Record<string, string> = {};\r\n    options.headers.forEach((value, key) => {\r\n      const lowerKey = key.toLowerCase();\r\n      // Skip headers that shouldn't be forwarded\r\n      if (\r\n        lowerKey !== 'host' &&\r\n        lowerKey !== 'connection' &&\r\n        lowerKey !== 'x-payment' && // Don't forward payment header to upstream\r\n        lowerKey !== 'x-forwarded-host'\r\n      ) {\r\n        proxyHeaders[key] = value;\r\n      }\r\n    });\r\n\r\n    // Add forwarded headers\r\n    proxyHeaders['X-Forwarded-For'] = options.headers.get('x-forwarded-for') || 'unknown';\r\n    proxyHeaders['X-Forwarded-Proto'] = options.headers.get('x-forwarded-proto') || 'https';\r\n\r\n    // Create fetch request with timeout\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\r\n\r\n    try {\r\n      const response = await fetch(options.upstreamUrl, {\r\n        method: options.method,\r\n        headers: proxyHeaders,\r\n        body: options.body || undefined,\r\n        signal: controller.signal,\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n\r\n      // Read response body\r\n      const body = await response.text();\r\n\r\n      // Convert response headers to object\r\n      const responseHeaders: Record<string, string> = {};\r\n      response.headers.forEach((value, key) => {\r\n        responseHeaders[key] = value;\r\n      });\r\n\r\n      const responseTime = Date.now() - startTime;\r\n\r\n      return {\r\n        success: response.ok,\r\n        statusCode: response.status,\r\n        headers: responseHeaders,\r\n        body,\r\n        responseTime,\r\n      };\r\n    } catch (fetchError) {\r\n      clearTimeout(timeoutId);\r\n      throw fetchError;\r\n    }\r\n  } catch (error) {\r\n    const responseTime = Date.now() - startTime;\r\n\r\n    if (error instanceof Error && error.name === 'AbortError') {\r\n      return {\r\n        success: false,\r\n        statusCode: 504,\r\n        headers: {},\r\n        body: JSON.stringify({ error: 'Upstream timeout' }),\r\n        responseTime,\r\n        error: 'Request timeout',\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      statusCode: 502,\r\n      headers: {},\r\n      body: JSON.stringify({\r\n        error: 'Upstream error',\r\n        details: error instanceof Error ? error.message : 'Unknown error',\r\n      }),\r\n      responseTime,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAsBM,eAAe,aAAa,OAAqB;IACtD,MAAM,YAAY,KAAK,GAAG;IAC1B,MAAM,UAAU,QAAQ,OAAO,IAAI,OAAO,4BAA4B;IAEtE,IAAI;QACF,wDAAwD;QACxD,MAAM,eAAuC,CAAC;QAC9C,QAAQ,OAAO,CAAC,OAAO,CAAC,CAAC,OAAO;YAC9B,MAAM,WAAW,IAAI,WAAW;YAChC,2CAA2C;YAC3C,IACE,aAAa,UACb,aAAa,gBACb,aAAa,eAAe,2CAA2C;YACvE,aAAa,oBACb;gBACA,YAAY,CAAC,IAAI,GAAG;YACtB;QACF;QAEA,wBAAwB;QACxB,YAAY,CAAC,kBAAkB,GAAG,QAAQ,OAAO,CAAC,GAAG,CAAC,sBAAsB;QAC5E,YAAY,CAAC,oBAAoB,GAAG,QAAQ,OAAO,CAAC,GAAG,CAAC,wBAAwB;QAEhF,oCAAoC;QACpC,MAAM,aAAa,IAAI;QACvB,MAAM,YAAY,WAAW,IAAM,WAAW,KAAK,IAAI;QAEvD,IAAI;YACF,MAAM,WAAW,MAAM,MAAM,QAAQ,WAAW,EAAE;gBAChD,QAAQ,QAAQ,MAAM;gBACtB,SAAS;gBACT,MAAM,QAAQ,IAAI,IAAI;gBACtB,QAAQ,WAAW,MAAM;YAC3B;YAEA,aAAa;YAEb,qBAAqB;YACrB,MAAM,OAAO,MAAM,SAAS,IAAI;YAEhC,qCAAqC;YACrC,MAAM,kBAA0C,CAAC;YACjD,SAAS,OAAO,CAAC,OAAO,CAAC,CAAC,OAAO;gBAC/B,eAAe,CAAC,IAAI,GAAG;YACzB;YAEA,MAAM,eAAe,KAAK,GAAG,KAAK;YAElC,OAAO;gBACL,SAAS,SAAS,EAAE;gBACpB,YAAY,SAAS,MAAM;gBAC3B,SAAS;gBACT;gBACA;YACF;QACF,EAAE,OAAO,YAAY;YACnB,aAAa;YACb,MAAM;QACR;IACF,EAAE,OAAO,OAAO;QACd,MAAM,eAAe,KAAK,GAAG,KAAK;QAElC,IAAI,iBAAiB,SAAS,MAAM,IAAI,KAAK,cAAc;YACzD,OAAO;gBACL,SAAS;gBACT,YAAY;gBACZ,SAAS,CAAC;gBACV,MAAM,KAAK,SAAS,CAAC;oBAAE,OAAO;gBAAmB;gBACjD;gBACA,OAAO;YACT;QACF;QAEA,OAAO;YACL,SAAS;YACT,YAAY;YACZ,SAAS,CAAC;YACV,MAAM,KAAK,SAAS,CAAC;gBACnB,OAAO;gBACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;YACpD;YACA;YACA,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD;IACF;AACF"}},
    {"offset": {"line": 1627, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/sentry.ts"],"sourcesContent":["// src/lib/sentry.ts\r\n\r\n// Temporary no-op Sentry shim to avoid module errors during dev\r\nconst Sentry = null as any;\r\n\r\nexport const sentry = {\r\n  captureException: (..._args: any[]) => {},\r\n  captureMessage: (..._args: any[]) => {},\r\n  withScope: (fn: (scope: any) => void) => fn({}),\r\n};\r\n\r\n// No-op functions for compatibility\r\nexport function initSentry() {}\r\nexport function setSentryUser(_userId?: string, _apiKeyId?: string) {}\r\nexport function setSentryContext(_context: any) {}\r\nexport function captureException(_error: Error, _context?: any) {}\r\nexport function captureMessage(_message: string, _level: any = 'info', _context?: any) {}\r\n"],"names":[],"mappings":"AAAA,oBAAoB;AAEpB,gEAAgE;;;;;;;;;;;;;;;AAChE,MAAM,SAAS;AAER,MAAM,SAAS;IACpB,kBAAkB,CAAC,GAAG,SAAkB;IACxC,gBAAgB,CAAC,GAAG,SAAkB;IACtC,WAAW,CAAC,KAA6B,GAAG,CAAC;AAC/C;AAGO,SAAS,cAAc;AACvB,SAAS,cAAc,OAAgB,EAAE,SAAkB,GAAG;AAC9D,SAAS,iBAAiB,QAAa,GAAG;AAC1C,SAAS,iBAAiB,MAAa,EAAE,QAAc,GAAG;AAC1D,SAAS,eAAe,QAAgB,EAAE,SAAc,MAAM,EAAE,QAAc,GAAG"}},
    {"offset": {"line": 1658, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/logger.ts"],"sourcesContent":["// =============================================================================\r\n// Structured Logging\r\n// =============================================================================\r\n// Uses Pino for fast, structured logging\r\n// Supports request ID tracking and different log levels\r\n// All logs include standard fields: timestamp, level, message, requestId, etc.\r\n\r\nimport pino from 'pino';\r\n\r\n// Determine log level from environment\r\nconst logLevel = process.env.LOG_LEVEL || (process.env.NODE_ENV === 'production' ? 'info' : 'debug');\r\n\r\n// Create logger instance with structured output\r\n// In Next.js dev mode, disable pino-pretty transport to avoid worker thread issues\r\n// Use simple JSON output instead (can be prettified by other tools)\r\nconst isNextDev = process.env.NODE_ENV === 'development' && process.env.NEXT_RUNTIME;\r\nconst usePrettyTransport = process.env.NODE_ENV !== 'production' && !isNextDev;\r\n\r\nconst logger = pino({\r\n  level: logLevel,\r\n  transport: usePrettyTransport ? {\r\n    target: 'pino-pretty',\r\n    options: {\r\n      colorize: true,\r\n      translateTime: 'SYS:standard',\r\n      ignore: 'pid,hostname',\r\n    },\r\n  } : undefined,\r\n  formatters: {\r\n    level: (label) => {\r\n      return { level: label.toUpperCase() };\r\n    },\r\n  },\r\n  base: {\r\n    env: process.env.NODE_ENV || 'development',\r\n    service: 'nexflow-api',\r\n  },\r\n  // Ensure timestamps are included\r\n  timestamp: pino.stdTimeFunctions.isoTime,\r\n});\r\n\r\nexport type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';\r\n\r\n/**\r\n * Standard log context fields\r\n */\r\nexport interface LogContext {\r\n  // Request tracking\r\n  requestId?: string;\r\n  apiKeyId?: string;\r\n  endpoint?: string;\r\n  method?: string;\r\n  statusCode?: number;\r\n  durationMs?: number;\r\n  ip?: string;\r\n  \r\n  // Error context\r\n  errorCode?: string;\r\n  error?: Error | any;\r\n  stack?: string;\r\n  \r\n  // CDP/x402 context\r\n  cdpStatus?: string;\r\n  cdpErrorId?: string;\r\n  paymentIntentId?: string;\r\n  x402HeaderId?: string;\r\n  \r\n  // Rate limiting\r\n  rateLimitKey?: string;\r\n  rateLimitRemaining?: number;\r\n  \r\n  // Additional context\r\n  [key: string]: any;\r\n}\r\n\r\n/**\r\n * Create a child logger with additional context\r\n * Useful for request-scoped logging with request IDs\r\n */\r\nexport function createLogger(context?: LogContext | Record<string, any>) {\r\n  return context ? logger.child(context) : logger;\r\n}\r\n\r\n/**\r\n * Get the default logger instance\r\n */\r\nexport function getLogger() {\r\n  return logger;\r\n}\r\n\r\n/**\r\n * Sanitize sensitive data from log context\r\n * Removes API keys, tokens, payment headers, and PII\r\n */\r\nfunction sanitizeContext(context: LogContext): LogContext {\r\n  const sanitized = { ...context };\r\n  \r\n  // Remove sensitive fields\r\n  const sensitiveKeys = [\r\n    'apiKey', 'token', 'authorization', 'x-payment', 'paymentHeader',\r\n    'cardNumber', 'cvv', 'ssn', 'password', 'secret',\r\n  ];\r\n  \r\n  sensitiveKeys.forEach(key => {\r\n    if (key in sanitized) {\r\n      delete sanitized[key];\r\n    }\r\n  });\r\n  \r\n  // Truncate long strings that might contain sensitive data\r\n  Object.keys(sanitized).forEach(key => {\r\n    const value = sanitized[key];\r\n    if (typeof value === 'string' && value.length > 200) {\r\n      sanitized[key] = value.substring(0, 200) + '... [truncated]';\r\n    }\r\n  });\r\n  \r\n  return sanitized;\r\n}\r\n\r\n/**\r\n * Log levels with structured context\r\n */\r\nexport const log = {\r\n  trace: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.trace(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  debug: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.debug(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  info: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.info(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  warn: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.warn(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  error: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.error(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry if error object exists\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'UNKNOWN_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n  fatal: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.fatal(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry for fatal errors\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'FATAL_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n            severity: 'fatal',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport default logger;\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1850, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/upstream-proxy-enhanced.ts"],"sourcesContent":["// =============================================================================\r\n// Enhanced Upstream Proxy with Retry Logic and Circuit Breaker\r\n// =============================================================================\r\n// Production-grade proxy with:\r\n// - Exponential backoff retry\r\n// - Circuit breaker pattern\r\n// - Connection pooling\r\n// - Better error handling\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'UpstreamProxy' });\r\n\r\nexport interface ProxyOptions {\r\n  upstreamUrl: string;\r\n  method: string;\r\n  headers: Headers;\r\n  body?: string | null;\r\n  timeout?: number;\r\n  maxRetries?: number;\r\n  retryDelay?: number;\r\n  retryableStatusCodes?: number[];\r\n}\r\n\r\nexport interface ProxyResult {\r\n  success: boolean;\r\n  statusCode: number;\r\n  headers: Record<string, string>;\r\n  body: string;\r\n  responseTime: number;\r\n  error?: string;\r\n  retries?: number;\r\n}\r\n\r\n/**\r\n * Circuit breaker state\r\n */\r\ninterface CircuitBreakerState {\r\n  failures: number;\r\n  lastFailureTime: number;\r\n  state: 'closed' | 'open' | 'half-open';\r\n}\r\n\r\nconst circuitBreakers = new Map<string, CircuitBreakerState>();\r\n\r\nconst DEFAULT_CIRCUIT_BREAKER_CONFIG = {\r\n  failureThreshold: 5, // Open circuit after 5 failures\r\n  resetTimeout: 60000, // 60 seconds before attempting to close\r\n  halfOpenTimeout: 30000, // 30 seconds in half-open state\r\n};\r\n\r\n/**\r\n * Check if circuit breaker allows request\r\n */\r\nfunction checkCircuitBreaker(upstreamUrl: string): boolean {\r\n  const state = circuitBreakers.get(upstreamUrl);\r\n  if (!state) {\r\n    // Initialize as closed\r\n    circuitBreakers.set(upstreamUrl, {\r\n      failures: 0,\r\n      lastFailureTime: 0,\r\n      state: 'closed',\r\n    });\r\n    return true;\r\n  }\r\n\r\n  const now = Date.now();\r\n  const config = DEFAULT_CIRCUIT_BREAKER_CONFIG;\r\n\r\n  switch (state.state) {\r\n    case 'closed':\r\n      return true;\r\n    \r\n    case 'open':\r\n      // Check if we should transition to half-open\r\n      if (now - state.lastFailureTime > config.resetTimeout) {\r\n        state.state = 'half-open';\r\n        logger.info('Circuit breaker transitioning to half-open', { upstreamUrl });\r\n        return true;\r\n      }\r\n      return false;\r\n    \r\n    case 'half-open':\r\n      // Allow one request to test\r\n      return true;\r\n    \r\n    default:\r\n      return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Record circuit breaker success\r\n */\r\nfunction recordSuccess(upstreamUrl: string): void {\r\n  const state = circuitBreakers.get(upstreamUrl);\r\n  if (state) {\r\n    if (state.state === 'half-open') {\r\n      // Success in half-open means we can close the circuit\r\n      state.state = 'closed';\r\n      state.failures = 0;\r\n      logger.info('Circuit breaker closed after successful request', { upstreamUrl });\r\n    } else {\r\n      // Reset failure count on success\r\n      state.failures = 0;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Record circuit breaker failure\r\n */\r\nfunction recordFailure(upstreamUrl: string): void {\r\n  const state = circuitBreakers.get(upstreamUrl);\r\n  if (!state) {\r\n    circuitBreakers.set(upstreamUrl, {\r\n      failures: 1,\r\n      lastFailureTime: Date.now(),\r\n      state: 'closed',\r\n    });\r\n    return;\r\n  }\r\n\r\n  state.failures++;\r\n  state.lastFailureTime = Date.now();\r\n  const config = DEFAULT_CIRCUIT_BREAKER_CONFIG;\r\n\r\n  if (state.state === 'half-open') {\r\n    // Failure in half-open means we should open again\r\n    state.state = 'open';\r\n    logger.warn('Circuit breaker opened after failure in half-open state', {\r\n      upstreamUrl,\r\n      failures: state.failures,\r\n    });\r\n  } else if (state.failures >= config.failureThreshold) {\r\n    state.state = 'open';\r\n    logger.warn('Circuit breaker opened due to failure threshold', {\r\n      upstreamUrl,\r\n      failures: state.failures,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Sleep for specified milliseconds\r\n */\r\nfunction sleep(ms: number): Promise<void> {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n/**\r\n * Calculate exponential backoff delay\r\n */\r\nfunction calculateBackoffDelay(attempt: number, baseDelay: number): number {\r\n  return Math.min(baseDelay * Math.pow(2, attempt), 10000); // Max 10 seconds\r\n}\r\n\r\n/**\r\n * Enhanced proxy with retry logic and circuit breaker\r\n */\r\nexport async function proxyRequestWithRetry(options: ProxyOptions): Promise<ProxyResult> {\r\n  const {\r\n    upstreamUrl,\r\n    method,\r\n    headers,\r\n    body,\r\n    timeout = 30000,\r\n    maxRetries = 3,\r\n    retryDelay = 1000,\r\n    retryableStatusCodes = [502, 503, 504, 408, 429],\r\n  } = options;\r\n\r\n  // Check circuit breaker\r\n  if (!checkCircuitBreaker(upstreamUrl)) {\r\n    logger.warn('Circuit breaker is open, rejecting request', { upstreamUrl });\r\n    return {\r\n      success: false,\r\n      statusCode: 503,\r\n      headers: {},\r\n      body: JSON.stringify({\r\n        error: 'Service temporarily unavailable',\r\n        code: 'CIRCUIT_BREAKER_OPEN',\r\n        details: 'Upstream service is experiencing issues',\r\n      }),\r\n      responseTime: 0,\r\n      error: 'Circuit breaker is open',\r\n    };\r\n  }\r\n\r\n  let lastError: Error | null = null;\r\n  let lastResult: ProxyResult | null = null;\r\n\r\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Prepare headers (exclude host and connection headers)\r\n      const proxyHeaders: Record<string, string> = {};\r\n      headers.forEach((value, key) => {\r\n        const lowerKey = key.toLowerCase();\r\n        if (\r\n          lowerKey !== 'host' &&\r\n          lowerKey !== 'connection' &&\r\n          lowerKey !== 'x-payment' &&\r\n          lowerKey !== 'x-forwarded-host'\r\n        ) {\r\n          proxyHeaders[key] = value;\r\n        }\r\n      });\r\n\r\n      // Add forwarded headers\r\n      proxyHeaders['X-Forwarded-For'] = headers.get('x-forwarded-for') || 'unknown';\r\n      proxyHeaders['X-Forwarded-Proto'] = headers.get('x-forwarded-proto') || 'https';\r\n\r\n      // Create fetch request with timeout\r\n      const controller = new AbortController();\r\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\r\n\r\n      try {\r\n        const response = await fetch(upstreamUrl, {\r\n          method,\r\n          headers: proxyHeaders,\r\n          body: body || undefined,\r\n          signal: controller.signal,\r\n        });\r\n\r\n        clearTimeout(timeoutId);\r\n\r\n        // Read response body\r\n        const responseBody = await response.text();\r\n\r\n        // Convert response headers to object\r\n        const responseHeaders: Record<string, string> = {};\r\n        response.headers.forEach((value, key) => {\r\n          responseHeaders[key] = value;\r\n        });\r\n\r\n        const responseTime = Date.now() - startTime;\r\n\r\n        const result: ProxyResult = {\r\n          success: response.ok,\r\n          statusCode: response.status,\r\n          headers: responseHeaders,\r\n          body: responseBody,\r\n          responseTime,\r\n          retries: attempt,\r\n        };\r\n\r\n        // Check if we should retry\r\n        if (!response.ok && retryableStatusCodes.includes(response.status) && attempt < maxRetries) {\r\n          const backoffDelay = calculateBackoffDelay(attempt, retryDelay);\r\n          logger.warn('Upstream returned retryable error, retrying', {\r\n            upstreamUrl,\r\n            statusCode: response.status,\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            backoffDelay,\r\n          });\r\n          \r\n          await sleep(backoffDelay);\r\n          lastResult = result;\r\n          continue;\r\n        }\r\n\r\n        // Success or non-retryable error\r\n        recordSuccess(upstreamUrl);\r\n        return result;\r\n      } catch (fetchError) {\r\n        clearTimeout(timeoutId);\r\n        throw fetchError;\r\n      }\r\n    } catch (error) {\r\n      const responseTime = Date.now() - startTime;\r\n      lastError = error instanceof Error ? error : new Error('Unknown error');\r\n\r\n      // Check if error is retryable\r\n      const isRetryable = \r\n        (error instanceof Error && error.name === 'AbortError') || // Timeout\r\n        (error instanceof TypeError && error.message.includes('fetch')); // Network error\r\n\r\n      if (isRetryable && attempt < maxRetries) {\r\n        const backoffDelay = calculateBackoffDelay(attempt, retryDelay);\r\n        logger.warn('Upstream request failed, retrying', {\r\n          upstreamUrl,\r\n          error: lastError.message,\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          backoffDelay,\r\n        });\r\n        \r\n        await sleep(backoffDelay);\r\n        continue;\r\n      }\r\n\r\n      // Non-retryable error or max retries reached\r\n      recordFailure(upstreamUrl);\r\n      \r\n      if (lastError.name === 'AbortError') {\r\n        return {\r\n          success: false,\r\n          statusCode: 504,\r\n          headers: {},\r\n          body: JSON.stringify({ error: 'Upstream timeout' }),\r\n          responseTime,\r\n          error: 'Request timeout',\r\n          retries: attempt,\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: false,\r\n        statusCode: 502,\r\n        headers: {},\r\n        body: JSON.stringify({\r\n          error: 'Upstream error',\r\n          details: lastError.message,\r\n        }),\r\n        responseTime,\r\n        error: lastError.message,\r\n        retries: attempt,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Max retries reached\r\n  recordFailure(upstreamUrl);\r\n  \r\n  return {\r\n    success: false,\r\n    statusCode: lastResult?.statusCode || 502,\r\n    headers: lastResult?.headers || {},\r\n    body: lastResult?.body || JSON.stringify({\r\n      error: 'Upstream error after retries',\r\n      details: lastError?.message || 'Unknown error',\r\n    }),\r\n    responseTime: lastResult?.responseTime || 0,\r\n    error: lastError?.message || 'Unknown error',\r\n    retries: maxRetries,\r\n  };\r\n}\r\n\r\n/**\r\n * Get circuit breaker status for monitoring\r\n */\r\nexport function getCircuitBreakerStatus(upstreamUrl?: string): Record<string, any> {\r\n  if (upstreamUrl) {\r\n    const state = circuitBreakers.get(upstreamUrl);\r\n    return {\r\n      [upstreamUrl]: state || {\r\n        failures: 0,\r\n        lastFailureTime: 0,\r\n        state: 'closed',\r\n      },\r\n    };\r\n  }\r\n\r\n  // Return all circuit breakers\r\n  const status: Record<string, any> = {};\r\n  circuitBreakers.forEach((state, url) => {\r\n    status[url] = state;\r\n  });\r\n  return status;\r\n}\r\n\r\n/**\r\n * Reset circuit breaker (for testing/admin)\r\n */\r\nexport function resetCircuitBreaker(upstreamUrl: string): void {\r\n  circuitBreakers.delete(upstreamUrl);\r\n  logger.info('Circuit breaker reset', { upstreamUrl });\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2149, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/request-id.ts"],"sourcesContent":["// =============================================================================\r\n// Request ID Tracking\r\n// =============================================================================\r\n// Generates and tracks request IDs for request correlation\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { createLogger, type LogContext } from './logger';\r\n\r\nconst REQUEST_ID_HEADER = 'x-request-id';\r\nconst REQUEST_ID_CONTEXT_KEY = 'requestId';\r\n\r\n/**\r\n * Generate a unique request ID (UUID v4 format)\r\n * Edge-compatible using Web Crypto API\r\n */\r\nexport function generateRequestId(): string {\r\n  // Generate UUID v4 format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\r\n  const array = new Uint8Array(16);\r\n  crypto.getRandomValues(array);\r\n  \r\n  // Set version (4) and variant bits\r\n  array[6] = (array[6] & 0x0f) | 0x40; // Version 4\r\n  array[8] = (array[8] & 0x3f) | 0x80; // Variant 10\r\n  \r\n  // Convert to UUID string format\r\n  const hex = Array.from(array)\r\n    .map(b => b.toString(16).padStart(2, '0'))\r\n    .join('');\r\n  \r\n  return [\r\n    hex.substring(0, 8),\r\n    hex.substring(8, 12),\r\n    hex.substring(12, 16),\r\n    hex.substring(16, 20),\r\n    hex.substring(20, 32),\r\n  ].join('-');\r\n}\r\n\r\n/**\r\n * Extract request ID from headers or generate a new one\r\n * \r\n * Trusts x-request-id from trusted sources (configurable via TRUSTED_REQUEST_ID_SOURCES env var)\r\n * Default: trusts all sources (can be restricted to specific IPs/domains)\r\n */\r\nexport function getOrCreateRequestId(request: NextRequest): string {\r\n  const existingId = request.headers.get(REQUEST_ID_HEADER);\r\n  \r\n  if (existingId) {\r\n    // Check if we should trust this request ID\r\n    const trustedSources = process.env.TRUSTED_REQUEST_ID_SOURCES?.split(',') || [];\r\n    const shouldTrust = trustedSources.length === 0 || \r\n      trustedSources.some(source => {\r\n        const origin = request.headers.get('origin') || '';\r\n        const referer = request.headers.get('referer') || '';\r\n        return origin.includes(source) || referer.includes(source);\r\n      });\r\n    \r\n    if (shouldTrust) {\r\n      return existingId;\r\n    }\r\n  }\r\n  \r\n  return generateRequestId();\r\n}\r\n\r\n/**\r\n * Add request ID to response headers\r\n */\r\nexport function addRequestIdToResponse(\r\n  response: NextResponse,\r\n  requestId: string\r\n): NextResponse {\r\n  response.headers.set(REQUEST_ID_HEADER, requestId);\r\n  return response;\r\n}\r\n\r\n/**\r\n * Get request ID from AsyncLocalStorage (if available)\r\n */\r\nexport function getRequestId(): string | undefined {\r\n  // In Next.js, we'll use headers instead of AsyncLocalStorage\r\n  // This is simpler and works with the serverless model\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Create a logger with request ID context\r\n * Uses full Pino logger for structured logging\r\n * Works in both Node.js and Edge runtime (Pino handles Edge compatibility)\r\n */\r\nexport function createRequestLogger(requestId: string, additionalContext?: Record<string, any>) {\r\n  const context: LogContext = { requestId, ...additionalContext };\r\n  const logger = createLogger(context);\r\n  \r\n  return {\r\n    info: (message: string, meta?: LogContext) => {\r\n      logger.info({ ...context, ...meta }, message);\r\n    },\r\n    warn: (message: string, meta?: LogContext) => {\r\n      logger.warn({ ...context, ...meta }, message);\r\n    },\r\n    error: (message: string, meta?: LogContext) => {\r\n      logger.error({ ...context, ...meta }, message);\r\n    },\r\n    debug: (message: string, meta?: LogContext) => {\r\n      logger.debug({ ...context, ...meta }, message);\r\n    },\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,sBAAsB;AACtB,gFAAgF;AAChF,2DAA2D;;;;;;;;;;;;;AAG3D;;AAEA,MAAM,oBAAoB;AAC1B,MAAM,yBAAyB;AAMxB,SAAS;IACd,gEAAgE;IAChE,MAAM,QAAQ,IAAI,WAAW;IAC7B,OAAO,eAAe,CAAC;IAEvB,mCAAmC;IACnC,KAAK,CAAC,EAAE,GAAG,AAAC,KAAK,CAAC,EAAE,GAAG,OAAQ,MAAM,YAAY;IACjD,KAAK,CAAC,EAAE,GAAG,AAAC,KAAK,CAAC,EAAE,GAAG,OAAQ,MAAM,aAAa;IAElD,gCAAgC;IAChC,MAAM,MAAM,MAAM,IAAI,CAAC,OACpB,GAAG,CAAC,CAAA,IAAK,EAAE,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG,MACpC,IAAI,CAAC;IAER,OAAO;QACL,IAAI,SAAS,CAAC,GAAG;QACjB,IAAI,SAAS,CAAC,GAAG;QACjB,IAAI,SAAS,CAAC,IAAI;QAClB,IAAI,SAAS,CAAC,IAAI;QAClB,IAAI,SAAS,CAAC,IAAI;KACnB,CAAC,IAAI,CAAC;AACT;AAQO,SAAS,qBAAqB,OAAoB;IACvD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IAEvC,IAAI,YAAY;QACd,2CAA2C;QAC3C,MAAM,iBAAiB,QAAQ,GAAG,CAAC,0BAA0B,EAAE,MAAM,QAAQ,EAAE;QAC/E,MAAM,cAAc,eAAe,MAAM,KAAK,KAC5C,eAAe,IAAI,CAAC,CAAA;YAClB,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC,aAAa;YAChD,MAAM,UAAU,QAAQ,OAAO,CAAC,GAAG,CAAC,cAAc;YAClD,OAAO,OAAO,QAAQ,CAAC,WAAW,QAAQ,QAAQ,CAAC;QACrD;QAEF,IAAI,aAAa;YACf,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAKO,SAAS,uBACd,QAAsB,EACtB,SAAiB;IAEjB,SAAS,OAAO,CAAC,GAAG,CAAC,mBAAmB;IACxC,OAAO;AACT;AAKO,SAAS;IACd,6DAA6D;IAC7D,sDAAsD;IACtD,OAAO;AACT;AAOO,SAAS,oBAAoB,SAAiB,EAAE,iBAAuC;IAC5F,MAAM,UAAsB;QAAE;QAAW,GAAG,iBAAiB;IAAC;IAC9D,MAAM,SAAS,IAAA,sIAAY,EAAC;IAE5B,OAAO;QACL,MAAM,CAAC,SAAiB;YACtB,OAAO,IAAI,CAAC;gBAAE,GAAG,OAAO;gBAAE,GAAG,IAAI;YAAC,GAAG;QACvC;QACA,MAAM,CAAC,SAAiB;YACtB,OAAO,IAAI,CAAC;gBAAE,GAAG,OAAO;gBAAE,GAAG,IAAI;YAAC,GAAG;QACvC;QACA,OAAO,CAAC,SAAiB;YACvB,OAAO,KAAK,CAAC;gBAAE,GAAG,OAAO;gBAAE,GAAG,IAAI;YAAC,GAAG;QACxC;QACA,OAAO,CAAC,SAAiB;YACvB,OAAO,KAAK,CAAC;gBAAE,GAAG,OAAO;gBAAE,GAAG,IAAI;YAAC,GAAG;QACxC;IACF;AACF"}},
    {"offset": {"line": 2248, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/rate-limit-store.ts"],"sourcesContent":["// =============================================================================\r\n// RATE LIMIT STORE\r\n// =============================================================================\r\n// Pluggable backing store for rate limiting with Upstash Redis support and in-memory fallback.\r\n// Supports distributed rate limiting across serverless instances.\r\n//\r\n// Environment Variables:\r\n// - UPSTASH_REDIS_REST_URL: Upstash Redis REST URL (from Vercel integration)\r\n// - UPSTASH_REDIS_REST_TOKEN: Upstash Redis REST token (from Vercel integration)\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'RateLimitStore' });\r\n\r\nexport interface RateLimitEntry {\r\n  count: number;\r\n  resetAt: number;\r\n}\r\n\r\nexport interface RateLimitStore {\r\n  get(key: string): Promise<RateLimitEntry | null>;\r\n  set(key: string, entry: RateLimitEntry): Promise<void>;\r\n  increment(key: string, windowMs: number): Promise<RateLimitEntry>;\r\n}\r\n\r\n// =============================================================================\r\n// IN-MEMORY STORE (fallback)\r\n// =============================================================================\r\n\r\nclass InMemoryStore implements RateLimitStore {\r\n  private store = new Map<string, RateLimitEntry>();\r\n  private cleanupInterval: ReturnType<typeof setInterval> | null = null;\r\n\r\n  constructor() {\r\n    // Cleanup every 5 minutes\r\n    if (typeof setInterval !== 'undefined') {\r\n      this.cleanupInterval = setInterval(() => this.cleanup(), 5 * 60 * 1000);\r\n    }\r\n  }\r\n\r\n  private cleanup(): void {\r\n    const now = Date.now();\r\n    const keysToDelete: string[] = [];\r\n    this.store.forEach((value, key) => {\r\n      if (value.resetAt < now) {\r\n        keysToDelete.push(key);\r\n      }\r\n    });\r\n    keysToDelete.forEach(key => this.store.delete(key));\r\n  }\r\n\r\n  async get(key: string): Promise<RateLimitEntry | null> {\r\n    const entry = this.store.get(key);\r\n    if (!entry || entry.resetAt < Date.now()) {\r\n      return null;\r\n    }\r\n    return entry;\r\n  }\r\n\r\n  async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n    this.store.set(key, entry);\r\n  }\r\n\r\n  async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n    const now = Date.now();\r\n    const existing = this.store.get(key);\r\n\r\n    if (!existing || existing.resetAt < now) {\r\n      const entry = { count: 1, resetAt: now + windowMs };\r\n      this.store.set(key, entry);\r\n      return entry;\r\n    }\r\n\r\n    existing.count++;\r\n    this.store.set(key, existing);\r\n    return existing;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// UPSTASH REDIS STORE (distributed)\r\n// =============================================================================\r\n\r\nclass UpstashRedisStore implements RateLimitStore {\r\n  private redis: any;\r\n\r\n  constructor(redisClient: any) {\r\n    this.redis = redisClient;\r\n  }\r\n\r\n  async get(key: string): Promise<RateLimitEntry | null> {\r\n    try {\r\n      const data = await this.redis.get(`ratelimit:${key}`);\r\n      if (!data) return null;\r\n      \r\n      // Upstash returns parsed JSON automatically if it's a JSON string\r\n      const entry = typeof data === 'string' ? JSON.parse(data) : data;\r\n      if (entry.resetAt < Date.now()) return null;\r\n      return entry as RateLimitEntry;\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis GET failed');\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n    try {\r\n      const ttlMs = Math.max(entry.resetAt - Date.now(), 1000);\r\n      const ttlSeconds = Math.ceil(ttlMs / 1000);\r\n      \r\n      await this.redis.set(\r\n        `ratelimit:${key}`,\r\n        JSON.stringify(entry),\r\n        { ex: ttlSeconds }\r\n      );\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis SET failed');\r\n    }\r\n  }\r\n\r\n  async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n    try {\r\n      const redisKey = `ratelimit:${key}`;\r\n      const now = Date.now();\r\n\r\n      // Get current entry\r\n      const data = await this.redis.get(redisKey);\r\n      \r\n      let count = 1;\r\n      let resetAt = now + windowMs;\r\n      \r\n      if (data) {\r\n        const entry = typeof data === 'string' ? JSON.parse(data) : data;\r\n        if (entry.resetAt > now) {\r\n          count = entry.count + 1;\r\n          resetAt = entry.resetAt;\r\n        }\r\n      }\r\n      \r\n      const newEntry = { count, resetAt };\r\n      const ttlMs = resetAt - now;\r\n      const ttlSeconds = Math.ceil(ttlMs / 1000);\r\n      \r\n      await this.redis.set(redisKey, JSON.stringify(newEntry), { ex: ttlSeconds });\r\n      \r\n      return newEntry;\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis INCR failed');\r\n      // Fallback: return a permissive entry\r\n      return { count: 1, resetAt: Date.now() + windowMs };\r\n    }\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// STORE FACTORY\r\n// =============================================================================\r\n\r\nlet storeInstance: RateLimitStore | null = null;\r\n\r\n/**\r\n * Get the rate limit store singleton.\r\n * Uses Upstash Redis if configured, otherwise falls back to in-memory.\r\n */\r\nexport async function getRateLimitStore(): Promise<RateLimitStore> {\r\n  if (storeInstance) {\r\n    return storeInstance;\r\n  }\r\n\r\n  // Check for Upstash Redis environment variables (set by Vercel integration)\r\n  const upstashUrl = process.env.UPSTASH_REDIS_REST_URL;\r\n  const upstashToken = process.env.UPSTASH_REDIS_REST_TOKEN;\r\n\r\n  if (upstashUrl && upstashToken) {\r\n    try {\r\n      // Dynamic import to avoid build issues\r\n      const { Redis } = await import('@upstash/redis');\r\n      const redis = new Redis({\r\n        url: upstashUrl,\r\n        token: upstashToken,\r\n      });\r\n\r\n      // Test connection\r\n      await redis.ping();\r\n      \r\n      logger.info('Rate limit store using Upstash Redis');\r\n      storeInstance = new UpstashRedisStore(redis);\r\n      return storeInstance;\r\n    } catch (error) {\r\n      logger.warn({ error }, 'Upstash Redis connection failed, falling back to in-memory');\r\n    }\r\n  }\r\n\r\n  // Legacy support: check for REDIS_URL (ioredis)\r\n  const redisUrl = process.env.REDIS_URL;\r\n  if (redisUrl) {\r\n    try {\r\n      const { Redis } = await import('ioredis');\r\n      const redis = new Redis(redisUrl, {\r\n        maxRetriesPerRequest: 3,\r\n        enableReadyCheck: true,\r\n        connectTimeout: 5000,\r\n        lazyConnect: true,\r\n      });\r\n\r\n      await redis.connect();\r\n      logger.info('Rate limit store using Redis (ioredis)');\r\n      \r\n      // Use a simple wrapper that matches UpstashRedisStore behavior\r\n      storeInstance = {\r\n        async get(key: string): Promise<RateLimitEntry | null> {\r\n          const data = await redis.get(`ratelimit:${key}`);\r\n          if (!data) return null;\r\n          const entry = JSON.parse(data) as RateLimitEntry;\r\n          if (entry.resetAt < Date.now()) return null;\r\n          return entry;\r\n        },\r\n        async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n          const ttlMs = Math.max(entry.resetAt - Date.now(), 1000);\r\n          await redis.set(`ratelimit:${key}`, JSON.stringify(entry), 'PX', ttlMs);\r\n        },\r\n        async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n          const now = Date.now();\r\n          const redisKey = `ratelimit:${key}`;\r\n          const data = await redis.get(redisKey);\r\n          \r\n          let count = 1;\r\n          let resetAt = now + windowMs;\r\n          \r\n          if (data) {\r\n            const entry = JSON.parse(data);\r\n            if (entry.resetAt > now) {\r\n              count = entry.count + 1;\r\n              resetAt = entry.resetAt;\r\n            }\r\n          }\r\n          \r\n          const newEntry = { count, resetAt };\r\n          const ttlMs = resetAt - now;\r\n          await redis.set(redisKey, JSON.stringify(newEntry), 'PX', ttlMs);\r\n          return newEntry;\r\n        }\r\n      };\r\n      return storeInstance;\r\n    } catch (error) {\r\n      logger.warn({ error }, 'Redis connection failed, falling back to in-memory');\r\n    }\r\n  }\r\n\r\n  logger.info('Rate limit store using in-memory (non-distributed)');\r\n  storeInstance = new InMemoryStore();\r\n  return storeInstance;\r\n}\r\n\r\n/**\r\n * Synchronous in-memory store for Edge runtime.\r\n * Edge runtime can use Upstash but requires async initialization.\r\n */\r\nexport function getEdgeRateLimitStore(): RateLimitStore {\r\n  // Edge runtime uses in-memory for sync access\r\n  // For async Edge operations, use getRateLimitStore()\r\n  if (!storeInstance) {\r\n    storeInstance = new InMemoryStore();\r\n  }\r\n  return storeInstance;\r\n}\r\n\r\n/**\r\n * Reset the store singleton (for testing)\r\n */\r\nexport function resetRateLimitStore(): void {\r\n  storeInstance = null;\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2498, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/rate-limit-unified.ts"],"sourcesContent":["// =============================================================================\r\n// UNIFIED RATE LIMITING\r\n// =============================================================================\r\n// Single implementation for both Edge and Node.js environments.\r\n// Supports distributed rate limiting via Redis with in-memory fallback.\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { getRateLimitStore, getEdgeRateLimitStore, type RateLimitStore } from './rate-limit-store';\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface RateLimitConfig {\r\n  windowMs: number;\r\n  maxRequests: number;\r\n  identifier: string;\r\n}\r\n\r\nexport interface RateLimitResult {\r\n  allowed: boolean;\r\n  remaining: number;\r\n  resetAt: number;\r\n  limit: number;\r\n}\r\n\r\nexport interface RateLimitTier {\r\n  name: string;\r\n  windowMs: number;\r\n  maxRequests: number;\r\n}\r\n\r\n// =============================================================================\r\n// DEFAULT TIERS\r\n// =============================================================================\r\n\r\nexport const RATE_LIMIT_TIERS: Record<string, RateLimitTier> = {\r\n  // Per-IP global limits\r\n  global: { name: 'global', windowMs: 60 * 60 * 1000, maxRequests: 1000 },\r\n  \r\n  // Per-endpoint limits (per IP, per minute)\r\n  endpoint: { name: 'endpoint', windowMs: 60 * 1000, maxRequests: 100 },\r\n  \r\n  // API key tiers (per hour)\r\n  free: { name: 'free', windowMs: 60 * 60 * 1000, maxRequests: 100 },\r\n  starter: { name: 'starter', windowMs: 60 * 60 * 1000, maxRequests: 1000 },\r\n  pro: { name: 'pro', windowMs: 60 * 60 * 1000, maxRequests: 5000 },\r\n  enterprise: { name: 'enterprise', windowMs: 60 * 60 * 1000, maxRequests: 50000 },\r\n  \r\n  // Cron job rate limiting (per minute)\r\n  cron: { name: 'cron', windowMs: 60 * 1000, maxRequests: 1 },\r\n};\r\n\r\n// =============================================================================\r\n// METRICS TRACKING\r\n// =============================================================================\r\n\r\ninterface RateLimitMetrics {\r\n  requests: Map<string, number>;      // tier:type -> total requests\r\n  blocked: Map<string, number>;       // tier:type -> blocked requests\r\n  latencies: Map<string, number[]>;   // tier:type -> latencies (last 100)\r\n  lastReset: number;\r\n}\r\n\r\nconst metrics: RateLimitMetrics = {\r\n  requests: new Map(),\r\n  blocked: new Map(),\r\n  latencies: new Map(),\r\n  lastReset: Date.now(),\r\n};\r\n\r\nconst MAX_LATENCY_SAMPLES = 100;\r\nconst METRICS_RESET_INTERVAL_MS = 60 * 60 * 1000; // 1 hour\r\n\r\n/**\r\n * Record a rate limit check\r\n */\r\nfunction recordMetric(\r\n  type: string,\r\n  allowed: boolean,\r\n  latencyMs: number\r\n): void {\r\n  // Reset metrics hourly\r\n  const now = Date.now();\r\n  if (now - metrics.lastReset > METRICS_RESET_INTERVAL_MS) {\r\n    metrics.requests.clear();\r\n    metrics.blocked.clear();\r\n    metrics.latencies.clear();\r\n    metrics.lastReset = now;\r\n  }\r\n  \r\n  // Record request\r\n  const key = type;\r\n  metrics.requests.set(key, (metrics.requests.get(key) || 0) + 1);\r\n  \r\n  // Record blocked\r\n  if (!allowed) {\r\n    metrics.blocked.set(key, (metrics.blocked.get(key) || 0) + 1);\r\n  }\r\n  \r\n  // Record latency (keep last N samples)\r\n  let latencies = metrics.latencies.get(key);\r\n  if (!latencies) {\r\n    latencies = [];\r\n    metrics.latencies.set(key, latencies);\r\n  }\r\n  latencies.push(latencyMs);\r\n  if (latencies.length > MAX_LATENCY_SAMPLES) {\r\n    latencies.shift();\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate percentile from sorted array\r\n */\r\nfunction percentile(sorted: number[], p: number): number {\r\n  if (sorted.length === 0) return 0;\r\n  const idx = Math.ceil(sorted.length * p) - 1;\r\n  return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];\r\n}\r\n\r\n/**\r\n * Get rate limit metrics for observability\r\n */\r\nexport function getRateLimitMetrics(): {\r\n  byType: Record<string, {\r\n    total: number;\r\n    blocked: number;\r\n    blockRate: string;\r\n    latency: { p50: number; p95: number; p99: number };\r\n  }>;\r\n  totals: {\r\n    requests: number;\r\n    blocked: number;\r\n    blockRate: string;\r\n  };\r\n  lastReset: string;\r\n} {\r\n  const byType: Record<string, any> = {};\r\n  let totalRequests = 0;\r\n  let totalBlocked = 0;\r\n  \r\n  const types = new Set([\r\n    ...metrics.requests.keys(),\r\n    ...metrics.blocked.keys(),\r\n  ]);\r\n  \r\n  for (const type of types) {\r\n    const requests = metrics.requests.get(type) || 0;\r\n    const blocked = metrics.blocked.get(type) || 0;\r\n    const latencies = metrics.latencies.get(type) || [];\r\n    \r\n    totalRequests += requests;\r\n    totalBlocked += blocked;\r\n    \r\n    // Calculate latency percentiles\r\n    const sorted = [...latencies].sort((a, b) => a - b);\r\n    \r\n    byType[type] = {\r\n      total: requests,\r\n      blocked,\r\n      blockRate: requests > 0 ? ((blocked / requests) * 100).toFixed(2) + '%' : '0%',\r\n      latency: {\r\n        p50: Math.round(percentile(sorted, 0.5)),\r\n        p95: Math.round(percentile(sorted, 0.95)),\r\n        p99: Math.round(percentile(sorted, 0.99)),\r\n      },\r\n    };\r\n  }\r\n  \r\n  return {\r\n    byType,\r\n    totals: {\r\n      requests: totalRequests,\r\n      blocked: totalBlocked,\r\n      blockRate: totalRequests > 0 \r\n        ? ((totalBlocked / totalRequests) * 100).toFixed(2) + '%' \r\n        : '0%',\r\n    },\r\n    lastReset: new Date(metrics.lastReset).toISOString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Reset rate limit metrics (for testing)\r\n */\r\nexport function resetRateLimitMetrics(): void {\r\n  metrics.requests.clear();\r\n  metrics.blocked.clear();\r\n  metrics.latencies.clear();\r\n  metrics.lastReset = Date.now();\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Extract API key from Authorization header\r\n */\r\nexport function extractApiKey(request: NextRequest): string | null {\r\n  const authHeader = request.headers.get('authorization');\r\n  if (!authHeader) return null;\r\n  \r\n  if (authHeader.startsWith('Bearer ')) {\r\n    return authHeader.substring(7).trim();\r\n  }\r\n  return authHeader.trim();\r\n}\r\n\r\n/**\r\n * Get client IP address\r\n */\r\nexport function getClientIp(request: NextRequest): string {\r\n  return (\r\n    request.ip ||\r\n    request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() ||\r\n    request.headers.get('x-real-ip') ||\r\n    'unknown'\r\n  );\r\n}\r\n\r\n/**\r\n * Hash a string for use as rate limit key (don't store full API keys)\r\n */\r\nfunction hashKey(key: string): string {\r\n  // Use first 16 chars as identifier (safe for rate limiting)\r\n  return key.substring(0, 16);\r\n}\r\n\r\n// =============================================================================\r\n// CORE RATE LIMIT CHECK\r\n// =============================================================================\r\n\r\n/**\r\n * Check rate limit against a store\r\n */\r\nasync function checkRateLimitAsync(\r\n  store: RateLimitStore,\r\n  config: RateLimitConfig,\r\n  metricType?: string\r\n): Promise<RateLimitResult> {\r\n  const start = Date.now();\r\n  const entry = await store.increment(config.identifier, config.windowMs);\r\n  \r\n  const allowed = entry.count <= config.maxRequests;\r\n  const remaining = Math.max(0, config.maxRequests - entry.count);\r\n  \r\n  // Record metrics if type provided\r\n  if (metricType) {\r\n    recordMetric(metricType, allowed, Date.now() - start);\r\n  }\r\n  \r\n  return {\r\n    allowed,\r\n    remaining,\r\n    resetAt: entry.resetAt,\r\n    limit: config.maxRequests,\r\n  };\r\n}\r\n\r\n/**\r\n * Synchronous check for Edge runtime\r\n */\r\nfunction checkRateLimitSync(\r\n  store: RateLimitStore,\r\n  config: RateLimitConfig\r\n): RateLimitResult {\r\n  const now = Date.now();\r\n  const key = config.identifier;\r\n  \r\n  // Note: This is a simplified sync version that may not be perfectly accurate\r\n  // but works for Edge runtime where we can't await\r\n  const resetAt = now + config.windowMs;\r\n  \r\n  return {\r\n    allowed: true, // Edge allows through, Node enforces\r\n    remaining: config.maxRequests,\r\n    resetAt,\r\n    limit: config.maxRequests,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API - ASYNC (Node.js)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by API key (Node.js - database lookup)\r\n */\r\nexport async function rateLimitByApiKey(\r\n  request: NextRequest,\r\n  apiKeyRateLimit?: number\r\n): Promise<RateLimitResult | null> {\r\n  const token = extractApiKey(request);\r\n  if (!token) return null;\r\n  \r\n  const store = await getRateLimitStore();\r\n  const limit = apiKeyRateLimit || RATE_LIMIT_TIERS.starter.maxRequests;\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.starter.windowMs,\r\n    maxRequests: limit,\r\n    identifier: `api_key:${hashKey(token)}`,\r\n  }, 'api_key');\r\n}\r\n\r\n/**\r\n * Rate limit by endpoint (Node.js)\r\n */\r\nexport async function rateLimitByEndpoint(\r\n  request: NextRequest,\r\n  endpointId: string,\r\n  maxRequests?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.endpoint.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.endpoint.maxRequests,\r\n    identifier: `endpoint:${endpointId}:${ip}`,\r\n  }, `endpoint:${endpointId}`);\r\n}\r\n\r\n/**\r\n * Rate limit by IP (Node.js)\r\n */\r\nexport async function rateLimitByIp(\r\n  request: NextRequest,\r\n  maxRequests?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.global.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.global.maxRequests,\r\n    identifier: `global:${ip}`,\r\n  }, 'global');\r\n}\r\n\r\n/**\r\n * Rate limit cron job (prevent concurrent runs)\r\n */\r\nexport async function rateLimitCronJob(\r\n  cronId: string,\r\n  intervalMs?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: intervalMs || RATE_LIMIT_TIERS.cron.windowMs,\r\n    maxRequests: RATE_LIMIT_TIERS.cron.maxRequests,\r\n    identifier: `cron:${cronId}`,\r\n  }, `cron:${cronId}`);\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API - SYNC (Edge Runtime)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by IP (Edge - sync, in-memory only)\r\n */\r\nexport function rateLimitByIpEdge(\r\n  request: NextRequest,\r\n  maxRequests?: number\r\n): RateLimitResult {\r\n  const store = getEdgeRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.global.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.global.maxRequests,\r\n    identifier: `global:${ip}`,\r\n  });\r\n}\r\n\r\n/**\r\n * Rate limit by API key (Edge - sync, default limit only)\r\n */\r\nexport function rateLimitByApiKeyEdge(\r\n  request: NextRequest,\r\n  defaultLimit?: number\r\n): RateLimitResult | null {\r\n  const token = extractApiKey(request);\r\n  if (!token) return null;\r\n  \r\n  const store = getEdgeRateLimitStore();\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.starter.windowMs,\r\n    maxRequests: defaultLimit || RATE_LIMIT_TIERS.starter.maxRequests,\r\n    identifier: `api_key:${hashKey(token)}`,\r\n  });\r\n}\r\n\r\n// =============================================================================\r\n// RESPONSE HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Add rate limit headers to response\r\n */\r\nexport function addRateLimitHeaders(\r\n  response: NextResponse,\r\n  result: RateLimitResult\r\n): NextResponse {\r\n  response.headers.set('X-RateLimit-Limit', result.limit.toString());\r\n  response.headers.set('X-RateLimit-Remaining', result.remaining.toString());\r\n  response.headers.set('X-RateLimit-Reset', new Date(result.resetAt).toISOString());\r\n  return response;\r\n}\r\n\r\n/**\r\n * Create rate limit error response\r\n */\r\nexport function createRateLimitResponse(result: RateLimitResult): NextResponse {\r\n  const resetDate = new Date(result.resetAt).toISOString();\r\n  const retryAfter = Math.ceil((result.resetAt - Date.now()) / 1000);\r\n  \r\n  const response = NextResponse.json(\r\n    {\r\n      error: 'Rate limit exceeded',\r\n      code: 'RATE_LIMIT_EXCEEDED',\r\n      message: `Too many requests. Limit: ${result.limit} per hour. Try again after ${resetDate}`,\r\n      retryAfter,\r\n    },\r\n    { status: 429 }\r\n  );\r\n  \r\n  response.headers.set('Retry-After', retryAfter.toString());\r\n  return addRateLimitHeaders(response, result);\r\n}\r\n\r\n// =============================================================================\r\n// COMPOSITE CHECKS\r\n// =============================================================================\r\n\r\n/**\r\n * Check all rate limits (API key + endpoint + global)\r\n * Returns first exceeded limit, or null if all pass\r\n */\r\nexport async function checkAllRateLimits(\r\n  request: NextRequest,\r\n  options?: {\r\n    endpointId?: string;\r\n    apiKeyRateLimit?: number;\r\n  }\r\n): Promise<{ result: RateLimitResult; type: string } | null> {\r\n  // 1. Global IP limit\r\n  const globalResult = await rateLimitByIp(request);\r\n  if (!globalResult.allowed) {\r\n    return { result: globalResult, type: 'global' };\r\n  }\r\n  \r\n  // 2. API key limit (if authenticated)\r\n  const apiKeyResult = await rateLimitByApiKey(request, options?.apiKeyRateLimit);\r\n  if (apiKeyResult && !apiKeyResult.allowed) {\r\n    return { result: apiKeyResult, type: 'api_key' };\r\n  }\r\n  \r\n  // 3. Endpoint limit (if specified)\r\n  if (options?.endpointId) {\r\n    const endpointResult = await rateLimitByEndpoint(request, options.endpointId);\r\n    if (!endpointResult.allowed) {\r\n      return { result: endpointResult, type: 'endpoint' };\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * Get rate limit info for response headers (async version)\r\n * Returns the most restrictive limit for informational headers\r\n */\r\nexport async function getRateLimitHeaders(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): Promise<RateLimitResult | null> {\r\n  const results: RateLimitResult[] = [];\r\n\r\n  // Global IP limit\r\n  const globalResult = await rateLimitByIp(request);\r\n  results.push(globalResult);\r\n\r\n  // API key limit\r\n  const apiKeyResult = await rateLimitByApiKey(request);\r\n  if (apiKeyResult) {\r\n    results.push(apiKeyResult);\r\n  }\r\n\r\n  // Endpoint limit\r\n  if (endpointId) {\r\n    const endpointResult = await rateLimitByEndpoint(request, endpointId);\r\n    results.push(endpointResult);\r\n  }\r\n\r\n  // Return the most restrictive (lowest remaining)\r\n  if (results.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return results.reduce((min, current) =>\r\n    current.remaining < min.remaining ? current : min\r\n  );\r\n}\r\n\r\n// =============================================================================\r\n// EDGE-COMPATIBLE FUNCTIONS (Sync)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by endpoint (Edge - sync, in-memory only)\r\n */\r\nexport function rateLimitByEndpointEdge(\r\n  request: NextRequest,\r\n  endpointId: string,\r\n  maxRequests?: number\r\n): RateLimitResult {\r\n  const store = getEdgeRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.endpoint.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.endpoint.maxRequests,\r\n    identifier: `endpoint:${endpointId}:${ip}`,\r\n  });\r\n}\r\n\r\n/**\r\n * Check all rate limits (Edge-compatible, sync version)\r\n * Returns first exceeded limit, or null if all pass\r\n */\r\nexport function checkAllRateLimitsEdge(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): { result: RateLimitResult; type: string } | null {\r\n  // 1. Global IP limit\r\n  const globalResult = rateLimitByIpEdge(request);\r\n  if (!globalResult.allowed) {\r\n    return { result: globalResult, type: 'global' };\r\n  }\r\n  \r\n  // 2. API key limit (Edge uses default limit)\r\n  const apiKeyResult = rateLimitByApiKeyEdge(request);\r\n  if (apiKeyResult && !apiKeyResult.allowed) {\r\n    return { result: apiKeyResult, type: 'api_key' };\r\n  }\r\n  \r\n  // 3. Endpoint limit (if specified)\r\n  if (endpointId) {\r\n    const endpointResult = rateLimitByEndpointEdge(request, endpointId);\r\n    if (!endpointResult.allowed) {\r\n      return { result: endpointResult, type: 'endpoint' };\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * Get rate limit info for response headers (Edge-compatible, sync version)\r\n */\r\nexport function getRateLimitHeadersEdge(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): RateLimitResult | null {\r\n  const results: RateLimitResult[] = [];\r\n\r\n  // Global IP limit\r\n  results.push(rateLimitByIpEdge(request));\r\n\r\n  // API key limit\r\n  const apiKeyResult = rateLimitByApiKeyEdge(request);\r\n  if (apiKeyResult) {\r\n    results.push(apiKeyResult);\r\n  }\r\n\r\n  // Endpoint limit\r\n  if (endpointId) {\r\n    results.push(rateLimitByEndpointEdge(request, endpointId));\r\n  }\r\n\r\n  // Return the most restrictive (lowest remaining)\r\n  if (results.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return results.reduce((min, current) =>\r\n    current.remaining < min.remaining ? current : min\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2915, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/discovery-metadata.ts"],"sourcesContent":["// =============================================================================\n// DISCOVERY METADATA HELPERS\n// =============================================================================\n// Helpers for declaring Bazaar discovery metadata\n// Note: @x402 packages may not be available - this module handles missing dependencies gracefully\n\nimport type { MeteredEndpoint } from '@/db/metered-endpoints';\n\n// Lazy load x402 packages\nasync function loadBazaarExtension() {\n  try {\n    const { declareDiscoveryExtension } = await import('@x402/extensions/bazaar');\n    return declareDiscoveryExtension;\n  } catch (error) {\n    // Return a stub function if package is not available\n    return (config: any) => ({\n      ...config,\n      _stub: true,\n    });\n  }\n}\n\n/**\n * Create discovery metadata for a metered endpoint\n * \n * This enables the endpoint to be discovered in the x402 Bazaar\n */\nexport async function createDiscoveryMetadata(endpoint: MeteredEndpoint) {\n  // Determine if this is a GET or POST endpoint based on typical usage\n  // Most metered endpoints are POST, but we can make it configurable later\n  const method = 'POST';\n  const bodyType = 'json'; // Most endpoints accept JSON\n\n  // Create output schema based on endpoint description\n  // This is a generic schema - can be customized per endpoint\n  const outputSchema = {\n    type: 'object',\n    properties: {\n      data: {\n        type: 'object',\n        description: 'Response data from upstream service',\n      },\n      timestamp: {\n        type: 'string',\n        format: 'date-time',\n        description: 'Response timestamp',\n      },\n    },\n  };\n\n  // Example output based on endpoint type\n  const outputExample: any = {\n    data: {},\n    timestamp: new Date().toISOString(),\n  };\n\n  // If endpoint has a specific description, use it to create better examples\n  if (endpoint.description?.toLowerCase().includes('revenue')) {\n    outputExample.data = {\n      revenue: 0.01,\n      currency: 'USDC',\n      period: 'daily',\n    };\n  } else if (endpoint.description?.toLowerCase().includes('health')) {\n    outputExample.data = {\n      status: 'healthy',\n      uptime: 99.9,\n    };\n  }\n\n  // Declare discovery extension\n  const declareExt = await loadBazaarExtension();\n  return declareExt({\n    // Input schema (for POST endpoints with body)\n    inputSchema: {\n      type: 'object',\n      properties: {\n        // Generic input - can be customized per endpoint\n      },\n      additionalProperties: true, // Allow any additional properties\n    },\n    bodyType: bodyType,\n    // Output schema and example\n    output: {\n      example: outputExample,\n      schema: outputSchema,\n    },\n  });\n}\n\n/**\n * Get discovery metadata for endpoint listing\n */\nexport function getEndpointDiscoveryInfo(endpoint: MeteredEndpoint) {\n  const isProduction = process.env.NODE_ENV === 'production';\n  const appUrl = process.env.NEXT_PUBLIC_APP_URL;\n  if (isProduction && !appUrl) {\n    throw new Error('NEXT_PUBLIC_APP_URL must be set in production');\n  }\n  const baseUrl = appUrl || 'http://localhost:3001';\n  const resourceUrl = `${baseUrl}/api/v1/metered/${endpoint.id}`;\n\n  return {\n    url: resourceUrl,\n    type: 'http',\n    method: 'POST',\n    x402Version: 1,\n    accepts: [\n      {\n        scheme: 'exact',\n        network: endpoint.network,\n        maxAmountRequired: endpoint.price,\n        asset: endpoint.tokenAddress,\n        payTo: endpoint.recipientAddress,\n        resource: resourceUrl,\n        description: endpoint.description || endpoint.name || 'Metered API endpoint',\n        mimeType: 'application/json',\n        maxTimeoutSeconds: 300,\n      },\n    ],\n    metadata: {\n      name: endpoint.name,\n      description: endpoint.description,\n      category: 'api',\n      provider: 'NexFlow',\n    },\n    lastUpdated: new Date(endpoint.updatedAt).getTime() / 1000,\n  };\n}\n\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,6BAA6B;AAC7B,gFAAgF;AAChF,kDAAkD;AAClD,kGAAkG;;;;;;;AAIlG,0BAA0B;AAC1B,eAAe;IACb,IAAI;QACF,MAAM,EAAE,yBAAyB,EAAE,GAAG;QACtC,OAAO;IACT,EAAE,OAAO,OAAO;QACd,qDAAqD;QACrD,OAAO,CAAC,SAAgB,CAAC;gBACvB,GAAG,MAAM;gBACT,OAAO;YACT,CAAC;IACH;AACF;AAOO,eAAe,wBAAwB,QAAyB;IACrE,qEAAqE;IACrE,yEAAyE;IACzE,MAAM,SAAS;IACf,MAAM,WAAW,QAAQ,6BAA6B;IAEtD,qDAAqD;IACrD,4DAA4D;IAC5D,MAAM,eAAe;QACnB,MAAM;QACN,YAAY;YACV,MAAM;gBACJ,MAAM;gBACN,aAAa;YACf;YACA,WAAW;gBACT,MAAM;gBACN,QAAQ;gBACR,aAAa;YACf;QACF;IACF;IAEA,wCAAwC;IACxC,MAAM,gBAAqB;QACzB,MAAM,CAAC;QACP,WAAW,IAAI,OAAO,WAAW;IACnC;IAEA,2EAA2E;IAC3E,IAAI,SAAS,WAAW,EAAE,cAAc,SAAS,YAAY;QAC3D,cAAc,IAAI,GAAG;YACnB,SAAS;YACT,UAAU;YACV,QAAQ;QACV;IACF,OAAO,IAAI,SAAS,WAAW,EAAE,cAAc,SAAS,WAAW;QACjE,cAAc,IAAI,GAAG;YACnB,QAAQ;YACR,QAAQ;QACV;IACF;IAEA,8BAA8B;IAC9B,MAAM,aAAa,MAAM;IACzB,OAAO,WAAW;QAChB,8CAA8C;QAC9C,aAAa;YACX,MAAM;YACN,YAAY;YAEZ;YACA,sBAAsB;QACxB;QACA,UAAU;QACV,4BAA4B;QAC5B,QAAQ;YACN,SAAS;YACT,QAAQ;QACV;IACF;AACF;AAKO,SAAS,yBAAyB,QAAyB;IAChE,MAAM,eAAe,oDAAyB;IAC9C,MAAM;IACN;;IAGA,MAAM,UAAU,UAAU;IAC1B,MAAM,cAAc,GAAG,QAAQ,gBAAgB,EAAE,SAAS,EAAE,EAAE;IAE9D,OAAO;QACL,KAAK;QACL,MAAM;QACN,QAAQ;QACR,aAAa;QACb,SAAS;YACP;gBACE,QAAQ;gBACR,SAAS,SAAS,OAAO;gBACzB,mBAAmB,SAAS,KAAK;gBACjC,OAAO,SAAS,YAAY;gBAC5B,OAAO,SAAS,gBAAgB;gBAChC,UAAU;gBACV,aAAa,SAAS,WAAW,IAAI,SAAS,IAAI,IAAI;gBACtD,UAAU;gBACV,mBAAmB;YACrB;SACD;QACD,UAAU;YACR,MAAM,SAAS,IAAI;YACnB,aAAa,SAAS,WAAW;YACjC,UAAU;YACV,UAAU;QACZ;QACA,aAAa,IAAI,KAAK,SAAS,SAAS,EAAE,OAAO,KAAK;IACxD;AACF"}},
    {"offset": {"line": 3034, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/nextjs-adapter.ts"],"sourcesContent":["// =============================================================================\n// NEXT.JS ADAPTER FOR X402 SDK\n// =============================================================================\n// Adapter to use x402 SDK with Next.js App Router\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getX402ResourceServer } from './resource-server';\nimport { createDiscoveryMetadata, getEndpointDiscoveryInfo } from './discovery-metadata';\nimport type { MeteredEndpoint } from '@/db/metered-endpoints';\nimport { createLogger } from '@/lib/logger';\n\nconst logger = createLogger({ component: 'X402NextJSAdapter' });\n\n/**\n * Generate x402-compliant 402 response with Bazaar discovery metadata\n * \n * This response format enables Bazaar discovery when the facilitator processes payments\n */\nexport async function create402Response(\n  request: NextRequest,\n  endpoint: MeteredEndpoint\n): Promise<NextResponse> {\n  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || \n                 (request.headers.get('x-forwarded-proto') === 'https' ? 'https' : 'http') + \n                 '://' + (request.headers.get('host') || 'localhost:3001');\n  const resourceUrl = `${baseUrl}/api/v1/metered/${endpoint.id}`;\n\n  // Get discovery metadata using Bazaar extension (may be stubbed if packages unavailable)\n  const discoveryExtension = await createDiscoveryMetadata(endpoint);\n\n  // Ensure price is a string (atomic units)\n  const priceString = String(endpoint.price);\n  \n  // Normalize network to 'base' if not specified (x402scan expects specific network values)\n  const network = (endpoint.network || 'base').toLowerCase();\n  \n  // Build outputSchema in x402scan format: { input: {...}, output?: {...} }\n  // x402scan expects outputSchema with input/output structure, not raw JSON schema\n  const outputSchema = {\n    input: {\n      type: 'http' as const,\n      method: 'POST' as const,\n      bodyType: 'json' as const,\n      // Optional: Add queryParams, bodyFields, headerFields if we have more info\n    },\n    output: {\n      type: 'object',\n      properties: {\n        data: {\n          type: 'object',\n          description: 'Response data from upstream service',\n          additionalProperties: true,\n        },\n        timestamp: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Response timestamp',\n        },\n      },\n    },\n  };\n\n  // Create x402scan-compliant EnhancedPaymentRequirements format\n  // x402scan requires strict schema matching - remove extensions, use extra instead\n  const accepts: Array<{\n    scheme: 'exact';\n    network: string;\n    maxAmountRequired: string;\n    resource: string;\n    description: string;\n    mimeType: string;\n    payTo: string;\n    maxTimeoutSeconds: number;\n    asset: string;\n    outputSchema?: typeof outputSchema;\n    extra?: Record<string, any>;\n  }> = [];\n  \n  // Add Base (EVM) accept entry - EnhancedPaymentRequirements format\n  // Only include one entry for now to match x402scan validation\n  accepts.push({\n    scheme: 'exact',\n    network: network === 'base' ? 'base' : network, // Ensure 'base' for Base network\n    maxAmountRequired: priceString, // Must be string of atomic units\n    asset: endpoint.tokenAddress,\n    payTo: endpoint.recipientAddress,\n    resource: resourceUrl,\n    description: endpoint.description || endpoint.name || 'Metered API endpoint',\n    mimeType: 'application/json',\n    maxTimeoutSeconds: 300,\n    outputSchema: outputSchema,\n    // Move Bazaar extension to extra field (not in schema, but we can include it)\n    extra: {\n      bazaar: discoveryExtension.bazaar,\n    },\n  });\n\n  // x402scan response format - use x402Version: 1 (number type)\n  // x402scan validation may only accept version 1\n  const response = {\n    x402Version: 1, // x402scan expects number, use 1 for compatibility\n    error: 'X-PAYMENT header is required',\n    accepts: accepts,\n  };\n\n  return NextResponse.json(response, { status: 402 });\n}\n\n// Note: Payment verification is handled by existing CDP facilitator\n// This adapter focuses on Bazaar discovery metadata integration\n\n/**\n * Get route configuration for an endpoint (for Bazaar discovery)\n */\nexport async function getRouteConfig(endpoint: MeteredEndpoint) {\n  const isProduction = process.env.NODE_ENV === 'production';\n  const appUrl = process.env.NEXT_PUBLIC_APP_URL;\n  if (isProduction && !appUrl) {\n    throw new Error('NEXT_PUBLIC_APP_URL must be set in production');\n  }\n  const baseUrl = appUrl || 'http://localhost:3001';\n  const resourceUrl = `${baseUrl}/api/v1/metered/${endpoint.id}`;\n\n  const discoveryExtension = await createDiscoveryMetadata(endpoint);\n\n  return {\n    [`POST /api/v1/metered/${endpoint.id}`]: {\n      accepts: {\n        scheme: 'exact',\n        network: endpoint.network,\n        price: endpoint.price,\n        payTo: endpoint.recipientAddress,\n        asset: endpoint.tokenAddress,\n        resource: resourceUrl,\n        description: endpoint.description || endpoint.name,\n        mimeType: 'application/json',\n        maxTimeoutSeconds: 300,\n      },\n      extensions: {\n        ...discoveryExtension,\n      },\n    },\n  };\n}\n\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,+BAA+B;AAC/B,gFAAgF;AAChF,kDAAkD;;;;;;;AAElD;AAEA;AAEA;;;;AAEA,MAAM,SAAS,IAAA,sIAAY,EAAC;IAAE,WAAW;AAAoB;AAOtD,eAAe,kBACpB,OAAoB,EACpB,QAAyB;IAEzB,MAAM,UAAU,kEACD,CAAC,QAAQ,OAAO,CAAC,GAAG,CAAC,yBAAyB,UAAU,UAAU,MAAM,IACxE,QAAQ,CAAC,QAAQ,OAAO,CAAC,GAAG,CAAC,WAAW,gBAAgB;IACvE,MAAM,cAAc,GAAG,QAAQ,gBAAgB,EAAE,SAAS,EAAE,EAAE;IAE9D,yFAAyF;IACzF,MAAM,qBAAqB,MAAM,IAAA,iLAAuB,EAAC;IAEzD,0CAA0C;IAC1C,MAAM,cAAc,OAAO,SAAS,KAAK;IAEzC,0FAA0F;IAC1F,MAAM,UAAU,CAAC,SAAS,OAAO,IAAI,MAAM,EAAE,WAAW;IAExD,0EAA0E;IAC1E,iFAAiF;IACjF,MAAM,eAAe;QACnB,OAAO;YACL,MAAM;YACN,QAAQ;YACR,UAAU;QAEZ;QACA,QAAQ;YACN,MAAM;YACN,YAAY;gBACV,MAAM;oBACJ,MAAM;oBACN,aAAa;oBACb,sBAAsB;gBACxB;gBACA,WAAW;oBACT,MAAM;oBACN,QAAQ;oBACR,aAAa;gBACf;YACF;QACF;IACF;IAEA,+DAA+D;IAC/D,kFAAkF;IAClF,MAAM,UAYD,EAAE;IAEP,mEAAmE;IACnE,8DAA8D;IAC9D,QAAQ,IAAI,CAAC;QACX,QAAQ;QACR,SAAS,YAAY,SAAS,SAAS;QACvC,mBAAmB;QACnB,OAAO,SAAS,YAAY;QAC5B,OAAO,SAAS,gBAAgB;QAChC,UAAU;QACV,aAAa,SAAS,WAAW,IAAI,SAAS,IAAI,IAAI;QACtD,UAAU;QACV,mBAAmB;QACnB,cAAc;QACd,8EAA8E;QAC9E,OAAO;YACL,QAAQ,mBAAmB,MAAM;QACnC;IACF;IAEA,8DAA8D;IAC9D,gDAAgD;IAChD,MAAM,WAAW;QACf,aAAa;QACb,OAAO;QACP,SAAS;IACX;IAEA,OAAO,gJAAY,CAAC,IAAI,CAAC,UAAU;QAAE,QAAQ;IAAI;AACnD;AAQO,eAAe,eAAe,QAAyB;IAC5D,MAAM,eAAe,oDAAyB;IAC9C,MAAM;IACN;;IAGA,MAAM,UAAU,UAAU;IAC1B,MAAM,cAAc,GAAG,QAAQ,gBAAgB,EAAE,SAAS,EAAE,EAAE;IAE9D,MAAM,qBAAqB,MAAM,IAAA,iLAAuB,EAAC;IAEzD,OAAO;QACL,CAAC,CAAC,qBAAqB,EAAE,SAAS,EAAE,EAAE,CAAC,EAAE;YACvC,SAAS;gBACP,QAAQ;gBACR,SAAS,SAAS,OAAO;gBACzB,OAAO,SAAS,KAAK;gBACrB,OAAO,SAAS,gBAAgB;gBAChC,OAAO,SAAS,YAAY;gBAC5B,UAAU;gBACV,aAAa,SAAS,WAAW,IAAI,SAAS,IAAI;gBAClD,UAAU;gBACV,mBAAmB;YACrB;YACA,YAAY;gBACV,GAAG,kBAAkB;YACvB;QACF;IACF;AACF"}},
    {"offset": {"line": 3155, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/cdp-jwt.ts"],"sourcesContent":["import { generateJwt } from '@coinbase/cdp-sdk/auth';\r\n\r\nexport interface CDPJWTPayload {\r\n  sub: string;\r\n  iss: string;\r\n  aud: string[];\r\n  nbf: number;\r\n  exp: number;\r\n  uris?: string[];\r\n}\r\n\r\nexport class CDPJWTGenerator {\r\n  private apiKeyId: string;\r\n  private apiKeySecret: string;\r\n\r\n  constructor(apiKeyId: string, apiKeySecret: string) {\r\n    this.apiKeyId = apiKeyId;\r\n    this.apiKeySecret = apiKeySecret;\r\n  }\r\n\r\n  /**\r\n   * Generate JWT token for CDP API authentication.\r\n   *\r\n   * Uses CDP SDK's generateJwt helper, which signs with the correct\r\n   * algorithm (ES256/EdDSA) for your CDP API key.\r\n   * \r\n   * @param requestMethod - HTTP method (GET, POST, etc.) or null for generic auth\r\n   * @param requestHost - Request host or null\r\n   * @param requestPath - Request path or null\r\n   */\r\n  async generateToken(\r\n    requestMethod: string | null = null,\r\n    requestHost: string | null = null,\r\n    requestPath: string | null = null,\r\n  ): Promise<string> {\r\n    // For REST requests, CDP expects method/host/path\r\n    // For generic facilitator auth, nulls are allowed\r\n    const token = await generateJwt({\r\n      apiKeyId: this.apiKeyId,\r\n      apiKeySecret: this.apiKeySecret,\r\n      requestMethod: requestMethod || null,\r\n      requestHost: requestHost || null,\r\n      requestPath: requestPath || null,\r\n      expiresIn: 120,\r\n      // CDP SDK will handle the JWT payload and headers correctly.\r\n    });\r\n\r\n    return token;\r\n  }\r\n\r\n  isTokenValid(_token: string): boolean {\r\n    // Keep simple: rely on short expiry and CDP errors instead of local decode.\r\n    return true;\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet jwtGenerator: CDPJWTGenerator | null = null;\r\n\r\nexport function getCDPJWTGenerator(): CDPJWTGenerator {\r\n  if (!jwtGenerator) {\r\n    const apiKeyId = process.env.CDP_API_KEY_ID;\r\n    const apiKeySecret = process.env.CDP_API_KEY_SECRET;\r\n\r\n    if (!apiKeyId || !apiKeySecret) {\r\n      throw new Error('CDP_API_KEY_ID and CDP_API_KEY_SECRET must be set');\r\n    }\r\n\r\n    jwtGenerator = new CDPJWTGenerator(apiKeyId, apiKeySecret);\r\n  }\r\n  return jwtGenerator;\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAWO,MAAM;IACH,SAAiB;IACjB,aAAqB;IAE7B,YAAY,QAAgB,EAAE,YAAoB,CAAE;QAClD,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,YAAY,GAAG;IACtB;IAEA;;;;;;;;;GASC,GACD,MAAM,cACJ,gBAA+B,IAAI,EACnC,cAA6B,IAAI,EACjC,cAA6B,IAAI,EAChB;QACjB,kDAAkD;QAClD,kDAAkD;QAClD,MAAM,QAAQ,MAAM,IAAA,yLAAW,EAAC;YAC9B,UAAU,IAAI,CAAC,QAAQ;YACvB,cAAc,IAAI,CAAC,YAAY;YAC/B,eAAe,iBAAiB;YAChC,aAAa,eAAe;YAC5B,aAAa,eAAe;YAC5B,WAAW;QAEb;QAEA,OAAO;IACT;IAEA,aAAa,MAAc,EAAW;QACpC,4EAA4E;QAC5E,OAAO;IACT;AACF;AAEA,qBAAqB;AACrB,IAAI,eAAuC;AAEpC,SAAS;IACd,IAAI,CAAC,cAAc;QACjB,MAAM,WAAW,QAAQ,GAAG,CAAC,cAAc;QAC3C,MAAM,eAAe,QAAQ,GAAG,CAAC,kBAAkB;QAEnD,IAAI,CAAC,YAAY,CAAC,cAAc;YAC9B,MAAM,IAAI,MAAM;QAClB;QAEA,eAAe,IAAI,gBAAgB,UAAU;IAC/C;IACA,OAAO;AACT"}},
    {"offset": {"line": 3214, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/signature-verifier.ts"],"sourcesContent":["import { verifyTypedData, type Address } from 'viem';\r\nimport { base } from 'viem/chains';\r\n\r\nexport interface EIP712Domain {\r\n  name: string;\r\n  version: string;\r\n  chainId: number;\r\n  verifyingContract: Address;\r\n}\r\n\r\nexport interface PaymentAuthorization {\r\n  from: Address;\r\n  to: Address;\r\n  value: string;\r\n  validAfter: string;\r\n  validBefore: string;\r\n  nonce: string;\r\n}\r\n\r\n/**\r\n * Verify EIP-712 signature for x402 payment authorization\r\n * Uses EIP-3009 TransferWithAuthorization domain for USDC\r\n * This provides an additional security layer before CDP verification\r\n */\r\nexport async function verifyPaymentSignature(\r\n  signature: string,\r\n  authorization: PaymentAuthorization,\r\n  signerAddress: Address,\r\n  chainId: number = 8453, // Base mainnet\r\n  asset?: string // Token contract address (optional, defaults to USDC)\r\n): Promise<boolean> {\r\n  try {\r\n    // EIP-3009 domain for USDC on Base (per official @x402/evm SDK)\r\n    // The domain comes from the token contract itself\r\n    const domain: EIP712Domain = {\r\n      name: 'USD Coin',\r\n      version: '2',\r\n      chainId,\r\n      verifyingContract: (asset || '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913') as Address, // Base USDC\r\n    };\r\n\r\n    // EIP-3009 TransferWithAuthorization types\r\n    const types = {\r\n      TransferWithAuthorization: [\r\n        { name: 'from', type: 'address' },\r\n        { name: 'to', type: 'address' },\r\n        { name: 'value', type: 'uint256' },\r\n        { name: 'validAfter', type: 'uint256' },\r\n        { name: 'validBefore', type: 'uint256' },\r\n        { name: 'nonce', type: 'bytes32' },\r\n      ],\r\n    };\r\n\r\n    // Verify the signature\r\n    const isValid = await verifyTypedData({\r\n      address: signerAddress,\r\n      domain,\r\n      types,\r\n      primaryType: 'TransferWithAuthorization',\r\n      message: authorization as Record<string, unknown>,\r\n      signature: signature as `0x${string}`,\r\n    });\r\n\r\n    return isValid;\r\n  } catch (error) {\r\n    console.error('[SignatureVerifier] Verification error:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Validate payment authorization fields\r\n */\r\nexport function validatePaymentAuthorization(\r\n  authorization: PaymentAuthorization\r\n): { valid: boolean; error?: string } {\r\n  const now = Math.floor(Date.now() / 1000);\r\n  const validAfter = parseInt(authorization.validAfter);\r\n  const validBefore = parseInt(authorization.validBefore);\r\n\r\n  if (now < validAfter) {\r\n    return { valid: false, error: 'Payment not yet valid' };\r\n  }\r\n\r\n  if (now >= validBefore) {\r\n    return { valid: false, error: 'Payment has expired' };\r\n  }\r\n\r\n  if (!authorization.from || !authorization.to) {\r\n    return { valid: false, error: 'Missing from or to address' };\r\n  }\r\n\r\n  if (!authorization.value || BigInt(authorization.value) <= BigInt(0)) {\r\n    return { valid: false, error: 'Invalid payment amount' };\r\n  }\r\n\r\n  if (!authorization.nonce) {\r\n    return { valid: false, error: 'Missing nonce' };\r\n  }\r\n\r\n  return { valid: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAwBO,eAAe,uBACpB,SAAiB,EACjB,aAAmC,EACnC,aAAsB,EACtB,UAAkB,IAAI,EACtB,KAAc,AAAC,sDAAsD;;IAErE,IAAI;QACF,gEAAgE;QAChE,kDAAkD;QAClD,MAAM,SAAuB;YAC3B,MAAM;YACN,SAAS;YACT;YACA,mBAAoB,SAAS;QAC/B;QAEA,2CAA2C;QAC3C,MAAM,QAAQ;YACZ,2BAA2B;gBACzB;oBAAE,MAAM;oBAAQ,MAAM;gBAAU;gBAChC;oBAAE,MAAM;oBAAM,MAAM;gBAAU;gBAC9B;oBAAE,MAAM;oBAAS,MAAM;gBAAU;gBACjC;oBAAE,MAAM;oBAAc,MAAM;gBAAU;gBACtC;oBAAE,MAAM;oBAAe,MAAM;gBAAU;gBACvC;oBAAE,MAAM;oBAAS,MAAM;gBAAU;aAClC;QACH;QAEA,uBAAuB;QACvB,MAAM,UAAU,MAAM,IAAA,0LAAe,EAAC;YACpC,SAAS;YACT;YACA;YACA,aAAa;YACb,SAAS;YACT,WAAW;QACb;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2CAA2C;QACzD,OAAO;IACT;AACF;AAKO,SAAS,6BACd,aAAmC;IAEnC,MAAM,MAAM,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;IACpC,MAAM,aAAa,SAAS,cAAc,UAAU;IACpD,MAAM,cAAc,SAAS,cAAc,WAAW;IAEtD,IAAI,MAAM,YAAY;QACpB,OAAO;YAAE,OAAO;YAAO,OAAO;QAAwB;IACxD;IAEA,IAAI,OAAO,aAAa;QACtB,OAAO;YAAE,OAAO;YAAO,OAAO;QAAsB;IACtD;IAEA,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,EAAE,EAAE;QAC5C,OAAO;YAAE,OAAO;YAAO,OAAO;QAA6B;IAC7D;IAEA,IAAI,CAAC,cAAc,KAAK,IAAI,OAAO,cAAc,KAAK,KAAK,OAAO,IAAI;QACpE,OAAO;YAAE,OAAO;YAAO,OAAO;QAAyB;IACzD;IAEA,IAAI,CAAC,cAAc,KAAK,EAAE;QACxB,OAAO;YAAE,OAAO;YAAO,OAAO;QAAgB;IAChD;IAEA,OAAO;QAAE,OAAO;IAAK;AACvB"}},
    {"offset": {"line": 3319, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/amount-utils.ts"],"sourcesContent":["// =============================================================================\r\n// AMOUNT UTILITIES\r\n// =============================================================================\r\n// Helper functions for converting between human-readable amounts and atomic units\r\n\r\n/**\r\n * Convert human-readable amount to atomic units\r\n * \r\n * For USDC on Base: 1 USDC = 1,000,000 atomic units (6 decimals)\r\n * \r\n * @param humanAmount - Human-readable amount (e.g., \"1\" for 1 USDC)\r\n * @param decimals - Number of decimals (default: 6 for USDC)\r\n * @returns Atomic units as string (e.g., \"1000000\" for 1 USDC)\r\n * \r\n * @example\r\n * toAtomicUnits(\"1\", 6) // \"1000000\"\r\n * toAtomicUnits(\"0.5\", 6) // \"500000\"\r\n * toAtomicUnits(\"1.5\", 6) // \"1500000\"\r\n */\r\nexport function toAtomicUnits(humanAmount: string, decimals: number = 6): string {\r\n  // Remove any whitespace\r\n  const cleanAmount = humanAmount.trim();\r\n  \r\n  // Parse as decimal number\r\n  const amount = parseFloat(cleanAmount);\r\n  \r\n  if (isNaN(amount) || amount < 0) {\r\n    throw new Error(`Invalid amount: ${humanAmount}`);\r\n  }\r\n  \r\n  // Convert to atomic units: multiply by 10^decimals\r\n  const atomicUnits = BigInt(Math.floor(amount * Math.pow(10, decimals)));\r\n  \r\n  // Return as string\r\n  return atomicUnits.toString();\r\n}\r\n\r\n/**\r\n * Convert atomic units to human-readable amount\r\n * \r\n * @param atomicUnits - Atomic units as string (e.g., \"1000000\")\r\n * @param decimals - Number of decimals (default: 6 for USDC)\r\n * @returns Human-readable amount as string (e.g., \"1\")\r\n * \r\n * @example\r\n * fromAtomicUnits(\"1000000\", 6) // \"1\"\r\n * fromAtomicUnits(\"500000\", 6) // \"0.5\"\r\n */\r\nexport function fromAtomicUnits(atomicUnits: string, decimals: number = 6): string {\r\n  const atomic = BigInt(atomicUnits);\r\n  const divisor = BigInt(Math.pow(10, decimals));\r\n  const whole = atomic / divisor;\r\n  const remainder = atomic % divisor;\r\n  \r\n  if (remainder === BigInt(0)) {\r\n    return whole.toString();\r\n  }\r\n  \r\n  // Format with proper decimal places\r\n  const remainderStr = remainder.toString().padStart(decimals, '0');\r\n  const trimmed = remainderStr.replace(/0+$/, '');\r\n  return `${whole}.${trimmed}`;\r\n}\r\n\r\n/**\r\n * Normalize network identifier to CAIP-2 format\r\n * \r\n * @param network - Network identifier (e.g., \"base\", \"eip155:8453\")\r\n * @returns CAIP-2 format network identifier\r\n * \r\n * @example\r\n * normalizeNetwork(\"base\") // \"eip155:8453\"\r\n * normalizeNetwork(\"eip155:8453\") // \"eip155:8453\"\r\n */\r\nexport function normalizeNetwork(network: string): string {\r\n  // If already in CAIP format, return as-is\r\n  if (network.includes(':')) {\r\n    return network;\r\n  }\r\n  \r\n  // Map common network names to CAIP-2 format\r\n  const networkMap: Record<string, string> = {\r\n    'base': 'eip155:8453',\r\n    'ethereum': 'eip155:1',\r\n    'polygon': 'eip155:137',\r\n    'arbitrum': 'eip155:42161',\r\n    'optimism': 'eip155:10',\r\n    'avalanche': 'eip155:43114',\r\n    'bnb': 'eip155:56',\r\n  };\r\n  \r\n  const normalized = networkMap[network.toLowerCase()];\r\n  if (normalized) {\r\n    return normalized;\r\n  }\r\n  \r\n  // If not found, assume it's already in the correct format or return as-is\r\n  return network;\r\n}\r\n\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,mBAAmB;AACnB,gFAAgF;AAChF,kFAAkF;AAElF;;;;;;;;;;;;;CAaC;;;;;;;;AACM,SAAS,cAAc,WAAmB,EAAE,WAAmB,CAAC;IACrE,wBAAwB;IACxB,MAAM,cAAc,YAAY,IAAI;IAEpC,0BAA0B;IAC1B,MAAM,SAAS,WAAW;IAE1B,IAAI,MAAM,WAAW,SAAS,GAAG;QAC/B,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,aAAa;IAClD;IAEA,mDAAmD;IACnD,MAAM,cAAc,OAAO,KAAK,KAAK,CAAC,SAAS,KAAK,GAAG,CAAC,IAAI;IAE5D,mBAAmB;IACnB,OAAO,YAAY,QAAQ;AAC7B;AAaO,SAAS,gBAAgB,WAAmB,EAAE,WAAmB,CAAC;IACvE,MAAM,SAAS,OAAO;IACtB,MAAM,UAAU,OAAO,KAAK,GAAG,CAAC,IAAI;IACpC,MAAM,QAAQ,SAAS;IACvB,MAAM,YAAY,SAAS;IAE3B,IAAI,cAAc,OAAO,IAAI;QAC3B,OAAO,MAAM,QAAQ;IACvB;IAEA,oCAAoC;IACpC,MAAM,eAAe,UAAU,QAAQ,GAAG,QAAQ,CAAC,UAAU;IAC7D,MAAM,UAAU,aAAa,OAAO,CAAC,OAAO;IAC5C,OAAO,GAAG,MAAM,CAAC,EAAE,SAAS;AAC9B;AAYO,SAAS,iBAAiB,OAAe;IAC9C,0CAA0C;IAC1C,IAAI,QAAQ,QAAQ,CAAC,MAAM;QACzB,OAAO;IACT;IAEA,4CAA4C;IAC5C,MAAM,aAAqC;QACzC,QAAQ;QACR,YAAY;QACZ,WAAW;QACX,YAAY;QACZ,YAAY;QACZ,aAAa;QACb,OAAO;IACT;IAEA,MAAM,aAAa,UAAU,CAAC,QAAQ,WAAW,GAAG;IACpD,IAAI,YAAY;QACd,OAAO;IACT;IAEA,0EAA0E;IAC1E,OAAO;AACT"}},
    {"offset": {"line": 3396, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/cdp-client.ts"],"sourcesContent":["// =============================================================================\r\n// CDP/x402 Client Wrapper\r\n// =============================================================================\r\n// Wraps all calls to Coinbase/CDP/x402 with normalized error handling\r\n// and structured logging\r\n\r\nimport { createLogger, type LogContext } from './logger';\r\n\r\nconst logger = createLogger({ component: 'CDPClient' });\r\n\r\n/**\r\n * Normalized CDP error codes\r\n */\r\nexport enum CDPErrorCode {\r\n  CDP_TIMEOUT = 'CDP_TIMEOUT',\r\n  CDP_4XX = 'CDP_4XX',\r\n  CDP_5XX = 'CDP_5XX',\r\n  CDP_INVALID_RESPONSE = 'CDP_INVALID_RESPONSE',\r\n  CDP_NETWORK_ERROR = 'CDP_NETWORK_ERROR',\r\n  CDP_AUTH_ERROR = 'CDP_AUTH_ERROR',\r\n  CDP_RATE_LIMIT = 'CDP_RATE_LIMIT',\r\n  CDP_UNKNOWN_ERROR = 'CDP_UNKNOWN_ERROR',\r\n}\r\n\r\n/**\r\n * Normalized CDP error\r\n */\r\nexport class CDPError extends Error {\r\n  constructor(\r\n    public code: CDPErrorCode,\r\n    message: string,\r\n    public statusCode?: number,\r\n    public cdpErrorId?: string,\r\n    public responseBody?: any\r\n  ) {\r\n    super(message);\r\n    this.name = 'CDPError';\r\n    // Ensure stack trace is captured\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, CDPError);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Normalize HTTP status code to CDP error code\r\n */\r\nfunction normalizeErrorCode(statusCode: number | undefined): CDPErrorCode {\r\n  if (!statusCode) {\r\n    return CDPErrorCode.CDP_UNKNOWN_ERROR;\r\n  }\r\n  \r\n  if (statusCode >= 500) {\r\n    return CDPErrorCode.CDP_5XX;\r\n  }\r\n  \r\n  if (statusCode === 401 || statusCode === 403) {\r\n    return CDPErrorCode.CDP_AUTH_ERROR;\r\n  }\r\n  \r\n  if (statusCode === 429) {\r\n    return CDPErrorCode.CDP_RATE_LIMIT;\r\n  }\r\n  \r\n  if (statusCode >= 400) {\r\n    return CDPErrorCode.CDP_4XX;\r\n  }\r\n  \r\n  return CDPErrorCode.CDP_UNKNOWN_ERROR;\r\n}\r\n\r\n/**\r\n * Extract safe excerpt from response body for logging\r\n * Removes sensitive data and truncates long responses\r\n */\r\nfunction extractSafeResponseExcerpt(body: any, maxLength: number = 500): string {\r\n  if (!body) return '';\r\n  \r\n  try {\r\n    const str = typeof body === 'string' ? body : JSON.stringify(body);\r\n    if (str.length <= maxLength) {\r\n      return str;\r\n    }\r\n    return str.substring(0, maxLength) + '... [truncated]';\r\n  } catch {\r\n    return '[unable to serialize response]';\r\n  }\r\n}\r\n\r\n/**\r\n * Wrapper for CDP API calls with error handling and logging\r\n */\r\nexport async function callCDP<T>(\r\n  operation: string,\r\n  requestFn: () => Promise<Response>,\r\n  context: {\r\n    requestId?: string;\r\n    apiKeyId?: string;\r\n    endpointId?: string;\r\n    targetUrl?: string;\r\n  }\r\n): Promise<T> {\r\n  const startTime = Date.now();\r\n  const logContext: LogContext = {\r\n    requestId: context.requestId,\r\n    apiKeyId: context.apiKeyId,\r\n    endpoint: context.endpointId,\r\n    cdpStatus: 'pending',\r\n  };\r\n  \r\n  try {\r\n    logger.debug({ ...logContext, operation, targetUrl: context.targetUrl }, `CDP call: ${operation}`);\r\n    \r\n    const response = await requestFn();\r\n    const duration = Date.now() - startTime;\r\n    \r\n    // Extract response body safely\r\n    let responseBody: any = null;\r\n    let responseText = '';\r\n    try {\r\n      responseText = await response.text();\r\n      if (responseText) {\r\n        responseBody = JSON.parse(responseText);\r\n      }\r\n    } catch {\r\n      // Response might not be JSON, that's okay\r\n      responseBody = responseText;\r\n    }\r\n    \r\n    // Check if response is successful\r\n    if (!response.ok) {\r\n      const errorCode = normalizeErrorCode(response.status);\r\n      const cdpErrorId = responseBody?.error?.id || responseBody?.errorId || response.headers.get('x-request-id');\r\n      const errorMessage = responseBody?.error?.message || responseBody?.message || `CDP API error: ${response.statusText}`;\r\n      \r\n      const error = new CDPError(\r\n        errorCode,\r\n        errorMessage,\r\n        response.status,\r\n        cdpErrorId,\r\n        responseBody\r\n      );\r\n      \r\n      // Log structured error\r\n      logger.error({\r\n        ...logContext,\r\n        operation,\r\n        targetUrl: context.targetUrl,\r\n        errorCode: error.code,\r\n        cdpErrorId: error.cdpErrorId,\r\n        statusCode: response.status,\r\n        durationMs: duration,\r\n        responseExcerpt: extractSafeResponseExcerpt(responseBody),\r\n      }, `CDP call failed: ${operation}`);\r\n      \r\n      throw error;\r\n    }\r\n    \r\n    // Log successful call\r\n    logger.info({\r\n      ...logContext,\r\n      operation,\r\n      targetUrl: context.targetUrl,\r\n      cdpStatus: 'success',\r\n      statusCode: response.status,\r\n      durationMs: duration,\r\n    }, `CDP call succeeded: ${operation}`);\r\n    \r\n    return responseBody as T;\r\n  } catch (error) {\r\n    const duration = Date.now() - startTime;\r\n    \r\n    // Handle network errors\r\n    if (error instanceof TypeError && error.message.includes('fetch')) {\r\n      const cdpError = new CDPError(\r\n        CDPErrorCode.CDP_NETWORK_ERROR,\r\n        `Network error calling CDP: ${error.message}`,\r\n        undefined,\r\n        undefined,\r\n        undefined\r\n      );\r\n      \r\n      logger.error({\r\n        ...logContext,\r\n        operation,\r\n        targetUrl: context.targetUrl,\r\n        errorCode: cdpError.code,\r\n        durationMs: duration,\r\n        error: error,\r\n      }, `CDP network error: ${operation}`);\r\n      \r\n      throw cdpError;\r\n    }\r\n    \r\n    // Handle timeout errors\r\n    if (error instanceof Error && (error.message.includes('timeout') || error.message.includes('aborted'))) {\r\n      const cdpError = new CDPError(\r\n        CDPErrorCode.CDP_TIMEOUT,\r\n        `CDP call timed out: ${operation}`,\r\n        undefined,\r\n        undefined,\r\n        undefined\r\n      );\r\n      \r\n      logger.error({\r\n        ...logContext,\r\n        operation,\r\n        targetUrl: context.targetUrl,\r\n        errorCode: cdpError.code,\r\n        durationMs: duration,\r\n        error: error,\r\n      }, `CDP timeout: ${operation}`);\r\n      \r\n      throw cdpError;\r\n    }\r\n    \r\n    // Re-throw CDPError as-is\r\n    if (error instanceof CDPError) {\r\n      throw error;\r\n    }\r\n    \r\n    // Wrap unknown errors\r\n    const cdpError = new CDPError(\r\n      CDPErrorCode.CDP_UNKNOWN_ERROR,\r\n      `Unknown error calling CDP: ${error instanceof Error ? error.message : String(error)}`,\r\n      undefined,\r\n      undefined,\r\n      undefined\r\n    );\r\n    \r\n    logger.error({\r\n      ...logContext,\r\n      operation,\r\n      targetUrl: context.targetUrl,\r\n      errorCode: cdpError.code,\r\n      durationMs: duration,\r\n      error: error,\r\n    }, `CDP unknown error: ${operation}`);\r\n    \r\n    throw cdpError;\r\n  }\r\n}\r\n\r\n/**\r\n * Helper to add request ID to CDP API calls\r\n */\r\nexport function addRequestIdToCDPHeaders(\r\n  headers: HeadersInit,\r\n  requestId?: string\r\n): HeadersInit {\r\n  const headersObj = headers instanceof Headers ? Object.fromEntries(headers.entries()) : \r\n                     Array.isArray(headers) ? Object.fromEntries(headers) : \r\n                     headers;\r\n  \r\n  if (requestId) {\r\n    return {\r\n      ...headersObj,\r\n      'x-request-id': requestId,\r\n    };\r\n  }\r\n  \r\n  return headersObj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3592, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/cdp-facilitator.ts"],"sourcesContent":["import { getCDPJWTGenerator } from './cdp-jwt';\r\nimport { verifyPaymentSignature, validatePaymentAuthorization, type PaymentAuthorization } from './signature-verifier';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { toAtomicUnits, normalizeNetwork } from './amount-utils';\r\nimport { callCDP, addRequestIdToCDPHeaders, CDPError, CDPErrorCode } from '@/lib/cdp-client';\r\n\r\nconst logger = createLogger({ component: 'CDPFacilitator' });\r\n\r\n/**\r\n * CDP (Coinbase Developer Platform) Facilitator\r\n * \r\n * Primary facilitator for x402 payment verification on Base network.\r\n * Handles JWT authentication, payment verification, and compliance checks.\r\n */\r\n\r\nexport interface CDPPaymentPayload {\r\n  x402Version: number;\r\n  scheme: 'x402';\r\n  network: string;\r\n  payload: {\r\n    signature: string;\r\n    authorization: PaymentAuthorization;\r\n  };\r\n}\r\n\r\nexport interface X402PaymentRequirements {\r\n  scheme: string;\r\n  network: string;\r\n  to?: string; // Internal field name\r\n  payTo?: string; // CDP field name\r\n  value?: string; // Internal field name\r\n  maxAmountRequired?: string; // CDP field name\r\n  resource: string;\r\n  validAfter?: string; // Validity window start\r\n  validBefore?: string; // Validity window end\r\n  asset: string;\r\n  // Optional fields\r\n  description?: string;\r\n  mimeType?: string;\r\n  maxTimeoutSeconds?: number;\r\n  outputSchema?: any; // Optional JSON schema\r\n  extra?: any; // Optional scheme-specific data\r\n  payer?: string; // Optional: payer address (internal only)\r\n}\r\n\r\n// CDP Verify Request Body - matches CDP x402 v2 API schema exactly\r\n// Per: https://docs.cdp.coinbase.com/api-reference/v2/rest-api/x402-facilitator/verify-a-payment\r\n// This type matches the v2 VerifyRequest schema exactly - no v1 fields or schemas\r\nexport interface CDPVerifyRequestBody {\r\n  x402Version: 2; // CDP x402 v2 - top level (must be 2, not 1)\r\n  paymentPayload: {\r\n    x402Version: 2; // CDP x402 v2 - inside paymentPayload (must match top level, must be 2)\r\n    scheme: string; // 'exact' for EVM\r\n    network: string; // 'base', 'ethereum', etc.\r\n    payload: {\r\n      signature: string; // EIP-712 signature\r\n      authorization: {\r\n        from: string; // EVM address\r\n        to: string; // EVM address\r\n        value: string; // Amount in atomic units\r\n        validAfter: string; // Unix timestamp\r\n        validBefore: string; // Unix timestamp\r\n        nonce: string; // Hex-encoded nonce\r\n      };\r\n    };\r\n  };\r\n  paymentRequirements: {\r\n    scheme: string; // 'exact' for EVM\r\n    network: string; // 'base', 'ethereum', etc.\r\n    payTo: string; // CDP v2 field name (destination address)\r\n    // CDP x402 v2: maxAmountRequired must be a string of atomic units (integer, not decimal)\r\n    // Example: \"1000000\" for 1 USDC (6 decimals), not \"1.0\" or 1000000\r\n    // Must match authorization.value exactly\r\n    maxAmountRequired: string; // Amount in atomic units as string (e.g., \"1000000\" for 1 USDC)\r\n    resource: string; // URI of the resource\r\n    description: string; // Description of the resource\r\n    mimeType: string; // MIME type of the resource response\r\n    maxTimeoutSeconds: number; // Maximum time for server to respond\r\n    asset: string; // Asset contract address (e.g., USDC)\r\n    validAfter?: string; // Optional: validity window start\r\n    validBefore?: string; // Optional: validity window end\r\n    outputSchema?: any; // Optional: JSON schema describing resource output\r\n    extra?: any; // Optional: scheme-specific payment information\r\n  };\r\n}\r\n\r\nexport interface CDPVerifyRequest {\r\n  payment: string; // Payment header or transaction hash\r\n  paymentPayload: CDPPaymentPayload;\r\n  paymentRequirements?: X402PaymentRequirements; // Optional - will be constructed if not provided\r\n}\r\n\r\nexport interface CDPVerifyResponse {\r\n  success: boolean;\r\n  valid: boolean;\r\n  transactionHash?: string;\r\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\r\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\r\n  error?: string;\r\n  errorDetails?: {\r\n    error: string;\r\n    cdpResponse?: any;\r\n    httpStatus?: number;\r\n  };\r\n}\r\n\r\nexport class CDPFacilitator {\r\n  private apiKeyId: string;\r\n  private facilitatorUrl: string;\r\n  private jwtGenerator: ReturnType<typeof getCDPJWTGenerator>;\r\n  private cachedToken: string | null = null;\r\n  private tokenExpiry: number = 0;\r\n\r\n  constructor(\r\n    apiKeyId: string,\r\n    facilitatorUrl: string = 'https://api.cdp.coinbase.com/platform/v2/x402'\r\n  ) {\r\n    this.apiKeyId = apiKeyId;\r\n    this.facilitatorUrl = facilitatorUrl;\r\n    this.jwtGenerator = getCDPJWTGenerator();\r\n  }\r\n\r\n  /**\r\n   * Generate JWT token for CDP API authentication\r\n   * Uses cached token if still valid, otherwise generates new one\r\n   * \r\n   * @param requestMethod - HTTP method for REST calls (optional)\r\n   * @param requestPath - Request path for REST calls (optional)\r\n   */\r\n  private async generateJWT(\r\n    requestMethod: string | null = null,\r\n    requestPath: string | null = null\r\n  ): Promise<string> {\r\n    const now = Date.now();\r\n    \r\n    // For REST calls with specific method/path, don't cache (must be request-specific)\r\n    if (requestMethod && requestPath) {\r\n      const url = new URL(this.facilitatorUrl);\r\n      return await this.jwtGenerator.generateToken(\r\n        requestMethod,\r\n        url.host,\r\n        requestPath\r\n      );\r\n    }\r\n    \r\n    // Return cached token if still valid (with 10 second buffer) - for generic auth\r\n    if (this.cachedToken && this.tokenExpiry > now + 10000) {\r\n      return this.cachedToken;\r\n    }\r\n\r\n    // Generate new token for generic facilitator auth\r\n    const token = await this.jwtGenerator.generateToken(null, null, null);\r\n    this.cachedToken = token;\r\n    this.tokenExpiry = now + 120000; // 2 minutes expiry\r\n\r\n    return token;\r\n  }\r\n\r\n  /**\r\n   * Call CDP /verify endpoint with retry logic for transient errors\r\n   * \r\n   * Retries on: 429 (rate limit), 500-504 (server errors), network timeouts\r\n   * Does NOT retry on: 400 (invalid_request), 401 (unauthorized), other 4xx\r\n   * \r\n   * Returns normalized result with success, valid, status, errorType, errorMessage, etc.\r\n   */\r\n  private async callCdpVerifyWithRetries(\r\n    verifyBody: any,\r\n    isProbe: boolean,\r\n    headers: HeadersInit\r\n  ): Promise<{\r\n    success: boolean;\r\n    valid: boolean;\r\n    status: number;\r\n    errorType?: string;\r\n    errorMessage?: string;\r\n    isRateLimited: boolean;\r\n    isNetworkError: boolean;\r\n    latencyMs: number;\r\n    data?: any;\r\n  }> {\r\n    const url = new URL('https://api.cdp.coinbase.com/platform/v2/x402/verify');\r\n    const maxRetries = 3;\r\n    const retryableStatuses = [429, 500, 502, 503, 504];\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const response = await fetch(url.toString(), {\r\n          method: 'POST',\r\n          headers,\r\n          body: JSON.stringify(verifyBody),\r\n          signal: AbortSignal.timeout(10000), // 10 second timeout\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data = text ? JSON.parse(text) : {};\r\n        const latencyMs = Date.now() - startTime;\r\n\r\n        // Success case\r\n        if (response.ok && data.isValid) {\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            status: response.status,\r\n            isRateLimited: false,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Check if retryable error\r\n        const isRetryable = retryableStatuses.includes(response.status);\r\n        const isRateLimit = response.status === 429;\r\n        \r\n        // If not retryable or last attempt, return error\r\n        if (!isRetryable || attempt === maxRetries - 1) {\r\n          const errorMessage = data.errorMessage || data.error || data.invalidReason || `HTTP ${response.status}`;\r\n          const errorType = data.errorType || data.code || (isRateLimit ? 'rate_limit' : 'CDP_VERIFY_FAILED');\r\n          \r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            status: response.status,\r\n            errorType,\r\n            errorMessage,\r\n            isRateLimited: isRateLimit,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Retry with exponential backoff\r\n        const delay = 100 * Math.pow(2, attempt); // 100ms, 200ms, 400ms\r\n        logger.info({\r\n          component: 'CDPFacilitator',\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          status: response.status,\r\n          delay,\r\n          isProbe,\r\n          msg: 'Retrying CDP verification after transient error',\r\n        });\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        \r\n      } catch (error: any) {\r\n        const latencyMs = Date.now() - startTime;\r\n        const isTimeout = error?.name === 'AbortError' || error?.message?.toLowerCase().includes('timeout');\r\n        const isNetworkError = error?.message?.toLowerCase().includes('network') || \r\n                              error?.message?.toLowerCase().includes('fetch') ||\r\n                              error?.message?.toLowerCase().includes('econnrefused');\r\n        \r\n        // If network error and not last attempt, retry\r\n        if ((isTimeout || isNetworkError) && attempt < maxRetries - 1) {\r\n          const delay = 100 * Math.pow(2, attempt);\r\n          logger.info({\r\n            component: 'CDPFacilitator',\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error?.message,\r\n            delay,\r\n            isProbe,\r\n            msg: 'Retrying CDP verification after network error',\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n        \r\n        // Last attempt or non-network error\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          status: 0,\r\n          errorType: isTimeout ? 'timeout' : isNetworkError ? 'network_error' : 'CDP_VERIFY_FAILED',\r\n          errorMessage: error?.message || 'CDP verification failed',\r\n          isRateLimited: false,\r\n          isNetworkError: isTimeout || isNetworkError,\r\n          latencyMs,\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Should never reach here, but TypeScript needs a return\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      status: 0,\r\n      errorType: 'CDP_VERIFY_FAILED',\r\n      errorMessage: 'Max retries exceeded',\r\n      isRateLimited: false,\r\n      isNetworkError: false,\r\n      latencyMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify payment with CDP facilitator API\r\n   * \r\n   * This method:\r\n   * 1. Validates payment authorization fields locally\r\n   * 2. Optionally verifies EIP-712 signature locally\r\n   * 3. Calls CDP API for on-chain verification with retry logic\r\n   * 4. Returns verification result with KYT/OFAC status\r\n   */\r\n  async verifyPayment(request: CDPVerifyRequest): Promise<CDPVerifyResponse> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // Step 1: Parse payment header to extract paymentPayload (build from decoded JSON)\r\n      // For probe mode, we need to decode the base64 payment header and build the payload\r\n      let paymentPayload: CDPPaymentPayload;\r\n      let parsedPayment: any;\r\n      \r\n      try {\r\n        const { parseX402Header } = await import('./payment-header-parser');\r\n        const parseResult = parseX402Header(request.payment);\r\n        \r\n        if (parseResult.valid && parseResult.parsed) {\r\n          parsedPayment = parseResult.parsed;\r\n          // Build paymentPayload from decoded payment JSON\r\n          // Note: parsedPayment.network might be legacy format (e.g., \"8453\" or \"base\")\r\n          // CDP requires CAIP-2 format (e.g., \"eip155:8453\"), so normalize it\r\n          const parsedNetwork = parsedPayment.network || request.paymentPayload.network;\r\n          const normalizedParsedNetwork = normalizeNetwork(parsedNetwork);\r\n          \r\n          paymentPayload = {\r\n            x402Version: 1, // CDP x402 v1 (per user instruction, use 1 unless docs specify 2)\r\n            scheme: 'x402' as const,\r\n            network: normalizedParsedNetwork, // Use normalized CAIP-2 format\r\n            payload: {\r\n              signature: parsedPayment.signature,\r\n              authorization: parsedPayment.authorization,\r\n            },\r\n          };\r\n        } else {\r\n          // Fallback to request.paymentPayload if parsing fails\r\n          paymentPayload = request.paymentPayload;\r\n        }\r\n      } catch (parseError) {\r\n        logger.warn({ error: parseError }, 'Failed to parse payment header, using request.paymentPayload');\r\n        paymentPayload = request.paymentPayload;\r\n      }\r\n      \r\n      // Step 2: Validate payment authorization fields locally\r\n      const authValidation = validatePaymentAuthorization(paymentPayload.payload.authorization);\r\n      if (!authValidation.valid) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: authValidation.error || 'Invalid payment authorization',\r\n        };\r\n      }\r\n\r\n      // Step 3: Extract authorization for use throughout\r\n      const auth = paymentPayload.payload.authorization;\r\n      const signature = paymentPayload.payload.signature;\r\n\r\n      // Step 4: Detect probe mode and skip local signature verification for probes\r\n      // Probe mode is detected by checking if signature is all zeros (dummy signature)\r\n      const isDummySignature = signature === '0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000' ||\r\n                               signature === '0x' + '0'.repeat(128);\r\n      const isProbe = isDummySignature || auth.from === '0x0000000000000000000000000000000000000000';\r\n\r\n      // Step 4: Optionally verify signature locally (additional security layer)\r\n      // Note: CDP will also verify, but local check catches issues early\r\n      // Skip local verification for probe mode to avoid viem errors with dummy signatures\r\n      if (isProbe) {\r\n        logger.warn({\r\n          component: 'CDPFacilitator',\r\n          isProbe: true,\r\n          msg: 'Skipping local signature verification for probe payload',\r\n        });\r\n      } else {\r\n        try {\r\n          const signatureValid = await verifyPaymentSignature(\r\n            signature,\r\n            auth,\r\n            auth.from as `0x${string}`\r\n          );\r\n          if (!signatureValid) {\r\n            logger.warn('Local signature verification failed, but continuing to CDP');\r\n            // Don't fail here - let CDP make the final decision\r\n          }\r\n        } catch (sigError) {\r\n          logger.warn({ error: sigError }, 'Signature verification error, continuing to CDP');\r\n          // Continue to CDP verification\r\n        }\r\n      }\r\n\r\n      // Step 5: Use paymentRequirements from request (must be provided by caller)\r\n      // CDP requires paymentRequirements that match the challenge\r\n      // For probe mode, build minimal valid paymentRequirements if missing\r\n      let finalPaymentRequirements = request.paymentRequirements;\r\n      \r\n      if (!finalPaymentRequirements || (!finalPaymentRequirements.to && !(finalPaymentRequirements as any)?.payTo)) {\r\n        // If in probe mode, build minimal valid paymentRequirements\r\n        if (isProbe) {\r\n          logger.info({\r\n            component: 'CDPFacilitator',\r\n            isProbe: true,\r\n            msg: 'Building minimal paymentRequirements for probe mode',\r\n          });\r\n          \r\n          // Extract network from paymentPayload (built from decoded payment)\r\n          // paymentPayload.network should already be in CAIP-2 format from normalization above\r\n          // If not, normalize it to ensure CAIP-2 format\r\n          const network = normalizeNetwork(paymentPayload.network || 'eip155:8453');\r\n          \r\n          // USDC contract address on Base\r\n          const USDC_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';\r\n          // Test receiver address for probes\r\n          const PROBE_RECEIVER = '0x0000000000000000000000000000000000000001';\r\n          \r\n          const now = Math.floor(Date.now() / 1000);\r\n          \r\n          // Build minimal valid paymentRequirements for probe\r\n          // CDP requires 'exact' scheme for EVM fixed-amount flows\r\n          // CDP requires CAIP-2 format (e.g., \"eip155:8453\") for network\r\n          finalPaymentRequirements = {\r\n            scheme: 'exact', // CDP expects 'exact' for EVM, not 'x402'\r\n            network: network, // Use CAIP-2 format (e.g., \"eip155:8453\")\r\n            to: PROBE_RECEIVER,\r\n            payTo: PROBE_RECEIVER,\r\n            value: '1000000', // 1 USDC in atomic units (must match authorization.value)\r\n            maxAmountRequired: '1000000', // 1 USDC in atomic units\r\n            resource: `https://probe.nexflow.dev/health/cdp/${network}/USDC`,\r\n            asset: USDC_BASE,\r\n            description: 'Health probe for CDP',\r\n            mimeType: 'application/json',\r\n            validAfter: now.toString(),\r\n            validBefore: (now + 300).toString(), // 5 minutes validity\r\n            maxTimeoutSeconds: 300,\r\n            // EIP-712 domain info required for EVM networks (USDC on Base)\r\n            extra: {\r\n              name: 'USD Coin',\r\n              version: '2',\r\n            },\r\n          };\r\n          \r\n          logger.info({\r\n            component: 'CDPFacilitator',\r\n            isProbe: true,\r\n            hasPaymentRequirements: true,\r\n            network: network, // CAIP-2 format\r\n            asset: USDC_BASE,\r\n            msg: 'Built probe paymentRequirements',\r\n          });\r\n        } else {\r\n          // Not probe mode and missing paymentRequirements - error\r\n          logger.error({\r\n            hasPaymentRequirements: !!request.paymentRequirements,\r\n            paymentRequirements: request.paymentRequirements,\r\n            isProbe: false,\r\n          }, 'Missing paymentRequirements');\r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            error: 'paymentRequirements must be provided for CDP verification',\r\n          };\r\n        }\r\n      }\r\n      // Normalize paymentRequirements to CDP's expected format\r\n      // CDP expects: scheme, network, to, value, resource, validAfter, validBefore, asset\r\n      // Remove any fields that CDP doesn't expect (payer, maxTimeoutSeconds, description, mimeType might be optional)\r\n      // Ensure network is in CAIP-2 format (CDP requires this)\r\n      const paymentRequirementsNetwork = normalizeNetwork(finalPaymentRequirements?.network || paymentPayload.network || 'eip155:8453');\r\n      const paymentRequirements: any = {\r\n        scheme: finalPaymentRequirements?.scheme || 'exact',\r\n        network: paymentRequirementsNetwork, // CAIP-2 format (e.g., \"eip155:8453\")\r\n        // Convert legacy field names to CDP format\r\n        to: finalPaymentRequirements?.to || (finalPaymentRequirements as any)?.payTo || auth.to,\r\n        value: finalPaymentRequirements?.value || (finalPaymentRequirements as any)?.maxAmountRequired || auth.value,\r\n        // Ensure validity window is included\r\n        validAfter: finalPaymentRequirements?.validAfter || auth.validAfter,\r\n        validBefore: finalPaymentRequirements?.validBefore || auth.validBefore,\r\n        // Required fields - ensure they exist\r\n        resource: finalPaymentRequirements?.resource,\r\n        asset: finalPaymentRequirements?.asset,\r\n        // Optional fields (only include if present)\r\n        ...(finalPaymentRequirements?.description && { description: finalPaymentRequirements.description }),\r\n        ...(finalPaymentRequirements?.mimeType && { mimeType: finalPaymentRequirements.mimeType }),\r\n        ...((finalPaymentRequirements as any)?.maxTimeoutSeconds && { maxTimeoutSeconds: (finalPaymentRequirements as any).maxTimeoutSeconds }),\r\n        // EIP-712 domain info required for EVM signature verification\r\n        ...((finalPaymentRequirements as any)?.extra && { extra: (finalPaymentRequirements as any).extra }),\r\n      };\r\n      \r\n      // Validate that required fields are present\r\n      // In probe mode, we already built complete requirements, so this should not fail\r\n      if (!paymentRequirements.resource || !paymentRequirements.asset) {\r\n        // If in probe mode and still missing fields, build them\r\n        if (isProbe) {\r\n          // Normalize network to CAIP-2 format\r\n          const network = normalizeNetwork(paymentPayload.network || 'eip155:8453');\r\n          const USDC_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';\r\n          \r\n          if (!paymentRequirements.resource) {\r\n            paymentRequirements.resource = `https://probe.nexflow.dev/health/cdp/${network}/USDC`;\r\n          }\r\n          if (!paymentRequirements.asset) {\r\n            paymentRequirements.asset = USDC_BASE;\r\n          }\r\n          // Ensure network is in CAIP-2 format\r\n          if (!paymentRequirements.network || !paymentRequirements.network.includes(':')) {\r\n            paymentRequirements.network = network;\r\n          }\r\n          \r\n          logger.info({\r\n            component: 'CDPFacilitator',\r\n            isProbe: true,\r\n            msg: 'Completed missing resource/asset fields for probe mode',\r\n          });\r\n        } else {\r\n          // Not probe mode - error\r\n          logger.error({\r\n            hasResource: !!paymentRequirements.resource,\r\n            hasAsset: !!paymentRequirements.asset,\r\n            paymentRequirements: request.paymentRequirements,\r\n            isProbe: false,\r\n          }, 'Missing required paymentRequirements fields (resource or asset)');\r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            error: 'paymentRequirements must include resource and asset',\r\n          };\r\n        }\r\n      }\r\n\r\n      // Step 5: Parse payment header to check for transaction hash\r\n      // CDP may require transaction hash for on-chain verification\r\n      let txHash: string | undefined;\r\n      try {\r\n        const { parseX402Header } = await import('./payment-header-parser');\r\n        const parsed = parseX402Header(request.payment);\r\n        if (parsed.valid && parsed.parsed?.txHash) {\r\n          txHash = parsed.parsed.txHash;\r\n          logger.debug({ txHash }, 'Found transaction hash in payment header');\r\n        }\r\n      } catch (error) {\r\n        logger.warn({ error }, 'Failed to parse payment header for txHash');\r\n      }\r\n\r\n      // Step 6: Construct request body matching CDP x402 v2 schema exactly\r\n      // CDP v2 schema per docs: https://docs.cdp.coinbase.com/api-reference/v2/rest-api/x402-facilitator/verify-a-payment\r\n      // \r\n      // CDP Requirements for USDC on Base:\r\n      // - 1 USDC = 1,000,000 atomic units (6 decimals)\r\n      // - network must be \"eip155:8453\" (not \"base\")\r\n      // - value and maxAmountRequired must be strings of atomic units\r\n      \r\n      // Normalize network to CAIP-2 format (e.g., \"base\" -> \"eip155:8453\")\r\n      const normalizedNetwork = normalizeNetwork(paymentPayload.network || paymentRequirements.network || 'base');\r\n      \r\n      // Convert authorization.value to atomic units if needed\r\n      // auth.value might already be in atomic units (string), or might be human-readable\r\n      // For now, assume it's already in atomic units if it's a large number string\r\n      // If it looks like a human amount (small number), convert it\r\n      let authorizationValue: string;\r\n      const authValueStr = String(auth.value);\r\n      const authValueNum = parseFloat(authValueStr);\r\n      \r\n      // If the value is less than 1000, assume it's human-readable (e.g., \"1\" = 1 USDC)\r\n      // Otherwise, assume it's already in atomic units\r\n      if (authValueNum < 1000 && authValueNum > 0) {\r\n        // Convert human amount to atomic units\r\n        authorizationValue = toAtomicUnits(authValueStr, 6);\r\n        logger.debug({ \r\n          original: authValueStr, \r\n          converted: authorizationValue \r\n        }, 'Converted human amount to atomic units');\r\n      } else {\r\n        // Already in atomic units, ensure it's a string\r\n        authorizationValue = authValueStr;\r\n      }\r\n      \r\n      // Convert maxAmountRequired to atomic units if needed\r\n      const maxAmountRaw = paymentRequirements.value || (paymentRequirements as any).maxAmountRequired || authorizationValue;\r\n      const maxAmountStr = String(maxAmountRaw);\r\n      const maxAmountNum = parseFloat(maxAmountStr);\r\n      \r\n      let maxAmountRequired: string;\r\n      if (maxAmountNum < 1000 && maxAmountNum > 0) {\r\n        // Convert human amount to atomic units\r\n        maxAmountRequired = toAtomicUnits(maxAmountStr, 6);\r\n        logger.debug({ \r\n          original: maxAmountStr, \r\n          converted: maxAmountRequired \r\n        }, 'Converted maxAmountRequired to atomic units');\r\n      } else {\r\n        // Already in atomic units, ensure it's a string\r\n        maxAmountRequired = maxAmountStr;\r\n      }\r\n      \r\n      // Ensure both are strings and digit-only (atomic units)\r\n      if (!/^[0-9]+$/.test(authorizationValue) || !/^[0-9]+$/.test(maxAmountRequired)) {\r\n        const error = new Error('Amount fields must be digit-only strings in atomic units');\r\n        logger.error({\r\n          authorizationValue,\r\n          maxAmountRequired,\r\n          authorizationValueType: typeof authorizationValue,\r\n          maxAmountRequiredType: typeof maxAmountRequired,\r\n        }, 'Amount validation failed');\r\n        throw error;\r\n      }\r\n      \r\n      // Log the final values being sent\r\n      logger.debug({\r\n        network: normalizedNetwork,\r\n        authorizationValue,\r\n        maxAmountRequired,\r\n        payTo: paymentRequirements.to || (paymentRequirements as any).payTo,\r\n      }, 'CDP verify request payload (amounts in atomic units)');\r\n      \r\n      // Build paymentRequirements object matching CDP's x402 /verify schema\r\n      // CDP expects: scheme, network, payTo, maxAmountRequired, resource, asset, description, mimeType, maxTimeoutSeconds\r\n      // For EVM networks, scheme should be 'exact', network can be CAIP-2 format (eip155:8453)\r\n      const paymentRequirementsBody: {\r\n        scheme: string;\r\n        network: string;\r\n        payTo: string;\r\n        maxAmountRequired: string;\r\n        resource: string;\r\n        asset: string;\r\n        description: string;\r\n        mimeType: string;\r\n        maxTimeoutSeconds: number;\r\n        validAfter?: string;\r\n        validBefore?: string;\r\n        outputSchema?: any;\r\n        extra?: any;\r\n      } = {\r\n        scheme: paymentRequirements.scheme || 'exact', // 'exact' for EVM fixed-amount flows\r\n        network: normalizedNetwork, // CAIP-2 format: \"eip155:8453\" (CDP accepts this)\r\n        payTo: paymentRequirements.to || (paymentRequirements as any).payTo || '',\r\n        maxAmountRequired: maxAmountRequired, // String of atomic units (e.g., \"1000000\" for 1 USDC)\r\n        resource: paymentRequirements.resource || '',\r\n        asset: paymentRequirements.asset || '',\r\n        description: paymentRequirements.description || 'x402 Payment Verification',\r\n        mimeType: paymentRequirements.mimeType || 'application/json',\r\n        maxTimeoutSeconds: (paymentRequirements as any).maxTimeoutSeconds || 300,\r\n      };\r\n      \r\n      // Add optional fields only if they exist\r\n      if (paymentRequirements.validAfter) {\r\n        paymentRequirementsBody.validAfter = paymentRequirements.validAfter;\r\n      }\r\n      if (paymentRequirements.validBefore) {\r\n        paymentRequirementsBody.validBefore = paymentRequirements.validBefore;\r\n      }\r\n      if ((paymentRequirements as any).outputSchema) {\r\n        paymentRequirementsBody.outputSchema = (paymentRequirements as any).outputSchema;\r\n      }\r\n      if ((paymentRequirements as any).extra) {\r\n        paymentRequirementsBody.extra = (paymentRequirements as any).extra;\r\n      }\r\n\r\n      // Parse payment header to extract the payment payload\r\n      let paymentHeaderString = request.payment;\r\n      if (paymentHeaderString.startsWith('x402 ')) {\r\n        paymentHeaderString = paymentHeaderString.slice(5);\r\n      }\r\n      \r\n      // Decode and parse the payment header\r\n      let parsedPaymentPayload: any;\r\n      try {\r\n        const decoded = Buffer.from(paymentHeaderString, 'base64').toString('utf-8');\r\n        parsedPaymentPayload = JSON.parse(decoded);\r\n      } catch (parseError) {\r\n        logger.error({ error: parseError }, 'Failed to parse payment header for CDP request');\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: 'Invalid payment header format',\r\n        };\r\n      }\r\n      \r\n      // Convert CAIP-2 network (eip155:8453) to legacy format (base) for CDP\r\n      const legacyNetworkMap: Record<string, string> = {\r\n        'eip155:8453': 'base',\r\n        'eip155:84532': 'base-sepolia',\r\n        'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp': 'solana',\r\n        'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1': 'solana-devnet',\r\n      };\r\n      const legacyNetwork = legacyNetworkMap[normalizedNetwork] || normalizedNetwork.replace('eip155:', '');\r\n      \r\n      // Build request body matching CDP's x402 /verify schema\r\n      // CDP expects legacy network format ('base', not 'eip155:8453')\r\n      const verifyBody = {\r\n        x402Version: 1, // CDP only supports version 1\r\n        paymentPayload: {\r\n          x402Version: 1,\r\n          scheme: 'exact' as const,\r\n          network: legacyNetwork, // CDP expects legacy format ('base')\r\n          payload: {\r\n            signature: parsedPaymentPayload.signature,\r\n            authorization: parsedPaymentPayload.authorization,\r\n          },\r\n        },\r\n        paymentRequirements: {\r\n          scheme: paymentRequirementsBody.scheme || 'exact',\r\n          network: legacyNetwork, // CDP expects legacy format ('base')\r\n          // CDP expects 'maxAmountRequired' for the amount field\r\n          maxAmountRequired: paymentRequirementsBody.maxAmountRequired || paymentRequirementsBody.amount,\r\n          resource: paymentRequirementsBody.resource,\r\n          description: paymentRequirementsBody.description || 'x402 payment verification',\r\n          mimeType: paymentRequirementsBody.mimeType || 'application/json',\r\n          // CDP expects 'payTo' for the recipient address\r\n          payTo: paymentRequirementsBody.payTo || paymentRequirementsBody.recipient,\r\n          maxTimeoutSeconds: paymentRequirementsBody.maxTimeoutSeconds || 300,\r\n          // CDP expects asset contract address, not symbol\r\n          asset: paymentRequirementsBody.asset,\r\n          // EIP-712 domain info required for EVM signature verification\r\n          ...(paymentRequirementsBody.extra && { extra: paymentRequirementsBody.extra }),\r\n        },\r\n      };\r\n      \r\n      // Log request details before sending\r\n      logger.info({\r\n        component: \"CDPFacilitator\",\r\n        isProbe,\r\n        network: paymentRequirementsBody.network,\r\n        asset: paymentRequirementsBody.asset,\r\n        hasPaymentHeader: typeof paymentHeaderString === \"string\" && paymentHeaderString.length > 0,\r\n        paymentHeaderPreview: paymentHeaderString.slice(0, 60),\r\n        msg: \"Sending CDP /verify request\"\r\n      });\r\n      \r\n      // DEBUG: Log full payload for troubleshooting CDP rejection\r\n      logger.info({\r\n        component: \"CDPFacilitator\",\r\n        debug: true,\r\n        fullPaymentPayload: {\r\n          x402Version: verifyBody.paymentPayload.x402Version,\r\n          scheme: verifyBody.paymentPayload.scheme,\r\n          network: verifyBody.paymentPayload.network,\r\n          hasSignature: !!verifyBody.paymentPayload.payload.signature,\r\n          signaturePreview: verifyBody.paymentPayload.payload.signature?.slice(0, 20),\r\n          authorization: verifyBody.paymentPayload.payload.authorization,\r\n        },\r\n        fullPaymentRequirements: verifyBody.paymentRequirements,\r\n        parsedPayloadKeys: Object.keys(parsedPaymentPayload || {}),\r\n        msg: \"CDP verify request full payload\"\r\n      });\r\n      \r\n      // TODO: CDP Support Mode - Add optional enhanced logging for non-production\r\n      // When CDP_SUPPORT_MODE=true, log full request/response for debugging with CDP support\r\n      // if (process.env.CDP_SUPPORT_MODE === 'true' && process.env.NODE_ENV !== 'production') {\r\n      //   logger.debug({ fullRequestBody: verifyBody, fullPaymentRequirements: paymentRequirementsBody }, 'CDP Support Mode: Full request details');\r\n      // }\r\n\r\n      // Note: Transaction hash is included in the paymentHeader string itself\r\n      // CDP will extract it from the payment header, so we don't need to add it separately\r\n      if (txHash) {\r\n        logger.debug({ txHash }, 'Transaction hash is included in paymentHeader');\r\n      }\r\n\r\n      // Step 5: Generate JWT token for CDP API\r\n      const url = new URL('https://api.cdp.coinbase.com/platform/v2/x402/verify');\r\n      const token = await this.generateJWT('POST', url.pathname);\r\n\r\n      // Log request details (without sensitive data)\r\n      logger.debug({\r\n        url: url.toString(),\r\n        x402Version: verifyBody.x402Version,\r\n        paymentPayload: {\r\n          x402Version: verifyBody.paymentPayload.x402Version,\r\n          scheme: verifyBody.paymentPayload.scheme,\r\n          network: verifyBody.paymentPayload.network,\r\n          hasSignature: !!verifyBody.paymentPayload.payload.signature,\r\n          hasAuthorization: !!verifyBody.paymentPayload.payload.authorization,\r\n        },\r\n        paymentRequirements: verifyBody.paymentRequirements,\r\n        isProbe: isProbe,\r\n      }, 'Sending verification request to CDP');\r\n\r\n      // Step 6: Call CDP API with retry logic\r\n      // Extract request ID from context if available (passed via verifyPaymentWithRetry)\r\n      const requestId = (request as any).requestId;\r\n      const headers: HeadersInit = {\r\n        'Content-Type': 'application/json',\r\n        'Authorization': `Bearer ${token}`,\r\n        'X-CDP-API-Key': this.apiKeyId,\r\n      };\r\n      \r\n      // Add request ID to CDP call for correlation\r\n      if (requestId) {\r\n        Object.assign(headers, addRequestIdToCDPHeaders(headers, requestId));\r\n      }\r\n      \r\n      // Call CDP /verify with retry logic\r\n      const result = await this.callCdpVerifyWithRetries(\r\n        verifyBody,\r\n        isProbe,\r\n        headers\r\n      );\r\n\r\n      // Log CDP response\r\n      logger.debug({\r\n        status: result.status,\r\n        success: result.success,\r\n        valid: result.valid,\r\n        errorType: result.errorType,\r\n        errorMessage: result.errorMessage,\r\n        isRateLimited: result.isRateLimited,\r\n        isNetworkError: result.isNetworkError,\r\n        latencyMs: result.latencyMs,\r\n      }, 'CDP verification response');\r\n\r\n      // Handle success\r\n      if (result.success && result.valid) {\r\n        logger.info({ latencyMs: result.latencyMs }, 'Payment verified successfully');\r\n        return {\r\n          success: true,\r\n          valid: true,\r\n          transactionHash: undefined, // CDP verify doesn't return transaction hash\r\n          kytStatus: 'passed', // CDP verify doesn't return KYT/OFAC status\r\n          ofacStatus: 'passed',\r\n        };\r\n      } else {\r\n        // Handle error - map CDP errorType/errorMessage to our error classification\r\n        const cdpErrorType = result.errorType || 'CDP_VERIFY_FAILED';\r\n        const cdpErrorMessage = result.errorMessage || 'CDP verification failed';\r\n        \r\n        // Map error types to result/errorCode\r\n        let errorCode = 'facilitator_error';\r\n        if (result.isRateLimited || cdpErrorType === 'rate_limit') {\r\n          errorCode = 'rate_limited';\r\n        } else if (result.isNetworkError) {\r\n          errorCode = 'network_error';\r\n        } else if (cdpErrorType === 'invalid_request' || result.status === 400) {\r\n          errorCode = 'invalid_request';\r\n        } else if (result.status === 401) {\r\n          errorCode = 'unauthorized';\r\n        }\r\n        \r\n        // Log detailed error information including request body for debugging\r\n        logger.error({\r\n          status: result.status,\r\n          errorType: cdpErrorType,\r\n          errorMessage: cdpErrorMessage,\r\n          errorCode,\r\n          isRateLimited: result.isRateLimited,\r\n          isNetworkError: result.isNetworkError,\r\n          cdpResponse: result.data,\r\n          requestBody: {\r\n            x402Version: verifyBody.x402Version,\r\n            paymentPayload: {\r\n              x402Version: verifyBody.paymentPayload.x402Version,\r\n              scheme: verifyBody.paymentPayload.scheme,\r\n              network: verifyBody.paymentPayload.network,\r\n            },\r\n            paymentRequirements: verifyBody.paymentRequirements,\r\n          },\r\n        }, 'Payment verification failed');\r\n        \r\n        // Extract authorization details from the parsed payment header for logging\r\n          let authorizationFrom = 'UNKNOWN';\r\n          let authorizationTo = 'UNKNOWN';\r\n          let transactionHash = 'NOT PROVIDED';\r\n          if (parsedPayment) {\r\n            authorizationFrom = parsedPayment.authorization.from;\r\n            authorizationTo = parsedPayment.authorization.to;\r\n            transactionHash = parsedPayment.txHash || 'NOT PROVIDED';\r\n          }\r\n          \r\n          const errorDetails = {\r\n            error: cdpErrorMessage, // Use CDP's errorMessage\r\n            errorType: cdpErrorType, // Use CDP's errorType\r\n            cdpResponse: result.data,\r\n            httpStatus: result.status,\r\n            errorCode,\r\n            isRateLimited: result.isRateLimited,\r\n            isNetworkError: result.isNetworkError,\r\n            // Include request details for debugging\r\n            requestDetails: {\r\n              scheme: verifyBody.paymentRequirements?.scheme || 'MISSING',\r\n              network: verifyBody.paymentRequirements?.network || 'MISSING',\r\n              payTo: verifyBody.paymentRequirements?.payTo || 'MISSING',\r\n              maxAmountRequired: verifyBody.paymentRequirements?.maxAmountRequired || 'MISSING',\r\n              validAfter: verifyBody.paymentRequirements?.validAfter || 'MISSING',\r\n              validBefore: verifyBody.paymentRequirements?.validBefore || 'MISSING',\r\n              resource: verifyBody.paymentRequirements?.resource || 'MISSING',\r\n              asset: verifyBody.paymentRequirements?.asset || 'MISSING',\r\n              fullPaymentRequirements: verifyBody.paymentRequirements,\r\n              authorizationFrom,\r\n              authorizationTo,\r\n              transactionHash,\r\n            },\r\n          };\r\n\r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            error: cdpErrorMessage, // Use CDP's errorMessage\r\n            errorDetails: {\r\n              ...errorDetails,\r\n              errorType: cdpErrorType, // Include CDP's errorType\r\n            },\r\n            kytStatus: undefined,\r\n            ofacStatus: undefined,\r\n          };\r\n      }\r\n    } catch (error: any) {\r\n      // Handle network errors with enhanced logging\r\n      const errorMessage = error?.message || 'CDP_VERIFY_FAILED';\r\n      const isTimeout = error?.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout');\r\n      const isNetworkError = errorMessage.toLowerCase().includes('network') || \r\n                            errorMessage.toLowerCase().includes('fetch') ||\r\n                            errorMessage.toLowerCase().includes('econnrefused');\r\n      \r\n      logger.error({ \r\n        error,\r\n        errorMessage,\r\n        isTimeout,\r\n        isNetworkError,\r\n        component: 'cdp-facilitator',\r\n        operation: 'verifyPayment',\r\n        requestId: (request as any).requestId,\r\n      }, 'CDP API request error');\r\n      \r\n      const errorDetails = {\r\n        error: errorMessage,\r\n        cdpResponse: undefined,\r\n        httpStatus: 500,\r\n        errorType: isTimeout ? 'timeout' : isNetworkError ? 'network' : 'unknown',\r\n      };\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: errorMessage,\r\n        errorDetails: errorDetails,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify payment with retry logic and exponential backoff\r\n   * \r\n   * Retries on network errors and timeouts, but not on validation failures\r\n   */\r\n  private async verifyPaymentWithRetry(\r\n    request: CDPVerifyRequest,\r\n    maxRetries: number = 3\r\n  ): Promise<CDPVerifyResponse> {\r\n    let lastError: Error | null = null;\r\n\r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const result = await this.verifyPayment(request);\r\n        \r\n        // If verification succeeded, return immediately\r\n        if (result.success && result.valid) {\r\n          return result;\r\n        }\r\n\r\n        // If verification failed due to validation (not network), don't retry\r\n        if (result.error && \r\n            !result.error.includes('timeout') && \r\n            !result.error.includes('network') &&\r\n            !result.error.includes('Unable to reach')) {\r\n          return result;\r\n        }\r\n\r\n        // If blocked by KYT/OFAC, don't retry\r\n        if (result.kytStatus === 'blocked' || result.ofacStatus === 'blocked') {\r\n          return result;\r\n        }\r\n\r\n        lastError = new Error(result.error || 'Verification failed');\r\n      } catch (error) {\r\n        lastError = error instanceof Error ? error : new Error(String(error));\r\n      }\r\n\r\n      // Exponential backoff: 100ms, 200ms, 400ms\r\n      if (attempt < maxRetries - 1) {\r\n        const delay = 100 * Math.pow(2, attempt);\r\n        logger.info({ attempt: attempt + 1, maxRetries, delay }, 'Retrying CDP verification');\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n      }\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      error: lastError?.message || 'Max retries exceeded',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Health check - verify CDP facilitator is accessible\r\n   * \r\n   * Note: CDP may not have a /health endpoint. This is a best-effort check.\r\n   * If it fails, it doesn't necessarily mean CDP is unavailable.\r\n   * \r\n   * IMPORTANT: If the facilitator URL domain doesn't resolve (DNS error),\r\n   * this will return unhealthy, but actual payment verification might\r\n   * still work if it uses a different endpoint.\r\n   */\r\n  async healthCheck(): Promise<{ healthy: boolean; error?: string }> {\r\n    try {\r\n      // For REST API calls, CDP requires request-specific JWT\r\n      // Generate JWT with the actual request details\r\n      const url = new URL(`${this.facilitatorUrl}/health`);\r\n      const token = await this.generateJWT('GET', url.pathname);\r\n      \r\n      const response = await fetch(url.toString(), {\r\n        method: 'GET',\r\n        headers: {\r\n          'Authorization': `Bearer ${token}`,\r\n          'X-CDP-API-Key': this.apiKeyId,\r\n        },\r\n        signal: AbortSignal.timeout(5000), // 5 second timeout\r\n      });\r\n\r\n      if (response.ok) {\r\n        return { healthy: true };\r\n      } else {\r\n        // 401/403 might mean auth is working but endpoint doesn't exist or keys are wrong\r\n        // 404 means endpoint doesn't exist (but auth might be working)\r\n        // For now, we'll consider it healthy if we get any response (not a network error)\r\n        if (response.status === 404) {\r\n          return { \r\n            healthy: true, \r\n            error: 'Health endpoint not found, but CDP is reachable' \r\n          };\r\n        }\r\n        \r\n        // Get error details from response if available\r\n        let errorMsg = `Health check failed: ${response.status} ${response.statusText}`;\r\n        try {\r\n          const errorBody = await response.text();\r\n          if (errorBody) {\r\n            errorMsg += ` - ${errorBody.substring(0, 200)}`;\r\n          }\r\n        } catch {\r\n          // Ignore parsing errors\r\n        }\r\n        \r\n        return { \r\n          healthy: false, \r\n          error: errorMsg\r\n        };\r\n      }\r\n    } catch (error) {\r\n      // Network errors or timeouts indicate CDP is not reachable\r\n      // This includes DNS resolution failures (domain doesn't exist)\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      \r\n      // If it's a DNS/network error, note that payment verification might still work\r\n      if (errorMessage.includes('fetch failed') || \r\n          errorMessage.includes('ENOTFOUND') || \r\n          errorMessage.includes('getaddrinfo')) {\r\n        return {\r\n          healthy: false,\r\n          error: `Facilitator URL not reachable (${errorMessage}). Payment verification may use a different endpoint.`,\r\n        };\r\n      }\r\n      \r\n      return {\r\n        healthy: false,\r\n        error: errorMessage,\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet cdpFacilitator: CDPFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton CDP facilitator instance\r\n */\r\nexport function getCDPFacilitator(): CDPFacilitator {\r\n  if (!cdpFacilitator) {\r\n    const apiKeyId = process.env.CDP_API_KEY_ID;\r\n    const facilitatorUrl = process.env.CDP_FACILITATOR_URL || 'https://api.cdp.coinbase.com/platform/v2/x402';\r\n\r\n    if (!apiKeyId) {\r\n      throw new Error('CDP_API_KEY_ID must be set in environment variables');\r\n    }\r\n\r\n    cdpFacilitator = new CDPFacilitator(apiKeyId, facilitatorUrl);\r\n  }\r\n  return cdpFacilitator;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4475, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/resource-server.ts"],"sourcesContent":["// =============================================================================\r\n// X402 RESOURCE SERVER WITH BAZAAR EXTENSION\r\n// =============================================================================\r\n// Official x402 SDK integration with Bazaar discovery support\r\n// Note: @x402 packages may not be available - this module will handle missing dependencies gracefully\r\n\r\nimport { getCDPFacilitator } from './cdp-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'X402ResourceServer' });\r\n\r\n// Lazy load x402 packages to handle missing dependencies\r\nlet x402ResourceServer: any;\r\nlet HTTPFacilitatorClient: any;\r\nlet bazaarResourceServerExtension: any;\r\nlet registerExactEvmScheme: any;\r\n\r\nasync function loadX402Packages() {\r\n  if (!x402ResourceServer) {\r\n    try {\r\n      const x402Core = await import('@x402/core/server');\r\n      const x402Http = await import('@x402/core/http');\r\n      const x402Bazaar = await import('@x402/extensions/bazaar');\r\n      const x402EVM = await import('@x402/evm/exact/server');\r\n      \r\n      x402ResourceServer = x402Core.x402ResourceServer;\r\n      HTTPFacilitatorClient = x402Http.HTTPFacilitatorClient;\r\n      bazaarResourceServerExtension = x402Bazaar.bazaarResourceServerExtension;\r\n      registerExactEvmScheme = x402EVM.registerExactEvmScheme;\r\n    } catch (error) {\r\n      logger.warn({ error }, 'x402 packages not available - discovery features will be limited');\r\n      throw new Error('x402 packages not installed');\r\n    }\r\n  }\r\n  return { x402ResourceServer, HTTPFacilitatorClient, bazaarResourceServerExtension, registerExactEvmScheme };\r\n}\r\n\r\n/**\r\n * CDP Facilitator Client Adapter\r\n * \r\n * Adapts our custom CDP facilitator to the SDK's HTTPFacilitatorClient interface\r\n * This class is only used when x402 packages are available\r\n */\r\nclass CDPFacilitatorClientAdapter {\r\n  private cdpFacilitator: ReturnType<typeof getCDPFacilitator>;\r\n  private baseClient: any;\r\n\r\n  constructor() {\r\n    // Will be initialized when x402 packages are loaded\r\n    this.cdpFacilitator = getCDPFacilitator();\r\n  }\r\n\r\n  async initialize(HTTPFacilitatorClient: any) {\r\n    // Initialize with CDP facilitator URL (not used directly, but required by base class)\r\n    this.baseClient = new HTTPFacilitatorClient({\r\n      url: process.env.CDP_FACILITATOR_URL || 'https://api.cdp.coinbase.com/platform/v2/x402',\r\n    });\r\n    Object.setPrototypeOf(this, this.baseClient.constructor.prototype);\r\n  }\r\n\r\n  /**\r\n   * Override verify method to use our CDP facilitator\r\n   */\r\n  async verify(payment: string, paymentPayload: any, paymentRequirements?: any): Promise<any> {\r\n    try {\r\n      const result = await this.cdpFacilitator.verifyPaymentWithRetry({\r\n        payment,\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      });\r\n\r\n      if (result.success && result.valid) {\r\n        return {\r\n          isValid: true,\r\n          transactionHash: result.transactionHash,\r\n          kytStatus: result.kytStatus,\r\n          ofacStatus: result.ofacStatus,\r\n        };\r\n      } else {\r\n        return {\r\n          isValid: false,\r\n          invalidReason: result.error,\r\n          errorMessage: result.error,\r\n        };\r\n      }\r\n    } catch (error) {\r\n      logger.error({ error }, 'CDP facilitator verification error');\r\n      return {\r\n        isValid: false,\r\n        invalidReason: error instanceof Error ? error.message : 'Verification failed',\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton resource server instance\r\nlet resourceServer: any | null = null;\r\n\r\n/**\r\n * Get or create the x402 resource server with Bazaar extension\r\n * \r\n * Enhanced to support multi-chain (all EVM chains via Exact scheme)\r\n * Returns null if x402 packages are not available\r\n */\r\nexport async function getX402ResourceServer() {\r\n  try {\r\n    const { x402ResourceServer: X402ResourceServer, HTTPFacilitatorClient: HTTPClient, bazaarResourceServerExtension: bazaarExt, registerExactEvmScheme: registerScheme } = await loadX402Packages();\r\n    \r\n    if (!resourceServer) {\r\n      // Create facilitator client adapter\r\n      const facilitatorClient = new CDPFacilitatorClientAdapter();\r\n      await facilitatorClient.initialize(HTTPClient);\r\n\r\n      // Create resource server\r\n      resourceServer = new X402ResourceServer(facilitatorClient);\r\n\r\n      // Register Exact EVM scheme (supports all EVM chains)\r\n      // The SDK's registerExactEvmScheme should handle multiple chains automatically\r\n      registerScheme(resourceServer);\r\n\r\n      // Register Bazaar extension for discovery\r\n      resourceServer.registerExtension(bazaarExt);\r\n\r\n    // Log supported networks (async import to avoid blocking)\r\n    import('./chain-registry')\r\n      .then(({ getChainRegistry }) => {\r\n        const chainRegistry = getChainRegistry();\r\n        const evmNetworks = chainRegistry.getEVMs();\r\n        logger.info(\r\n          {\r\n            supportedNetworks: evmNetworks.map((n) => ({\r\n              caip: n.caip,\r\n              name: n.name,\r\n              chainId: n.chainId,\r\n            })),\r\n          },\r\n          'x402 Resource Server initialized with Bazaar extension and multi-chain support'\r\n        );\r\n      })\r\n      .catch(() => {\r\n        logger.info('x402 Resource Server initialized with Bazaar extension');\r\n      });\r\n    }\r\n\r\n    return resourceServer;\r\n  } catch (error) {\r\n    logger.warn({ error }, 'x402 resource server not available - discovery endpoint may not function');\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get facilitator client adapter (for direct use if needed)\r\n */\r\nexport function getFacilitatorClientAdapter() {\r\n  return new CDPFacilitatorClientAdapter();\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4622, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/input-validator.ts"],"sourcesContent":["// =============================================================================\r\n// INPUT VALIDATION & SANITIZATION\r\n// =============================================================================\r\n// Comprehensive input validation and sanitization for all API inputs\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'InputValidator' });\r\n\r\nexport interface ValidationResult {\r\n  valid: boolean;\r\n  errors: string[];\r\n  sanitized?: any;\r\n}\r\n\r\n/**\r\n * Validate and sanitize endpoint ID\r\n */\r\nexport function validateEndpointId(endpointId: string): ValidationResult {\r\n  const errors: string[] = [];\r\n\r\n  // Check format: ep_<timestamp>_<random>\r\n  if (!endpointId || typeof endpointId !== 'string') {\r\n    errors.push('Endpoint ID must be a string');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // Allow formats:\r\n  // - ep_<digits>_<alphanumeric> (standard format)\r\n  // - ep_<alphanumeric>_<alphanumeric> (descriptive format like ep_url_enrich_demo_v1)\r\n  // - ep_<alphanumeric> (simple format)\r\n  if (!/^ep_[a-z0-9_]+$/i.test(endpointId)) {\r\n    errors.push('Invalid endpoint ID format');\r\n  }\r\n\r\n  if (endpointId.length > 100) {\r\n    errors.push('Endpoint ID too long');\r\n  }\r\n\r\n  // Sanitize: remove any non-alphanumeric characters except underscore and dash\r\n  const sanitized = endpointId.replace(/[^a-z0-9_-]/gi, '');\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    sanitized: errors.length === 0 ? sanitized : undefined,\r\n  };\r\n}\r\n\r\n/**\r\n * Validate and sanitize API key token\r\n */\r\nexport function validateApiKeyToken(token: string): ValidationResult {\r\n  const errors: string[] = [];\r\n\r\n  if (!token || typeof token !== 'string') {\r\n    errors.push('API key must be a string');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // Check format: nf_live_... or nf_test_...\r\n  if (!token.startsWith('nf_live_') && !token.startsWith('nf_test_')) {\r\n    errors.push('Invalid API key format');\r\n  }\r\n\r\n  if (token.length < 20 || token.length > 200) {\r\n    errors.push('API key length invalid');\r\n  }\r\n\r\n  // Sanitize: only allow alphanumeric, underscore, dash\r\n  const sanitized = token.replace(/[^a-z0-9_-]/gi, '');\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    sanitized: errors.length === 0 ? sanitized : undefined,\r\n  };\r\n}\r\n\r\n/**\r\n * Validate and sanitize payment header\r\n * \r\n * x402 payment headers have format: \"x402 <base64-encoded-json>\"\r\n * The base64 content contains the payment authorization and signature\r\n */\r\nexport function validatePaymentHeader(header: string): ValidationResult {\r\n  const errors: string[] = [];\r\n\r\n  if (!header || typeof header !== 'string') {\r\n    errors.push('Payment header must be a string');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // Length check - x402 headers can be large due to signatures\r\n  if (header.length > 10000) {\r\n    errors.push('Payment header too long');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  if (header.length < 10) {\r\n    errors.push('Payment header too short');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // Check for suspicious patterns (XSS, etc.)\r\n  if (header.includes('<script') || header.includes('javascript:')) {\r\n    errors.push('Suspicious content in payment header');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // x402 headers should start with \"x402 \" prefix\r\n  const hasX402Prefix = /^x402\\s+/i.test(header);\r\n  \r\n  // Extract base64 portion\r\n  const cleanHeader = hasX402Prefix \r\n    ? header.replace(/^x402\\s+/i, '').trim()\r\n    : header.trim();\r\n\r\n  // Validate base64 format (allow standard base64 chars plus URL-safe variants)\r\n  // Base64 can contain: A-Z, a-z, 0-9, +, /, =\r\n  // URL-safe base64 can also contain: -, _\r\n  if (cleanHeader.length > 0 && !/^[A-Za-z0-9+/=_-]+$/.test(cleanHeader)) {\r\n    // Log what characters are invalid for debugging\r\n    const invalidChars = cleanHeader.split('').filter(c => !/[A-Za-z0-9+/=_-]/.test(c));\r\n    logger.warn('Invalid characters in payment header base64', { \r\n      invalidChars: [...new Set(invalidChars)].slice(0, 10),\r\n      headerLength: header.length,\r\n      hasX402Prefix,\r\n    });\r\n    errors.push('Invalid base64 format in payment header');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // Verify it's decodable base64 (optional strict check)\r\n  try {\r\n    if (cleanHeader.length > 0) {\r\n      const decoded = Buffer.from(cleanHeader, 'base64').toString('utf-8');\r\n      // Should be valid JSON\r\n      JSON.parse(decoded);\r\n    }\r\n  } catch (e) {\r\n    // Don't fail validation, just log - the parser will handle this\r\n    logger.debug('Payment header base64 decode check failed (non-blocking)', {\r\n      error: e instanceof Error ? e.message : 'Unknown',\r\n    });\r\n  }\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    sanitized: header, // Return original header, let parser handle decoding\r\n  };\r\n}\r\n\r\n/**\r\n * Validate and sanitize request body\r\n */\r\nexport function validateRequestBody(body: any, schema?: {\r\n  required?: string[];\r\n  maxSize?: number;\r\n  allowedFields?: string[];\r\n}): ValidationResult {\r\n  const errors: string[] = [];\r\n\r\n  if (!body || typeof body !== 'object') {\r\n    errors.push('Request body must be an object');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // Check size\r\n  const bodySize = JSON.stringify(body).length;\r\n  if (schema?.maxSize && bodySize > schema.maxSize) {\r\n    errors.push(`Request body too large: ${bodySize} bytes (max: ${schema.maxSize})`);\r\n  }\r\n\r\n  // Check required fields\r\n  if (schema?.required) {\r\n    for (const field of schema.required) {\r\n      if (!(field in body)) {\r\n        errors.push(`Required field missing: ${field}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Filter allowed fields\r\n  let sanitized = body;\r\n  if (schema?.allowedFields) {\r\n    sanitized = {};\r\n    for (const field of schema.allowedFields) {\r\n      if (field in body) {\r\n        sanitized[field] = sanitizeValue(body[field]);\r\n      }\r\n    }\r\n  } else {\r\n    // Sanitize all values\r\n    sanitized = sanitizeObject(body);\r\n  }\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    sanitized: errors.length === 0 ? sanitized : undefined,\r\n  };\r\n}\r\n\r\n/**\r\n * Sanitize a value (recursive)\r\n */\r\nfunction sanitizeValue(value: any): any {\r\n  if (typeof value === 'string') {\r\n    return sanitizeString(value);\r\n  } else if (Array.isArray(value)) {\r\n    return value.map(sanitizeValue);\r\n  } else if (value && typeof value === 'object') {\r\n    return sanitizeObject(value);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * Sanitize a string\r\n */\r\nfunction sanitizeString(str: string): string {\r\n  // Remove null bytes\r\n  str = str.replace(/\\0/g, '');\r\n  \r\n  // Remove control characters (except newline, tab, carriage return)\r\n  str = str.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, '');\r\n  \r\n  // Trim whitespace\r\n  str = str.trim();\r\n  \r\n  return str;\r\n}\r\n\r\n/**\r\n * Sanitize an object\r\n */\r\nfunction sanitizeObject(obj: Record<string, any>): Record<string, any> {\r\n  const sanitized: Record<string, any> = {};\r\n  \r\n  for (const [key, value] of Object.entries(obj)) {\r\n    // Sanitize key\r\n    const cleanKey = sanitizeString(key);\r\n    \r\n    // Skip if key is empty after sanitization\r\n    if (!cleanKey) continue;\r\n    \r\n    // Sanitize value\r\n    sanitized[cleanKey] = sanitizeValue(value);\r\n  }\r\n  \r\n  return sanitized;\r\n}\r\n\r\n/**\r\n * Validate URL parameter\r\n */\r\nexport function validateUrlParam(param: string, type: 'string' | 'number' | 'uuid' | 'endpointId'): ValidationResult {\r\n  const errors: string[] = [];\r\n\r\n  if (!param || typeof param !== 'string') {\r\n    errors.push(`Parameter must be a string`);\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  switch (type) {\r\n    case 'number':\r\n      if (!/^\\d+$/.test(param)) {\r\n        errors.push('Parameter must be a number');\r\n      }\r\n      break;\r\n    case 'uuid':\r\n      if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(param)) {\r\n        errors.push('Parameter must be a valid UUID');\r\n      }\r\n      break;\r\n    case 'endpointId':\r\n      return validateEndpointId(param);\r\n    case 'string':\r\n      if (param.length > 1000) {\r\n        errors.push('Parameter too long');\r\n      }\r\n      break;\r\n  }\r\n\r\n  const sanitized = sanitizeString(param);\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    sanitized: errors.length === 0 ? sanitized : undefined,\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4886, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/base-facilitator.ts"],"sourcesContent":["// =============================================================================\n// FACILITATOR ABSTRACTION LAYER\n// =============================================================================\n// Base interface and types for pluggable x402 facilitators\n// Enables multi-facilitator orchestration and routing\n\nimport { createLogger } from '@/lib/logger';\n\nconst logger = createLogger({ component: 'BaseFacilitator' });\n\n/**\n * CAIP-2 Network Identifier (e.g., \"eip155:8453\" for Base)\n * CAIP-19 Asset Identifier (e.g., \"eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\" for USDC on Base)\n */\nexport type CAIPNetworkId = string; // e.g., \"eip155:8453\", \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\", \"bip122:000000000019d6689c085ae165831e93\"\nexport type CAIPAssetId = string; // e.g., \"eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\"\n\n/**\n * Settlement mode for payments\n */\nexport type SettlementMode = 'immediate' | 'deferred' | 'batch';\n\n/**\n * Payment requirements for x402 payment verification\n * Extended to support CAIP identifiers and settlement modes\n */\nexport interface PaymentRequirements {\n  scheme: string; // 'exact', 'x402', etc.\n  network: string; // Legacy: 'base', 'ethereum', 'solana', etc.\n  networks?: CAIPNetworkId[]; // CAIP-2 network identifiers (multi-network support)\n  maxAmountRequired: string; // Amount in smallest units\n  resource: string; // Resource URL\n  description?: string;\n  mimeType?: string;\n  payTo: string; // Recipient address\n  maxTimeoutSeconds?: number;\n  asset: string; // Legacy: Token address\n  assets?: CAIPAssetId[]; // CAIP-19 asset identifiers (multi-asset support)\n  settlementMode?: SettlementMode; // 'immediate', 'deferred', or 'batch'\n}\n\n/**\n * Payment verification result\n */\nexport interface VerificationResult {\n  success: boolean;\n  valid: boolean;\n  transactionHash?: string;\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\n  error?: string;\n  errorDetails?: Record<string, any>;\n  facilitatorId: string; // Which facilitator verified this\n  verifiedAt: string; // ISO timestamp\n}\n\n/**\n * Facilitator health status\n */\nexport interface FacilitatorHealth {\n  healthy: boolean;\n  latency?: number; // ms\n  lastChecked: string; // ISO timestamp\n  error?: string;\n  capabilities: {\n    networks: string[];\n    assets: string[];\n    schemes: string[];\n  };\n}\n\n/**\n * Pricing information for a facilitator\n */\nexport interface PricingInfo {\n  network: string;\n  asset: string;\n  baseFee?: string; // Base fee in smallest units\n  percentageFee?: number; // Percentage fee (0-1)\n  estimatedGas?: string; // Estimated gas cost\n  currency: string; // Fee currency\n}\n\n/**\n * Facilitator configuration\n */\nexport interface FacilitatorConfig {\n  id: string;\n  name: string;\n  enabled: boolean;\n  priority: number; // Lower = higher priority\n  networks: string[]; // Legacy: Supported networks\n  networksCAIP?: CAIPNetworkId[]; // CAIP-2 network identifiers\n  assets: string[]; // Legacy: Supported assets\n  assetsCAIP?: CAIPAssetId[]; // CAIP-19 asset identifiers\n  schemes: string[]; // Supported schemes ('exact', 'x402', etc.)\n  settlementModes?: SettlementMode[]; // Supported settlement modes\n  healthCheckUrl?: string;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Base facilitator interface\n * All facilitators must implement this interface\n */\nexport interface IFacilitator {\n  /**\n   * Unique identifier for this facilitator\n   */\n  readonly id: string;\n\n  /**\n   * Human-readable name\n   */\n  readonly name: string;\n\n  /**\n   * Facilitator configuration\n   */\n  readonly config: FacilitatorConfig;\n\n  /**\n   * Verify an x402 payment\n   */\n  verify(\n    payment: string,\n    requirements: PaymentRequirements\n  ): Promise<VerificationResult>;\n\n  /**\n   * Check facilitator health\n   */\n  getHealth(): Promise<FacilitatorHealth>;\n\n  /**\n   * Get pricing information for a network/asset combination\n   */\n  getPricing(network: string, asset: string): Promise<PricingInfo | null>;\n\n  /**\n   * Check if facilitator supports a given network/asset/scheme\n   * Extended to support settlement modes\n   */\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean;\n\n  /**\n   * Check if facilitator supports a CAIP-2 network identifier\n   */\n  supportsCAIPNetwork(caip: CAIPNetworkId): boolean;\n\n  /**\n   * Check if facilitator supports a CAIP-19 asset identifier\n   */\n  supportsCAIPAsset(caip: CAIPAssetId): boolean;\n}\n\n/**\n * Base facilitator class with common functionality\n */\nexport abstract class BaseFacilitator implements IFacilitator {\n  abstract readonly id: string;\n  abstract readonly name: string;\n  abstract readonly config: FacilitatorConfig;\n\n  protected getLogger() {\n    return logger.child({ facilitator: this.constructor.name });\n  }\n\n  /**\n   * Verify payment (must be implemented by subclasses)\n   */\n  abstract verify(\n    payment: string,\n    requirements: PaymentRequirements\n  ): Promise<VerificationResult>;\n\n  /**\n   * Get health status (must be implemented by subclasses)\n   */\n  abstract getHealth(): Promise<FacilitatorHealth>;\n\n  /**\n   * Get pricing (default implementation returns null)\n   */\n  async getPricing(network: string, asset: string): Promise<PricingInfo | null> {\n    // Default: no pricing info available\n    return null;\n  }\n\n  /**\n   * Check if facilitator supports network/asset/scheme\n   * Enhanced to support both legacy and CAIP identifiers\n   */\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n\n    // Check scheme support\n    if (!this.config.schemes.includes(scheme)) {\n      return false;\n    }\n\n    // Check settlement mode support\n    if (settlementMode && this.config.settlementModes && !this.config.settlementModes.includes(settlementMode)) {\n      return false;\n    }\n\n    // Check network support (legacy or CAIP)\n    const supportsNetwork = \n      this.config.networks.includes(network) ||\n      (this.config.networksCAIP && this.config.networksCAIP.includes(network as CAIPNetworkId));\n\n    if (!supportsNetwork) {\n      return false;\n    }\n\n    // Check asset support (legacy or CAIP)\n    const supportsAsset = \n      this.config.assets.includes(asset) ||\n      (this.config.assetsCAIP && this.config.assetsCAIP.includes(asset as CAIPAssetId));\n\n    return supportsAsset;\n  }\n\n  /**\n   * Check if facilitator supports a CAIP-2 network identifier\n   */\n  supportsCAIPNetwork(caip: CAIPNetworkId): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n    return this.config.networksCAIP?.includes(caip) || false;\n  }\n\n  /**\n   * Check if facilitator supports a CAIP-19 asset identifier\n   */\n  supportsCAIPAsset(caip: CAIPAssetId): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n    return this.config.assetsCAIP?.includes(caip) || false;\n  }\n\n  /**\n   * Validate payment requirements\n   * Enhanced to support CAIP identifiers\n   */\n  protected validateRequirements(\n    requirements: PaymentRequirements\n  ): { valid: boolean; error?: string } {\n    // Check network (legacy or CAIP)\n    const hasNetwork = \n      !!requirements.network || \n      (requirements.networks && requirements.networks.length > 0);\n    \n    if (!hasNetwork) {\n      return { valid: false, error: 'Network is required' };\n    }\n\n    // Check asset (legacy or CAIP)\n    const hasAsset = \n      !!requirements.asset || \n      (requirements.assets && requirements.assets.length > 0);\n    \n    if (!hasAsset) {\n      return { valid: false, error: 'Asset is required' };\n    }\n\n    if (!requirements.payTo) {\n      return { valid: false, error: 'Recipient address (payTo) is required' };\n    }\n    if (!requirements.maxAmountRequired) {\n      return { valid: false, error: 'Amount is required' };\n    }\n\n    // Check support (use legacy network/asset for supports() check, or check CAIP directly)\n    const networkToCheck = requirements.network || (requirements.networks?.[0] || '');\n    const assetToCheck = requirements.asset || (requirements.assets?.[0] || '');\n    \n    // Check CAIP support if CAIP identifiers are provided\n    if (requirements.networks && requirements.networks.length > 0) {\n      const supportsAnyNetwork = requirements.networks.some((n) => \n        this.supportsCAIPNetwork(n) || this.config.networks.includes(n)\n      );\n      if (!supportsAnyNetwork) {\n        return {\n          valid: false,\n          error: `Facilitator ${this.id} does not support any of the requested networks: ${requirements.networks.join(', ')}`,\n        };\n      }\n    }\n\n    if (requirements.assets && requirements.assets.length > 0) {\n      const supportsAnyAsset = requirements.assets.some((a) => \n        this.supportsCAIPAsset(a) || this.config.assets.includes(a)\n      );\n      if (!supportsAnyAsset) {\n        return {\n          valid: false,\n          error: `Facilitator ${this.id} does not support any of the requested assets: ${requirements.assets.join(', ')}`,\n        };\n      }\n    }\n\n    // Check legacy support\n    if (!this.supports(networkToCheck, assetToCheck, requirements.scheme, requirements.settlementMode)) {\n      return {\n        valid: false,\n        error: `Facilitator ${this.id} does not support ${networkToCheck}/${assetToCheck}/${requirements.scheme}`,\n      };\n    }\n    return { valid: true };\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5022, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/cdp-facilitator-adapter.ts"],"sourcesContent":["// =============================================================================\r\n// CDP FACILITATOR ADAPTER\r\n// =============================================================================\r\n// Adapter to make CDP facilitator conform to IFacilitator interface\r\n\r\nimport { BaseFacilitator, type IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorHealth, type FacilitatorConfig, type CAIPNetworkId, type CAIPAssetId } from './base-facilitator';\r\nimport { getCDPFacilitator, type CDPVerifyRequest, type CDPVerifyResponse, type X402PaymentRequirements } from '../cdp-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\n// Logger will be created per instance\r\n\r\n/**\r\n * Build CDP-specific payment requirements for probe mode\r\n * Uses known-good values for Base + USDC that CDP expects\r\n * CDP x402 v2 API expects: scheme, network, payTo, maxAmountRequired, resource, asset, etc.\r\n */\r\nfunction buildCdpProbePaymentRequirements(config: FacilitatorProbeConfig): X402PaymentRequirements {\r\n  // USDC contract address on Base\r\n  const USDC_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';\r\n  \r\n  // Use a test receiver address (can be any valid address you control)\r\n  // For probes, we use a known test address that won't cause issues\r\n  const PROBE_RECEIVER = '0x0000000000000000000000000000000000000001'; // Test address\r\n  \r\n  // CDP requires CAIP-2 format (e.g., \"eip155:8453\") for network\r\n  // Keep network in CAIP-2 format, don't convert to legacy\r\n  const network = config.network; // Already in CAIP-2 format (e.g., \"eip155:8453\")\r\n  \r\n  const now = Math.floor(Date.now() / 1000);\r\n  \r\n  return {\r\n    scheme: 'exact', // CDP expects 'exact' scheme for EVM fixed-amount flows\r\n    network: network, // Use CAIP-2 format (e.g., \"eip155:8453\")\r\n    to: PROBE_RECEIVER, // Internal field name\r\n    payTo: PROBE_RECEIVER, // CDP field name (required)\r\n    value: '1000000', // Internal field name (1 USDC in atomic units, must match authorization.value)\r\n    maxAmountRequired: '1000000', // CDP field name (required) - 1 USDC in atomic units\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    asset: USDC_BASE,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    maxTimeoutSeconds: 10, // Short timeout for probes\r\n    validAfter: now.toString(),\r\n    validBefore: (now + 300).toString(), // 5 minutes validity window\r\n  };\r\n}\r\n\r\n/**\r\n * CDP Facilitator Adapter\r\n * Wraps the existing CDP facilitator to implement IFacilitator interface\r\n */\r\nexport class CDPFacilitatorAdapter extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'cdp';\r\n  readonly name = 'Coinbase Developer Platform';\r\n  \r\n  readonly config: FacilitatorConfig = {\r\n    id: 'cdp',\r\n    name: 'Coinbase Developer Platform',\r\n    enabled: true,\r\n    priority: 1, // High priority (primary facilitator)\r\n    networks: ['base'], // Legacy: Currently Base only\r\n    networksCAIP: ['eip155:8453'], // CAIP-2: Base mainnet\r\n    assets: ['0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // Legacy: USDC on Base\r\n    assetsCAIP: ['eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // CAIP-19: USDC on Base\r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'], // CDP supports immediate settlement\r\n    healthCheckUrl: process.env.CDP_FACILITATOR_URL || 'https://api.cdp.coinbase.com/platform/v2/x402',\r\n    metadata: {\r\n      provider: 'Coinbase',\r\n      kytEnabled: true,\r\n      ofacEnabled: true,\r\n      complianceLevel: 'enterprise',\r\n    },\r\n  };\r\n\r\n  private cdpFacilitator = getCDPFacilitator();\r\n\r\n  /**\r\n   * Verify payment using CDP facilitator\r\n   * \r\n   * Note: This adapter expects the payment header to be passed as-is.\r\n   * The CDP facilitator will parse it internally. For a more complete\r\n   * adapter, we could parse the header here and extract the authorization,\r\n   * but for now we rely on CDP's internal parsing.\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Import payment header parser to extract authorization\r\n      const { parseAndVerifyPaymentHeader } = await import('../payment-header-parser');\r\n      const parsed = await parseAndVerifyPaymentHeader(payment);\r\n\r\n      if (!parsed.valid || !parsed.payment) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parsed.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Detect probe mode: check if resource URL matches probe pattern\r\n      // Probe resources use pattern: https://probe.nexflow.dev/health/{facilitatorId}/{network}/{token}\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n      \r\n      // For probe mode, build CDP-specific probe paymentRequirements\r\n      // Extract probe config from resource URL if in probe mode\r\n      let cdpPaymentRequirements: X402PaymentRequirements;\r\n      if (isProbe) {\r\n        // Extract facilitatorId, network, token from resource URL\r\n        // Format: https://probe.nexflow.dev/health/{facilitatorId}/{network}/{token}\r\n        const resourceMatch = requirements.resource.match(/\\/health\\/([^/]+)\\/([^/]+)\\/([^/]+)/);\r\n        if (resourceMatch) {\r\n          const [, facilitatorId, network, token] = resourceMatch;\r\n          const probeConfig: FacilitatorProbeConfig = {\r\n            id: `${facilitatorId}-${network}-${token.toLowerCase()}`,\r\n            facilitatorId,\r\n            network,\r\n            token,\r\n            desiredIntervalSeconds: 30, // Default, not used for building requirements\r\n            enabled: true,\r\n          };\r\n          cdpPaymentRequirements = buildCdpProbePaymentRequirements(probeConfig);\r\n          this.getLogger().info({\r\n            component: 'CDPFacilitatorAdapter',\r\n            isProbe: true,\r\n            probeConfigId: probeConfig.id,\r\n            hasPaymentRequirements: true,\r\n            msg: 'Using probe-specific paymentRequirements for CDP',\r\n          });\r\n        } else {\r\n          // Fallback: use requirements as-is if we can't parse probe config\r\n          cdpPaymentRequirements = {\r\n            scheme: requirements.scheme,\r\n            network: requirements.network,\r\n            maxAmountRequired: requirements.maxAmountRequired,\r\n            resource: requirements.resource,\r\n            description: requirements.description || '',\r\n            mimeType: requirements.mimeType || 'application/json',\r\n            payTo: requirements.payTo,\r\n            maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n            asset: requirements.asset,\r\n          };\r\n        }\r\n      } else {\r\n        // Normal mode: use requirements from caller\r\n        cdpPaymentRequirements = {\r\n          scheme: requirements.scheme,\r\n          network: requirements.network,\r\n          maxAmountRequired: requirements.maxAmountRequired,\r\n          resource: requirements.resource,\r\n          description: requirements.description || '',\r\n          mimeType: requirements.mimeType || 'application/json',\r\n          payTo: requirements.payTo,\r\n          maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n          asset: requirements.asset,\r\n        };\r\n      }\r\n\r\n      // Build CDP request with parsed payment data\r\n      const cdpRequest: CDPVerifyRequest = {\r\n        payment,\r\n        paymentPayload: {\r\n          x402Version: 1,\r\n          scheme: 'x402' as const,\r\n          network: parsed.payment.network || requirements.network,\r\n          payload: {\r\n            signature: parsed.payment.signature,\r\n            authorization: parsed.payment.authorization,\r\n          },\r\n        },\r\n        paymentRequirements: cdpPaymentRequirements,\r\n      };\r\n\r\n      // Verify with CDP\r\n      const result = await this.cdpFacilitator.verifyPaymentWithRetry(cdpRequest);\r\n\r\n      return {\r\n        success: result.success,\r\n        valid: result.valid,\r\n        transactionHash: result.transactionHash,\r\n        kytStatus: result.kytStatus,\r\n        ofacStatus: result.ofacStatus,\r\n        error: result.error,\r\n        errorDetails: result.errorDetails,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      this.getLogger().error({ error, requirements }, 'CDP verification error');\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: error instanceof Error ? error.message : 'Verification failed',\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get CDP facilitator health\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    try {\r\n      const start = Date.now();\r\n      const health = await this.cdpFacilitator.healthCheck();\r\n      const latency = Date.now() - start;\r\n\r\n      return {\r\n        healthy: health.healthy,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        healthy: false,\r\n        lastChecked: new Date().toISOString(),\r\n        error: error instanceof Error ? error.message : 'Health check failed',\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing (CDP doesn't charge fees, but we track gas costs)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    if (network === 'base' && asset === '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913') {\r\n      return {\r\n        network: 'base',\r\n        asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n        baseFee: '0', // CDP doesn't charge fees\r\n        percentageFee: 0,\r\n        estimatedGas: '21000', // Typical gas for USDC transfer\r\n        currency: 'USDC',\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get CDP facilitator adapter instance\r\n */\r\nlet cdpAdapter: CDPFacilitatorAdapter | null = null;\r\n\r\nexport function getCDPFacilitatorAdapter(): CDPFacilitatorAdapter {\r\n  if (!cdpAdapter) {\r\n    cdpAdapter = new CDPFacilitatorAdapter();\r\n  }\r\n  return cdpAdapter;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5291, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/payai-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// PAYAI FACILITATOR\r\n// =============================================================================\r\n// Multi-chain facilitator for x402 payment verification\r\n// Supports Base, Solana, Ethereum, BNB Chain, and other networks\r\n\r\nimport { BaseFacilitator, type IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorHealth, type FacilitatorConfig, type CAIPNetworkId, type CAIPAssetId } from './base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\nconst logger = createLogger({ component: 'PayAIFacilitator' });\r\n\r\n/**\r\n * Build PayAI-specific payment requirements for probe mode\r\n * Uses known-good values for Base + USDC that PayAI expects\r\n */\r\nfunction buildPayAIProbePaymentRequirements(config: FacilitatorProbeConfig): PaymentRequirements {\r\n  // USDC contract address on Base\r\n  const USDC_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';\r\n  \r\n  // Use a test receiver address (can be any valid address you control)\r\n  // For probes, we use a known test address that won't cause issues\r\n  const PROBE_RECEIVER = '0x0000000000000000000000000000000000000001'; // Test address\r\n  \r\n  // Convert CAIP-2 network to legacy format\r\n  let legacyNetwork = config.network;\r\n  if (config.network === 'eip155:8453') {\r\n    legacyNetwork = 'base';\r\n  }\r\n  \r\n  return {\r\n    scheme: 'x402',\r\n    network: legacyNetwork,\r\n    asset: USDC_BASE,\r\n    maxAmountRequired: '1', // Minimal amount (1 atomic unit)\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    payTo: PROBE_RECEIVER, // Use test receiver address for probes\r\n    maxTimeoutSeconds: 10, // Short timeout for probes\r\n    settlementMode: 'immediate',\r\n  };\r\n}\r\n\r\n/**\r\n * PayAI Facilitator\r\n * \r\n * Multi-chain facilitator supporting multiple networks beyond Base.\r\n * Implements x402 payment verification via PayAI facilitator API.\r\n */\r\nexport class PayAIFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'payai';\r\n  readonly name = 'PayAI Facilitator';\r\n\r\n  readonly config: FacilitatorConfig = {\r\n    id: 'payai',\r\n    name: 'PayAI Facilitator',\r\n    enabled: process.env.PAYAI_ENABLED !== 'false', // Enabled by default, can be disabled via env\r\n    priority: 2, // Lower priority than CDP (CDP = 1, PayAI = 2)\r\n    \r\n    // Legacy network identifiers\r\n    networks: ['base', 'ethereum', 'solana', 'bnb', 'polygon'],\r\n    \r\n    // CAIP-2 network identifiers (multi-chain support)\r\n    networksCAIP: [\r\n      'eip155:1',      // Ethereum mainnet\r\n      'eip155:8453',   // Base mainnet\r\n      'eip155:56',     // BNB Chain\r\n      'eip155:137',    // Polygon\r\n      'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp', // Solana mainnet\r\n    ],\r\n    \r\n    // Legacy asset identifiers\r\n    assets: [\r\n      '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base\r\n      '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC on Ethereum\r\n    ],\r\n    \r\n    // CAIP-19 asset identifiers (multi-chain support)\r\n    assetsCAIP: [\r\n      // Ethereum USDC\r\n      'eip155:1/erc20:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\r\n      // Base USDC\r\n      'eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n      // BNB Chain USDC\r\n      'eip155:56/erc20:0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d',\r\n      // Polygon USDC\r\n      'eip155:137/erc20:0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\r\n      // Solana USDC (EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v)\r\n      // Note: Solana CAIP-19 format may differ, adding placeholder\r\n      // 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp/spl:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',\r\n    ],\r\n    \r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'], // PayAI supports immediate settlement\r\n    \r\n    healthCheckUrl: process.env.PAYAI_FACILITATOR_URL || 'https://facilitator.payai.network',\r\n    \r\n    metadata: {\r\n      provider: 'PayAI',\r\n      multiChain: true,\r\n      complianceLevel: 'standard',\r\n      website: 'https://payai.network',\r\n    },\r\n  };\r\n\r\n  private baseUrl: string;\r\n\r\n  constructor(\r\n    baseUrl?: string\r\n  ) {\r\n    super();\r\n    // No API key required for hosted facilitator\r\n    this.baseUrl = baseUrl || process.env.PAYAI_FACILITATOR_URL || 'https://facilitator.payai.network';\r\n  }\r\n\r\n  /**\r\n   * Call PayAI /verify endpoint with retry logic for transient errors\r\n   * \r\n   * Retries on: 429 (rate limit), 500-504 (server errors), network timeouts\r\n   * Does NOT retry on: 400 (invalid_request), 401 (unauthorized), other 4xx\r\n   * \r\n   * Returns normalized result with success, valid, status, errorType, errorMessage, etc.\r\n   */\r\n  private async callPayAIVerifyWithRetries(\r\n    verifyUrl: string,\r\n    requestBody: any,\r\n    isProbe: boolean\r\n  ): Promise<{\r\n    success: boolean;\r\n    valid: boolean;\r\n    status: number;\r\n    errorType?: string;\r\n    errorMessage?: string;\r\n    isRateLimited: boolean;\r\n    isNetworkError: boolean;\r\n    latencyMs: number;\r\n    data?: any;\r\n  }> {\r\n    const maxRetries = 3;\r\n    const retryableStatuses = [429, 500, 502, 503, 504];\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const response = await fetch(verifyUrl, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify(requestBody),\r\n          signal: AbortSignal.timeout(10000), // 10 second timeout\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data = text ? JSON.parse(text) : {};\r\n        const latencyMs = Date.now() - startTime;\r\n\r\n        // Success case\r\n        if (response.ok && data.valid === true) {\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            status: response.status,\r\n            isRateLimited: false,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Check if retryable error\r\n        const isRetryable = retryableStatuses.includes(response.status);\r\n        const isRateLimit = response.status === 429;\r\n        \r\n        // If not retryable or last attempt, return error\r\n        if (!isRetryable || attempt === maxRetries - 1) {\r\n          const errorMessage = data.message || data.reason || data.error || `HTTP ${response.status}`;\r\n          const errorType = data.errorType || data.code || (isRateLimit ? 'rate_limit' : 'PAYAI_VERIFY_FAILED');\r\n          \r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            status: response.status,\r\n            errorType,\r\n            errorMessage,\r\n            isRateLimited: isRateLimit,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Retry with exponential backoff\r\n        const delay = 100 * Math.pow(2, attempt); // 100ms, 200ms, 400ms\r\n        logger.info({\r\n          component: 'PayAIFacilitator',\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          status: response.status,\r\n          delay,\r\n          isProbe,\r\n          msg: 'Retrying PayAI verification after transient error',\r\n        });\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        \r\n      } catch (error: any) {\r\n        const latencyMs = Date.now() - startTime;\r\n        const isTimeout = error?.name === 'AbortError' || error?.message?.toLowerCase().includes('timeout');\r\n        const isNetworkError = error?.message?.toLowerCase().includes('network') || \r\n                              error?.message?.toLowerCase().includes('fetch') ||\r\n                              error?.message?.toLowerCase().includes('econnrefused');\r\n        \r\n        // If network error and not last attempt, retry\r\n        if ((isTimeout || isNetworkError) && attempt < maxRetries - 1) {\r\n          const delay = 100 * Math.pow(2, attempt);\r\n          logger.info({\r\n            component: 'PayAIFacilitator',\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error?.message,\r\n            delay,\r\n            isProbe,\r\n            msg: 'Retrying PayAI verification after network error',\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n        \r\n        // Last attempt or non-network error\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          status: 0,\r\n          errorType: isTimeout ? 'timeout' : isNetworkError ? 'network_error' : 'PAYAI_VERIFY_FAILED',\r\n          errorMessage: error?.message || 'PayAI verification failed',\r\n          isRateLimited: false,\r\n          isNetworkError: isTimeout || isNetworkError,\r\n          latencyMs,\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Should never reach here, but TypeScript needs a return\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      status: 0,\r\n      errorType: 'PAYAI_VERIFY_FAILED',\r\n      errorMessage: 'Max retries exceeded',\r\n      isRateLimited: false,\r\n      isNetworkError: false,\r\n      latencyMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify payment using PayAI facilitator\r\n   * \r\n   * POST to /verify endpoint with paymentPayload and paymentRequirements.\r\n   * No authentication required for hosted facilitator.\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    const start = Date.now();\r\n\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Parse payment header to extract authorization details\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Detect probe mode: check if resource URL matches probe pattern\r\n      // Probe resources use pattern: https://probe.nexflow.dev/health/{facilitatorId}/{network}/{token}\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n      \r\n      // For probe mode, build PayAI-specific probe paymentRequirements\r\n      // Extract probe config from resource URL if in probe mode\r\n      let probeRequirements: PaymentRequirements;\r\n      if (isProbe) {\r\n        // Extract facilitatorId, network, token from resource URL\r\n        // Format: https://probe.nexflow.dev/health/{facilitatorId}/{network}/{token}\r\n        const resourceMatch = requirements.resource.match(/\\/health\\/([^/]+)\\/([^/]+)\\/([^/]+)/);\r\n        if (resourceMatch) {\r\n          const [, facilitatorId, network, token] = resourceMatch;\r\n          const probeConfig: FacilitatorProbeConfig = {\r\n            id: `${facilitatorId}-${network}-${token.toLowerCase()}`,\r\n            facilitatorId,\r\n            network,\r\n            token,\r\n            desiredIntervalSeconds: 120, // Default, not used for building requirements\r\n            enabled: true,\r\n          };\r\n          probeRequirements = buildPayAIProbePaymentRequirements(probeConfig);\r\n          logger.info({\r\n            component: 'PayAIFacilitator',\r\n            isProbe: true,\r\n            probeConfigId: probeConfig.id,\r\n            hasPaymentRequirements: true,\r\n            msg: 'Using probe-specific paymentRequirements for PayAI',\r\n          });\r\n        } else {\r\n          // Fallback: use requirements as-is if we can't parse probe config\r\n          probeRequirements = requirements;\r\n        }\r\n      } else {\r\n        // Normal mode: use requirements from caller\r\n        probeRequirements = requirements;\r\n      }\r\n\r\n      // Build paymentPayload from parsed payment header\r\n      const paymentPayload = {\r\n        x402Version: 2, // x402 v2\r\n        scheme: probeRequirements.scheme || 'x402',\r\n        network: parsed.network || probeRequirements.network,\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: {\r\n            from: parsed.authorization.from,\r\n            to: parsed.authorization.to,\r\n            value: parsed.authorization.value,\r\n            validAfter: parsed.authorization.validAfter,\r\n            validBefore: parsed.authorization.validBefore,\r\n            nonce: parsed.authorization.nonce,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Build paymentRequirements from requirements (use probe-specific if in probe mode)\r\n      const paymentRequirements = {\r\n        scheme: probeRequirements.scheme,\r\n        network: probeRequirements.network,\r\n        maxAmountRequired: probeRequirements.maxAmountRequired,\r\n        resource: probeRequirements.resource,\r\n        description: probeRequirements.description || '',\r\n        mimeType: probeRequirements.mimeType || 'application/json',\r\n        payTo: probeRequirements.payTo,\r\n        maxTimeoutSeconds: probeRequirements.maxTimeoutSeconds || 300,\r\n        asset: probeRequirements.asset,\r\n      };\r\n\r\n      // POST to PayAI verification endpoint with retry logic\r\n      const verifyUrl = `${this.baseUrl}/verify`;\r\n      const requestBody = {\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      };\r\n\r\n      // isProbe already declared above (line 300), reuse it\r\n      logger.info({\r\n        component: \"PayAIFacilitator\",\r\n        isProbe,\r\n        network: paymentRequirements.network,\r\n        asset: paymentRequirements.asset,\r\n        url: verifyUrl,\r\n        msg: \"Sending PayAI /verify request\"\r\n      });\r\n\r\n      // Call PayAI /verify with retry logic\r\n      const result = await this.callPayAIVerifyWithRetries(\r\n        verifyUrl,\r\n        requestBody,\r\n        isProbe\r\n      );\r\n\r\n      const latency = result.latencyMs;\r\n\r\n      // Handle success\r\n      if (result.success && result.valid) {\r\n        logger.info({ latencyMs: result.latencyMs }, 'Payment verified successfully by PayAI');\r\n        return {\r\n          success: true,\r\n          valid: true,\r\n          transactionHash: result.data?.transactionHash || result.data?.txHash,\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Handle error - map PayAI errorType/errorMessage to our error classification\r\n      const payaiErrorType = result.errorType || 'PAYAI_VERIFY_FAILED';\r\n      const payaiErrorMessage = result.errorMessage || 'PayAI verification failed';\r\n      \r\n      // Map error types to result/errorCode\r\n      let errorCode = 'facilitator_error';\r\n      if (result.isRateLimited || payaiErrorType === 'rate_limit') {\r\n        errorCode = 'rate_limited';\r\n      } else if (result.isNetworkError) {\r\n        errorCode = 'network_error';\r\n      } else if (payaiErrorType === 'invalid_request' || result.status === 400) {\r\n        errorCode = 'invalid_request';\r\n      } else if (result.status === 401) {\r\n        errorCode = 'unauthorized';\r\n      }\r\n\r\n      logger.debug({\r\n        status: result.status,\r\n        errorType: payaiErrorType,\r\n        errorMessage: payaiErrorMessage,\r\n        errorCode,\r\n        isRateLimited: result.isRateLimited,\r\n        isNetworkError: result.isNetworkError,\r\n        latencyMs: result.latencyMs,\r\n      }, 'PayAI verification failed');\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: payaiErrorMessage,\r\n        errorDetails: {\r\n          error: payaiErrorMessage,\r\n          errorType: payaiErrorType,\r\n          httpStatus: result.status,\r\n          errorCode,\r\n          isRateLimited: result.isRateLimited,\r\n          isNetworkError: result.isNetworkError,\r\n          payaiResponse: result.data,\r\n        },\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'PayAI verification error');\r\n      \r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: isTimeout ? 'PayAI_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get PayAI facilitator health\r\n   * \r\n   * Calls GET /list endpoint. If 200 with non-empty networks/assets, returns healthy.\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // PayAI redirects /list to /discovery/resources\r\n      const healthUrl = `${this.baseUrl}/discovery/resources`;\r\n      \r\n      const response = await fetch(healthUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000), // 5 second timeout\r\n      });\r\n\r\n      const latency = Date.now() - start;\r\n\r\n      if (response.ok) {\r\n        const data = await response.json();\r\n        \r\n        // Check if response has networks/assets (non-empty)\r\n        const hasNetworks = data.networks && Array.isArray(data.networks) && data.networks.length > 0;\r\n        const hasAssets = data.assets && Array.isArray(data.assets) && data.assets.length > 0;\r\n\r\n        if (hasNetworks || hasAssets) {\r\n          return {\r\n            healthy: true,\r\n            latency,\r\n            lastChecked: new Date().toISOString(),\r\n            capabilities: {\r\n              networks: data.networks || this.config.networks,\r\n              assets: data.assets || this.config.assets,\r\n              schemes: data.schemes || this.config.schemes,\r\n            },\r\n          };\r\n        }\r\n\r\n        // 200 but empty response - consider unhealthy\r\n        return {\r\n          healthy: false,\r\n          latency,\r\n          lastChecked: new Date().toISOString(),\r\n          error: 'Health check returned empty networks/assets',\r\n          capabilities: {\r\n            networks: this.config.networks,\r\n            assets: this.config.assets,\r\n            schemes: this.config.schemes,\r\n          },\r\n        };\r\n      }\r\n\r\n      // Non-2xx response\r\n      const errorText = await response.text().catch(() => `HTTP ${response.status}`);\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: errorText,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Health check failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: isTimeout ? 'Health check timeout' : errorMessage,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing information\r\n   * \r\n   * Returns null for now - can be implemented once PayAI pricing API is available.\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    // TODO: Implement pricing lookup if PayAI provides pricing API\r\n    // For now, return null (allowed by interface)\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   * Uses base class implementation which checks config\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: string): boolean {\r\n    return super.supports(network, asset, scheme, settlementMode as any);\r\n  }\r\n}\r\n\r\n/**\r\n * Singleton PayAI facilitator instance\r\n */\r\nlet payaiFacilitator: PayAIFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton PayAI facilitator instance\r\n */\r\nexport function getPayAIFacilitator(): PayAIFacilitator {\r\n  if (!payaiFacilitator) {\r\n    payaiFacilitator = new PayAIFacilitator();\r\n  }\r\n  return payaiFacilitator;\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,oBAAoB;AACpB,gFAAgF;AAChF,wDAAwD;AACxD,iEAAiE;;;;;;;AAEjE;AACA;;;AAGA,MAAM,SAAS,IAAA,sIAAY,EAAC;IAAE,WAAW;AAAmB;AAE5D;;;CAGC,GACD,SAAS,mCAAmC,MAA8B;IACxE,gCAAgC;IAChC,MAAM,YAAY;IAElB,qEAAqE;IACrE,kEAAkE;IAClE,MAAM,iBAAiB,8CAA8C,eAAe;IAEpF,0CAA0C;IAC1C,IAAI,gBAAgB,OAAO,OAAO;IAClC,IAAI,OAAO,OAAO,KAAK,eAAe;QACpC,gBAAgB;IAClB;IAEA,OAAO;QACL,QAAQ;QACR,SAAS;QACT,OAAO;QACP,mBAAmB;QACnB,UAAU,CAAC,iCAAiC,EAAE,OAAO,aAAa,CAAC,CAAC,EAAE,OAAO,OAAO,CAAC,CAAC,EAAE,OAAO,KAAK,EAAE;QACtG,aAAa,CAAC,iBAAiB,EAAE,OAAO,aAAa,CAAC,IAAI,EAAE,OAAO,OAAO,EAAE;QAC5E,UAAU;QACV,OAAO;QACP,mBAAmB;QACnB,gBAAgB;IAClB;AACF;AAQO,MAAM,yBAAyB,uLAAe;IAC1C,KAAK,QAAQ;IACb,OAAO,oBAAoB;IAE3B,SAA4B;QACnC,IAAI;QACJ,MAAM;QACN,SAAS,QAAQ,GAAG,CAAC,aAAa,KAAK;QACvC,UAAU;QAEV,6BAA6B;QAC7B,UAAU;YAAC;YAAQ;YAAY;YAAU;YAAO;SAAU;QAE1D,mDAAmD;QACnD,cAAc;YACZ;YACA;YACA;YACA;YACA;SACD;QAED,2BAA2B;QAC3B,QAAQ;YACN;YACA;SACD;QAED,kDAAkD;QAClD,YAAY;YACV,gBAAgB;YAChB;YACA,YAAY;YACZ;YACA,iBAAiB;YACjB;YACA,eAAe;YACf;SAID;QAED,SAAS;YAAC;YAAS;SAAO;QAC1B,iBAAiB;YAAC;SAAY;QAE9B,gBAAgB,QAAQ,GAAG,CAAC,qBAAqB,IAAI;QAErD,UAAU;YACR,UAAU;YACV,YAAY;YACZ,iBAAiB;YACjB,SAAS;QACX;IACF,EAAE;IAEM,QAAgB;IAExB,YACE,OAAgB,CAChB;QACA,KAAK;QACL,6CAA6C;QAC7C,IAAI,CAAC,OAAO,GAAG,WAAW,QAAQ,GAAG,CAAC,qBAAqB,IAAI;IACjE;IAEA;;;;;;;GAOC,GACD,MAAc,2BACZ,SAAiB,EACjB,WAAgB,EAChB,OAAgB,EAWf;QACD,MAAM,aAAa;QACnB,MAAM,oBAAoB;YAAC;YAAK;YAAK;YAAK;YAAK;SAAI;QACnD,MAAM,YAAY,KAAK,GAAG;QAE1B,IAAK,IAAI,UAAU,GAAG,UAAU,YAAY,UAAW;YACrD,IAAI;gBACF,MAAM,WAAW,MAAM,MAAM,WAAW;oBACtC,QAAQ;oBACR,SAAS;wBACP,gBAAgB;oBAClB;oBACA,MAAM,KAAK,SAAS,CAAC;oBACrB,QAAQ,YAAY,OAAO,CAAC;gBAC9B;gBAEA,MAAM,OAAO,MAAM,SAAS,IAAI;gBAChC,MAAM,OAAO,OAAO,KAAK,KAAK,CAAC,QAAQ,CAAC;gBACxC,MAAM,YAAY,KAAK,GAAG,KAAK;gBAE/B,eAAe;gBACf,IAAI,SAAS,EAAE,IAAI,KAAK,KAAK,KAAK,MAAM;oBACtC,OAAO;wBACL,SAAS;wBACT,OAAO;wBACP,QAAQ,SAAS,MAAM;wBACvB,eAAe;wBACf,gBAAgB;wBAChB;wBACA;oBACF;gBACF;gBAEA,2BAA2B;gBAC3B,MAAM,cAAc,kBAAkB,QAAQ,CAAC,SAAS,MAAM;gBAC9D,MAAM,cAAc,SAAS,MAAM,KAAK;gBAExC,iDAAiD;gBACjD,IAAI,CAAC,eAAe,YAAY,aAAa,GAAG;oBAC9C,MAAM,eAAe,KAAK,OAAO,IAAI,KAAK,MAAM,IAAI,KAAK,KAAK,IAAI,CAAC,KAAK,EAAE,SAAS,MAAM,EAAE;oBAC3F,MAAM,YAAY,KAAK,SAAS,IAAI,KAAK,IAAI,IAAI,CAAC,cAAc,eAAe,qBAAqB;oBAEpG,OAAO;wBACL,SAAS;wBACT,OAAO;wBACP,QAAQ,SAAS,MAAM;wBACvB;wBACA;wBACA,eAAe;wBACf,gBAAgB;wBAChB;wBACA;oBACF;gBACF;gBAEA,iCAAiC;gBACjC,MAAM,QAAQ,MAAM,KAAK,GAAG,CAAC,GAAG,UAAU,sBAAsB;gBAChE,OAAO,IAAI,CAAC;oBACV,WAAW;oBACX,SAAS,UAAU;oBACnB;oBACA,QAAQ,SAAS,MAAM;oBACvB;oBACA;oBACA,KAAK;gBACP;gBACA,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;YAEnD,EAAE,OAAO,OAAY;gBACnB,MAAM,YAAY,KAAK,GAAG,KAAK;gBAC/B,MAAM,YAAY,OAAO,SAAS,gBAAgB,OAAO,SAAS,cAAc,SAAS;gBACzF,MAAM,iBAAiB,OAAO,SAAS,cAAc,SAAS,cACxC,OAAO,SAAS,cAAc,SAAS,YACvC,OAAO,SAAS,cAAc,SAAS;gBAE7D,+CAA+C;gBAC/C,IAAI,CAAC,aAAa,cAAc,KAAK,UAAU,aAAa,GAAG;oBAC7D,MAAM,QAAQ,MAAM,KAAK,GAAG,CAAC,GAAG;oBAChC,OAAO,IAAI,CAAC;wBACV,WAAW;wBACX,SAAS,UAAU;wBACnB;wBACA,OAAO,OAAO;wBACd;wBACA;wBACA,KAAK;oBACP;oBACA,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;oBACjD;gBACF;gBAEA,oCAAoC;gBACpC,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,QAAQ;oBACR,WAAW,YAAY,YAAY,iBAAiB,kBAAkB;oBACtE,cAAc,OAAO,WAAW;oBAChC,eAAe;oBACf,gBAAgB,aAAa;oBAC7B;gBACF;YACF;QACF;QAEA,yDAAyD;QACzD,OAAO;YACL,SAAS;YACT,OAAO;YACP,QAAQ;YACR,WAAW;YACX,cAAc;YACd,eAAe;YACf,gBAAgB;YAChB,WAAW,KAAK,GAAG,KAAK;QAC1B;IACF;IAEA;;;;;GAKC,GACD,MAAM,OACJ,OAAe,EACf,YAAiC,EACJ;QAC7B,MAAM,QAAQ,KAAK,GAAG;QAEtB,wBAAwB;QACxB,MAAM,aAAa,IAAI,CAAC,oBAAoB,CAAC;QAC7C,IAAI,CAAC,WAAW,KAAK,EAAE;YACrB,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,OAAO,WAAW,KAAK;gBACvB,eAAe,IAAI,CAAC,EAAE;gBACtB,YAAY,IAAI,OAAO,WAAW;YACpC;QACF;QAEA,IAAI;YACF,wDAAwD;YACxD,MAAM,EAAE,eAAe,EAAE,GAAG;YAC5B,MAAM,cAAc,gBAAgB;YAEpC,IAAI,CAAC,YAAY,KAAK,IAAI,CAAC,YAAY,MAAM,EAAE;gBAC7C,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,OAAO,YAAY,KAAK,IAAI;oBAC5B,eAAe,IAAI,CAAC,EAAE;oBACtB,YAAY,IAAI,OAAO,WAAW;gBACpC;YACF;YAEA,MAAM,SAAS,YAAY,MAAM;YAEjC,iEAAiE;YACjE,kGAAkG;YAClG,MAAM,UAAU,aAAa,QAAQ,EAAE,WAAW,wCAAwC;YAE1F,iEAAiE;YACjE,0DAA0D;YAC1D,IAAI;YACJ,IAAI,SAAS;gBACX,0DAA0D;gBAC1D,6EAA6E;gBAC7E,MAAM,gBAAgB,aAAa,QAAQ,CAAC,KAAK,CAAC;gBAClD,IAAI,eAAe;oBACjB,MAAM,GAAG,eAAe,SAAS,MAAM,GAAG;oBAC1C,MAAM,cAAsC;wBAC1C,IAAI,GAAG,cAAc,CAAC,EAAE,QAAQ,CAAC,EAAE,MAAM,WAAW,IAAI;wBACxD;wBACA;wBACA;wBACA,wBAAwB;wBACxB,SAAS;oBACX;oBACA,oBAAoB,mCAAmC;oBACvD,OAAO,IAAI,CAAC;wBACV,WAAW;wBACX,SAAS;wBACT,eAAe,YAAY,EAAE;wBAC7B,wBAAwB;wBACxB,KAAK;oBACP;gBACF,OAAO;oBACL,kEAAkE;oBAClE,oBAAoB;gBACtB;YACF,OAAO;gBACL,4CAA4C;gBAC5C,oBAAoB;YACtB;YAEA,kDAAkD;YAClD,MAAM,iBAAiB;gBACrB,aAAa;gBACb,QAAQ,kBAAkB,MAAM,IAAI;gBACpC,SAAS,OAAO,OAAO,IAAI,kBAAkB,OAAO;gBACpD,SAAS;oBACP,WAAW,OAAO,SAAS;oBAC3B,eAAe;wBACb,MAAM,OAAO,aAAa,CAAC,IAAI;wBAC/B,IAAI,OAAO,aAAa,CAAC,EAAE;wBAC3B,OAAO,OAAO,aAAa,CAAC,KAAK;wBACjC,YAAY,OAAO,aAAa,CAAC,UAAU;wBAC3C,aAAa,OAAO,aAAa,CAAC,WAAW;wBAC7C,OAAO,OAAO,aAAa,CAAC,KAAK;oBACnC;gBACF;YACF;YAEA,oFAAoF;YACpF,MAAM,sBAAsB;gBAC1B,QAAQ,kBAAkB,MAAM;gBAChC,SAAS,kBAAkB,OAAO;gBAClC,mBAAmB,kBAAkB,iBAAiB;gBACtD,UAAU,kBAAkB,QAAQ;gBACpC,aAAa,kBAAkB,WAAW,IAAI;gBAC9C,UAAU,kBAAkB,QAAQ,IAAI;gBACxC,OAAO,kBAAkB,KAAK;gBAC9B,mBAAmB,kBAAkB,iBAAiB,IAAI;gBAC1D,OAAO,kBAAkB,KAAK;YAChC;YAEA,uDAAuD;YACvD,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC;YAC1C,MAAM,cAAc;gBAClB;gBACA;YACF;YAEA,sDAAsD;YACtD,OAAO,IAAI,CAAC;gBACV,WAAW;gBACX;gBACA,SAAS,oBAAoB,OAAO;gBACpC,OAAO,oBAAoB,KAAK;gBAChC,KAAK;gBACL,KAAK;YACP;YAEA,sCAAsC;YACtC,MAAM,SAAS,MAAM,IAAI,CAAC,0BAA0B,CAClD,WACA,aACA;YAGF,MAAM,UAAU,OAAO,SAAS;YAEhC,iBAAiB;YACjB,IAAI,OAAO,OAAO,IAAI,OAAO,KAAK,EAAE;gBAClC,OAAO,IAAI,CAAC;oBAAE,WAAW,OAAO,SAAS;gBAAC,GAAG;gBAC7C,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,iBAAiB,OAAO,IAAI,EAAE,mBAAmB,OAAO,IAAI,EAAE;oBAC9D,eAAe,IAAI,CAAC,EAAE;oBACtB,YAAY,IAAI,OAAO,WAAW;gBACpC;YACF;YAEA,8EAA8E;YAC9E,MAAM,iBAAiB,OAAO,SAAS,IAAI;YAC3C,MAAM,oBAAoB,OAAO,YAAY,IAAI;YAEjD,sCAAsC;YACtC,IAAI,YAAY;YAChB,IAAI,OAAO,aAAa,IAAI,mBAAmB,cAAc;gBAC3D,YAAY;YACd,OAAO,IAAI,OAAO,cAAc,EAAE;gBAChC,YAAY;YACd,OAAO,IAAI,mBAAmB,qBAAqB,OAAO,MAAM,KAAK,KAAK;gBACxE,YAAY;YACd,OAAO,IAAI,OAAO,MAAM,KAAK,KAAK;gBAChC,YAAY;YACd;YAEA,OAAO,KAAK,CAAC;gBACX,QAAQ,OAAO,MAAM;gBACrB,WAAW;gBACX,cAAc;gBACd;gBACA,eAAe,OAAO,aAAa;gBACnC,gBAAgB,OAAO,cAAc;gBACrC,WAAW,OAAO,SAAS;YAC7B,GAAG;YAEH,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,OAAO;gBACP,cAAc;oBACZ,OAAO;oBACP,WAAW;oBACX,YAAY,OAAO,MAAM;oBACzB;oBACA,eAAe,OAAO,aAAa;oBACnC,gBAAgB,OAAO,cAAc;oBACrC,eAAe,OAAO,IAAI;gBAC5B;gBACA,eAAe,IAAI,CAAC,EAAE;gBACtB,YAAY,IAAI,OAAO,WAAW;YACpC;QACF,EAAE,OAAO,OAAO;YACd,MAAM,UAAU,KAAK,GAAG,KAAK;YAC7B,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;YAC9D,MAAM,YAAY,iBAAiB,SAAS,CAAC,MAAM,IAAI,KAAK,gBAAgB,aAAa,WAAW,GAAG,QAAQ,CAAC,UAAU;YAE1H,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;gBAAE;gBAAO;gBAAc;gBAAS;YAAU,GAAG;YAEpE,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,OAAO,YAAY,0BAA0B;gBAC7C,eAAe,IAAI,CAAC,EAAE;gBACtB,YAAY,IAAI,OAAO,WAAW;YACpC;QACF;IACF;IAEA;;;;GAIC,GACD,MAAM,YAAwC;QAC5C,MAAM,QAAQ,KAAK,GAAG;QAEtB,IAAI;YACF,gDAAgD;YAChD,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,oBAAoB,CAAC;YAEvD,MAAM,WAAW,MAAM,MAAM,WAAW;gBACtC,QAAQ;gBACR,SAAS;oBACP,gBAAgB;gBAClB;gBACA,QAAQ,YAAY,OAAO,CAAC;YAC9B;YAEA,MAAM,UAAU,KAAK,GAAG,KAAK;YAE7B,IAAI,SAAS,EAAE,EAAE;gBACf,MAAM,OAAO,MAAM,SAAS,IAAI;gBAEhC,oDAAoD;gBACpD,MAAM,cAAc,KAAK,QAAQ,IAAI,MAAM,OAAO,CAAC,KAAK,QAAQ,KAAK,KAAK,QAAQ,CAAC,MAAM,GAAG;gBAC5F,MAAM,YAAY,KAAK,MAAM,IAAI,MAAM,OAAO,CAAC,KAAK,MAAM,KAAK,KAAK,MAAM,CAAC,MAAM,GAAG;gBAEpF,IAAI,eAAe,WAAW;oBAC5B,OAAO;wBACL,SAAS;wBACT;wBACA,aAAa,IAAI,OAAO,WAAW;wBACnC,cAAc;4BACZ,UAAU,KAAK,QAAQ,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ;4BAC/C,QAAQ,KAAK,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM;4BACzC,SAAS,KAAK,OAAO,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO;wBAC9C;oBACF;gBACF;gBAEA,8CAA8C;gBAC9C,OAAO;oBACL,SAAS;oBACT;oBACA,aAAa,IAAI,OAAO,WAAW;oBACnC,OAAO;oBACP,cAAc;wBACZ,UAAU,IAAI,CAAC,MAAM,CAAC,QAAQ;wBAC9B,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM;wBAC1B,SAAS,IAAI,CAAC,MAAM,CAAC,OAAO;oBAC9B;gBACF;YACF;YAEA,mBAAmB;YACnB,MAAM,YAAY,MAAM,SAAS,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,KAAK,EAAE,SAAS,MAAM,EAAE;YAC7E,OAAO;gBACL,SAAS;gBACT;gBACA,aAAa,IAAI,OAAO,WAAW;gBACnC,OAAO;gBACP,cAAc;oBACZ,UAAU,IAAI,CAAC,MAAM,CAAC,QAAQ;oBAC9B,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM;oBAC1B,SAAS,IAAI,CAAC,MAAM,CAAC,OAAO;gBAC9B;YACF;QACF,EAAE,OAAO,OAAO;YACd,MAAM,UAAU,KAAK,GAAG,KAAK;YAC7B,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;YAC9D,MAAM,YAAY,iBAAiB,SAAS,CAAC,MAAM,IAAI,KAAK,gBAAgB,aAAa,WAAW,GAAG,QAAQ,CAAC,UAAU;YAE1H,OAAO;gBACL,SAAS;gBACT;gBACA,aAAa,IAAI,OAAO,WAAW;gBACnC,OAAO,YAAY,yBAAyB;gBAC5C,cAAc;oBACZ,UAAU,IAAI,CAAC,MAAM,CAAC,QAAQ;oBAC9B,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM;oBAC1B,SAAS,IAAI,CAAC,MAAM,CAAC,OAAO;gBAC9B;YACF;QACF;IACF;IAEA;;;;GAIC,GACD,MAAM,WAAW,OAAe,EAAE,KAAa,EAAE;QAC/C,+DAA+D;QAC/D,8CAA8C;QAC9C,OAAO;IACT;IAEA;;;GAGC,GACD,SAAS,OAAe,EAAE,KAAa,EAAE,MAAc,EAAE,cAAuB,EAAW;QACzF,OAAO,KAAK,CAAC,SAAS,SAAS,OAAO,QAAQ;IAChD;AACF;AAEA;;CAEC,GACD,IAAI,mBAA4C;AAKzC,SAAS;IACd,IAAI,CAAC,kBAAkB;QACrB,mBAAmB,IAAI;IACzB;IACA,OAAO;AACT"}},
    {"offset": {"line": 5806, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/x402rs-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// X402RS FACILITATOR\r\n// =============================================================================\r\n// Rust-based x402 facilitator operated by the x402 community\r\n// Public hosted endpoint: https://facilitator.x402.rs\r\n// Can also be self-hosted via Docker: https://github.com/x402-rs/x402-rs\r\n// Supported networks: Base, Base Sepolia, XDC, Solana (configurable)\r\n\r\nimport {\r\n  BaseFacilitator,\r\n  type IFacilitator,\r\n  type PaymentRequirements,\r\n  type VerificationResult,\r\n  type FacilitatorHealth,\r\n  type FacilitatorConfig,\r\n  type CAIPNetworkId,\r\n  type CAIPAssetId,\r\n  type SettlementMode,\r\n} from './base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\nconst logger = createLogger({ component: 'X402rsFacilitator' });\r\n\r\n/**\r\n * Build X402rs-specific payment requirements for probe mode\r\n * Uses known-good values that X402rs expects\r\n */\r\nfunction buildX402rsProbePaymentRequirements(config: FacilitatorProbeConfig): PaymentRequirements {\r\n  // USDC contract address on Base\r\n  const USDC_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';\r\n  // USDC on Base Sepolia (testnet)\r\n  const USDC_BASE_SEPOLIA = '0x036CbD53842c5426634e7929541eC2318f3dCF7e';\r\n  \r\n  // Determine asset based on network\r\n  let asset = USDC_BASE;\r\n  if (config.network === 'eip155:84532') {\r\n    asset = USDC_BASE_SEPOLIA;\r\n  }\r\n  \r\n  // Use a test receiver address for probes\r\n  const PROBE_RECEIVER = '0x0000000000000000000000000000000000000001';\r\n  \r\n  return {\r\n    scheme: 'x402',\r\n    network: config.network,\r\n    asset,\r\n    maxAmountRequired: '1', // Minimal amount (1 atomic unit)\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    payTo: PROBE_RECEIVER,\r\n    maxTimeoutSeconds: 10,\r\n    settlementMode: 'immediate',\r\n  };\r\n}\r\n\r\n/**\r\n * X402rs Facilitator\r\n * \r\n * Rust-based community facilitator with public hosted endpoint.\r\n * Public URL: https://facilitator.x402.rs\r\n * GitHub: https://github.com/x402-rs/x402-rs\r\n * \r\n * Supports Base, Base Sepolia, XDC, and Solana networks.\r\n */\r\nexport class X402rsFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'x402rs';\r\n  readonly name = 'X402rs Facilitator';\r\n\r\n  readonly config: FacilitatorConfig = {\r\n    id: 'x402rs',\r\n    name: 'X402rs Facilitator',\r\n    enabled: process.env.X402RS_ENABLED !== 'false', // Enabled by default\r\n    priority: 2, // Same priority tier as PayAI\r\n    \r\n    // Legacy network identifiers\r\n    networks: ['base', 'base-sepolia', 'xdc'],\r\n    \r\n    // CAIP-2 network identifiers\r\n    networksCAIP: [\r\n      'eip155:84532',  // Base Sepolia (testnet)\r\n      'eip155:8453',   // Base mainnet\r\n      'xdc:50',        // XDC mainnet\r\n    ],\r\n    \r\n    // Legacy asset identifiers (include both contract addresses and symbols for probe compatibility)\r\n    assets: [\r\n      'USDC', // Symbol alias for probes\r\n      '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base mainnet\r\n      '0x036CbD53842c5426634e7929541eC2318f3dCF7e', // USDC on Base Sepolia\r\n    ],\r\n    \r\n    // CAIP-19 asset identifiers\r\n    assetsCAIP: [\r\n      'eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',   // USDC on Base mainnet\r\n      'eip155:84532/erc20:0x036CbD53842c5426634e7929541eC2318f3dCF7e',  // USDC on Base Sepolia\r\n    ],\r\n    \r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'],\r\n    \r\n    healthCheckUrl: process.env.X402RS_FACILITATOR_URL || 'https://facilitator.x402.rs',\r\n    \r\n    metadata: {\r\n      provider: 'x402 Community',\r\n      label: 'X402rs Facilitator',\r\n      url: 'https://facilitator.x402.rs',\r\n      website: 'https://x402.org',\r\n      rustBased: true,\r\n      openSource: true,\r\n      complianceLevel: 'community',\r\n    },\r\n  };\r\n\r\n  private baseUrl: string;\r\n\r\n  constructor(baseUrl?: string) {\r\n    super();\r\n    this.baseUrl = baseUrl || process.env.X402RS_FACILITATOR_URL || 'https://facilitator.x402.rs';\r\n  }\r\n\r\n  /**\r\n   * Get the facilitator URL\r\n   */\r\n  getUrl(): string {\r\n    return this.baseUrl;\r\n  }\r\n\r\n  /**\r\n   * Call X402rs /verify endpoint with retry logic for transient errors\r\n   */\r\n  private async callX402rsVerifyWithRetries(\r\n    verifyUrl: string,\r\n    requestBody: any,\r\n    isProbe: boolean\r\n  ): Promise<{\r\n    success: boolean;\r\n    valid: boolean;\r\n    status: number;\r\n    errorType?: string;\r\n    errorMessage?: string;\r\n    isRateLimited: boolean;\r\n    isNetworkError: boolean;\r\n    latencyMs: number;\r\n    data?: any;\r\n  }> {\r\n    const maxRetries = 3;\r\n    const retryableStatuses = [429, 500, 502, 503, 504];\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const response = await fetch(verifyUrl, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify(requestBody),\r\n          signal: AbortSignal.timeout(10000), // 10 second timeout\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data = text ? JSON.parse(text) : {};\r\n        const latencyMs = Date.now() - startTime;\r\n\r\n        // Success case\r\n        if (response.ok && data.valid === true) {\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            status: response.status,\r\n            isRateLimited: false,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Check if retryable error\r\n        const isRetryable = retryableStatuses.includes(response.status);\r\n        const isRateLimit = response.status === 429;\r\n        \r\n        // If not retryable or last attempt, return error\r\n        if (!isRetryable || attempt === maxRetries - 1) {\r\n          const errorMessage = data.message || data.reason || data.error || `HTTP ${response.status}`;\r\n          const errorType = data.errorType || data.code || (isRateLimit ? 'rate_limit' : 'X402RS_VERIFY_FAILED');\r\n          \r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            status: response.status,\r\n            errorType,\r\n            errorMessage,\r\n            isRateLimited: isRateLimit,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Retry with exponential backoff\r\n        const delay = 100 * Math.pow(2, attempt);\r\n        logger.info({\r\n          component: 'X402rsFacilitator',\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          status: response.status,\r\n          delay,\r\n          isProbe,\r\n          msg: 'Retrying X402rs verification after transient error',\r\n        });\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        \r\n      } catch (error: any) {\r\n        const latencyMs = Date.now() - startTime;\r\n        const isTimeout = error?.name === 'AbortError' || error?.message?.toLowerCase().includes('timeout');\r\n        const isNetworkError = error?.message?.toLowerCase().includes('network') || \r\n                              error?.message?.toLowerCase().includes('fetch') ||\r\n                              error?.message?.toLowerCase().includes('econnrefused');\r\n        \r\n        if ((isTimeout || isNetworkError) && attempt < maxRetries - 1) {\r\n          const delay = 100 * Math.pow(2, attempt);\r\n          logger.info({\r\n            component: 'X402rsFacilitator',\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error?.message,\r\n            delay,\r\n            isProbe,\r\n            msg: 'Retrying X402rs verification after network error',\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n        \r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          status: 0,\r\n          errorType: isTimeout ? 'timeout' : isNetworkError ? 'network_error' : 'X402RS_VERIFY_FAILED',\r\n          errorMessage: error?.message || 'X402rs verification failed',\r\n          isRateLimited: false,\r\n          isNetworkError: isTimeout || isNetworkError,\r\n          latencyMs,\r\n        };\r\n      }\r\n    }\r\n    \r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      status: 0,\r\n      errorType: 'X402RS_VERIFY_FAILED',\r\n      errorMessage: 'Max retries exceeded',\r\n      isRateLimited: false,\r\n      isNetworkError: false,\r\n      latencyMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify payment using X402rs facilitator\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    const start = Date.now();\r\n\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Parse payment header\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Detect probe mode\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n      \r\n      // Build payment payload\r\n      const paymentPayload = {\r\n        x402Version: 2,\r\n        scheme: requirements.scheme || 'x402',\r\n        network: parsed.network || requirements.network,\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: {\r\n            from: parsed.authorization.from,\r\n            to: parsed.authorization.to,\r\n            value: parsed.authorization.value,\r\n            validAfter: parsed.authorization.validAfter,\r\n            validBefore: parsed.authorization.validBefore,\r\n            nonce: parsed.authorization.nonce,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Build payment requirements\r\n      const paymentRequirements = {\r\n        scheme: requirements.scheme,\r\n        network: requirements.network,\r\n        maxAmountRequired: requirements.maxAmountRequired,\r\n        resource: requirements.resource,\r\n        description: requirements.description || '',\r\n        mimeType: requirements.mimeType || 'application/json',\r\n        payTo: requirements.payTo,\r\n        maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n        asset: requirements.asset,\r\n      };\r\n\r\n      // POST to X402rs verification endpoint\r\n      const verifyUrl = `${this.baseUrl}/verify`;\r\n      const requestBody = {\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      };\r\n\r\n      logger.info({\r\n        component: 'X402rsFacilitator',\r\n        isProbe,\r\n        network: paymentRequirements.network,\r\n        asset: paymentRequirements.asset,\r\n        url: verifyUrl,\r\n        facilitatorId: this.id,\r\n        facilitatorUrl: this.baseUrl,\r\n        msg: 'Sending X402rs /verify request',\r\n      });\r\n\r\n      // Call with retry logic\r\n      const result = await this.callX402rsVerifyWithRetries(verifyUrl, requestBody, isProbe);\r\n\r\n      // Handle success\r\n      if (result.success && result.valid) {\r\n        logger.info({\r\n          component: 'X402rsFacilitator',\r\n          facilitatorId: this.id,\r\n          facilitatorUrl: this.baseUrl,\r\n          latencyMs: result.latencyMs,\r\n          network: requirements.network,\r\n          msg: 'Payment verified successfully by X402rs',\r\n        });\r\n        return {\r\n          success: true,\r\n          valid: true,\r\n          transactionHash: result.data?.transactionHash || result.data?.txHash,\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Handle error\r\n      const errorType = result.errorType || 'X402RS_VERIFY_FAILED';\r\n      const errorMessage = result.errorMessage || 'X402rs verification failed';\r\n      \r\n      let errorCode = 'facilitator_error';\r\n      if (result.isRateLimited || errorType === 'rate_limit') {\r\n        errorCode = 'rate_limited';\r\n      } else if (result.isNetworkError) {\r\n        errorCode = 'network_error';\r\n      } else if (errorType === 'invalid_request' || result.status === 400) {\r\n        errorCode = 'invalid_request';\r\n      }\r\n\r\n      logger.debug({\r\n        component: 'X402rsFacilitator',\r\n        facilitatorId: this.id,\r\n        status: result.status,\r\n        errorType,\r\n        errorMessage,\r\n        errorCode,\r\n        isRateLimited: result.isRateLimited,\r\n        isNetworkError: result.isNetworkError,\r\n        latencyMs: result.latencyMs,\r\n        msg: 'X402rs verification failed',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: errorMessage,\r\n        errorDetails: {\r\n          error: errorMessage,\r\n          errorType,\r\n          httpStatus: result.status,\r\n          errorCode,\r\n          isRateLimited: result.isRateLimited,\r\n          isNetworkError: result.isNetworkError,\r\n          x402rsResponse: result.data,\r\n        },\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'X402rs verification error');\r\n      \r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: isTimeout ? 'X402RS_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get X402rs facilitator health\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // X402rs health check endpoint\r\n      const healthUrl = `${this.baseUrl}/health`;\r\n      \r\n      const response = await fetch(healthUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n\r\n      const latency = Date.now() - start;\r\n\r\n      if (response.ok) {\r\n        let data: any = {};\r\n        try {\r\n          data = await response.json();\r\n        } catch {\r\n          // Health endpoint might return simple OK\r\n        }\r\n\r\n        return {\r\n          healthy: true,\r\n          latency,\r\n          lastChecked: new Date().toISOString(),\r\n          capabilities: {\r\n            networks: data.networks || this.config.networks,\r\n            assets: data.assets || this.config.assets,\r\n            schemes: data.schemes || this.config.schemes,\r\n          },\r\n        };\r\n      }\r\n\r\n      const errorText = await response.text().catch(() => `HTTP ${response.status}`);\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: errorText,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Health check failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: isTimeout ? 'Health check timeout' : errorMessage,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing information (not available for X402rs yet)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    // TODO: Implement if X402rs provides pricing API\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\r\n    return super.supports(network, asset, scheme, settlementMode);\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet x402rsFacilitator: X402rsFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton X402rs facilitator instance\r\n */\r\nexport function getX402rsFacilitator(): X402rsFacilitator {\r\n  if (!x402rsFacilitator) {\r\n    x402rsFacilitator = new X402rsFacilitator();\r\n  }\r\n  return x402rsFacilitator;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6262, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/dexter-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// DEXTER FACILITATOR\r\n// =============================================================================\r\n// Solana-native x402 facilitator operated by Dexter\r\n// Public hosted endpoint: https://facilitator.dexter.cash\r\n// Standard x402 endpoints: /verify and /settle\r\n// Supports Solana mainnet and devnet networks\r\n\r\nimport {\r\n  BaseFacilitator,\r\n  type IFacilitator,\r\n  type PaymentRequirements,\r\n  type VerificationResult,\r\n  type FacilitatorHealth,\r\n  type FacilitatorConfig,\r\n  type CAIPNetworkId,\r\n  type CAIPAssetId,\r\n  type SettlementMode,\r\n} from './base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\nconst logger = createLogger({ component: 'DexterFacilitator' });\r\n\r\n/**\r\n * Dexter verify request body shape\r\n * Standard x402 payment verification format\r\n */\r\nexport interface DexterVerifyRequest {\r\n  paymentPayload: {\r\n    x402Version: number;\r\n    scheme: string;\r\n    network: string;\r\n    payload: {\r\n      signature: string;\r\n      authorization: {\r\n        from: string;\r\n        to: string;\r\n        value: string;\r\n        validAfter: string;\r\n        validBefore: string;\r\n        nonce: string;\r\n      };\r\n    };\r\n  };\r\n  paymentRequirements: {\r\n    scheme: string;\r\n    network: string;\r\n    maxAmountRequired: string;\r\n    resource: string;\r\n    description: string;\r\n    mimeType: string;\r\n    payTo: string;\r\n    maxTimeoutSeconds: number;\r\n    asset: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Dexter settle request body shape\r\n * Standard x402 settlement format\r\n */\r\nexport interface DexterSettleRequest {\r\n  paymentPayload: {\r\n    x402Version: number;\r\n    scheme: string;\r\n    network: string;\r\n    payload: {\r\n      signature: string;\r\n      authorization: {\r\n        from: string;\r\n        to: string;\r\n        value: string;\r\n        validAfter: string;\r\n        validBefore: string;\r\n        nonce: string;\r\n      };\r\n    };\r\n  };\r\n  paymentRequirements: {\r\n    scheme: string;\r\n    network: string;\r\n    maxAmountRequired: string;\r\n    resource: string;\r\n    description: string;\r\n    mimeType: string;\r\n    payTo: string;\r\n    maxTimeoutSeconds: number;\r\n    asset: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Facilitator verify result shape\r\n */\r\nexport interface FacilitatorVerifyResult {\r\n  success: boolean;\r\n  valid: boolean;\r\n  transactionHash?: string;\r\n  error?: string;\r\n  errorDetails?: Record<string, any>;\r\n  facilitatorId: string;\r\n  verifiedAt: string;\r\n}\r\n\r\n/**\r\n * Facilitator settle result shape\r\n */\r\nexport interface FacilitatorSettleResult {\r\n  success: boolean;\r\n  settled: boolean;\r\n  transactionHash?: string;\r\n  error?: string;\r\n  errorDetails?: Record<string, any>;\r\n  facilitatorId: string;\r\n  settledAt: string;\r\n}\r\n\r\n/**\r\n * Build Dexter-specific payment requirements for probe mode\r\n * Uses known-good values that Dexter expects\r\n */\r\nfunction buildDexterProbePaymentRequirements(config: FacilitatorProbeConfig): PaymentRequirements {\r\n  // USDC on Solana mainnet (SPL token mint address)\r\n  const USDC_SOLANA_MAINNET = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';\r\n  // USDC on Solana devnet (SPL token mint address)\r\n  const USDC_SOLANA_DEVNET = '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU';\r\n  \r\n  // Determine asset based on network\r\n  let asset = USDC_SOLANA_MAINNET;\r\n  if (config.network === 'solana:102' || config.network === 'solana:devnet') {\r\n    asset = USDC_SOLANA_DEVNET;\r\n  }\r\n  \r\n  // Use a test receiver address for probes\r\n  const PROBE_RECEIVER = '11111111111111111111111111111111'; // System program (placeholder)\r\n  \r\n  return {\r\n    scheme: 'x402',\r\n    network: config.network,\r\n    asset,\r\n    maxAmountRequired: '1', // Minimal amount (1 atomic unit)\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    payTo: PROBE_RECEIVER,\r\n    maxTimeoutSeconds: 10,\r\n    settlementMode: 'immediate',\r\n  };\r\n}\r\n\r\n/**\r\n * Dexter Facilitator\r\n * \r\n * Solana-native community facilitator with public hosted endpoint.\r\n * Public URL: https://facilitator.dexter.cash\r\n * \r\n * Supports Solana mainnet and devnet networks.\r\n */\r\nexport class DexterFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'dexter';\r\n  readonly name = 'Dexter Facilitator';\r\n\r\n  readonly config: FacilitatorConfig = {\r\n    id: 'dexter',\r\n    name: 'Dexter Facilitator',\r\n    enabled: process.env.DEXTER_ENABLED !== 'false', // Enabled by default\r\n    priority: 2, // Same priority tier as X402rs/PayAI for auto-routing\r\n    \r\n    // Legacy network identifiers\r\n    networks: ['solana', 'solana-mainnet', 'solana-devnet'],\r\n    \r\n    // CAIP-2 network identifiers\r\n    networksCAIP: [\r\n      'solana:101',    // Solana mainnet\r\n      'solana:102',    // Solana devnet\r\n      'solana:mainnet', // Legacy alias\r\n      'solana:devnet',  // Legacy alias\r\n    ],\r\n    \r\n    // Legacy asset identifiers (include both contract addresses and symbols for probe compatibility)\r\n    assets: [\r\n      'USDC', // Symbol alias for probes\r\n      'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC on Solana mainnet\r\n      '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU', // USDC on Solana devnet\r\n    ],\r\n    \r\n    // CAIP-19 asset identifiers\r\n    assetsCAIP: [\r\n      'solana:101/spl:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC on Solana mainnet\r\n      'solana:102/spl:4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU', // USDC on Solana devnet\r\n    ],\r\n    \r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'],\r\n    \r\n    healthCheckUrl: process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash',\r\n    \r\n    metadata: {\r\n      provider: 'Dexter',\r\n      label: 'Dexter Facilitator',\r\n      url: 'https://facilitator.dexter.cash',\r\n      website: 'https://dexter.cash',\r\n      solanaNative: true,\r\n      complianceLevel: 'community',\r\n      notes: 'Solana-native x402 facilitator',\r\n    },\r\n  };\r\n\r\n  private baseUrl: string;\r\n\r\n  constructor(baseUrl?: string) {\r\n    super();\r\n    this.baseUrl = baseUrl || process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash';\r\n  }\r\n\r\n  /**\r\n   * Get the facilitator URL\r\n   */\r\n  getUrl(): string {\r\n    return this.baseUrl;\r\n  }\r\n\r\n  /**\r\n   * Call Dexter /verify endpoint with retry logic for transient errors\r\n   */\r\n  private async callDexterVerifyWithRetries(\r\n    verifyUrl: string,\r\n    requestBody: DexterVerifyRequest,\r\n    isProbe: boolean\r\n  ): Promise<{\r\n    success: boolean;\r\n    valid: boolean;\r\n    status: number;\r\n    errorType?: string;\r\n    errorMessage?: string;\r\n    isRateLimited: boolean;\r\n    isNetworkError: boolean;\r\n    latencyMs: number;\r\n    data?: any;\r\n  }> {\r\n    const maxRetries = 3;\r\n    const retryableStatuses = [429, 500, 502, 503, 504];\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const response = await fetch(verifyUrl, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify(requestBody),\r\n          signal: AbortSignal.timeout(10000), // 10 second timeout\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data = text ? JSON.parse(text) : {};\r\n        const latencyMs = Date.now() - startTime;\r\n\r\n        // Success case\r\n        if (response.ok && data.valid === true) {\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            status: response.status,\r\n            isRateLimited: false,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Check if retryable error\r\n        const isRetryable = retryableStatuses.includes(response.status);\r\n        const isRateLimit = response.status === 429;\r\n        \r\n        // If not retryable or last attempt, return error\r\n        if (!isRetryable || attempt === maxRetries - 1) {\r\n          const errorMessage = data.message || data.reason || data.error || `HTTP ${response.status}`;\r\n          const errorType = data.errorType || data.code || (isRateLimit ? 'rate_limit' : 'DEXTER_VERIFY_FAILED');\r\n          \r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            status: response.status,\r\n            errorType,\r\n            errorMessage,\r\n            isRateLimited: isRateLimit,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Retry with exponential backoff\r\n        const delay = 100 * Math.pow(2, attempt);\r\n        logger.info({\r\n          component: 'DexterFacilitator',\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          status: response.status,\r\n          delay,\r\n          isProbe,\r\n          msg: 'Retrying Dexter verification after transient error',\r\n        });\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        \r\n      } catch (error: any) {\r\n        const latencyMs = Date.now() - startTime;\r\n        const isTimeout = error?.name === 'AbortError' || error?.message?.toLowerCase().includes('timeout');\r\n        const isNetworkError = error?.message?.toLowerCase().includes('network') || \r\n                              error?.message?.toLowerCase().includes('fetch') ||\r\n                              error?.message?.toLowerCase().includes('econnrefused');\r\n        \r\n        if ((isTimeout || isNetworkError) && attempt < maxRetries - 1) {\r\n          const delay = 100 * Math.pow(2, attempt);\r\n          logger.info({\r\n            component: 'DexterFacilitator',\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error?.message,\r\n            delay,\r\n            isProbe,\r\n            msg: 'Retrying Dexter verification after network error',\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n        \r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          status: 0,\r\n          errorType: isTimeout ? 'timeout' : isNetworkError ? 'network_error' : 'DEXTER_VERIFY_FAILED',\r\n          errorMessage: error?.message || 'Dexter verification failed',\r\n          isRateLimited: false,\r\n          isNetworkError: isTimeout || isNetworkError,\r\n          latencyMs,\r\n        };\r\n      }\r\n    }\r\n    \r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      status: 0,\r\n      errorType: 'DEXTER_VERIFY_FAILED',\r\n      errorMessage: 'Max retries exceeded',\r\n      isRateLimited: false,\r\n      isNetworkError: false,\r\n      latencyMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify payment using Dexter facilitator\r\n   * POST https://facilitator.dexter.cash/verify\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    const start = Date.now();\r\n\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Parse payment header\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Detect probe mode\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n      \r\n      // Build payment payload\r\n      const paymentPayload = {\r\n        x402Version: 2,\r\n        scheme: requirements.scheme || 'x402',\r\n        network: parsed.network || requirements.network,\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: {\r\n            from: parsed.authorization.from,\r\n            to: parsed.authorization.to,\r\n            value: parsed.authorization.value,\r\n            validAfter: parsed.authorization.validAfter,\r\n            validBefore: parsed.authorization.validBefore,\r\n            nonce: parsed.authorization.nonce,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Build payment requirements\r\n      const paymentRequirements = {\r\n        scheme: requirements.scheme,\r\n        network: requirements.network,\r\n        maxAmountRequired: requirements.maxAmountRequired,\r\n        resource: requirements.resource,\r\n        description: requirements.description || '',\r\n        mimeType: requirements.mimeType || 'application/json',\r\n        payTo: requirements.payTo,\r\n        maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n        asset: requirements.asset,\r\n      };\r\n\r\n      // POST to Dexter verification endpoint\r\n      const verifyUrl = `${this.baseUrl}/verify`;\r\n      const requestBody: DexterVerifyRequest = {\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      };\r\n\r\n      logger.info({\r\n        component: 'DexterFacilitator',\r\n        isProbe,\r\n        network: paymentRequirements.network,\r\n        asset: paymentRequirements.asset,\r\n        url: verifyUrl,\r\n        facilitatorId: this.id,\r\n        facilitatorUrl: this.baseUrl,\r\n        msg: 'Sending Dexter /verify request',\r\n      });\r\n\r\n      // Call with retry logic\r\n      const result = await this.callDexterVerifyWithRetries(verifyUrl, requestBody, isProbe);\r\n\r\n      // Handle success\r\n      if (result.success && result.valid) {\r\n        logger.info({\r\n          component: 'DexterFacilitator',\r\n          facilitatorId: this.id,\r\n          facilitatorUrl: this.baseUrl,\r\n          latencyMs: result.latencyMs,\r\n          network: requirements.network,\r\n          msg: 'Payment verified successfully by Dexter',\r\n        });\r\n        return {\r\n          success: true,\r\n          valid: true,\r\n          transactionHash: result.data?.transactionHash || result.data?.txHash,\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Handle error\r\n      const errorType = result.errorType || 'DEXTER_VERIFY_FAILED';\r\n      const errorMessage = result.errorMessage || 'Dexter verification failed';\r\n      \r\n      let errorCode = 'facilitator_error';\r\n      if (result.isRateLimited || errorType === 'rate_limit') {\r\n        errorCode = 'rate_limited';\r\n      } else if (result.isNetworkError) {\r\n        errorCode = 'network_error';\r\n      } else if (errorType === 'invalid_request' || result.status === 400) {\r\n        errorCode = 'invalid_request';\r\n      }\r\n\r\n      logger.debug({\r\n        component: 'DexterFacilitator',\r\n        facilitatorId: this.id,\r\n        status: result.status,\r\n        errorType,\r\n        errorMessage,\r\n        errorCode,\r\n        isRateLimited: result.isRateLimited,\r\n        isNetworkError: result.isNetworkError,\r\n        latencyMs: result.latencyMs,\r\n        msg: 'Dexter verification failed',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: errorMessage,\r\n        errorDetails: {\r\n          error: errorMessage,\r\n          errorType,\r\n          httpStatus: result.status,\r\n          errorCode,\r\n          isRateLimited: result.isRateLimited,\r\n          isNetworkError: result.isNetworkError,\r\n          dexterResponse: result.data,\r\n        },\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'Dexter verification error');\r\n      \r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: isTimeout ? 'DEXTER_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Settle payment using Dexter facilitator\r\n   * POST https://facilitator.dexter.cash/settle\r\n   */\r\n  async settle(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<FacilitatorSettleResult> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // Parse payment header\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          settled: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          settledAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Build payment payload\r\n      const paymentPayload = {\r\n        x402Version: 2,\r\n        scheme: requirements.scheme || 'x402',\r\n        network: parsed.network || requirements.network,\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: {\r\n            from: parsed.authorization.from,\r\n            to: parsed.authorization.to,\r\n            value: parsed.authorization.value,\r\n            validAfter: parsed.authorization.validAfter,\r\n            validBefore: parsed.authorization.validBefore,\r\n            nonce: parsed.authorization.nonce,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Build payment requirements\r\n      const paymentRequirements = {\r\n        scheme: requirements.scheme,\r\n        network: requirements.network,\r\n        maxAmountRequired: requirements.maxAmountRequired,\r\n        resource: requirements.resource,\r\n        description: requirements.description || '',\r\n        mimeType: requirements.mimeType || 'application/json',\r\n        payTo: requirements.payTo,\r\n        maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n        asset: requirements.asset,\r\n      };\r\n\r\n      // POST to Dexter settlement endpoint\r\n      const settleUrl = `${this.baseUrl}/settle`;\r\n      const requestBody: DexterSettleRequest = {\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      };\r\n\r\n      logger.info({\r\n        component: 'DexterFacilitator',\r\n        network: paymentRequirements.network,\r\n        asset: paymentRequirements.asset,\r\n        url: settleUrl,\r\n        facilitatorId: this.id,\r\n        facilitatorUrl: this.baseUrl,\r\n        msg: 'Sending Dexter /settle request',\r\n      });\r\n\r\n      const response = await fetch(settleUrl, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(requestBody),\r\n        signal: AbortSignal.timeout(30000), // 30 second timeout for settlement\r\n      });\r\n\r\n      const latencyMs = Date.now() - start;\r\n      const text = await response.text();\r\n      const data = text ? JSON.parse(text) : {};\r\n\r\n      if (response.ok && (data.settled === true || data.success === true)) {\r\n        logger.info({\r\n          component: 'DexterFacilitator',\r\n          facilitatorId: this.id,\r\n          facilitatorUrl: this.baseUrl,\r\n          latencyMs,\r\n          network: requirements.network,\r\n          transactionHash: data.transactionHash || data.txHash,\r\n          msg: 'Payment settled successfully by Dexter',\r\n        });\r\n        return {\r\n          success: true,\r\n          settled: true,\r\n          transactionHash: data.transactionHash || data.txHash,\r\n          facilitatorId: this.id,\r\n          settledAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const errorMessage = data.message || data.reason || data.error || `HTTP ${response.status}`;\r\n      logger.error({\r\n        component: 'DexterFacilitator',\r\n        facilitatorId: this.id,\r\n        status: response.status,\r\n        errorMessage,\r\n        latencyMs,\r\n        msg: 'Dexter settlement failed',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        settled: false,\r\n        error: errorMessage,\r\n        errorDetails: {\r\n          httpStatus: response.status,\r\n          dexterResponse: data,\r\n        },\r\n        facilitatorId: this.id,\r\n        settledAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Settlement failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'Dexter settlement error');\r\n      \r\n      return {\r\n        success: false,\r\n        settled: false,\r\n        error: isTimeout ? 'DEXTER_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        settledAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get Dexter facilitator health\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // Dexter health check endpoint\r\n      const healthUrl = `${this.baseUrl}/health`;\r\n      \r\n      const response = await fetch(healthUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n\r\n      const latency = Date.now() - start;\r\n\r\n      if (response.ok) {\r\n        let data: any = {};\r\n        try {\r\n          data = await response.json();\r\n        } catch {\r\n          // Health endpoint might return simple OK\r\n        }\r\n\r\n        return {\r\n          healthy: true,\r\n          latency,\r\n          lastChecked: new Date().toISOString(),\r\n          capabilities: {\r\n            networks: data.networks || this.config.networks,\r\n            assets: data.assets || this.config.assets,\r\n            schemes: data.schemes || this.config.schemes,\r\n          },\r\n        };\r\n      }\r\n\r\n      const errorText = await response.text().catch(() => `HTTP ${response.status}`);\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: errorText,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Health check failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: isTimeout ? 'Health check timeout' : errorMessage,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing information (not available for Dexter yet)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    // TODO: Implement if Dexter provides pricing API\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\r\n    return super.supports(network, asset, scheme, settlementMode);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// STANDALONE VERIFY/SETTLE FUNCTIONS\r\n// =============================================================================\r\n// These functions can be used directly without the facilitator class\r\n\r\n/**\r\n * Verify payment using Dexter facilitator\r\n * Direct function for standalone use\r\n */\r\nexport async function dexterVerify(payload: DexterVerifyRequest): Promise<FacilitatorVerifyResult> {\r\n  const baseUrl = process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash';\r\n  const verifyUrl = `${baseUrl}/verify`;\r\n  const start = Date.now();\r\n\r\n  try {\r\n    const response = await fetch(verifyUrl, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify(payload),\r\n      signal: AbortSignal.timeout(10000),\r\n    });\r\n\r\n    const latencyMs = Date.now() - start;\r\n    const text = await response.text();\r\n    const data = text ? JSON.parse(text) : {};\r\n\r\n    if (response.ok && data.valid === true) {\r\n      return {\r\n        success: true,\r\n        valid: true,\r\n        transactionHash: data.transactionHash || data.txHash,\r\n        facilitatorId: 'dexter',\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      error: data.message || data.error || `HTTP ${response.status}`,\r\n      errorDetails: {\r\n        httpStatus: response.status,\r\n        dexterResponse: data,\r\n        latencyMs,\r\n      },\r\n      facilitatorId: 'dexter',\r\n      verifiedAt: new Date().toISOString(),\r\n    };\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      error: errorMessage,\r\n      facilitatorId: 'dexter',\r\n      verifiedAt: new Date().toISOString(),\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Settle payment using Dexter facilitator\r\n * Direct function for standalone use\r\n */\r\nexport async function dexterSettle(payload: DexterSettleRequest): Promise<FacilitatorSettleResult> {\r\n  const baseUrl = process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash';\r\n  const settleUrl = `${baseUrl}/settle`;\r\n  const start = Date.now();\r\n\r\n  try {\r\n    const response = await fetch(settleUrl, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify(payload),\r\n      signal: AbortSignal.timeout(30000),\r\n    });\r\n\r\n    const latencyMs = Date.now() - start;\r\n    const text = await response.text();\r\n    const data = text ? JSON.parse(text) : {};\r\n\r\n    if (response.ok && (data.settled === true || data.success === true)) {\r\n      return {\r\n        success: true,\r\n        settled: true,\r\n        transactionHash: data.transactionHash || data.txHash,\r\n        facilitatorId: 'dexter',\r\n        settledAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      settled: false,\r\n      error: data.message || data.error || `HTTP ${response.status}`,\r\n      errorDetails: {\r\n        httpStatus: response.status,\r\n        dexterResponse: data,\r\n        latencyMs,\r\n      },\r\n      facilitatorId: 'dexter',\r\n      settledAt: new Date().toISOString(),\r\n    };\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Settlement failed';\r\n    return {\r\n      success: false,\r\n      settled: false,\r\n      error: errorMessage,\r\n      facilitatorId: 'dexter',\r\n      settledAt: new Date().toISOString(),\r\n    };\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet dexterFacilitator: DexterFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton Dexter facilitator instance\r\n */\r\nexport function getDexterFacilitator(): DexterFacilitator {\r\n  if (!dexterFacilitator) {\r\n    dexterFacilitator = new DexterFacilitator();\r\n  }\r\n  return dexterFacilitator;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6951, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/cronos-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// CRONOS X402 FACILITATOR\r\n// =============================================================================\r\n// Official Cronos Labs x402 facilitator for Cronos network payments.\r\n// Documentation: https://docs.cronos.org/cronos-x402-facilitator\r\n// Resources: https://docs.cronos.org/cronos-x402-facilitator/resources-and-next-steps\r\n//\r\n// Base URL: https://facilitator.cronoslabs.org\r\n// Health: GET /healthcheck\r\n// Verify: POST /v2/x402/verify\r\n// Settle: POST /v2/x402/settle\r\n// Discovery: GET /v2/x402/supported\r\n//\r\n// Network field values:\r\n// - \"cronos\" for mainnet (chain ID 25)\r\n// - \"cronos-testnet\" for testnet (chain ID 338)\r\n//\r\n// Rate limits: 5 requests per minute per IP for settle/verify\r\n\r\nimport {\r\n  BaseFacilitator,\r\n  type IFacilitator,\r\n  type PaymentRequirements,\r\n  type VerificationResult,\r\n  type FacilitatorHealth,\r\n  type FacilitatorConfig,\r\n  type CAIPNetworkId,\r\n  type CAIPAssetId,\r\n  type SettlementMode,\r\n} from './base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\nconst logger = createLogger({ component: 'CronosFacilitator' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\n/**\r\n * Cronos health check response\r\n * GET /healthcheck\r\n */\r\ninterface CronosHealthResponse {\r\n  status: 'OK' | string;\r\n  uptime?: number;\r\n  responseTime?: number;\r\n  timestamp?: string;\r\n}\r\n\r\n/**\r\n * Cronos supported assets response\r\n * GET /v2/x402/supported\r\n */\r\ninterface CronosSupportedResponse {\r\n  networks?: string[];\r\n  assets?: Array<{\r\n    network: string;\r\n    address: string;\r\n    symbol: string;\r\n    decimals: number;\r\n  }>;\r\n  limits?: {\r\n    maxAmount?: string;\r\n    minAmount?: string;\r\n    rateLimit?: {\r\n      requestsPerMinute: number;\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Cronos verify request body\r\n * POST /v2/x402/verify\r\n */\r\ninterface CronosVerifyRequest {\r\n  paymentPayload: {\r\n    x402Version: number;\r\n    scheme: string;\r\n    network: string; // \"cronos\" or \"cronos-testnet\"\r\n    payload: {\r\n      signature: string;\r\n      authorization: {\r\n        from: string;\r\n        to: string;\r\n        value: string;\r\n        validAfter: string;\r\n        validBefore: string;\r\n        nonce: string;\r\n      };\r\n    };\r\n  };\r\n  paymentRequirements: {\r\n    scheme: string;\r\n    network: string;\r\n    maxAmountRequired: string;\r\n    resource: string;\r\n    description?: string;\r\n    mimeType?: string;\r\n    payTo: string;\r\n    maxTimeoutSeconds?: number;\r\n    asset: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Cronos verify response\r\n */\r\ninterface CronosVerifyResponse {\r\n  valid: boolean;\r\n  transactionHash?: string;\r\n  error?: string;\r\n  errorCode?: string;\r\n}\r\n\r\n/**\r\n * Cronos settle request body\r\n * POST /v2/x402/settle\r\n */\r\ninterface CronosSettleRequest {\r\n  paymentIntent: {\r\n    x402Version: number;\r\n    scheme: string;\r\n    network: string;\r\n    payload: {\r\n      signature: string;\r\n      authorization: {\r\n        from: string;\r\n        to: string;\r\n        value: string;\r\n        validAfter: string;\r\n        validBefore: string;\r\n        nonce: string;\r\n      };\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Cronos settle response\r\n */\r\ninterface CronosSettleResponse {\r\n  success: boolean;\r\n  transactionHash?: string;\r\n  blockNumber?: number;\r\n  timestamp?: string;\r\n  error?: string;\r\n  errorCode?: string;\r\n}\r\n\r\n/**\r\n * Known Cronos facilitator error codes\r\n */\r\nconst CRONOS_ERROR_CODES = {\r\n  AUTHORIZATION_ALREADY_USED: 'authorization_already_used',\r\n  INVALID_SIGNATURE: 'invalid_signature',\r\n  INVALID_AUTHORIZATION: 'invalid_authorization',\r\n  RATE_LIMITED: 'rate_limited',\r\n  NETWORK_ERROR: 'network_error',\r\n  TIMEOUT: 'timeout',\r\n} as const;\r\n\r\n// =============================================================================\r\n// HELPER FUNCTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Convert CAIP-2 network identifier to Cronos network name\r\n */\r\nfunction caipToCronosNetwork(network: string): string {\r\n  const mapping: Record<string, string> = {\r\n    'eip155:25': 'cronos',\r\n    'eip155:338': 'cronos-testnet',\r\n    'cronos': 'cronos',\r\n    'cronos-testnet': 'cronos-testnet',\r\n    'cronos-mainnet': 'cronos',\r\n  };\r\n  return mapping[network] || network;\r\n}\r\n\r\n/**\r\n * Build Cronos-specific payment requirements for probe mode\r\n */\r\nfunction buildCronosProbePaymentRequirements(config: FacilitatorProbeConfig): PaymentRequirements {\r\n  // Placeholder USDX contract address on Cronos\r\n  // Replace with the official Cronos USDX contract from Cronos docs/block explorer\r\n  const USDX_CRONOS = '0x0000000000000000000000000000000000000000'; // TODO: Replace with actual USDX address\r\n  \r\n  // Test receiver address for probes\r\n  const PROBE_RECEIVER = '0x0000000000000000000000000000000000000001';\r\n  \r\n  // Convert CAIP-2 to Cronos network name\r\n  const cronosNetwork = caipToCronosNetwork(config.network);\r\n  \r\n  return {\r\n    scheme: 'x402',\r\n    network: cronosNetwork,\r\n    asset: USDX_CRONOS,\r\n    maxAmountRequired: '1', // Minimal amount (1 atomic unit)\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    payTo: PROBE_RECEIVER,\r\n    maxTimeoutSeconds: 10,\r\n    settlementMode: 'immediate',\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// CRONOS FACILITATOR CLASS\r\n// =============================================================================\r\n\r\n/**\r\n * Cronos x402 Facilitator\r\n * \r\n * Official Cronos Labs x402 facilitator supporting Cronos mainnet and testnet.\r\n * Documentation: https://docs.cronos.org/cronos-x402-facilitator\r\n */\r\nexport class CronosFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'cronos';\r\n  readonly name = 'Cronos x402 Facilitator';\r\n\r\n  readonly config: FacilitatorConfig = {\r\n    id: 'cronos',\r\n    name: 'Cronos x402 Facilitator',\r\n    enabled: process.env.CRONOS_ENABLED !== 'false', // Enabled by default\r\n    priority: 2, // Similar priority to other community facilitators\r\n    \r\n    // Legacy network identifiers\r\n    networks: ['cronos', 'cronos-testnet'],\r\n    \r\n    // CAIP-2 network identifiers\r\n    networksCAIP: [\r\n      'eip155:25',   // Cronos mainnet\r\n      'eip155:338',  // Cronos testnet\r\n    ],\r\n    \r\n    // Legacy asset identifiers\r\n    // Note: Replace placeholders with actual Cronos stablecoin contract addresses\r\n    // from Cronos docs/block explorer\r\n    assets: [\r\n      'USDC',\r\n      'USDX', // Placeholder - replace with actual contract address\r\n    ],\r\n    \r\n    // CAIP-19 asset identifiers\r\n    assetsCAIP: [\r\n      // Placeholder - replace with actual Cronos USDC/USDX CAIP-19 identifiers\r\n      // 'eip155:25/erc20:0x...',\r\n    ],\r\n    \r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'],\r\n    \r\n    healthCheckUrl: process.env.CRONOS_FACILITATOR_URL || 'https://facilitator.cronoslabs.org',\r\n    \r\n    metadata: {\r\n      provider: 'Cronos Labs',\r\n      label: 'Cronos x402 Facilitator',\r\n      url: 'https://facilitator.cronoslabs.org',\r\n      website: 'https://cronos.org',\r\n      documentation: 'https://docs.cronos.org/cronos-x402-facilitator',\r\n      complianceLevel: 'standard',\r\n      // Rate limits as documented\r\n      rateLimits: {\r\n        requestsPerMinute: 5, // 5 requests per minute per IP for settle/verify\r\n      },\r\n    },\r\n  };\r\n\r\n  private baseUrl: string;\r\n  private cachedSupported: CronosSupportedResponse | null = null;\r\n  private lastSupportedFetch: number = 0;\r\n  private readonly SUPPORTED_CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\r\n\r\n  constructor(baseUrl?: string) {\r\n    super();\r\n    this.baseUrl = baseUrl || process.env.CRONOS_FACILITATOR_URL || 'https://facilitator.cronoslabs.org';\r\n  }\r\n\r\n  /**\r\n   * Get the facilitator base URL\r\n   */\r\n  getUrl(): string {\r\n    return this.baseUrl;\r\n  }\r\n\r\n  // ===========================================================================\r\n  // HEALTH & DISCOVERY\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get Cronos facilitator health status\r\n   * GET /healthcheck\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      const healthUrl = `${this.baseUrl}/healthcheck`;\r\n      \r\n      const response = await fetch(healthUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n\r\n      const latency = Date.now() - start;\r\n\r\n      if (response.ok) {\r\n        let data: CronosHealthResponse = { status: 'OK' };\r\n        try {\r\n          data = await response.json();\r\n        } catch {\r\n          // Health endpoint might return simple OK\r\n        }\r\n\r\n        const isHealthy = data.status === 'OK';\r\n\r\n        // Fetch supported assets for capabilities\r\n        const supported = await this.fetchSupported();\r\n\r\n        return {\r\n          healthy: isHealthy,\r\n          latency,\r\n          lastChecked: new Date().toISOString(),\r\n          capabilities: {\r\n            networks: supported?.networks || this.config.networks,\r\n            assets: supported?.assets?.map(a => a.symbol) || this.config.assets,\r\n            schemes: this.config.schemes,\r\n          },\r\n        };\r\n      }\r\n\r\n      const errorText = await response.text().catch(() => `HTTP ${response.status}`);\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: errorText,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Health check failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: isTimeout ? 'Health check timeout' : errorMessage,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch supported assets and networks from discovery endpoint\r\n   * GET /v2/x402/supported\r\n   */\r\n  async fetchSupported(): Promise<CronosSupportedResponse | null> {\r\n    // Check cache\r\n    if (this.cachedSupported && (Date.now() - this.lastSupportedFetch) < this.SUPPORTED_CACHE_TTL_MS) {\r\n      return this.cachedSupported;\r\n    }\r\n\r\n    try {\r\n      const url = `${this.baseUrl}/v2/x402/supported`;\r\n      \r\n      const response = await fetch(url, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n\r\n      if (response.ok) {\r\n        const data: CronosSupportedResponse = await response.json();\r\n        this.cachedSupported = data;\r\n        this.lastSupportedFetch = Date.now();\r\n        \r\n        logger.info({\r\n          component: 'CronosFacilitator',\r\n          networks: data.networks,\r\n          assetsCount: data.assets?.length,\r\n          msg: 'Cronos supported assets refreshed',\r\n        });\r\n        \r\n        return data;\r\n      }\r\n\r\n      logger.warn({\r\n        component: 'CronosFacilitator',\r\n        status: response.status,\r\n        msg: 'Failed to fetch Cronos supported assets',\r\n      });\r\n      return null;\r\n    } catch (error) {\r\n      logger.warn({\r\n        component: 'CronosFacilitator',\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        msg: 'Error fetching Cronos supported assets',\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // VERIFY FLOW\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Call Cronos /v2/x402/verify endpoint with retry logic for transient errors\r\n   */\r\n  private async callCronosVerifyWithRetries(\r\n    verifyUrl: string,\r\n    requestBody: CronosVerifyRequest,\r\n    isProbe: boolean\r\n  ): Promise<{\r\n    success: boolean;\r\n    valid: boolean;\r\n    status: number;\r\n    errorType?: string;\r\n    errorMessage?: string;\r\n    isRateLimited: boolean;\r\n    isNetworkError: boolean;\r\n    latencyMs: number;\r\n    data?: CronosVerifyResponse;\r\n  }> {\r\n    const maxRetries = 3;\r\n    const retryableStatuses = [429, 500, 502, 503, 504];\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const response = await fetch(verifyUrl, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify(requestBody),\r\n          signal: AbortSignal.timeout(10000), // 10 second timeout\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data: CronosVerifyResponse = text ? JSON.parse(text) : {};\r\n        const latencyMs = Date.now() - startTime;\r\n\r\n        // Success case\r\n        if (response.ok && data.valid === true) {\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            status: response.status,\r\n            isRateLimited: false,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Check if retryable error\r\n        const isRetryable = retryableStatuses.includes(response.status);\r\n        const isRateLimit = response.status === 429;\r\n        \r\n        // If not retryable or last attempt, return error\r\n        if (!isRetryable || attempt === maxRetries - 1) {\r\n          const errorMessage = data.error || `HTTP ${response.status}`;\r\n          const errorType = data.errorCode || (isRateLimit ? CRONOS_ERROR_CODES.RATE_LIMITED : 'CRONOS_VERIFY_FAILED');\r\n          \r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            status: response.status,\r\n            errorType,\r\n            errorMessage,\r\n            isRateLimited: isRateLimit,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Retry with exponential backoff\r\n        const delay = 100 * Math.pow(2, attempt);\r\n        logger.info({\r\n          component: 'CronosFacilitator',\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          status: response.status,\r\n          delay,\r\n          isProbe,\r\n          msg: 'Retrying Cronos verification after transient error',\r\n        });\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        \r\n      } catch (error: any) {\r\n        const latencyMs = Date.now() - startTime;\r\n        const isTimeout = error?.name === 'AbortError' || error?.message?.toLowerCase().includes('timeout');\r\n        const isNetworkError = error?.message?.toLowerCase().includes('network') || \r\n                              error?.message?.toLowerCase().includes('fetch') ||\r\n                              error?.message?.toLowerCase().includes('econnrefused');\r\n        \r\n        // If network error and not last attempt, retry\r\n        if ((isTimeout || isNetworkError) && attempt < maxRetries - 1) {\r\n          const delay = 100 * Math.pow(2, attempt);\r\n          logger.info({\r\n            component: 'CronosFacilitator',\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error?.message,\r\n            delay,\r\n            isProbe,\r\n            msg: 'Retrying Cronos verification after network error',\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n        \r\n        // Last attempt or non-network error\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          status: 0,\r\n          errorType: isTimeout ? CRONOS_ERROR_CODES.TIMEOUT : isNetworkError ? CRONOS_ERROR_CODES.NETWORK_ERROR : 'CRONOS_VERIFY_FAILED',\r\n          errorMessage: error?.message || 'Cronos verification failed',\r\n          isRateLimited: false,\r\n          isNetworkError: isTimeout || isNetworkError,\r\n          latencyMs,\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Should never reach here\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      status: 0,\r\n      errorType: 'CRONOS_VERIFY_FAILED',\r\n      errorMessage: 'Max retries exceeded',\r\n      isRateLimited: false,\r\n      isNetworkError: false,\r\n      latencyMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify payment using Cronos facilitator\r\n   * POST /v2/x402/verify\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    const start = Date.now();\r\n\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Parse payment header to extract authorization details\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Detect probe mode\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n\r\n      // Convert network to Cronos format\r\n      const cronosNetwork = caipToCronosNetwork(requirements.network);\r\n\r\n      // Build verify request\r\n      const requestBody: CronosVerifyRequest = {\r\n        paymentPayload: {\r\n          x402Version: 2,\r\n          scheme: requirements.scheme || 'x402',\r\n          network: cronosNetwork,\r\n          payload: {\r\n            signature: parsed.signature,\r\n            authorization: {\r\n              from: parsed.authorization.from,\r\n              to: parsed.authorization.to,\r\n              value: parsed.authorization.value,\r\n              validAfter: parsed.authorization.validAfter,\r\n              validBefore: parsed.authorization.validBefore,\r\n              nonce: parsed.authorization.nonce,\r\n            },\r\n          },\r\n        },\r\n        paymentRequirements: {\r\n          scheme: requirements.scheme,\r\n          network: cronosNetwork,\r\n          maxAmountRequired: requirements.maxAmountRequired,\r\n          resource: requirements.resource,\r\n          description: requirements.description || '',\r\n          mimeType: requirements.mimeType || 'application/json',\r\n          payTo: requirements.payTo,\r\n          maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n          asset: requirements.asset,\r\n        },\r\n      };\r\n\r\n      // POST to Cronos verification endpoint\r\n      const verifyUrl = `${this.baseUrl}/v2/x402/verify`;\r\n\r\n      logger.info({\r\n        component: 'CronosFacilitator',\r\n        isProbe,\r\n        network: cronosNetwork,\r\n        asset: requirements.asset,\r\n        url: verifyUrl,\r\n        facilitatorId: this.id,\r\n        facilitatorUrl: this.baseUrl,\r\n        msg: 'Sending Cronos /v2/x402/verify request',\r\n      });\r\n\r\n      // Call with retry logic\r\n      const result = await this.callCronosVerifyWithRetries(verifyUrl, requestBody, isProbe);\r\n\r\n      // Handle success\r\n      if (result.success && result.valid) {\r\n        logger.info({\r\n          component: 'CronosFacilitator',\r\n          facilitatorId: this.id,\r\n          facilitatorUrl: this.baseUrl,\r\n          latencyMs: result.latencyMs,\r\n          network: cronosNetwork,\r\n          transactionHash: result.data?.transactionHash,\r\n          msg: 'Payment verified successfully by Cronos',\r\n        });\r\n        return {\r\n          success: true,\r\n          valid: true,\r\n          transactionHash: result.data?.transactionHash,\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Handle error - map Cronos error codes\r\n      const errorType = result.errorType || 'CRONOS_VERIFY_FAILED';\r\n      const errorMessage = result.errorMessage || 'Cronos verification failed';\r\n      \r\n      let errorCode = 'facilitator_error';\r\n      if (result.isRateLimited || errorType === CRONOS_ERROR_CODES.RATE_LIMITED) {\r\n        errorCode = 'rate_limited';\r\n      } else if (result.isNetworkError) {\r\n        errorCode = 'network_error';\r\n      } else if (errorType === CRONOS_ERROR_CODES.AUTHORIZATION_ALREADY_USED) {\r\n        errorCode = 'authorization_already_used';\r\n      } else if (errorType === CRONOS_ERROR_CODES.INVALID_SIGNATURE || errorType === CRONOS_ERROR_CODES.INVALID_AUTHORIZATION) {\r\n        errorCode = 'invalid_authorization';\r\n      } else if (result.status === 400) {\r\n        errorCode = 'invalid_request';\r\n      }\r\n\r\n      logger.debug({\r\n        component: 'CronosFacilitator',\r\n        facilitatorId: this.id,\r\n        status: result.status,\r\n        errorType,\r\n        errorMessage,\r\n        errorCode,\r\n        isRateLimited: result.isRateLimited,\r\n        isNetworkError: result.isNetworkError,\r\n        latencyMs: result.latencyMs,\r\n        msg: 'Cronos verification failed',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: errorMessage,\r\n        errorDetails: {\r\n          error: errorMessage,\r\n          errorType,\r\n          httpStatus: result.status,\r\n          errorCode,\r\n          isRateLimited: result.isRateLimited,\r\n          isNetworkError: result.isNetworkError,\r\n          cronosResponse: result.data,\r\n        },\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'Cronos verification error');\r\n      \r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: isTimeout ? 'CRONOS_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // SETTLE FLOW\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Settle a verified payment intent with Cronos facilitator\r\n   * POST /v2/x402/settle\r\n   * \r\n   * Blocks until the facilitator returns the settlement receipt with\r\n   * transaction hash, block number, and timestamp.\r\n   */\r\n  async settle(\r\n    paymentIntent: {\r\n      x402Version: number;\r\n      scheme: string;\r\n      network: string;\r\n      payload: {\r\n        signature: string;\r\n        authorization: {\r\n          from: string;\r\n          to: string;\r\n          value: string;\r\n          validAfter: string;\r\n          validBefore: string;\r\n          nonce: string;\r\n        };\r\n      };\r\n    }\r\n  ): Promise<{\r\n    success: boolean;\r\n    transactionHash?: string;\r\n    blockNumber?: number;\r\n    timestamp?: string;\r\n    error?: string;\r\n    errorCode?: string;\r\n  }> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // Convert network to Cronos format\r\n      const cronosNetwork = caipToCronosNetwork(paymentIntent.network);\r\n\r\n      const requestBody: CronosSettleRequest = {\r\n        paymentIntent: {\r\n          ...paymentIntent,\r\n          network: cronosNetwork,\r\n        },\r\n      };\r\n\r\n      const settleUrl = `${this.baseUrl}/v2/x402/settle`;\r\n\r\n      logger.info({\r\n        component: 'CronosFacilitator',\r\n        network: cronosNetwork,\r\n        url: settleUrl,\r\n        facilitatorId: this.id,\r\n        msg: 'Sending Cronos /v2/x402/settle request',\r\n      });\r\n\r\n      const response = await fetch(settleUrl, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(requestBody),\r\n        signal: AbortSignal.timeout(30000), // 30 second timeout for settlement\r\n      });\r\n\r\n      const latency = Date.now() - start;\r\n      const text = await response.text();\r\n      const data: CronosSettleResponse = text ? JSON.parse(text) : {};\r\n\r\n      if (response.ok && data.success) {\r\n        logger.info({\r\n          component: 'CronosFacilitator',\r\n          facilitatorId: this.id,\r\n          latencyMs: latency,\r\n          transactionHash: data.transactionHash,\r\n          blockNumber: data.blockNumber,\r\n          msg: 'Payment settled successfully by Cronos',\r\n        });\r\n\r\n        return {\r\n          success: true,\r\n          transactionHash: data.transactionHash,\r\n          blockNumber: data.blockNumber,\r\n          timestamp: data.timestamp,\r\n        };\r\n      }\r\n\r\n      // Handle known error codes\r\n      const errorCode = data.errorCode || 'CRONOS_SETTLE_FAILED';\r\n      const errorMessage = data.error || `HTTP ${response.status}`;\r\n\r\n      logger.warn({\r\n        component: 'CronosFacilitator',\r\n        facilitatorId: this.id,\r\n        status: response.status,\r\n        errorCode,\r\n        errorMessage,\r\n        latencyMs: latency,\r\n        msg: 'Cronos settlement failed',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        error: errorMessage,\r\n        errorCode,\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Settlement failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n\r\n      logger.error({\r\n        component: 'CronosFacilitator',\r\n        error: errorMessage,\r\n        latencyMs: latency,\r\n        isTimeout,\r\n        msg: 'Cronos settlement error',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        error: isTimeout ? 'CRONOS_SETTLE_TIMEOUT' : errorMessage,\r\n        errorCode: isTimeout ? CRONOS_ERROR_CODES.TIMEOUT : CRONOS_ERROR_CODES.NETWORK_ERROR,\r\n      };\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // PRICING & SUPPORT\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get pricing information (not available yet for Cronos)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    // TODO: Implement if Cronos provides pricing API\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\r\n    // Normalize network to check\r\n    const normalizedNetwork = caipToCronosNetwork(network);\r\n    const supportedNetworks = ['cronos', 'cronos-testnet', 'eip155:25', 'eip155:338'];\r\n    \r\n    if (!supportedNetworks.includes(network) && !supportedNetworks.includes(normalizedNetwork)) {\r\n      return false;\r\n    }\r\n\r\n    return super.supports(normalizedNetwork, asset, scheme, settlementMode);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// SINGLETON\r\n// =============================================================================\r\n\r\nlet cronosFacilitator: CronosFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton Cronos facilitator instance\r\n */\r\nexport function getCronosFacilitator(): CronosFacilitator {\r\n  if (!cronosFacilitator) {\r\n    cronosFacilitator = new CronosFacilitator();\r\n  }\r\n  return cronosFacilitator;\r\n}\r\n\r\n/**\r\n * Export probe requirements builder for probe system\r\n */\r\nexport { buildCronosProbePaymentRequirements };\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7614, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/smf.ts"],"sourcesContent":["// =============================================================================\r\n// SMF DATABASE OPERATIONS\r\n// =============================================================================\r\n// Database operations for Smart Meta-Facilitator routing, attempts, and health\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'SMFDatabase' });\r\n\r\nexport interface Facilitator {\r\n  id: string;\r\n  name: string;\r\n  status: 'active' | 'disabled' | 'testing';\r\n  base_url: string;\r\n  priority: number;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface FacilitatorCapability {\r\n  id: string;\r\n  facilitator_id: string;\r\n  network: string;\r\n  token: string;\r\n  min_amount: string;\r\n  max_amount: string | null;\r\n  fee_bps: number;\r\n  regions: string[] | null;\r\n  supports_deferred: boolean;\r\n  supports_subscriptions: boolean;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface Route {\r\n  id: string;\r\n  request_id: string | null;\r\n  correlation_id: string | null;\r\n  client_id: string | null;\r\n  agent_id: string | null;\r\n  network: string;\r\n  token: string;\r\n  amount: string;\r\n  selected_facilitator_id: string;\r\n  status: 'planned' | 'verifying' | 'settling' | 'settled' | 'failed';\r\n  created_at: string;\r\n  updated_at: string;\r\n  completed_at: string | null;\r\n}\r\n\r\nexport interface RouteAttempt {\r\n  id: string;\r\n  route_id: string;\r\n  facilitator_id: string;\r\n  phase: 'verify' | 'settle';\r\n  result: 'success' | 'failure' | 'timeout' | 'rate_limited' | 'insufficient_liquidity' | 'invalid_request' | 'network_error';\r\n  latency_ms: number;\r\n  error_code: string | null;\r\n  raw_status: number | null;\r\n  is_probe: boolean;\r\n  created_at: string;\r\n}\r\n\r\nexport interface FacilitatorHealthSnapshot {\r\n  id: string;\r\n  facilitator_id: string;\r\n  network: string;\r\n  token: string;\r\n  window_start: string;\r\n  window_end: string;\r\n  success_rate: number;\r\n  p50_latency_ms: number | null;\r\n  p95_latency_ms: number | null;\r\n  p99_latency_ms: number | null;\r\n  error_rate: number;\r\n  last_error_type: string | null;\r\n  status: 'healthy' | 'degraded' | 'down';\r\n  created_at: string;\r\n}\r\n\r\n/**\r\n * Create a route record\r\n */\r\nexport async function createRoute(route: Omit<Route, 'id' | 'created_at' | 'updated_at' | 'completed_at'>): Promise<Route> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO routes (\r\n        id, request_id, correlation_id, client_id, agent_id, network, token, amount,\r\n        selected_facilitator_id, status, created_at, updated_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        route.request_id,\r\n        route.correlation_id,\r\n        route.client_id,\r\n        route.agent_id,\r\n        route.network,\r\n        route.token,\r\n        route.amount,\r\n        route.selected_facilitator_id,\r\n        route.status,\r\n        now,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO routes (\r\n        id, request_id, correlation_id, client_id, agent_id, network, token, amount,\r\n        selected_facilitator_id, status, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      route.request_id,\r\n      route.correlation_id,\r\n      route.client_id,\r\n      route.agent_id,\r\n      route.network,\r\n      route.token,\r\n      route.amount,\r\n      route.selected_facilitator_id,\r\n      route.status,\r\n      now,\r\n      now\r\n    );\r\n    return {\r\n      id,\r\n      ...route,\r\n      created_at: now,\r\n      updated_at: now,\r\n      completed_at: null,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update route status\r\n */\r\nexport async function updateRouteStatus(\r\n  routeId: string,\r\n  status: Route['status'],\r\n  completedAt?: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE routes SET status = $1, updated_at = $2, completed_at = $3 WHERE id = $4`,\r\n      [status, now, completedAt || null, routeId]\r\n    );\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(\r\n      `UPDATE routes SET status = ?, updated_at = ?, completed_at = ? WHERE id = ?`\r\n    );\r\n    stmt.run(status, now, completedAt || null, routeId);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a route attempt record\r\n */\r\nexport async function createRouteAttempt(\r\n  attempt: Omit<RouteAttempt, 'id' | 'created_at'>\r\n): Promise<RouteAttempt> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO route_attempts (\r\n        id, route_id, facilitator_id, phase, result, latency_ms, error_code, raw_status, is_probe, created_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        attempt.route_id,\r\n        attempt.facilitator_id,\r\n        attempt.phase,\r\n        attempt.result,\r\n        attempt.latency_ms,\r\n        attempt.error_code,\r\n        attempt.raw_status,\r\n        attempt.is_probe ?? false,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO route_attempts (\r\n        id, route_id, facilitator_id, phase, result, latency_ms, error_code, raw_status, is_probe, created_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      attempt.route_id,\r\n      attempt.facilitator_id,\r\n      attempt.phase,\r\n      attempt.result,\r\n      attempt.latency_ms,\r\n      attempt.error_code,\r\n      attempt.raw_status,\r\n      attempt.is_probe ?? false,\r\n      now\r\n    );\r\n    return {\r\n      id,\r\n      ...attempt,\r\n      created_at: now,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get facilitator capabilities\r\n */\r\nexport async function getFacilitatorCapabilities(\r\n  facilitatorId?: string,\r\n  network?: string,\r\n  token?: string\r\n): Promise<FacilitatorCapability[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let query = 'SELECT * FROM facilitator_capabilities WHERE 1=1';\r\n  const params: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (facilitatorId) {\r\n    if (isPostgres) {\r\n      query += ` AND facilitator_id = $${paramIndex++}`;\r\n      params.push(facilitatorId);\r\n    } else {\r\n      query += ` AND facilitator_id = ?`;\r\n      params.push(facilitatorId);\r\n    }\r\n  }\r\n\r\n  if (network) {\r\n    if (isPostgres) {\r\n      query += ` AND network = $${paramIndex++}`;\r\n      params.push(network);\r\n    } else {\r\n      query += ` AND network = ?`;\r\n      params.push(network);\r\n    }\r\n  }\r\n\r\n  if (token) {\r\n    if (isPostgres) {\r\n      query += ` AND token = $${paramIndex++}`;\r\n      params.push(token);\r\n    } else {\r\n      query += ` AND token = ?`;\r\n      params.push(token);\r\n    }\r\n  }\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, params);\r\n    return result.rows;\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(query);\r\n    const rows = stmt.all(...params);\r\n    return rows;\r\n  }\r\n}\r\n\r\n/**\r\n * Get latest health snapshot for a facilitator/network/token\r\n */\r\nexport async function getLatestHealthSnapshot(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string\r\n): Promise<FacilitatorHealthSnapshot | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_health_snapshots\r\n       WHERE facilitator_id = $1 AND network = $2 AND token = $3\r\n       ORDER BY window_end DESC\r\n       LIMIT 1`,\r\n      [facilitatorId, network, token]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(\r\n      `SELECT * FROM facilitator_health_snapshots\r\n       WHERE facilitator_id = ? AND network = ? AND token = ?\r\n       ORDER BY window_end DESC\r\n       LIMIT 1`\r\n    );\r\n    const row = stmt.get(facilitatorId, network, token);\r\n    return row || null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get route attempts for health aggregation\r\n */\r\nexport async function getRouteAttemptsForHealth(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowStart: string,\r\n  windowEnd: string,\r\n  includeProbes: boolean = true\r\n): Promise<RouteAttempt[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  // Build probe route_id pattern for matching\r\n  const probePattern = `probe-${facilitatorId}-${network}-${token}%`;\r\n\r\n  if (isPostgres) {\r\n    // For probes, route_id starts with \"probe-{facilitatorId}-{network}-{token}\"\r\n    // For real routes, we join with routes table\r\n    // Note: Cast route_id to TEXT for LIKE comparison (UUID doesn't support LIKE directly)\r\n    const result = await (db as any).pool.query(\r\n      `SELECT ra.* FROM route_attempts ra\r\n       LEFT JOIN routes r ON (ra.route_id::text = r.id::text AND ra.is_probe = false)\r\n       WHERE ra.facilitator_id = $1\r\n         AND (\r\n           (ra.is_probe = true AND ra.route_id::text LIKE $2)\r\n           OR (ra.is_probe = false AND r.network = $3 AND r.token = $4)\r\n         )\r\n         AND ra.created_at >= $5\r\n         AND ra.created_at < $6\r\n       ORDER BY ra.created_at`,\r\n      [facilitatorId, probePattern, network, token, windowStart, windowEnd]\r\n    );\r\n    return result.rows;\r\n  } else {\r\n    // SQLite - similar logic\r\n    const stmt = (db as any).prepare(\r\n      `SELECT ra.* FROM route_attempts ra\r\n       LEFT JOIN routes r ON (ra.route_id = r.id AND ra.is_probe = 0)\r\n       WHERE ra.facilitator_id = ?\r\n         AND (\r\n           (ra.is_probe = 1 AND ra.route_id LIKE ?)\r\n           OR (ra.is_probe = 0 AND r.network = ? AND r.token = ?)\r\n         )\r\n         AND ra.created_at >= ?\r\n         AND ra.created_at < ?\r\n       ORDER BY ra.created_at`\r\n    );\r\n    const rows = stmt.all(facilitatorId, probePattern, network, token, windowStart, windowEnd);\r\n    return rows;\r\n  }\r\n}\r\n\r\n/**\r\n * Create or update health snapshot\r\n */\r\nexport async function upsertHealthSnapshot(\r\n  snapshot: Omit<FacilitatorHealthSnapshot, 'id' | 'created_at'>\r\n): Promise<FacilitatorHealthSnapshot> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    // Use ON CONFLICT for upsert\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO facilitator_health_snapshots (\r\n        id, facilitator_id, network, token, window_start, window_end,\r\n        success_rate, p50_latency_ms, p95_latency_ms, p99_latency_ms,\r\n        error_rate, last_error_type, status, created_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\r\n      ON CONFLICT (facilitator_id, network, token, window_end)\r\n      DO UPDATE SET\r\n        success_rate = EXCLUDED.success_rate,\r\n        p50_latency_ms = EXCLUDED.p50_latency_ms,\r\n        p95_latency_ms = EXCLUDED.p95_latency_ms,\r\n        p99_latency_ms = EXCLUDED.p99_latency_ms,\r\n        error_rate = EXCLUDED.error_rate,\r\n        last_error_type = EXCLUDED.last_error_type,\r\n        status = EXCLUDED.status\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        snapshot.facilitator_id,\r\n        snapshot.network,\r\n        snapshot.token,\r\n        snapshot.window_start,\r\n        snapshot.window_end,\r\n        snapshot.success_rate,\r\n        snapshot.p50_latency_ms,\r\n        snapshot.p95_latency_ms,\r\n        snapshot.p99_latency_ms,\r\n        snapshot.error_rate,\r\n        snapshot.last_error_type,\r\n        snapshot.status,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite - simple insert (no upsert for now)\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO facilitator_health_snapshots (\r\n        id, facilitator_id, network, token, window_start, window_end,\r\n        success_rate, p50_latency_ms, p95_latency_ms, p99_latency_ms,\r\n        error_rate, last_error_type, status, created_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      snapshot.facilitator_id,\r\n      snapshot.network,\r\n      snapshot.token,\r\n      snapshot.window_start,\r\n      snapshot.window_end,\r\n      snapshot.success_rate,\r\n      snapshot.p50_latency_ms,\r\n      snapshot.p95_latency_ms,\r\n      snapshot.p99_latency_ms,\r\n      snapshot.error_rate,\r\n      snapshot.last_error_type,\r\n      snapshot.status,\r\n      now\r\n    );\r\n    return {\r\n      id,\r\n      ...snapshot,\r\n      created_at: now,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Record facilitator probe event arguments\r\n */\r\nexport interface RecordFacilitatorProbeEventArgs {\r\n  probe_config_id: string;\r\n  facilitator_id: string;\r\n  network: string;\r\n  token: string;\r\n  result: 'success' | 'failure';\r\n  error_code: string | null;\r\n  facilitator_status: number | null;\r\n  facilitator_error_code: string | null;\r\n  latency_ms: number;\r\n  probe_tier?: 'light' | 'deep'; // Optional for backwards compatibility\r\n}\r\n\r\n/**\r\n * Record a facilitator probe event for analytics\r\n */\r\nexport async function recordFacilitatorProbeEvent(event: RecordFacilitatorProbeEventArgs): Promise<void> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    // Use probe_tier if provided, otherwise default to 'light'\r\n    const probeTier = event.probe_tier || 'light';\r\n    \r\n    await (db as any).pool.query(\r\n      `INSERT INTO facilitator_probe_events (\r\n        probe_config_id, facilitator_id, network, token, result,\r\n        error_code, facilitator_status, facilitator_error_code, latency_ms, probe_tier\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,\r\n      [\r\n        event.probe_config_id,\r\n        event.facilitator_id,\r\n        event.network,\r\n        event.token,\r\n        event.result,\r\n        event.error_code,\r\n        event.facilitator_status,\r\n        event.facilitator_error_code,\r\n        event.latency_ms,\r\n        probeTier,\r\n      ]\r\n    );\r\n  } else {\r\n    // SQLite - table might not exist, skip silently\r\n    logger.warn('facilitator_probe_events table not available in SQLite');\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7941, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/health-aggregator.ts"],"sourcesContent":["// =============================================================================\r\n// HEALTH AGGREGATOR\r\n// =============================================================================\r\n// Aggregates health metrics from route attempts for scoring and monitoring\r\n\r\nimport { getRouteAttemptsForHealth, upsertHealthSnapshot, getLatestHealthSnapshot, type RouteAttempt, type FacilitatorHealthSnapshot } from '@/db/smf';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'HealthAggregator' });\r\n\r\n/**\r\n * Calculate percentile from sorted array\r\n */\r\nfunction percentile(sortedValues: number[], p: number): number {\r\n  if (sortedValues.length === 0) return 0;\r\n  const index = Math.ceil((p / 100) * sortedValues.length) - 1;\r\n  return sortedValues[Math.max(0, index)];\r\n}\r\n\r\n/**\r\n * Aggregate health metrics from route attempts\r\n */\r\nexport async function aggregateHealthMetrics(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowStart: Date,\r\n  windowEnd: Date\r\n): Promise<FacilitatorHealthSnapshot | null> {\r\n  try {\r\n    const attempts = await getRouteAttemptsForHealth(\r\n      facilitatorId,\r\n      network,\r\n      token,\r\n      windowStart.toISOString(),\r\n      windowEnd.toISOString()\r\n    );\r\n\r\n    if (attempts.length === 0) {\r\n      logger.debug({ facilitatorId, network, token }, 'No attempts found for health aggregation');\r\n      return null;\r\n    }\r\n\r\n    // Calculate success rate\r\n    const successful = attempts.filter((a) => a.result === 'success').length;\r\n    const successRate = successful / attempts.length;\r\n\r\n    // Calculate latency percentiles\r\n    const latencies = attempts\r\n      .map((a) => a.latency_ms)\r\n      .filter((l) => l > 0)\r\n      .sort((a, b) => a - b);\r\n\r\n    const p50 = latencies.length > 0 ? percentile(latencies, 50) : null;\r\n    const p95 = latencies.length > 0 ? percentile(latencies, 95) : null;\r\n    const p99 = latencies.length > 0 ? percentile(latencies, 99) : null;\r\n\r\n    // Calculate error rate\r\n    const errors = attempts.filter((a) => a.result !== 'success').length;\r\n    const errorRate = errors / attempts.length;\r\n\r\n    // Get last error type\r\n    const failedAttempts = attempts.filter((a) => a.result !== 'success');\r\n    const lastErrorType = failedAttempts.length > 0 ? failedAttempts[failedAttempts.length - 1].result : null;\r\n\r\n    // Determine status\r\n    let status: 'healthy' | 'degraded' | 'down' = 'healthy';\r\n    if (successRate < 0.5) {\r\n      status = 'down';\r\n    } else if (successRate < 0.9 || (p95 && p95 > 5000)) {\r\n      status = 'degraded';\r\n    }\r\n\r\n    const snapshot: Omit<FacilitatorHealthSnapshot, 'id' | 'created_at'> = {\r\n      facilitator_id: facilitatorId,\r\n      network,\r\n      token,\r\n      window_start: windowStart.toISOString(),\r\n      window_end: windowEnd.toISOString(),\r\n      success_rate: successRate,\r\n      p50_latency_ms: p50,\r\n      p95_latency_ms: p95,\r\n      p99_latency_ms: p99,\r\n      error_rate: errorRate,\r\n      last_error_type: lastErrorType,\r\n      status,\r\n    };\r\n\r\n    const saved = await upsertHealthSnapshot(snapshot);\r\n    logger.info(\r\n      {\r\n        facilitatorId,\r\n        network,\r\n        token,\r\n        successRate,\r\n        p95Latency: p95,\r\n        status,\r\n        attempts: attempts.length,\r\n      },\r\n      'Health snapshot created'\r\n    );\r\n\r\n    return saved;\r\n  } catch (error) {\r\n    logger.error({ error, facilitatorId, network, token }, 'Failed to aggregate health metrics');\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get current health for a facilitator/network/token\r\n * Returns latest snapshot or calculates from recent attempts\r\n */\r\nexport async function getCurrentHealth(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowMinutes: number = 15\r\n): Promise<{\r\n  successRate: number;\r\n  p50LatencyMs: number | null;\r\n  p95LatencyMs: number | null;\r\n  p99LatencyMs: number | null;\r\n  errorRate: number;\r\n  lastErrorType: string | null;\r\n  status: 'healthy' | 'degraded' | 'down';\r\n}> {\r\n  // Try to get latest snapshot first\r\n  const snapshot = await getLatestHealthSnapshot(facilitatorId, network, token);\r\n\r\n  if (snapshot) {\r\n    const snapshotAge = Date.now() - new Date(snapshot.window_end).getTime();\r\n    const maxAge = windowMinutes * 60 * 1000;\r\n\r\n    // If snapshot is recent enough, use it\r\n    if (snapshotAge < maxAge) {\r\n      return {\r\n        successRate: Number(snapshot.success_rate),\r\n        p50LatencyMs: snapshot.p50_latency_ms,\r\n        p95LatencyMs: snapshot.p95_latency_ms,\r\n        p99LatencyMs: snapshot.p99_latency_ms,\r\n        errorRate: Number(snapshot.error_rate),\r\n        lastErrorType: snapshot.last_error_type,\r\n        status: snapshot.status,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Otherwise, calculate from recent attempts\r\n  const windowEnd = new Date();\r\n  const windowStart = new Date(windowEnd.getTime() - windowMinutes * 60 * 1000);\r\n\r\n  const aggregated = await aggregateHealthMetrics(facilitatorId, network, token, windowStart, windowEnd);\r\n\r\n  if (aggregated) {\r\n    return {\r\n      successRate: Number(aggregated.success_rate),\r\n      p50LatencyMs: aggregated.p50_latency_ms,\r\n      p95LatencyMs: aggregated.p95_latency_ms,\r\n      p99LatencyMs: aggregated.p99_latency_ms,\r\n      errorRate: Number(aggregated.error_rate),\r\n      lastErrorType: aggregated.last_error_type,\r\n      status: aggregated.status,\r\n    };\r\n  }\r\n\r\n  // Default values if no data\r\n  return {\r\n    successRate: 1.0,\r\n    p50LatencyMs: null,\r\n    p95LatencyMs: null,\r\n    p99LatencyMs: null,\r\n    errorRate: 0.0,\r\n    lastErrorType: null,\r\n    status: 'healthy',\r\n  };\r\n}\r\n\r\n/**\r\n * Periodic job to update health snapshots\r\n * Should be called every 5-15 minutes\r\n * \r\n * Now supports all registered facilitators via dynamic discovery\r\n */\r\nexport async function updateHealthSnapshots(windowMinutes: number = 15): Promise<void> {\r\n  logger.info({ windowMinutes }, 'Starting health snapshot update');\r\n\r\n  // Dynamically get all facilitator/network/token combinations from probe configs\r\n  // This ensures we track health for all probed facilitators, not just CDP\r\n  const { getEnabledProbeConfigs } = await import('./facilitator-probe-config');\r\n  const probeConfigs = getEnabledProbeConfigs();\r\n\r\n  // De-duplicate combinations (light and deep probes hit the same facilitator/network/token)\r\n  const combinationsMap = new Map<string, { facilitatorId: string; network: string; token: string }>();\r\n\r\n  for (const config of probeConfigs) {\r\n    const key = `${config.facilitatorId}-${config.network}-${config.token}`;\r\n    if (!combinationsMap.has(key)) {\r\n      combinationsMap.set(key, {\r\n        facilitatorId: config.facilitatorId,\r\n        network: config.network,\r\n        token: config.token,\r\n      });\r\n    }\r\n  }\r\n\r\n  // Fallback if no probes are configured (maintain backwards compatibility)\r\n  if (combinationsMap.size === 0) {\r\n    combinationsMap.set('cdp-base-usdc', {\r\n      facilitatorId: 'cdp',\r\n      network: 'base',\r\n      token: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n    });\r\n  }\r\n\r\n  const combinations = Array.from(combinationsMap.values());\r\n  logger.info({ combinationCount: combinations.length }, 'Updating health snapshots for facilitators');\r\n\r\n  const windowEnd = new Date();\r\n  const windowStart = new Date(windowEnd.getTime() - windowMinutes * 60 * 1000);\r\n\r\n  await Promise.all(\r\n    combinations.map(async (combo) => {\r\n      try {\r\n        await aggregateHealthMetrics(combo.facilitatorId, combo.network, combo.token, windowStart, windowEnd);\r\n      } catch (error) {\r\n        logger.error({ error, ...combo }, 'Failed to update health snapshot');\r\n      }\r\n    })\r\n  );\r\n\r\n  logger.info('Health snapshot update complete');\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8136, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/services/facilitator-metrics-service.ts"],"sourcesContent":["// =============================================================================\r\n// FACILITATOR METRICS SERVICE\r\n// =============================================================================\r\n// Service for persisting and managing facilitator path metrics from x402scan\r\n// Uses Supabase/PostgreSQL in production, falls back to JSON files in development\r\n//\r\n// =============================================================================\r\n// RETENTION & COMPACTION PLAN (TODO)\r\n// =============================================================================\r\n// 1. Raw buckets (bucketMinutes < 60):\r\n//    - Keep for 7 days\r\n//    - After 7 days, compact into hourly rollups\r\n//\r\n// 2. Hourly rollups (bucketMinutes = 60):\r\n//    - Keep for 30 days\r\n//    - After 30 days, compact into daily rollups\r\n//\r\n// 3. Daily rollups (bucketMinutes = 1440):\r\n//    - Keep for 90 days\r\n//    - After 90 days, archive or delete\r\n//\r\n// Compaction strategy:\r\n//    - Sum invocations, successCount, failureCount, status buckets\r\n//    - Weighted average for latency percentiles (weight by invocations)\r\n//    - Recalculate errorRate from compacted counts\r\n//\r\n// TODO: Implement compactMetrics() function for scheduled compaction job\r\n// =============================================================================\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport {\r\n  type FacilitatorPathMetrics,\r\n  type FacilitatorSummary,\r\n  type FacilitatorPathMetricsTimeframe,\r\n  type FacilitatorMethodMetrics,\r\n} from '@/infra/x402scan/types';\r\nimport { Pool } from 'pg';\r\n\r\nconst logger = createLogger({ component: 'FacilitatorMetricsService' });\r\n\r\n// =============================================================================\r\n// DATABASE CONNECTION\r\n// =============================================================================\r\n\r\nlet pool: Pool | null = null;\r\n\r\nfunction getPool(): Pool | null {\r\n  if (pool) return pool;\r\n  \r\n  const databaseUrl = process.env.DATABASE_URL;\r\n  if (!databaseUrl || !databaseUrl.startsWith('postgresql://')) {\r\n    return null;\r\n  }\r\n  \r\n  pool = new Pool({\r\n    connectionString: databaseUrl,\r\n    max: 5,\r\n    idleTimeoutMillis: 30000,\r\n    connectionTimeoutMillis: 5000,\r\n  });\r\n  \r\n  return pool;\r\n}\r\n\r\n// =============================================================================\r\n// DATABASE STORAGE FUNCTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Upsert facilitator path metrics to the database\r\n */\r\nasync function upsertMetricsToDb(metrics: FacilitatorPathMetrics[]): Promise<void> {\r\n  const db = getPool();\r\n  if (!db || metrics.length === 0) return;\r\n\r\n  const client = await db.connect();\r\n  try {\r\n    await client.query('BEGIN');\r\n\r\n    for (const m of metrics) {\r\n      await client.query(`\r\n        INSERT INTO smf_facilitator_metrics (\r\n          kind, facilitator_id, resource_url, server_id, network,\r\n          timeframe, bucket_minutes, time_bucket_start, time_bucket_end,\r\n          invocations, success_count, failure_count,\r\n          count_2xx, count_3xx, count_4xx, count_5xx,\r\n          error_rate, avg_latency_ms, p50_latency_ms, p90_latency_ms, p95_latency_ms, p99_latency_ms,\r\n          methods, fetched_at, updated_at\r\n        ) VALUES (\r\n          $1, $2, $3, $4, $5,\r\n          $6, $7, $8, $9,\r\n          $10, $11, $12,\r\n          $13, $14, $15, $16,\r\n          $17, $18, $19, $20, $21, $22,\r\n          $23, $24, NOW()\r\n        )\r\n        ON CONFLICT (facilitator_id, timeframe, time_bucket_start)\r\n        DO UPDATE SET\r\n          kind = EXCLUDED.kind,\r\n          resource_url = EXCLUDED.resource_url,\r\n          server_id = EXCLUDED.server_id,\r\n          network = EXCLUDED.network,\r\n          bucket_minutes = EXCLUDED.bucket_minutes,\r\n          time_bucket_end = EXCLUDED.time_bucket_end,\r\n          invocations = EXCLUDED.invocations,\r\n          success_count = EXCLUDED.success_count,\r\n          failure_count = EXCLUDED.failure_count,\r\n          count_2xx = EXCLUDED.count_2xx,\r\n          count_3xx = EXCLUDED.count_3xx,\r\n          count_4xx = EXCLUDED.count_4xx,\r\n          count_5xx = EXCLUDED.count_5xx,\r\n          error_rate = EXCLUDED.error_rate,\r\n          avg_latency_ms = EXCLUDED.avg_latency_ms,\r\n          p50_latency_ms = EXCLUDED.p50_latency_ms,\r\n          p90_latency_ms = EXCLUDED.p90_latency_ms,\r\n          p95_latency_ms = EXCLUDED.p95_latency_ms,\r\n          p99_latency_ms = EXCLUDED.p99_latency_ms,\r\n          methods = EXCLUDED.methods,\r\n          fetched_at = EXCLUDED.fetched_at,\r\n          updated_at = NOW()\r\n      `, [\r\n        m.kind,\r\n        m.facilitatorId,\r\n        m.resourceUrl || null,\r\n        m.serverId || null,\r\n        m.network || null,\r\n        m.timeframe,\r\n        m.bucketMinutes,\r\n        m.timeBucketStart,\r\n        m.timeBucketEnd,\r\n        m.invocations,\r\n        m.successCount,\r\n        m.failureCount,\r\n        m.count2xx,\r\n        m.count3xx,\r\n        m.count4xx,\r\n        m.count5xx,\r\n        m.errorRate,\r\n        m.avgLatencyMs || null,\r\n        m.p50LatencyMs || null,\r\n        m.p90LatencyMs || null,\r\n        m.p95LatencyMs || null,\r\n        m.p99LatencyMs || null,\r\n        m.methods ? JSON.stringify(m.methods) : null,\r\n        m.fetchedAt,\r\n      ]);\r\n    }\r\n\r\n    await client.query('COMMIT');\r\n    \r\n    logger.info({\r\n      count: metrics.length,\r\n      facilitatorId: metrics[0]?.facilitatorId,\r\n      timeframe: metrics[0]?.timeframe,\r\n      msg: 'Facilitator metrics upserted to database',\r\n    });\r\n  } catch (error) {\r\n    await client.query('ROLLBACK');\r\n    throw error;\r\n  } finally {\r\n    client.release();\r\n  }\r\n}\r\n\r\n/**\r\n * Load metrics from database\r\n */\r\nasync function loadMetricsFromDb(\r\n  facilitatorId?: string,\r\n  timeframe?: FacilitatorPathMetricsTimeframe\r\n): Promise<FacilitatorPathMetrics[]> {\r\n  const db = getPool();\r\n  if (!db) return [];\r\n\r\n  let query = `\r\n    SELECT * FROM smf_facilitator_metrics\r\n    WHERE fetched_at > NOW() - INTERVAL '30 days'\r\n  `;\r\n  const params: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (facilitatorId) {\r\n    query += ` AND facilitator_id = $${paramIndex}`;\r\n    params.push(facilitatorId);\r\n    paramIndex++;\r\n  }\r\n\r\n  if (timeframe) {\r\n    query += ` AND timeframe = $${paramIndex}`;\r\n    params.push(timeframe);\r\n    paramIndex++;\r\n  }\r\n\r\n  query += ' ORDER BY time_bucket_start DESC LIMIT 1000';\r\n\r\n  const result = await db.query(query, params);\r\n  return result.rows.map(mapDbRowToMetrics);\r\n}\r\n\r\n/**\r\n * Map database row to FacilitatorPathMetrics\r\n */\r\nfunction mapDbRowToMetrics(row: any): FacilitatorPathMetrics {\r\n  return {\r\n    kind: row.kind || 'facilitator-global',\r\n    facilitatorId: row.facilitator_id,\r\n    resourceUrl: row.resource_url || undefined,\r\n    serverId: row.server_id || undefined,\r\n    network: row.network || undefined,\r\n    timeframe: row.timeframe,\r\n    bucketMinutes: row.bucket_minutes,\r\n    timeBucketStart: row.time_bucket_start?.toISOString() || row.time_bucket_start,\r\n    timeBucketEnd: row.time_bucket_end?.toISOString() || row.time_bucket_end,\r\n    invocations: row.invocations,\r\n    successCount: row.success_count,\r\n    failureCount: row.failure_count,\r\n    count2xx: row.count_2xx,\r\n    count3xx: row.count_3xx,\r\n    count4xx: row.count_4xx,\r\n    count5xx: row.count_5xx,\r\n    errorRate: parseFloat(row.error_rate) || 0,\r\n    avgLatencyMs: row.avg_latency_ms ? parseFloat(row.avg_latency_ms) : undefined,\r\n    p50LatencyMs: row.p50_latency_ms ? parseFloat(row.p50_latency_ms) : undefined,\r\n    p90LatencyMs: row.p90_latency_ms ? parseFloat(row.p90_latency_ms) : undefined,\r\n    p95LatencyMs: row.p95_latency_ms ? parseFloat(row.p95_latency_ms) : undefined,\r\n    p99LatencyMs: row.p99_latency_ms ? parseFloat(row.p99_latency_ms) : undefined,\r\n    methods: row.methods || undefined,\r\n    fetchedAt: row.fetched_at?.toISOString() || row.fetched_at,\r\n  };\r\n}\r\n\r\n/**\r\n * Upsert summary to database\r\n */\r\nasync function upsertSummaryToDb(summary: FacilitatorSummary): Promise<void> {\r\n  const db = getPool();\r\n  if (!db) return;\r\n\r\n  // Handle empty timestamps - skip if no valid data\r\n  const dataStart = summary.dataStart && summary.dataStart.length > 0 ? summary.dataStart : null;\r\n  const dataEnd = summary.dataEnd && summary.dataEnd.length > 0 ? summary.dataEnd : null;\r\n  \r\n  // Skip summaries with no actual data\r\n  if (summary.totalInvocations === 0 && !dataStart && !dataEnd) {\r\n    logger.debug({\r\n      facilitatorId: summary.facilitatorId,\r\n      timeframe: summary.timeframe,\r\n      msg: 'Skipping summary with no data',\r\n    });\r\n    return;\r\n  }\r\n\r\n  await db.query(`\r\n    INSERT INTO smf_facilitator_summaries (\r\n      facilitator_id, timeframe,\r\n      total_invocations, total_successes, total_failures, overall_error_rate,\r\n      avg_p50_latency_ms, avg_p90_latency_ms, avg_p99_latency_ms,\r\n      top_methods, data_start, data_end, fetched_at, updated_at\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, NOW())\r\n    ON CONFLICT (facilitator_id, timeframe)\r\n    DO UPDATE SET\r\n      total_invocations = EXCLUDED.total_invocations,\r\n      total_successes = EXCLUDED.total_successes,\r\n      total_failures = EXCLUDED.total_failures,\r\n      overall_error_rate = EXCLUDED.overall_error_rate,\r\n      avg_p50_latency_ms = EXCLUDED.avg_p50_latency_ms,\r\n      avg_p90_latency_ms = EXCLUDED.avg_p90_latency_ms,\r\n      avg_p99_latency_ms = EXCLUDED.avg_p99_latency_ms,\r\n      top_methods = EXCLUDED.top_methods,\r\n      data_start = COALESCE(EXCLUDED.data_start, smf_facilitator_summaries.data_start),\r\n      data_end = COALESCE(EXCLUDED.data_end, smf_facilitator_summaries.data_end),\r\n      fetched_at = EXCLUDED.fetched_at,\r\n      updated_at = NOW()\r\n  `, [\r\n    summary.facilitatorId,\r\n    summary.timeframe,\r\n    summary.totalInvocations,\r\n    summary.totalSuccesses,\r\n    summary.totalFailures,\r\n    summary.overallErrorRate,\r\n    summary.avgP50LatencyMs || null,\r\n    summary.avgP90LatencyMs || null,\r\n    summary.avgP99LatencyMs || null,\r\n    JSON.stringify(summary.topMethods),\r\n    dataStart,\r\n    dataEnd,\r\n    summary.fetchedAt,\r\n  ]);\r\n\r\n  logger.info({\r\n    facilitatorId: summary.facilitatorId,\r\n    timeframe: summary.timeframe,\r\n    totalInvocations: summary.totalInvocations,\r\n    msg: 'Facilitator summary upserted to database',\r\n  });\r\n}\r\n\r\n/**\r\n * Load all summaries from database\r\n */\r\nasync function loadSummariesFromDb(): Promise<Record<string, FacilitatorSummary>> {\r\n  const db = getPool();\r\n  if (!db) return {};\r\n\r\n  const result = await db.query(`\r\n    SELECT * FROM smf_facilitator_summaries\r\n    ORDER BY fetched_at DESC\r\n  `);\r\n\r\n  const summaries: Record<string, FacilitatorSummary> = {};\r\n  for (const row of result.rows) {\r\n    const key = `${row.facilitator_id}:${row.timeframe}`;\r\n    summaries[key] = {\r\n      facilitatorId: row.facilitator_id,\r\n      timeframe: row.timeframe,\r\n      totalInvocations: parseInt(row.total_invocations) || 0,\r\n      totalSuccesses: parseInt(row.total_successes) || 0,\r\n      totalFailures: parseInt(row.total_failures) || 0,\r\n      overallErrorRate: parseFloat(row.overall_error_rate) || 0,\r\n      avgP50LatencyMs: row.avg_p50_latency_ms ? parseFloat(row.avg_p50_latency_ms) : undefined,\r\n      avgP90LatencyMs: row.avg_p90_latency_ms ? parseFloat(row.avg_p90_latency_ms) : undefined,\r\n      avgP99LatencyMs: row.avg_p99_latency_ms ? parseFloat(row.avg_p99_latency_ms) : undefined,\r\n      topMethods: row.top_methods || [],\r\n      dataStart: row.data_start?.toISOString() || row.data_start,\r\n      dataEnd: row.data_end?.toISOString() || row.data_end,\r\n      fetchedAt: row.fetched_at?.toISOString() || row.fetched_at,\r\n    };\r\n  }\r\n\r\n  return summaries;\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API - Abstracts storage backend\r\n// =============================================================================\r\n\r\n/**\r\n * Check if database is available\r\n */\r\nexport function isDatabaseAvailable(): boolean {\r\n  return getPool() !== null;\r\n}\r\n\r\n/**\r\n * Load all stored metrics\r\n */\r\nexport async function loadAllMetrics(): Promise<FacilitatorPathMetrics[]> {\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      return await loadMetricsFromDb();\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to load metrics from database, returning empty' });\r\n      return [];\r\n    }\r\n  }\r\n  // Fallback: return empty in production if DB not available\r\n  logger.warn({ msg: 'Database not available, returning empty metrics' });\r\n  return [];\r\n}\r\n\r\n/**\r\n * Upsert facilitator path metrics\r\n * Updates existing records or inserts new ones based on (facilitatorId, timeframe, timeBucketStart)\r\n */\r\nexport async function upsertFacilitatorPathMetrics(\r\n  metrics: FacilitatorPathMetrics[]\r\n): Promise<void> {\r\n  if (metrics.length === 0) {\r\n    logger.debug('No metrics to upsert');\r\n    return;\r\n  }\r\n\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      await upsertMetricsToDb(metrics);\r\n      return;\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to upsert metrics to database' });\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  // In production without DB, log warning\r\n  logger.warn({ \r\n    count: metrics.length, \r\n    msg: 'Database not available, metrics not persisted' \r\n  });\r\n}\r\n\r\n/**\r\n * Load stored summaries\r\n */\r\nexport async function loadAllSummaries(): Promise<Record<string, FacilitatorSummary>> {\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      return await loadSummariesFromDb();\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to load summaries from database' });\r\n      return {};\r\n    }\r\n  }\r\n  return {};\r\n}\r\n\r\n/**\r\n * Upsert facilitator summary\r\n */\r\nexport async function upsertFacilitatorSummary(summary: FacilitatorSummary): Promise<void> {\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      await upsertSummaryToDb(summary);\r\n      return;\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to upsert summary to database' });\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  logger.warn({ \r\n    facilitatorId: summary.facilitatorId, \r\n    msg: 'Database not available, summary not persisted' \r\n  });\r\n}\r\n\r\n/**\r\n * Upsert multiple facilitator summaries\r\n */\r\nexport async function upsertFacilitatorSummaries(summaries: FacilitatorSummary[]): Promise<void> {\r\n  for (const summary of summaries) {\r\n    await upsertFacilitatorSummary(summary);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// QUERY FUNCTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Get metrics for a specific facilitator\r\n */\r\nexport async function getMetricsForFacilitator(\r\n  facilitatorId: string,\r\n  timeframe?: FacilitatorPathMetricsTimeframe\r\n): Promise<FacilitatorPathMetrics[]> {\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      return await loadMetricsFromDb(facilitatorId, timeframe);\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to get metrics for facilitator' });\r\n      return [];\r\n    }\r\n  }\r\n  return [];\r\n}\r\n\r\n/**\r\n * Get summary for a specific facilitator and timeframe\r\n */\r\nexport async function getSummary(\r\n  facilitatorId: string,\r\n  timeframe: FacilitatorPathMetricsTimeframe\r\n): Promise<FacilitatorSummary | null> {\r\n  const summaries = await loadAllSummaries();\r\n  const key = `${facilitatorId}:${timeframe}`;\r\n  return summaries[key] ?? null;\r\n}\r\n\r\n/**\r\n * Get all summaries for a specific facilitator across all timeframes\r\n */\r\nexport async function getSummariesForFacilitator(\r\n  facilitatorId: string\r\n): Promise<FacilitatorSummary[]> {\r\n  const summaries = await loadAllSummaries();\r\n  return Object.values(summaries).filter((s) => s.facilitatorId === facilitatorId);\r\n}\r\n\r\n/**\r\n * Get latest metrics across all facilitators\r\n */\r\nexport async function getLatestMetrics(\r\n  limit: number = 100\r\n): Promise<FacilitatorPathMetrics[]> {\r\n  const allMetrics = await loadAllMetrics();\r\n  return allMetrics.slice(0, limit);\r\n}\r\n\r\n/**\r\n * Get metrics comparison across facilitators for a timeframe\r\n */\r\nexport async function compareFacilitators(\r\n  facilitatorIds: string[],\r\n  timeframe: FacilitatorPathMetricsTimeframe\r\n): Promise<Map<string, FacilitatorSummary | null>> {\r\n  const summaries = await loadAllSummaries();\r\n  const result = new Map<string, FacilitatorSummary | null>();\r\n\r\n  for (const id of facilitatorIds) {\r\n    const key = `${id}:${timeframe}`;\r\n    result.set(id, summaries[key] ?? null);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// =============================================================================\r\n// CLEANUP\r\n// =============================================================================\r\n\r\n/**\r\n * Clean up old metrics data\r\n */\r\nexport async function cleanupOldMetrics(daysToKeep: number = 30): Promise<number> {\r\n  const db = getPool();\r\n  if (!db) return 0;\r\n\r\n  const result = await db.query(`\r\n    DELETE FROM smf_facilitator_metrics\r\n    WHERE time_bucket_start < NOW() - INTERVAL '${daysToKeep} days'\r\n  `);\r\n\r\n  const removed = result.rowCount || 0;\r\n  if (removed > 0) {\r\n    logger.info({ removed, daysToKeep, msg: 'Old metrics cleaned up from database' });\r\n  }\r\n\r\n  return removed;\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8603, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/services/facilitator-volume-service.ts"],"sourcesContent":["// =============================================================================\r\n// FACILITATOR VOLUME SERVICE\r\n// =============================================================================\r\n// Service for persisting and managing facilitator volume/activity metrics from Scattering\r\n// Uses Supabase/PostgreSQL in production, falls back to logging-only in development\r\n//\r\n// =============================================================================\r\n// RETENTION PLAN (TODO)\r\n// =============================================================================\r\n// 1. Current period snapshots (3d):\r\n//    - Keep last 30 snapshots (approx 1 month if pulled daily)\r\n//    - Each snapshot is a full picture of facilitator activity\r\n//\r\n// 2. Historical rollups:\r\n//    - Weekly: Keep 12 weeks of weekly summaries\r\n//    - Monthly: Keep 12 months of monthly summaries\r\n//\r\n// Compaction strategy:\r\n//    - Average volumeUsd3d, txCount3d across period\r\n//    - Track min/max/avg for trend analysis\r\n//    - Keep peak values for market awareness\r\n//\r\n// TODO: Implement weekly/monthly compaction\r\n// =============================================================================\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport { type ScatteringFacilitatorMetrics } from '@/infra/scattering/types';\r\nimport { Pool } from 'pg';\r\n\r\nconst logger = createLogger({ component: 'FacilitatorVolumeService' });\r\n\r\n// =============================================================================\r\n// DATABASE CONNECTION\r\n// =============================================================================\r\n\r\nlet pool: Pool | null = null;\r\n\r\nfunction getPool(): Pool | null {\r\n  if (pool) return pool;\r\n  \r\n  const databaseUrl = process.env.DATABASE_URL;\r\n  if (!databaseUrl || !databaseUrl.startsWith('postgresql://')) {\r\n    return null;\r\n  }\r\n  \r\n  pool = new Pool({\r\n    connectionString: databaseUrl,\r\n    max: 5,\r\n    idleTimeoutMillis: 30000,\r\n    connectionTimeoutMillis: 5000,\r\n  });\r\n  \r\n  return pool;\r\n}\r\n\r\n// =============================================================================\r\n// DATABASE STORAGE FUNCTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Upsert Scattering metrics to database\r\n */\r\nasync function upsertScatteringToDb(metrics: ScatteringFacilitatorMetrics[]): Promise<void> {\r\n  const db = getPool();\r\n  if (!db || metrics.length === 0) return;\r\n\r\n  const client = await db.connect();\r\n  const fetchedAt = new Date().toISOString();\r\n  const snapshotId = crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(36).slice(2)}`;\r\n  \r\n  try {\r\n    await client.query('BEGIN');\r\n\r\n    for (const m of metrics) {\r\n      // Upsert current metrics\r\n      await client.query(`\r\n        INSERT INTO smf_scattering_metrics (\r\n          facilitator_id, period,\r\n          volume_usd_3d, tx_count_3d, unique_buyers_3d, unique_sellers_3d,\r\n          volume_usd_all_time, chains, volume_change_rate, tx_change_rate,\r\n          fetched_at, updated_at\r\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW())\r\n        ON CONFLICT (facilitator_id, period)\r\n        DO UPDATE SET\r\n          volume_usd_3d = EXCLUDED.volume_usd_3d,\r\n          tx_count_3d = EXCLUDED.tx_count_3d,\r\n          unique_buyers_3d = EXCLUDED.unique_buyers_3d,\r\n          unique_sellers_3d = EXCLUDED.unique_sellers_3d,\r\n          volume_usd_all_time = EXCLUDED.volume_usd_all_time,\r\n          chains = EXCLUDED.chains,\r\n          volume_change_rate = EXCLUDED.volume_change_rate,\r\n          tx_change_rate = EXCLUDED.tx_change_rate,\r\n          fetched_at = EXCLUDED.fetched_at,\r\n          updated_at = NOW()\r\n      `, [\r\n        m.facilitatorId,\r\n        m.period,\r\n        m.volumeUsd3d,\r\n        m.txCount3d,\r\n        m.uniqueBuyers3d,\r\n        m.uniqueSellers3d,\r\n        m.volumeUsdAllTime,\r\n        JSON.stringify(m.chains),\r\n        m.volumeChangeRate ?? null,\r\n        m.txChangeRate ?? null,\r\n        fetchedAt,\r\n      ]);\r\n\r\n      // Insert into history table\r\n      await client.query(`\r\n        INSERT INTO smf_scattering_history (\r\n          snapshot_id, facilitator_id, period,\r\n          volume_usd_3d, tx_count_3d, unique_buyers_3d, unique_sellers_3d,\r\n          volume_usd_all_time, chains, volume_change_rate, tx_change_rate,\r\n          fetched_at\r\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\r\n      `, [\r\n        snapshotId,\r\n        m.facilitatorId,\r\n        m.period,\r\n        m.volumeUsd3d,\r\n        m.txCount3d,\r\n        m.uniqueBuyers3d,\r\n        m.uniqueSellers3d,\r\n        m.volumeUsdAllTime,\r\n        JSON.stringify(m.chains),\r\n        m.volumeChangeRate ?? null,\r\n        m.txChangeRate ?? null,\r\n        fetchedAt,\r\n      ]);\r\n    }\r\n\r\n    await client.query('COMMIT');\r\n    \r\n    // Log summary\r\n    const totalVolume = metrics.reduce((sum, m) => sum + m.volumeUsd3d, 0);\r\n    const totalTxns = metrics.reduce((sum, m) => sum + m.txCount3d, 0);\r\n\r\n    logger.info({\r\n      facilitatorCount: metrics.length,\r\n      totalVolume3d: `$${formatNumber(totalVolume)}`,\r\n      totalTxns3d: formatNumber(totalTxns),\r\n      msg: 'Scattering metrics upserted to database',\r\n    });\r\n  } catch (error) {\r\n    await client.query('ROLLBACK');\r\n    throw error;\r\n  } finally {\r\n    client.release();\r\n  }\r\n}\r\n\r\n/**\r\n * Load current Scattering metrics from database\r\n */\r\nasync function loadScatteringFromDb(): Promise<Record<string, ScatteringFacilitatorMetrics>> {\r\n  const db = getPool();\r\n  if (!db) return {};\r\n\r\n  const result = await db.query(`\r\n    SELECT * FROM smf_scattering_metrics\r\n    ORDER BY fetched_at DESC\r\n  `);\r\n\r\n  const metrics: Record<string, ScatteringFacilitatorMetrics> = {};\r\n  for (const row of result.rows) {\r\n    metrics[row.facilitator_id] = mapDbRowToScattering(row);\r\n  }\r\n\r\n  return metrics;\r\n}\r\n\r\n/**\r\n * Map database row to ScatteringFacilitatorMetrics\r\n */\r\nfunction mapDbRowToScattering(row: any): ScatteringFacilitatorMetrics {\r\n  return {\r\n    facilitatorId: row.facilitator_id,\r\n    period: row.period || '3d',\r\n    volumeUsd3d: parseFloat(row.volume_usd_3d) || 0,\r\n    txCount3d: parseInt(row.tx_count_3d) || 0,\r\n    uniqueBuyers3d: row.unique_buyers_3d || 0,\r\n    uniqueSellers3d: row.unique_sellers_3d || 0,\r\n    volumeUsdAllTime: parseFloat(row.volume_usd_all_time) || 0,\r\n    chains: row.chains || [],\r\n    volumeChangeRate: row.volume_change_rate ? parseFloat(row.volume_change_rate) : undefined,\r\n    txChangeRate: row.tx_change_rate ? parseFloat(row.tx_change_rate) : undefined,\r\n    fetchedAt: row.fetched_at?.toISOString() || row.fetched_at,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API\r\n// =============================================================================\r\n\r\n/**\r\n * Check if database is available\r\n */\r\nexport function isDatabaseAvailable(): boolean {\r\n  return getPool() !== null;\r\n}\r\n\r\n/**\r\n * Upsert Scattering metrics\r\n * - Updates the \"current\" snapshot with latest data\r\n * - Appends to history for trend analysis\r\n */\r\nexport async function upsertScatteringMetrics(\r\n  metrics: ScatteringFacilitatorMetrics[]\r\n): Promise<void> {\r\n  if (metrics.length === 0) {\r\n    logger.debug('No Scattering metrics to upsert');\r\n    return;\r\n  }\r\n\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      await upsertScatteringToDb(metrics);\r\n      return;\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to upsert Scattering metrics to database' });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Log summary even without DB\r\n  const totalVolume = metrics.reduce((sum, m) => sum + m.volumeUsd3d, 0);\r\n  const totalTxns = metrics.reduce((sum, m) => sum + m.txCount3d, 0);\r\n\r\n  logger.warn({\r\n    facilitatorCount: metrics.length,\r\n    totalVolume3d: `$${formatNumber(totalVolume)}`,\r\n    totalTxns3d: formatNumber(totalTxns),\r\n    msg: 'Database not available, Scattering metrics not persisted',\r\n  });\r\n}\r\n\r\n/**\r\n * Load all current Scattering metrics\r\n */\r\nexport async function loadAllScatteringMetrics(): Promise<ScatteringFacilitatorMetrics[]> {\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      const metrics = await loadScatteringFromDb();\r\n      return Object.values(metrics);\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to load Scattering metrics from database' });\r\n      return [];\r\n    }\r\n  }\r\n  return [];\r\n}\r\n\r\n/**\r\n * Get Scattering metrics for a specific facilitator\r\n */\r\nexport async function getScatteringMetricsForFacilitator(\r\n  facilitatorId: string\r\n): Promise<ScatteringFacilitatorMetrics | null> {\r\n  const db = getPool();\r\n  if (!db) return null;\r\n\r\n  try {\r\n    const result = await db.query(`\r\n      SELECT * FROM smf_scattering_metrics\r\n      WHERE facilitator_id = $1\r\n      ORDER BY fetched_at DESC\r\n      LIMIT 1\r\n    `, [facilitatorId]);\r\n\r\n    if (result.rows.length === 0) return null;\r\n    return mapDbRowToScattering(result.rows[0]);\r\n  } catch (error) {\r\n    logger.error({ error, facilitatorId, msg: 'Failed to get Scattering metrics' });\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get Scattering metrics for multiple facilitators\r\n */\r\nexport async function getScatteringMetricsForFacilitators(\r\n  facilitatorIds: string[]\r\n): Promise<Map<string, ScatteringFacilitatorMetrics | null>> {\r\n  const result = new Map<string, ScatteringFacilitatorMetrics | null>();\r\n  \r\n  const db = getPool();\r\n  if (!db) {\r\n    for (const id of facilitatorIds) {\r\n      result.set(id, null);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  try {\r\n    const metrics = await loadScatteringFromDb();\r\n    for (const id of facilitatorIds) {\r\n      result.set(id, metrics[id] ?? null);\r\n    }\r\n    return result;\r\n  } catch (error) {\r\n    logger.error({ error, msg: 'Failed to get Scattering metrics for facilitators' });\r\n    for (const id of facilitatorIds) {\r\n      result.set(id, null);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n/**\r\n * Get historical snapshots for trend analysis\r\n */\r\nexport async function getScatteringHistory(\r\n  limit: number = 10\r\n): Promise<{ fetchedAt: string; metrics: ScatteringFacilitatorMetrics[] }[]> {\r\n  const db = getPool();\r\n  if (!db) return [];\r\n\r\n  try {\r\n    // Get distinct snapshots\r\n    const snapshotsResult = await db.query(`\r\n      SELECT DISTINCT snapshot_id, fetched_at \r\n      FROM smf_scattering_history\r\n      ORDER BY fetched_at DESC\r\n      LIMIT $1\r\n    `, [limit]);\r\n\r\n    const history: { fetchedAt: string; metrics: ScatteringFacilitatorMetrics[] }[] = [];\r\n\r\n    for (const snapshot of snapshotsResult.rows) {\r\n      const metricsResult = await db.query(`\r\n        SELECT * FROM smf_scattering_history\r\n        WHERE snapshot_id = $1\r\n      `, [snapshot.snapshot_id]);\r\n\r\n      history.push({\r\n        fetchedAt: snapshot.fetched_at?.toISOString() || snapshot.fetched_at,\r\n        metrics: metricsResult.rows.map(mapDbRowToScattering),\r\n      });\r\n    }\r\n\r\n    return history;\r\n  } catch (error) {\r\n    logger.error({ error, msg: 'Failed to get Scattering history' });\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get historical metrics for a specific facilitator\r\n */\r\nexport async function getFacilitatorVolumeHistory(\r\n  facilitatorId: string,\r\n  limit: number = 10\r\n): Promise<ScatteringFacilitatorMetrics[]> {\r\n  const db = getPool();\r\n  if (!db) return [];\r\n\r\n  try {\r\n    const result = await db.query(`\r\n      SELECT * FROM smf_scattering_history\r\n      WHERE facilitator_id = $1\r\n      ORDER BY fetched_at DESC\r\n      LIMIT $2\r\n    `, [facilitatorId, limit]);\r\n\r\n    return result.rows.map(mapDbRowToScattering);\r\n  } catch (error) {\r\n    logger.error({ error, facilitatorId, msg: 'Failed to get volume history' });\r\n    return [];\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// ANALYSIS HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Get top facilitators by 3-day volume\r\n */\r\nexport async function getTopFacilitatorsByVolume(\r\n  limit: number = 10\r\n): Promise<ScatteringFacilitatorMetrics[]> {\r\n  const metrics = await loadAllScatteringMetrics();\r\n  \r\n  return metrics\r\n    .sort((a, b) => b.volumeUsd3d - a.volumeUsd3d)\r\n    .slice(0, limit);\r\n}\r\n\r\n/**\r\n * Get top facilitators by 3-day transaction count\r\n */\r\nexport async function getTopFacilitatorsByTxCount(\r\n  limit: number = 10\r\n): Promise<ScatteringFacilitatorMetrics[]> {\r\n  const metrics = await loadAllScatteringMetrics();\r\n  \r\n  return metrics\r\n    .sort((a, b) => b.txCount3d - a.txCount3d)\r\n    .slice(0, limit);\r\n}\r\n\r\n/**\r\n * Get facilitators with positive volume growth\r\n */\r\nexport async function getGrowingFacilitators(): Promise<ScatteringFacilitatorMetrics[]> {\r\n  const metrics = await loadAllScatteringMetrics();\r\n  \r\n  return metrics\r\n    .filter((m) => m.volumeChangeRate !== undefined && m.volumeChangeRate > 0)\r\n    .sort((a, b) => (b.volumeChangeRate ?? 0) - (a.volumeChangeRate ?? 0));\r\n}\r\n\r\n/**\r\n * Calculate activity score for a facilitator (0-1 scale)\r\n * Used by SMF scoring to evaluate facilitator health\r\n */\r\nexport function computeActivityScore(metrics: ScatteringFacilitatorMetrics): number {\r\n  // Weights for different factors\r\n  const VOLUME_WEIGHT = 0.3;\r\n  const TX_WEIGHT = 0.3;\r\n  const BUYERS_WEIGHT = 0.2;\r\n  const SELLERS_WEIGHT = 0.1;\r\n  const GROWTH_WEIGHT = 0.1;\r\n\r\n  // Reference values (approximate top-tier facilitator numbers)\r\n  const MAX_VOLUME = 200_000; // $200K 3d volume\r\n  const MAX_TX = 3_000_000;   // 3M txns\r\n  const MAX_BUYERS = 15_000;  // 15K unique buyers\r\n  const MAX_SELLERS = 1_000;  // 1K unique sellers\r\n\r\n  // Normalize each factor to 0-1\r\n  const volumeScore = Math.min(metrics.volumeUsd3d / MAX_VOLUME, 1);\r\n  const txScore = Math.min(metrics.txCount3d / MAX_TX, 1);\r\n  const buyersScore = Math.min(metrics.uniqueBuyers3d / MAX_BUYERS, 1);\r\n  const sellersScore = Math.min(metrics.uniqueSellers3d / MAX_SELLERS, 1);\r\n\r\n  // Growth bonus (positive growth adds to score, negative subtracts)\r\n  let growthScore = 0.5; // neutral\r\n  if (metrics.volumeChangeRate !== undefined) {\r\n    // Clamp growth between -100% and +100%\r\n    const clampedGrowth = Math.max(-100, Math.min(100, metrics.volumeChangeRate));\r\n    growthScore = (clampedGrowth + 100) / 200; // normalize to 0-1\r\n  }\r\n\r\n  // Calculate weighted score\r\n  const score = \r\n    volumeScore * VOLUME_WEIGHT +\r\n    txScore * TX_WEIGHT +\r\n    buyersScore * BUYERS_WEIGHT +\r\n    sellersScore * SELLERS_WEIGHT +\r\n    growthScore * GROWTH_WEIGHT;\r\n\r\n  return Math.min(Math.max(score, 0), 1); // clamp to 0-1\r\n}\r\n\r\n// =============================================================================\r\n// CLEANUP\r\n// =============================================================================\r\n\r\n/**\r\n * Clean up old history snapshots\r\n */\r\nexport async function cleanupOldSnapshots(keepDays: number = 30): Promise<number> {\r\n  const db = getPool();\r\n  if (!db) return 0;\r\n\r\n  try {\r\n    const result = await db.query(`\r\n      DELETE FROM smf_scattering_history\r\n      WHERE fetched_at < NOW() - INTERVAL '${keepDays} days'\r\n    `);\r\n\r\n    const removed = result.rowCount || 0;\r\n    if (removed > 0) {\r\n      logger.info({ removed, keepDays, msg: 'Old Scattering snapshots cleaned up' });\r\n    }\r\n\r\n    return removed;\r\n  } catch (error) {\r\n    logger.error({ error, msg: 'Failed to cleanup old snapshots' });\r\n    return 0;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// UTILITY\r\n// =============================================================================\r\n\r\n/**\r\n * Format number for logging (e.g., 137535 -> \"137.5K\")\r\n */\r\nfunction formatNumber(num: number): string {\r\n  if (num >= 1_000_000) {\r\n    return `${(num / 1_000_000).toFixed(1)}M`;\r\n  }\r\n  if (num >= 1_000) {\r\n    return `${(num / 1_000).toFixed(1)}K`;\r\n  }\r\n  return num.toFixed(2);\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9041, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/services/facilitator-metrics-reader.ts"],"sourcesContent":["// =============================================================================\n// FACILITATOR METRICS READER\n// =============================================================================\n// Read-side helper for SMF to access facilitator path metrics\n// Used by the SMF router to inform routing decisions\n//\n// Scoring blends two data sources:\n// 1. x402scan: Observability metrics (success rate, latency, confidence)\n// 2. Scattering: Activity metrics (volume, tx count, unique buyers)\n\nimport { createLogger } from '@/lib/logger';\nimport {\n  type FacilitatorPathMetrics,\n  type FacilitatorSummary,\n  type FacilitatorPathMetricsTimeframe,\n} from '@/infra/x402scan/types';\nimport {\n  loadAllMetrics,\n  loadAllSummaries,\n  getSummary,\n  getMetricsForFacilitator,\n} from './facilitator-metrics-service';\nimport {\n  getScatteringMetricsForFacilitator,\n  computeActivityScore,\n} from './facilitator-volume-service';\nimport type { ScatteringFacilitatorMetrics } from '@/infra/scattering/types';\n\nconst logger = createLogger({ component: 'FacilitatorMetricsReader' });\n\n// =============================================================================\n// FRESHNESS & CONFIDENCE CONFIGURATION\n// =============================================================================\n\n/**\n * Configuration for determining when metrics are trustworthy\n * These thresholds prevent routing decisions based on stale or thin data\n */\nexport interface MetricsTrustConfig {\n  /** Maximum age of data to trust (hours) */\n  maxDataAgeHours: number;\n  /** Minimum invocations for high confidence scoring */\n  minInvocationsHighConfidence: number;\n  /** Minimum invocations to use data at all */\n  minInvocationsMinimum: number;\n  /** Penalty multiplier for low confidence data (0-1) */\n  lowConfidencePenalty: number;\n}\n\n/**\n * Default trust configuration\n * Can be overridden via environment variables\n */\nexport const DEFAULT_TRUST_CONFIG: MetricsTrustConfig = {\n  maxDataAgeHours: parseFloat(process.env.METRICS_MAX_AGE_HOURS ?? '4'),\n  minInvocationsHighConfidence: parseInt(process.env.METRICS_MIN_INVOCATIONS_HIGH ?? '1000', 10),\n  minInvocationsMinimum: parseInt(process.env.METRICS_MIN_INVOCATIONS ?? '100', 10),\n  lowConfidencePenalty: parseFloat(process.env.METRICS_LOW_CONFIDENCE_PENALTY ?? '0.5'),\n};\n\n/**\n * Check if metrics should be trusted for routing decisions\n */\nexport function shouldTrustMetrics(\n  dataAgeHours: number,\n  invocations: number,\n  config: MetricsTrustConfig = DEFAULT_TRUST_CONFIG\n): { trust: boolean; confidence: 'high' | 'medium' | 'low' | 'none'; reason: string } {\n  // Data too old\n  if (dataAgeHours > config.maxDataAgeHours) {\n    return {\n      trust: false,\n      confidence: 'none',\n      reason: `data-stale:${dataAgeHours.toFixed(1)}h-old`,\n    };\n  }\n\n  // Not enough data\n  if (invocations < config.minInvocationsMinimum) {\n    return {\n      trust: false,\n      confidence: 'none',\n      reason: `insufficient-data:${invocations}-invocations`,\n    };\n  }\n\n  // High confidence\n  if (invocations >= config.minInvocationsHighConfidence) {\n    return {\n      trust: true,\n      confidence: 'high',\n      reason: `high-confidence:${invocations}-invocations`,\n    };\n  }\n\n  // Medium confidence\n  return {\n    trust: true,\n    confidence: 'medium',\n    reason: `medium-confidence:${invocations}-invocations`,\n  };\n}\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface GetBestPathsParams {\n  /** Facilitator ID (NexFlow format, e.g., \"cdp\", \"payai\") */\n  facilitatorId: string;\n  \n  /** Network filter (optional) */\n  network?: string;\n  \n  /** Timeframe to consider (default: \"1d\") */\n  timeframe?: FacilitatorPathMetricsTimeframe;\n  \n  /** Maximum number of results */\n  limit?: number;\n}\n\nexport interface FacilitatorScoreParams {\n  /** Facilitator ID */\n  facilitatorId: string;\n  \n  /** Timeframe to consider */\n  timeframe?: FacilitatorPathMetricsTimeframe;\n}\n\nexport interface FacilitatorScore {\n  facilitatorId: string;\n  score: number;             // 0-100, higher is better\n  successRate: number;       // 0-1\n  avgLatencyMs?: number;\n  p95LatencyMs?: number;\n  totalInvocations: number;\n  dataFreshness: number;     // hours since last data\n  confidence: 'high' | 'medium' | 'low' | 'none';  // based on data availability\n  reasons: string[];\n  // Scattering activity metrics\n  scatteringActivityScore?: number;    // 0-1 activity score from Scattering\n  scatteringVolume3d?: number;         // 3-day volume in USD\n  scatteringTxCount3d?: number;        // 3-day transaction count\n  scatteringUniqueBuyers3d?: number;   // 3-day unique buyers\n  scatteringLowActivity?: boolean;     // true if below thresholds\n}\n\nexport interface FacilitatorRanking {\n  rankings: FacilitatorScore[];\n  timestamp: string;\n  timeframe: FacilitatorPathMetricsTimeframe;\n}\n\n// =============================================================================\n// SCORING WEIGHTS & CONFIGURATION\n// =============================================================================\n\n/**\n * Scattering score weight (0-1)\n * Controls how much Scattering activity metrics influence the final score\n * Default: 0.2 (20%) - configurable via SCATTERING_SCORE_WEIGHT env var\n */\nconst SCATTERING_SCORE_WEIGHT = parseFloat(process.env.SCATTERING_SCORE_WEIGHT ?? '0.2');\n\n/**\n * Minimum thresholds for Scattering data to be considered meaningful\n * Below these thresholds, activity is flagged as \"low\" and doesn't boost score\n */\nconst SCATTERING_MIN_TX_COUNT_3D = parseInt(process.env.SCATTERING_MIN_TX_COUNT ?? '100', 10);\nconst SCATTERING_MIN_VOLUME_USD_3D = parseFloat(process.env.SCATTERING_MIN_VOLUME ?? '100');\n\n/**\n * x402scan score weight (the remainder after Scattering)\n * x402scan measures reliability (success rate, latency, confidence)\n */\nconst X402SCAN_SCORE_WEIGHT = 1 - SCATTERING_SCORE_WEIGHT;\n\n/**\n * Internal weights for x402scan sub-components\n * These are applied to the x402scan portion of the score\n */\nconst SCORING_WEIGHTS = {\n  successRate: 50,     // 50% weight on success rate\n  latency: 30,         // 30% weight on latency\n  volume: 10,          // 10% weight on volume (more volume = more confidence)\n  freshness: 10,       // 10% weight on data freshness\n};\n\n// =============================================================================\n// QUERY FUNCTIONS\n// =============================================================================\n\n/**\n * Get best performing facilitator paths\n * Sorted by success rate, then by latency\n */\nexport async function getBestFacilitatorPaths(\n  params: GetBestPathsParams\n): Promise<FacilitatorPathMetrics[]> {\n  const timeframe = params.timeframe ?? '1d';\n  const limit = params.limit ?? 10;\n\n  try {\n    const metrics = await getMetricsForFacilitator(params.facilitatorId, timeframe);\n\n    if (metrics.length === 0) {\n      logger.debug({\n        facilitatorId: params.facilitatorId,\n        timeframe,\n        msg: 'No metrics found for facilitator',\n      });\n      return [];\n    }\n\n    // Sort by success rate (descending), then by latency (ascending)\n    const sorted = [...metrics].sort((a, b) => {\n      // Primary: higher success rate is better\n      const successRateDiff = (1 - b.errorRate) - (1 - a.errorRate);\n      if (Math.abs(successRateDiff) > 0.01) {\n        return successRateDiff > 0 ? 1 : -1;\n      }\n\n      // Secondary: lower latency is better\n      const aLatency = a.p95LatencyMs ?? a.avgLatencyMs ?? Infinity;\n      const bLatency = b.p95LatencyMs ?? b.avgLatencyMs ?? Infinity;\n      return aLatency - bLatency;\n    });\n\n    return sorted.slice(0, limit);\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId: params.facilitatorId,\n      msg: 'Failed to get best facilitator paths',\n    });\n    return [];\n  }\n}\n\n/**\n * Calculate a composite score for a facilitator blending:\n * 1. x402scan: reliability metrics (success rate, latency, confidence)\n * 2. Scattering: activity metrics (volume, tx count, unique buyers)\n * \n * Score is 0-100, higher is better\n * \n * The blend is controlled by SCATTERING_SCORE_WEIGHT (default 0.2):\n * - x402scan contributes (1 - SCATTERING_SCORE_WEIGHT) * x402scanScore\n * - Scattering contributes SCATTERING_SCORE_WEIGHT * scatteringScore\n */\nexport async function getFacilitatorScore(\n  params: FacilitatorScoreParams\n): Promise<FacilitatorScore | null> {\n  const timeframe = params.timeframe ?? '1d';\n  const reasons: string[] = [];\n\n  try {\n    // ==========================================================================\n    // PART 1: x402scan reliability metrics\n    // ==========================================================================\n    const summary = await getSummary(params.facilitatorId, timeframe);\n    \n    let x402scanScore = 50; // Default neutral\n    let successRate = 0;\n    let hoursOld = Infinity;\n    let totalInvocations = 0;\n    let avgLatencyMs: number | undefined;\n    let p95LatencyMs: number | undefined;\n    let hasX402scanData = false;\n\n    if (summary) {\n      hasX402scanData = true;\n      \n      // Calculate success rate score (0-50)\n      successRate = 1 - summary.overallErrorRate;\n      const successRateScore = successRate * SCORING_WEIGHTS.successRate;\n      reasons.push(`success-rate:${(successRate * 100).toFixed(1)}%`);\n\n      // Calculate latency score (0-30)\n      let latencyScore = SCORING_WEIGHTS.latency;\n      const p95 = summary.avgP90LatencyMs ?? summary.avgP99LatencyMs;\n      if (p95 !== undefined) {\n        const normalizedLatency = Math.min(p95, 2000) / 2000;\n        latencyScore = (1 - normalizedLatency) * SCORING_WEIGHTS.latency;\n        reasons.push(`p95-latency:${p95.toFixed(0)}ms`);\n        p95LatencyMs = summary.avgP90LatencyMs;\n      } else {\n        latencyScore = SCORING_WEIGHTS.latency * 0.5;\n        reasons.push('latency:unknown');\n      }\n\n      // Calculate volume score (0-10)\n      const volumeThreshold = 1000;\n      const volumeRatio = Math.min(summary.totalInvocations / volumeThreshold, 1);\n      const volumeScore = volumeRatio * SCORING_WEIGHTS.volume;\n      totalInvocations = summary.totalInvocations;\n      reasons.push(`x402scan:${summary.totalInvocations}/${summary.totalInvocations >= 1000 ? 'high' : summary.totalInvocations >= 100 ? 'medium' : 'low'}-confidence`);\n\n      // Calculate freshness score (0-10)\n      const fetchedAt = new Date(summary.fetchedAt);\n      hoursOld = (Date.now() - fetchedAt.getTime()) / (1000 * 60 * 60);\n      const freshnessRatio = Math.max(0, 1 - hoursOld / 24);\n      const freshnessScore = freshnessRatio * SCORING_WEIGHTS.freshness;\n\n      x402scanScore = successRateScore + latencyScore + volumeScore + freshnessScore;\n      avgLatencyMs = summary.avgP50LatencyMs;\n    } else {\n      reasons.push('x402scan:no-data');\n    }\n\n    // ==========================================================================\n    // PART 2: Scattering activity metrics\n    // ==========================================================================\n    let scatteringActivityScore = 0;\n    let scatteringVolume3d: number | undefined;\n    let scatteringTxCount3d: number | undefined;\n    let scatteringUniqueBuyers3d: number | undefined;\n    let scatteringLowActivity = false;\n    let hasScatteringData = false;\n\n    try {\n      const scattering = await getScatteringMetricsForFacilitator(params.facilitatorId);\n      \n      if (scattering) {\n        hasScatteringData = true;\n        scatteringVolume3d = scattering.volumeUsd3d;\n        scatteringTxCount3d = scattering.txCount3d;\n        scatteringUniqueBuyers3d = scattering.uniqueBuyers3d;\n\n        // Check for low activity guardrail\n        const isLowActivity = \n          scattering.txCount3d < SCATTERING_MIN_TX_COUNT_3D &&\n          scattering.volumeUsd3d < SCATTERING_MIN_VOLUME_USD_3D;\n\n        if (isLowActivity) {\n          scatteringLowActivity = true;\n          scatteringActivityScore = 0.1; // Minimal score for low activity\n          reasons.push(`scattering-low-activity:${scattering.txCount3d}tx/$${scattering.volumeUsd3d.toFixed(0)}`);\n        } else {\n          // Compute normalized activity score (0-1)\n          scatteringActivityScore = computeActivityScore(scattering);\n          reasons.push(`scattering-activity:${scatteringActivityScore.toFixed(2)}`);\n        }\n      } else {\n        reasons.push('scattering:no-data');\n      }\n    } catch (error) {\n      logger.debug({\n        error: error instanceof Error ? error.message : 'Unknown',\n        facilitatorId: params.facilitatorId,\n        msg: 'Failed to fetch Scattering metrics for scoring',\n      });\n      reasons.push('scattering:error');\n    }\n\n    // ==========================================================================\n    // PART 3: Blend x402scan and Scattering scores\n    // ==========================================================================\n    let finalScore: number;\n    \n    if (hasX402scanData && hasScatteringData) {\n      // Both sources available - blend according to weights\n      // x402scan score is 0-100, Scattering score is 0-1 (convert to 0-100)\n      finalScore = (X402SCAN_SCORE_WEIGHT * x402scanScore) + \n                   (SCATTERING_SCORE_WEIGHT * scatteringActivityScore * 100);\n    } else if (hasX402scanData) {\n      // Only x402scan - use full weight\n      finalScore = x402scanScore;\n    } else if (hasScatteringData) {\n      // Only Scattering - convert to 0-100 scale\n      finalScore = scatteringActivityScore * 100;\n    } else {\n      // No data - neutral score\n      finalScore = 50;\n    }\n\n    // ==========================================================================\n    // PART 4: Determine confidence level\n    // ==========================================================================\n    let confidence: 'high' | 'medium' | 'low' | 'none' = 'none';\n    \n    if (hasX402scanData) {\n      if (totalInvocations >= 1000 && hoursOld < 6) {\n        confidence = 'high';\n      } else if (totalInvocations >= 100 && hoursOld < 24) {\n        confidence = 'medium';\n      } else {\n        confidence = 'low';\n      }\n    } else if (hasScatteringData && !scatteringLowActivity) {\n      // Scattering-only data provides some confidence\n      confidence = scatteringActivityScore > 0.5 ? 'medium' : 'low';\n    }\n\n    return {\n      facilitatorId: params.facilitatorId,\n      score: Math.round(finalScore),\n      successRate,\n      avgLatencyMs,\n      p95LatencyMs,\n      totalInvocations,\n      dataFreshness: hoursOld,\n      confidence,\n      reasons,\n      // Scattering fields\n      scatteringActivityScore: hasScatteringData ? scatteringActivityScore : undefined,\n      scatteringVolume3d,\n      scatteringTxCount3d,\n      scatteringUniqueBuyers3d,\n      scatteringLowActivity: scatteringLowActivity || undefined,\n    };\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId: params.facilitatorId,\n      msg: 'Failed to get facilitator score',\n    });\n    return null;\n  }\n}\n\n/**\n * Rank multiple facilitators by their x402scan-derived score\n * Enforces freshness and confidence thresholds - only returns trusted scores\n * \n * @param facilitatorIds - List of facilitator IDs to rank\n * @param timeframe - Timeframe for metrics (default: '1d')\n * @param config - Trust configuration (default: DEFAULT_TRUST_CONFIG)\n */\nexport async function rankFacilitators(\n  facilitatorIds: string[],\n  timeframe: FacilitatorPathMetricsTimeframe = '1d',\n  config: MetricsTrustConfig = DEFAULT_TRUST_CONFIG\n): Promise<FacilitatorRanking> {\n  const scores: FacilitatorScore[] = [];\n  const untrusted: Array<{ id: string; reason: string }> = [];\n\n  for (const id of facilitatorIds) {\n    const score = await getFacilitatorScore({ facilitatorId: id, timeframe });\n    \n    if (!score) {\n      untrusted.push({ id, reason: 'no-data' });\n      continue;\n    }\n\n    // Check if metrics meet trust thresholds\n    const trustCheck = shouldTrustMetrics(\n      score.dataFreshness,\n      score.totalInvocations,\n      config\n    );\n\n    if (!trustCheck.trust) {\n      untrusted.push({ id, reason: trustCheck.reason });\n      // Still include in rankings but with penalized score\n      scores.push({\n        ...score,\n        score: score.score * config.lowConfidencePenalty, // Heavy penalty\n        confidence: 'low',\n        reasons: [...score.reasons, `untrusted:${trustCheck.reason}`],\n      });\n      continue;\n    }\n\n    // Apply confidence-based adjustments\n    if (trustCheck.confidence === 'medium') {\n      // Slight penalty for medium confidence\n      scores.push({\n        ...score,\n        score: score.score * 0.9, // 10% penalty\n        confidence: 'medium',\n        reasons: [...score.reasons, trustCheck.reason],\n      });\n    } else {\n      // High confidence - use score as-is\n      scores.push({\n        ...score,\n        reasons: [...score.reasons, trustCheck.reason],\n      });\n    }\n  }\n\n  // Log untrusted facilitators for visibility\n  if (untrusted.length > 0) {\n    logger.debug({\n      untrusted,\n      trusted: scores.filter((s) => s.confidence !== 'low').map((s) => s.facilitatorId),\n      msg: 'Facilitator metrics trust check results',\n    });\n  }\n\n  // Sort by score descending\n  scores.sort((a, b) => b.score - a.score);\n\n  return {\n    rankings: scores,\n    timestamp: new Date().toISOString(),\n    timeframe,\n  };\n}\n\n/**\n * Get recommended facilitator for a given context\n * Uses x402scan data to inform the recommendation\n * Falls back to default candidate when metrics are stale/missing\n */\nexport async function getRecommendedFacilitator(\n  candidateIds: string[],\n  options?: {\n    network?: string;\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    prioritize?: 'latency' | 'reliability' | 'balanced';\n    trustConfig?: MetricsTrustConfig;\n  }\n): Promise<{\n  recommended: string | null;\n  ranking: FacilitatorRanking;\n  reason: string;\n  usedFallback: boolean;\n}> {\n  const timeframe = options?.timeframe ?? '1d';\n  const trustConfig = options?.trustConfig ?? DEFAULT_TRUST_CONFIG;\n  const ranking = await rankFacilitators(candidateIds, timeframe, trustConfig);\n\n  // Check if we have any trusted rankings\n  const trustedRankings = ranking.rankings.filter((r) => r.confidence !== 'low');\n\n  if (trustedRankings.length === 0) {\n    // No trusted data - fall back to first candidate\n    logger.warn({\n      candidates: candidateIds,\n      rankings: ranking.rankings.map((r) => ({\n        id: r.facilitatorId,\n        confidence: r.confidence,\n        reasons: r.reasons,\n      })),\n      msg: 'No trusted x402scan data available, using fallback',\n    });\n\n    return {\n      recommended: candidateIds[0] ?? null,\n      ranking,\n      reason: 'No trusted x402scan data (stale or insufficient), using default order',\n      usedFallback: true,\n    };\n  }\n\n  const prioritize = options?.prioritize ?? 'balanced';\n  let recommended: FacilitatorScore;\n\n  switch (prioritize) {\n    case 'latency':\n      // Sort by latency (ascending), filter out unknown latency, only trusted\n      const byLatency = trustedRankings\n        .filter((r) => r.p95LatencyMs !== undefined)\n        .sort((a, b) => (a.p95LatencyMs ?? Infinity) - (b.p95LatencyMs ?? Infinity));\n      recommended = byLatency[0] ?? trustedRankings[0];\n      break;\n\n    case 'reliability':\n      // Sort by success rate (descending), only trusted\n      const byReliability = [...trustedRankings].sort((a, b) => b.successRate - a.successRate);\n      recommended = byReliability[0];\n      break;\n\n    case 'balanced':\n    default:\n      // Use overall score from trusted rankings\n      recommended = trustedRankings[0];\n      break;\n  }\n\n  return {\n    recommended: recommended.facilitatorId,\n    ranking,\n    reason: `Selected ${recommended.facilitatorId} with score ${recommended.score} ` +\n      `(${recommended.confidence} confidence, ${recommended.reasons.slice(0, 3).join(', ')})`,\n    usedFallback: false,\n  };\n}\n\n/**\n * Check if a facilitator should be avoided based on recent performance\n */\nexport async function shouldAvoidFacilitator(\n  facilitatorId: string,\n  threshold: {\n    maxErrorRate?: number;    // Default: 0.2 (20%)\n    minInvocations?: number;  // Default: 10\n  } = {}\n): Promise<{\n  avoid: boolean;\n  reason?: string;\n}> {\n  const maxErrorRate = threshold.maxErrorRate ?? 0.2;\n  const minInvocations = threshold.minInvocations ?? 10;\n\n  try {\n    const score = await getFacilitatorScore({ facilitatorId, timeframe: '1d' });\n\n    if (!score) {\n      return { avoid: false, reason: 'No data available' };\n    }\n\n    // Not enough data to make a decision\n    if (score.totalInvocations < minInvocations) {\n      return { avoid: false, reason: `Insufficient data (${score.totalInvocations} invocations)` };\n    }\n\n    // Check error rate\n    const errorRate = 1 - score.successRate;\n    if (errorRate > maxErrorRate) {\n      return {\n        avoid: true,\n        reason: `Error rate ${(errorRate * 100).toFixed(1)}% exceeds threshold ${(maxErrorRate * 100).toFixed(1)}%`,\n      };\n    }\n\n    return { avoid: false };\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId,\n      msg: 'Failed to check if facilitator should be avoided',\n    });\n    return { avoid: false, reason: 'Error checking metrics' };\n  }\n}\n\n/**\n * Get all available facilitator summaries\n * Useful for dashboard/monitoring\n */\nexport async function getAllFacilitatorSummaries(): Promise<Record<string, FacilitatorSummary>> {\n  return loadAllSummaries();\n}\n\n// =============================================================================\n// SMF EXPLAINER\n// =============================================================================\n\n/**\n * Structured explanation for SMF routing decisions\n */\nexport interface FacilitatorExplanation {\n  facilitatorId: string;\n  selected: boolean;\n  score: number;\n  confidence: 'high' | 'medium' | 'low' | 'none';\n  shortReason: string;      // One-line summary\n  detailedReasons: string[];\n  metrics: {\n    successRate?: number;\n    errorRate?: number;\n    p95LatencyMs?: number;\n    invocations?: number;\n    dataAgeHours?: number;\n  };\n}\n\n/**\n * Get a structured explanation for why a facilitator was/wasn't selected\n * Used by SMF to provide transparent routing decisions\n * \n * @example\n * const explanation = await getFacilitatorExplainer('cdp', { timeframe: '1d' });\n * console.log(explanation.shortReason);\n * // \"cdp: 98.5% success, 185ms p95, high confidence (12K invocations)\"\n */\nexport async function getFacilitatorExplainer(\n  facilitatorId: string,\n  options?: {\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    wasSelected?: boolean;\n  }\n): Promise<FacilitatorExplanation> {\n  const timeframe = options?.timeframe ?? '1d';\n  const wasSelected = options?.wasSelected ?? false;\n\n  const score = await getFacilitatorScore({ facilitatorId, timeframe });\n\n  if (!score) {\n    return {\n      facilitatorId,\n      selected: wasSelected,\n      score: 50,\n      confidence: 'low',\n      shortReason: `${facilitatorId}: no x402scan data available`,\n      detailedReasons: ['No observability data from x402scan'],\n      metrics: {},\n    };\n  }\n\n  // Build short reason string\n  const successPct = (score.successRate * 100).toFixed(1);\n  const latencyStr = score.p95LatencyMs ? `${score.p95LatencyMs.toFixed(0)}ms p95` : 'latency unknown';\n  const volumeStr = score.totalInvocations >= 1000 \n    ? `${(score.totalInvocations / 1000).toFixed(1)}K invocations`\n    : `${score.totalInvocations} invocations`;\n\n  const shortReason = `${facilitatorId}: ${successPct}% success, ${latencyStr}, ${score.confidence} confidence (${volumeStr})`;\n\n  // Build detailed reasons\n  const detailedReasons: string[] = [];\n  \n  if (score.successRate >= 0.99) {\n    detailedReasons.push(`Excellent success rate: ${successPct}%`);\n  } else if (score.successRate >= 0.95) {\n    detailedReasons.push(`Good success rate: ${successPct}%`);\n  } else if (score.successRate >= 0.90) {\n    detailedReasons.push(`Acceptable success rate: ${successPct}%`);\n  } else {\n    detailedReasons.push(` Low success rate: ${successPct}%`);\n  }\n\n  if (score.p95LatencyMs !== undefined) {\n    if (score.p95LatencyMs < 200) {\n      detailedReasons.push(`Fast response times: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    } else if (score.p95LatencyMs < 500) {\n      detailedReasons.push(`Moderate latency: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    } else {\n      detailedReasons.push(` High latency: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    }\n  }\n\n  if (score.confidence === 'high') {\n    detailedReasons.push(`High confidence: ${volumeStr}, data ${score.dataFreshness.toFixed(1)}h old`);\n  } else if (score.confidence === 'medium') {\n    detailedReasons.push(`Medium confidence: ${volumeStr}`);\n  } else {\n    detailedReasons.push(`Low confidence: limited data (${volumeStr})`);\n  }\n\n  if (score.dataFreshness > 12) {\n    detailedReasons.push(` Data is ${score.dataFreshness.toFixed(1)} hours old`);\n  }\n\n  return {\n    facilitatorId,\n    selected: wasSelected,\n    score: score.score,\n    confidence: score.confidence,\n    shortReason,\n    detailedReasons,\n    metrics: {\n      successRate: score.successRate,\n      errorRate: 1 - score.successRate,\n      p95LatencyMs: score.p95LatencyMs,\n      invocations: score.totalInvocations,\n      dataAgeHours: score.dataFreshness,\n    },\n  };\n}\n\n/**\n * Get explanations for multiple facilitators (for comparison)\n */\nexport async function getMultipleFacilitatorExplanations(\n  facilitatorIds: string[],\n  options?: {\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    selectedId?: string;\n  }\n): Promise<FacilitatorExplanation[]> {\n  const explanations: FacilitatorExplanation[] = [];\n\n  for (const id of facilitatorIds) {\n    const explanation = await getFacilitatorExplainer(id, {\n      timeframe: options?.timeframe,\n      wasSelected: id === options?.selectedId,\n    });\n    explanations.push(explanation);\n  }\n\n  // Sort by score descending\n  return explanations.sort((a, b) => b.score - a.score);\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9594, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/types/facilitator-scores.ts"],"sourcesContent":["// =============================================================================\r\n// FACILITATOR SCORE TYPES\r\n// =============================================================================\r\n// TypeScript interfaces for facilitator score persistence, history, and experiments\r\n// Maps to migration 034_facilitator_scores.ts\r\n\r\n// =============================================================================\r\n// FACILITATOR SCORES\r\n// =============================================================================\r\n\r\n/**\r\n * Persistent facilitator score with time-based decay\r\n * One row per facilitator/chain combination\r\n */\r\nexport interface FacilitatorScore {\r\n  id: string;\r\n  facilitator_id: string;\r\n  chain_id: string;        // e.g., \"eip155:8453\" (Base)\r\n  score: number;           // 0-100 composite score\r\n  confidence: number;      // 0-1 confidence level\r\n  decay_factor: number;    // Legacy; kept for schema compat\r\n  sample_size: number;\r\n  last_updated_at: Date;\r\n  created_at: Date;\r\n}\r\n\r\n/**\r\n * Input for upserting a facilitator score\r\n */\r\nexport interface UpsertFacilitatorScoreInput {\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  score: number;           // 0-100 new observation\r\n  confidence: number;      // 0-1\r\n  sample_size: number;\r\n  now?: Date;\r\n}\r\n\r\n// =============================================================================\r\n// SCORE HISTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Historical score snapshot for trend analysis\r\n */\r\nexport interface FacilitatorScoreHistory {\r\n  id: string;\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  score: number;\r\n  confidence: number;\r\n  sample_size: number;\r\n  snapshot_at: Date;\r\n}\r\n\r\n// =============================================================================\r\n// ROUTING EXPERIMENTS\r\n// =============================================================================\r\n\r\n/**\r\n * Experiment status enum\r\n */\r\nexport type ExperimentStatus = 'draft' | 'running' | 'paused' | 'completed';\r\n\r\n/**\r\n * Routing experiment for A/B testing and canary deployments\r\n */\r\nexport interface RoutingExperiment {\r\n  id: string;\r\n  name: string;\r\n  variant: string;\r\n  facilitator_id: string | null;  // nullable - can apply to all facilitators\r\n  chain_id: string | null;        // nullable - can apply to all chains\r\n  traffic_share: number;          // 0-1 (e.g., 0.1 = 10% of traffic)\r\n  status: ExperimentStatus;\r\n  metrics_tracked: Record<string, unknown>;  // e.g., { success_rate: 0.95 }\r\n  started_at: Date | null;\r\n  ended_at: Date | null;\r\n  completed_at: Date | null;\r\n  created_at: Date;\r\n}\r\n\r\n/**\r\n * Input for creating a routing experiment\r\n */\r\nexport interface CreateRoutingExperimentInput {\r\n  name: string;\r\n  variant: string;\r\n  facilitator_id?: string;\r\n  chain_id?: string;\r\n  traffic_share: number;\r\n}\r\n\r\n/**\r\n * Input for updating experiment metrics\r\n */\r\nexport interface UpdateExperimentMetricsInput {\r\n  experiment_id: string;\r\n  metrics: Record<string, unknown>;\r\n}\r\n\r\n// =============================================================================\r\n// PAYMENT EXPERIMENT ASSIGNMENTS\r\n// =============================================================================\r\n\r\n/**\r\n * Outcome of a payment routed through an experiment\r\n */\r\nexport type PaymentOutcome = 'success' | 'failed' | 'timeout';\r\n\r\n/**\r\n * Payment experiment assignment\r\n * Tracks which payments were routed via which experiments\r\n */\r\nexport interface PaymentExperimentAssignment {\r\n  id: string;\r\n  payment_id: string;\r\n  experiment_id: string;\r\n  assigned_at: Date;\r\n  outcome: PaymentOutcome | null;\r\n  latency_ms: number | null;\r\n  created_at: Date;\r\n}\r\n\r\n/**\r\n * Input for recording a payment experiment assignment\r\n */\r\nexport interface RecordPaymentAssignmentInput {\r\n  payment_id: string;\r\n  experiment_id: string;\r\n  outcome?: PaymentOutcome;\r\n  latency_ms?: number;\r\n}\r\n\r\n// =============================================================================\r\n// ROUTING OUTCOME\r\n// =============================================================================\r\n\r\n/**\r\n * Input for recording a routing outcome\r\n */\r\nexport interface RoutingOutcomeInput {\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  payment_id: string;\r\n  success: boolean;\r\n  latency_ms: number;\r\n  http_status?: number;\r\n  amount_wei?: bigint;\r\n}\r\n\r\n/**\r\n * Effective score returned for routing decisions\r\n */\r\nexport interface EffectiveScore {\r\n  score: number;\r\n  confidence: number;\r\n}\r\n\r\n// =============================================================================\r\n// TIME DECAY CONFIGURATION\r\n// =============================================================================\r\n\r\n/**\r\n * Configuration for time-based score decay\r\n */\r\nexport interface DecayConfig {\r\n  /** Half-life in milliseconds (default: 1 hour = 3600000) */\r\n  halfLifeMs: number;\r\n}\r\n\r\n/**\r\n * Default decay configuration\r\n * After 1 hour, old score is weighted 50%\r\n */\r\nexport const DEFAULT_DECAY_CONFIG: DecayConfig = {\r\n  halfLifeMs: 3600000, // 1 hour\r\n};\r\n\r\n// =============================================================================\r\n// SCORE DELTA CALCULATION\r\n// =============================================================================\r\n\r\n/**\r\n * Configuration for converting outcomes to score deltas\r\n */\r\nexport interface ScoreDeltaConfig {\r\n  /** Base score for successful outcomes */\r\n  successBase: number;\r\n  /** Base score for failed outcomes */\r\n  failureBase: number;\r\n  /** Bonus for low latency (< 500ms) */\r\n  lowLatencyBonus: number;\r\n  /** Bonus for medium latency (< 1000ms) */\r\n  mediumLatencyBonus: number;\r\n  /** Penalty for high latency failures (> 2000ms) */\r\n  highLatencyPenalty: number;\r\n  /** Penalty for 5xx HTTP errors */\r\n  serverErrorPenalty: number;\r\n}\r\n\r\n/**\r\n * Default score delta configuration\r\n */\r\nexport const DEFAULT_SCORE_DELTA_CONFIG: ScoreDeltaConfig = {\r\n  successBase: 75,\r\n  failureBase: 25,\r\n  lowLatencyBonus: 15,      // < 500ms\r\n  mediumLatencyBonus: 5,    // < 1000ms\r\n  highLatencyPenalty: 10,   // > 2000ms\r\n  serverErrorPenalty: 15,   // HTTP 5xx\r\n};\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;AAC1B,gFAAgF;AAChF,oFAAoF;AACpF,8CAA8C;AAE9C,gFAAgF;AAChF,qBAAqB;AACrB,gFAAgF;AAEhF;;;CAGC;;;;;;AAkKM,MAAM,uBAAoC;IAC/C,YAAY;AACd;AA2BO,MAAM,6BAA+C;IAC1D,aAAa;IACb,aAAa;IACb,iBAAiB;IACjB,oBAAoB;IACpB,oBAAoB;IACpB,oBAAoB;AACtB"}},
    {"offset": {"line": 9628, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/facilitator-scores.ts"],"sourcesContent":["// =============================================================================\r\n// FACILITATOR SCORES DATABASE OPERATIONS\r\n// =============================================================================\r\n// Query helpers for facilitator score persistence, history, and experiments\r\n// Supports both PostgreSQL and SQLite adapters\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  FacilitatorScore,\r\n  FacilitatorScoreHistory,\r\n  RoutingExperiment,\r\n  PaymentExperimentAssignment,\r\n  UpsertFacilitatorScoreInput,\r\n  RecordPaymentAssignmentInput,\r\n  CreateRoutingExperimentInput,\r\n  ExperimentStatus,\r\n  PaymentOutcome,\r\n  DecayConfig,\r\n} from '@/types/facilitator-scores';\r\nimport { DEFAULT_DECAY_CONFIG } from '@/types/facilitator-scores';\r\n\r\nconst logger = createLogger({ component: 'FacilitatorScoresDB' });\r\n\r\n// =============================================================================\r\n// HELPER FUNCTIONS\r\n// =============================================================================\r\n\r\nfunction isPostgres(db: any): boolean {\r\n  return 'pool' in db || typeof db?.pool?.query === 'function';\r\n}\r\n\r\n/**\r\n * Compute time-based exponential decay factor\r\n * After halfLifeMs milliseconds, old score is weighted 50%\r\n * \r\n * Formula: 2^(-elapsed / halfLife)\r\n */\r\nexport function computeTimeDecay(\r\n  lastUpdatedAt: Date,\r\n  now: Date,\r\n  halfLifeMs: number = DEFAULT_DECAY_CONFIG.halfLifeMs\r\n): number {\r\n  const elapsedMs = now.getTime() - lastUpdatedAt.getTime();\r\n  if (elapsedMs <= 0) return 1; // No decay for same or past time\r\n  return Math.pow(2, -elapsedMs / halfLifeMs);\r\n}\r\n\r\n/**\r\n * Convert database row to FacilitatorScore\r\n */\r\nfunction rowToFacilitatorScore(row: any): FacilitatorScore {\r\n  return {\r\n    id: row.id,\r\n    facilitator_id: row.facilitator_id,\r\n    chain_id: row.chain_id,\r\n    score: Number(row.score),\r\n    confidence: Number(row.confidence),\r\n    decay_factor: Number(row.decay_factor),\r\n    sample_size: Number(row.sample_size),\r\n    last_updated_at: new Date(row.last_updated_at),\r\n    created_at: new Date(row.created_at),\r\n  };\r\n}\r\n\r\n/**\r\n * Convert database row to FacilitatorScoreHistory\r\n */\r\nfunction rowToScoreHistory(row: any): FacilitatorScoreHistory {\r\n  return {\r\n    id: row.id,\r\n    facilitator_id: row.facilitator_id,\r\n    chain_id: row.chain_id,\r\n    score: Number(row.score),\r\n    confidence: Number(row.confidence),\r\n    sample_size: Number(row.sample_size),\r\n    snapshot_at: new Date(row.snapshot_at),\r\n  };\r\n}\r\n\r\n/**\r\n * Convert database row to RoutingExperiment\r\n */\r\nfunction rowToRoutingExperiment(row: any): RoutingExperiment {\r\n  return {\r\n    id: row.id,\r\n    name: row.name,\r\n    variant: row.variant,\r\n    facilitator_id: row.facilitator_id,\r\n    chain_id: row.chain_id,\r\n    traffic_share: Number(row.traffic_share),\r\n    status: row.status as ExperimentStatus,\r\n    metrics_tracked: typeof row.metrics_tracked === 'string'\r\n      ? JSON.parse(row.metrics_tracked)\r\n      : row.metrics_tracked || {},\r\n    started_at: row.started_at ? new Date(row.started_at) : null,\r\n    ended_at: row.ended_at ? new Date(row.ended_at) : null,\r\n    completed_at: row.completed_at ? new Date(row.completed_at) : null,\r\n    created_at: new Date(row.created_at),\r\n  };\r\n}\r\n\r\n/**\r\n * Convert database row to PaymentExperimentAssignment\r\n */\r\nfunction rowToPaymentAssignment(row: any): PaymentExperimentAssignment {\r\n  return {\r\n    id: row.id,\r\n    payment_id: row.payment_id,\r\n    experiment_id: row.experiment_id,\r\n    assigned_at: new Date(row.assigned_at),\r\n    outcome: row.outcome as PaymentOutcome | null,\r\n    latency_ms: row.latency_ms ? Number(row.latency_ms) : null,\r\n    created_at: new Date(row.created_at),\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// FACILITATOR SCORES\r\n// =============================================================================\r\n\r\n/**\r\n * Upsert a facilitator score with time-based decay\r\n * If row exists: blends old score with new observation using exponential decay\r\n * If row doesn't exist: inserts new score\r\n */\r\nexport async function upsertFacilitatorScore(\r\n  input: UpsertFacilitatorScoreInput,\r\n  decayConfig: DecayConfig = DEFAULT_DECAY_CONFIG\r\n): Promise<FacilitatorScore> {\r\n  const db = getDb();\r\n  const now = input.now || new Date();\r\n  const nowStr = now.toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    // Check for existing score\r\n    const existing = await (db as any).pool.query(\r\n      `SELECT id, score, confidence, sample_size, last_updated_at \r\n       FROM facilitator_scores \r\n       WHERE facilitator_id = $1 AND chain_id = $2`,\r\n      [input.facilitator_id, input.chain_id]\r\n    );\r\n\r\n    if (existing.rows.length === 0) {\r\n      // Insert new score\r\n      const id = crypto.randomUUID();\r\n      const result = await (db as any).pool.query(\r\n        `INSERT INTO facilitator_scores \r\n         (id, facilitator_id, chain_id, score, confidence, decay_factor, \r\n          sample_size, last_updated_at, created_at)\r\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\r\n         RETURNING *`,\r\n        [\r\n          id,\r\n          input.facilitator_id,\r\n          input.chain_id,\r\n          input.score,\r\n          input.confidence,\r\n          0.9, // Legacy decay_factor\r\n          input.sample_size,\r\n          nowStr,\r\n          nowStr,\r\n        ]\r\n      );\r\n      logger.debug({\r\n        facilitator_id: input.facilitator_id,\r\n        chain_id: input.chain_id,\r\n        score: input.score,\r\n        action: 'insert',\r\n      }, 'Facilitator score inserted');\r\n      return rowToFacilitatorScore(result.rows[0]);\r\n    } else {\r\n      // Apply time-based decay and blend with new observation\r\n      const oldRow = existing.rows[0];\r\n      const lastUpdated = new Date(oldRow.last_updated_at);\r\n      const decayFactor = computeTimeDecay(lastUpdated, now, decayConfig.halfLifeMs);\r\n      \r\n      // Blend: old_score * decay + new_score * (1 - decay)\r\n      const decayedOldScore = Number(oldRow.score) * decayFactor;\r\n      const blendedScore = decayedOldScore + input.score * (1 - decayFactor);\r\n      \r\n      // Confidence: weighted average\r\n      const blendedConfidence = Number(oldRow.confidence) * decayFactor + input.confidence * (1 - decayFactor);\r\n      \r\n      // Sample size: cumulative\r\n      const newSampleSize = Number(oldRow.sample_size) + input.sample_size;\r\n\r\n      const result = await (db as any).pool.query(\r\n        `UPDATE facilitator_scores \r\n         SET score = $1, confidence = $2, sample_size = $3, last_updated_at = $4\r\n         WHERE id = $5\r\n         RETURNING *`,\r\n        [blendedScore, blendedConfidence, newSampleSize, nowStr, oldRow.id]\r\n      );\r\n\r\n      logger.debug({\r\n        facilitator_id: input.facilitator_id,\r\n        chain_id: input.chain_id,\r\n        old_score: Number(oldRow.score),\r\n        new_observation: input.score,\r\n        decay_factor: decayFactor,\r\n        blended_score: blendedScore,\r\n        action: 'update',\r\n      }, 'Facilitator score updated with decay');\r\n\r\n      return rowToFacilitatorScore(result.rows[0]);\r\n    }\r\n  } else {\r\n    // SQLite path\r\n    const existing = (db as any).prepare(\r\n      `SELECT id, score, confidence, sample_size, last_updated_at \r\n       FROM facilitator_scores \r\n       WHERE facilitator_id = ? AND chain_id = ?`\r\n    ).get(input.facilitator_id, input.chain_id);\r\n\r\n    if (!existing) {\r\n      const id = crypto.randomUUID();\r\n      (db as any).prepare(\r\n        `INSERT INTO facilitator_scores \r\n         (id, facilitator_id, chain_id, score, confidence, decay_factor, \r\n          sample_size, last_updated_at, created_at)\r\n         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`\r\n      ).run(\r\n        id,\r\n        input.facilitator_id,\r\n        input.chain_id,\r\n        input.score,\r\n        input.confidence,\r\n        0.9,\r\n        input.sample_size,\r\n        nowStr,\r\n        nowStr\r\n      );\r\n      const row = (db as any).prepare('SELECT * FROM facilitator_scores WHERE id = ?').get(id);\r\n      return rowToFacilitatorScore(row);\r\n    } else {\r\n      const lastUpdated = new Date(existing.last_updated_at);\r\n      const decayFactor = computeTimeDecay(lastUpdated, now, decayConfig.halfLifeMs);\r\n      const decayedOldScore = existing.score * decayFactor;\r\n      const blendedScore = decayedOldScore + input.score * (1 - decayFactor);\r\n      const blendedConfidence = existing.confidence * decayFactor + input.confidence * (1 - decayFactor);\r\n      const newSampleSize = existing.sample_size + input.sample_size;\r\n\r\n      (db as any).prepare(\r\n        `UPDATE facilitator_scores \r\n         SET score = ?, confidence = ?, sample_size = ?, last_updated_at = ?\r\n         WHERE id = ?`\r\n      ).run(blendedScore, blendedConfidence, newSampleSize, nowStr, existing.id);\r\n\r\n      const row = (db as any).prepare('SELECT * FROM facilitator_scores WHERE id = ?').get(existing.id);\r\n      return rowToFacilitatorScore(row);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get facilitator score for a specific facilitator/chain combination\r\n */\r\nexport async function getFacilitatorScore(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<FacilitatorScore | null> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_scores \r\n       WHERE facilitator_id = $1 AND chain_id = $2`,\r\n      [facilitator_id, chain_id]\r\n    );\r\n    return result.rows[0] ? rowToFacilitatorScore(result.rows[0]) : null;\r\n  } else {\r\n    const row = (db as any).prepare(\r\n      `SELECT * FROM facilitator_scores \r\n       WHERE facilitator_id = ? AND chain_id = ?`\r\n    ).get(facilitator_id, chain_id);\r\n    return row ? rowToFacilitatorScore(row) : null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all facilitator scores for a chain\r\n */\r\nexport async function getFacilitatorScoresByChain(\r\n  chain_id: string\r\n): Promise<FacilitatorScore[]> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_scores WHERE chain_id = $1 ORDER BY score DESC`,\r\n      [chain_id]\r\n    );\r\n    return result.rows.map(rowToFacilitatorScore);\r\n  } else {\r\n    const rows = (db as any).prepare(\r\n      `SELECT * FROM facilitator_scores WHERE chain_id = ? ORDER BY score DESC`\r\n    ).all(chain_id);\r\n    return rows.map(rowToFacilitatorScore);\r\n  }\r\n}\r\n\r\n/**\r\n * Get all scores for a facilitator across all chains\r\n */\r\nexport async function getFacilitatorScoresByFacilitator(\r\n  facilitator_id: string\r\n): Promise<FacilitatorScore[]> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_scores WHERE facilitator_id = $1 ORDER BY chain_id`,\r\n      [facilitator_id]\r\n    );\r\n    return result.rows.map(rowToFacilitatorScore);\r\n  } else {\r\n    const rows = (db as any).prepare(\r\n      `SELECT * FROM facilitator_scores WHERE facilitator_id = ? ORDER BY chain_id`\r\n    ).all(facilitator_id);\r\n    return rows.map(rowToFacilitatorScore);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// SCORE HISTORY / SNAPSHOTS\r\n// =============================================================================\r\n\r\n/**\r\n * Snapshot all current facilitator scores to history\r\n * Returns count of rows inserted\r\n */\r\nexport async function snapshotFacilitatorScores(now?: Date): Promise<number> {\r\n  const db = getDb();\r\n  const snapshotTime = (now || new Date()).toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO facilitator_score_history \r\n       (id, facilitator_id, chain_id, score, confidence, sample_size, snapshot_at)\r\n       SELECT \r\n         gen_random_uuid(),\r\n         facilitator_id,\r\n         chain_id,\r\n         score,\r\n         confidence,\r\n         sample_size,\r\n         $1\r\n       FROM facilitator_scores`,\r\n      [snapshotTime]\r\n    );\r\n    logger.info({ count: result.rowCount, snapshot_at: snapshotTime }, 'Facilitator scores snapshotted');\r\n    return result.rowCount || 0;\r\n  } else {\r\n    // SQLite: need to iterate and insert\r\n    const scores = (db as any).prepare('SELECT * FROM facilitator_scores').all();\r\n    let count = 0;\r\n    for (const score of scores) {\r\n      (db as any).prepare(\r\n        `INSERT INTO facilitator_score_history \r\n         (id, facilitator_id, chain_id, score, confidence, sample_size, snapshot_at)\r\n         VALUES (?, ?, ?, ?, ?, ?, ?)`\r\n      ).run(\r\n        crypto.randomUUID(),\r\n        score.facilitator_id,\r\n        score.chain_id,\r\n        score.score,\r\n        score.confidence,\r\n        score.sample_size,\r\n        snapshotTime\r\n      );\r\n      count++;\r\n    }\r\n    logger.info({ count, snapshot_at: snapshotTime }, 'Facilitator scores snapshotted');\r\n    return count;\r\n  }\r\n}\r\n\r\n/**\r\n * Get score history for a facilitator/chain\r\n */\r\nexport async function getScoreHistory(\r\n  facilitator_id: string,\r\n  chain_id: string,\r\n  limit: number = 100\r\n): Promise<FacilitatorScoreHistory[]> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_score_history \r\n       WHERE facilitator_id = $1 AND chain_id = $2 \r\n       ORDER BY snapshot_at DESC \r\n       LIMIT $3`,\r\n      [facilitator_id, chain_id, limit]\r\n    );\r\n    return result.rows.map(rowToScoreHistory);\r\n  } else {\r\n    const rows = (db as any).prepare(\r\n      `SELECT * FROM facilitator_score_history \r\n       WHERE facilitator_id = ? AND chain_id = ? \r\n       ORDER BY snapshot_at DESC \r\n       LIMIT ?`\r\n    ).all(facilitator_id, chain_id, limit);\r\n    return rows.map(rowToScoreHistory);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// ROUTING EXPERIMENTS\r\n// =============================================================================\r\n\r\n/**\r\n * Create a new routing experiment\r\n */\r\nexport async function createRoutingExperiment(\r\n  input: CreateRoutingExperimentInput\r\n): Promise<RoutingExperiment> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO routing_experiments \r\n       (id, name, variant, facilitator_id, chain_id, traffic_share, status, created_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, 'draft', $7)\r\n       RETURNING *`,\r\n      [\r\n        id,\r\n        input.name,\r\n        input.variant,\r\n        input.facilitator_id || null,\r\n        input.chain_id || null,\r\n        input.traffic_share,\r\n        now,\r\n      ]\r\n    );\r\n    return rowToRoutingExperiment(result.rows[0]);\r\n  } else {\r\n    (db as any).prepare(\r\n      `INSERT INTO routing_experiments \r\n       (id, name, variant, facilitator_id, chain_id, traffic_share, status, created_at)\r\n       VALUES (?, ?, ?, ?, ?, ?, 'draft', ?)`\r\n    ).run(\r\n      id,\r\n      input.name,\r\n      input.variant,\r\n      input.facilitator_id || null,\r\n      input.chain_id || null,\r\n      input.traffic_share,\r\n      now\r\n    );\r\n    const row = (db as any).prepare('SELECT * FROM routing_experiments WHERE id = ?').get(id);\r\n    return rowToRoutingExperiment(row);\r\n  }\r\n}\r\n\r\n/**\r\n * Get a running experiment for a facilitator/chain\r\n */\r\nexport async function getRunningExperiment(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<RoutingExperiment | null> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    // Check for specific facilitator/chain experiment first\r\n    let result = await (db as any).pool.query(\r\n      `SELECT * FROM routing_experiments \r\n       WHERE facilitator_id = $1 AND chain_id = $2 AND status = 'running'\r\n       LIMIT 1`,\r\n      [facilitator_id, chain_id]\r\n    );\r\n\r\n    if (result.rows.length > 0) {\r\n      return rowToRoutingExperiment(result.rows[0]);\r\n    }\r\n\r\n    // Check for facilitator-wide experiment (any chain)\r\n    result = await (db as any).pool.query(\r\n      `SELECT * FROM routing_experiments \r\n       WHERE facilitator_id = $1 AND chain_id IS NULL AND status = 'running'\r\n       LIMIT 1`,\r\n      [facilitator_id]\r\n    );\r\n\r\n    if (result.rows.length > 0) {\r\n      return rowToRoutingExperiment(result.rows[0]);\r\n    }\r\n\r\n    // Check for chain-wide experiment (any facilitator)\r\n    result = await (db as any).pool.query(\r\n      `SELECT * FROM routing_experiments \r\n       WHERE facilitator_id IS NULL AND chain_id = $1 AND status = 'running'\r\n       LIMIT 1`,\r\n      [chain_id]\r\n    );\r\n\r\n    return result.rows.length > 0 ? rowToRoutingExperiment(result.rows[0]) : null;\r\n  } else {\r\n    // SQLite path\r\n    let row = (db as any).prepare(\r\n      `SELECT * FROM routing_experiments \r\n       WHERE facilitator_id = ? AND chain_id = ? AND status = 'running'\r\n       LIMIT 1`\r\n    ).get(facilitator_id, chain_id);\r\n\r\n    if (row) return rowToRoutingExperiment(row);\r\n\r\n    row = (db as any).prepare(\r\n      `SELECT * FROM routing_experiments \r\n       WHERE facilitator_id = ? AND chain_id IS NULL AND status = 'running'\r\n       LIMIT 1`\r\n    ).get(facilitator_id);\r\n\r\n    if (row) return rowToRoutingExperiment(row);\r\n\r\n    row = (db as any).prepare(\r\n      `SELECT * FROM routing_experiments \r\n       WHERE facilitator_id IS NULL AND chain_id = ? AND status = 'running'\r\n       LIMIT 1`\r\n    ).get(chain_id);\r\n\r\n    return row ? rowToRoutingExperiment(row) : null;\r\n  }\r\n}\r\n\r\n/**\r\n * Update experiment status\r\n */\r\nexport async function updateExperimentStatus(\r\n  experiment_id: string,\r\n  status: ExperimentStatus\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    let updateFields = 'status = $2';\r\n    const params: any[] = [experiment_id, status];\r\n\r\n    if (status === 'running') {\r\n      updateFields += ', started_at = COALESCE(started_at, $3)';\r\n      params.push(now);\r\n    } else if (status === 'paused' || status === 'completed') {\r\n      updateFields += ', ended_at = $3';\r\n      params.push(now);\r\n      if (status === 'completed') {\r\n        updateFields += ', completed_at = $' + (params.length + 1);\r\n        params.push(now);\r\n      }\r\n    }\r\n\r\n    await (db as any).pool.query(\r\n      `UPDATE routing_experiments SET ${updateFields} WHERE id = $1`,\r\n      params\r\n    );\r\n  } else {\r\n    if (status === 'running') {\r\n      (db as any).prepare(\r\n        `UPDATE routing_experiments \r\n         SET status = ?, started_at = COALESCE(started_at, ?)\r\n         WHERE id = ?`\r\n      ).run(status, now, experiment_id);\r\n    } else if (status === 'completed') {\r\n      (db as any).prepare(\r\n        `UPDATE routing_experiments \r\n         SET status = ?, ended_at = ?, completed_at = ?\r\n         WHERE id = ?`\r\n      ).run(status, now, now, experiment_id);\r\n    } else {\r\n      (db as any).prepare(\r\n        `UPDATE routing_experiments SET status = ?, ended_at = ? WHERE id = ?`\r\n      ).run(status, now, experiment_id);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get experiment by ID\r\n */\r\nexport async function getRoutingExperiment(\r\n  experiment_id: string\r\n): Promise<RoutingExperiment | null> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM routing_experiments WHERE id = $1`,\r\n      [experiment_id]\r\n    );\r\n    return result.rows[0] ? rowToRoutingExperiment(result.rows[0]) : null;\r\n  } else {\r\n    const row = (db as any).prepare(\r\n      `SELECT * FROM routing_experiments WHERE id = ?`\r\n    ).get(experiment_id);\r\n    return row ? rowToRoutingExperiment(row) : null;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// PAYMENT EXPERIMENT ASSIGNMENTS\r\n// =============================================================================\r\n\r\n/**\r\n * Record a payment's experiment assignment and outcome\r\n */\r\nexport async function recordPaymentExperimentAssignment(\r\n  input: RecordPaymentAssignmentInput\r\n): Promise<PaymentExperimentAssignment> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO payment_experiment_assignments \r\n       (id, payment_id, experiment_id, assigned_at, outcome, latency_ms, created_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, $7)\r\n       ON CONFLICT (payment_id) DO UPDATE SET\r\n         outcome = COALESCE(EXCLUDED.outcome, payment_experiment_assignments.outcome),\r\n         latency_ms = COALESCE(EXCLUDED.latency_ms, payment_experiment_assignments.latency_ms)\r\n       RETURNING *`,\r\n      [\r\n        id,\r\n        input.payment_id,\r\n        input.experiment_id,\r\n        now,\r\n        input.outcome || null,\r\n        input.latency_ms || null,\r\n        now,\r\n      ]\r\n    );\r\n    return rowToPaymentAssignment(result.rows[0]);\r\n  } else {\r\n    // SQLite: try insert, update if exists\r\n    const existing = (db as any).prepare(\r\n      `SELECT id FROM payment_experiment_assignments WHERE payment_id = ?`\r\n    ).get(input.payment_id);\r\n\r\n    if (existing) {\r\n      (db as any).prepare(\r\n        `UPDATE payment_experiment_assignments \r\n         SET outcome = COALESCE(?, outcome), latency_ms = COALESCE(?, latency_ms)\r\n         WHERE payment_id = ?`\r\n      ).run(input.outcome || null, input.latency_ms || null, input.payment_id);\r\n      const row = (db as any).prepare(\r\n        `SELECT * FROM payment_experiment_assignments WHERE payment_id = ?`\r\n      ).get(input.payment_id);\r\n      return rowToPaymentAssignment(row);\r\n    } else {\r\n      (db as any).prepare(\r\n        `INSERT INTO payment_experiment_assignments \r\n         (id, payment_id, experiment_id, assigned_at, outcome, latency_ms, created_at)\r\n         VALUES (?, ?, ?, ?, ?, ?, ?)`\r\n      ).run(\r\n        id,\r\n        input.payment_id,\r\n        input.experiment_id,\r\n        now,\r\n        input.outcome || null,\r\n        input.latency_ms || null,\r\n        now\r\n      );\r\n      const row = (db as any).prepare(\r\n        `SELECT * FROM payment_experiment_assignments WHERE id = ?`\r\n      ).get(id);\r\n      return rowToPaymentAssignment(row);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get experiment outcomes summary\r\n */\r\nexport async function getExperimentOutcomes(\r\n  experiment_id: string\r\n): Promise<{\r\n  total: number;\r\n  success: number;\r\n  failed: number;\r\n  timeout: number;\r\n  avg_latency_ms: number | null;\r\n}> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT \r\n         COUNT(*) as total,\r\n         COUNT(*) FILTER (WHERE outcome = 'success') as success,\r\n         COUNT(*) FILTER (WHERE outcome = 'failed') as failed,\r\n         COUNT(*) FILTER (WHERE outcome = 'timeout') as timeout,\r\n         AVG(latency_ms) as avg_latency_ms\r\n       FROM payment_experiment_assignments \r\n       WHERE experiment_id = $1`,\r\n      [experiment_id]\r\n    );\r\n    const row = result.rows[0];\r\n    return {\r\n      total: Number(row.total),\r\n      success: Number(row.success),\r\n      failed: Number(row.failed),\r\n      timeout: Number(row.timeout),\r\n      avg_latency_ms: row.avg_latency_ms ? Number(row.avg_latency_ms) : null,\r\n    };\r\n  } else {\r\n    const rows = (db as any).prepare(\r\n      `SELECT * FROM payment_experiment_assignments WHERE experiment_id = ?`\r\n    ).all(experiment_id);\r\n\r\n    const total = rows.length;\r\n    const success = rows.filter((r: any) => r.outcome === 'success').length;\r\n    const failed = rows.filter((r: any) => r.outcome === 'failed').length;\r\n    const timeout = rows.filter((r: any) => r.outcome === 'timeout').length;\r\n    const latencies = rows.filter((r: any) => r.latency_ms).map((r: any) => r.latency_ms);\r\n    const avg_latency_ms = latencies.length > 0\r\n      ? latencies.reduce((a: number, b: number) => a + b, 0) / latencies.length\r\n      : null;\r\n\r\n    return { total, success, failed, timeout, avg_latency_ms };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 10142, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/services/smf/scoring.ts"],"sourcesContent":["// =============================================================================\r\n// SMF SCORING SERVICE\r\n// =============================================================================\r\n// Converts routing outcomes into score deltas and manages persistent scores\r\n// Integrates with time-based decay and experiment tracking\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport {\r\n  upsertFacilitatorScore,\r\n  getFacilitatorScore as getPersistedScore,\r\n  getRunningExperiment,\r\n  recordPaymentExperimentAssignment,\r\n} from '@/db/facilitator-scores';\r\nimport type {\r\n  FacilitatorScore,\r\n  RoutingOutcomeInput,\r\n  EffectiveScore,\r\n  ScoreDeltaConfig,\r\n} from '@/types/facilitator-scores';\r\nimport { DEFAULT_SCORE_DELTA_CONFIG } from '@/types/facilitator-scores';\r\n\r\nconst logger = createLogger({ component: 'SMFScoring' });\r\n\r\n// =============================================================================\r\n// SCORE DELTA CALCULATION\r\n// =============================================================================\r\n\r\n/**\r\n * Convert a routing outcome to a score (0-100)\r\n * Higher scores indicate better performance\r\n */\r\nexport function computeScoreDelta(\r\n  params: {\r\n    success: boolean;\r\n    latency_ms: number;\r\n    http_status?: number;\r\n  },\r\n  config: ScoreDeltaConfig = DEFAULT_SCORE_DELTA_CONFIG\r\n): number {\r\n  let score: number;\r\n\r\n  if (params.success) {\r\n    // Success: start at base success score\r\n    score = config.successBase;\r\n\r\n    // Bonus for low latency\r\n    if (params.latency_ms < 500) {\r\n      score += config.lowLatencyBonus;\r\n    } else if (params.latency_ms < 1000) {\r\n      score += config.mediumLatencyBonus;\r\n    }\r\n  } else {\r\n    // Failure: start at base failure score\r\n    score = config.failureBase;\r\n\r\n    // Extra penalty for high latency failures\r\n    if (params.latency_ms > 2000) {\r\n      score -= config.highLatencyPenalty;\r\n    }\r\n\r\n    // Penalty for server errors (5xx)\r\n    if (params.http_status && params.http_status >= 500) {\r\n      score -= config.serverErrorPenalty;\r\n    }\r\n  }\r\n\r\n  // Clamp to 0-100\r\n  return Math.max(0, Math.min(100, score));\r\n}\r\n\r\n// =============================================================================\r\n// ROUTING OUTCOME RECORDING\r\n// =============================================================================\r\n\r\n/**\r\n * Record a routing outcome and update persistent scores\r\n * \r\n * This function:\r\n * 1. Converts the outcome to a score delta\r\n * 2. Updates the persistent score with time-based decay\r\n * 3. Records experiment assignment if applicable\r\n */\r\nexport async function recordRoutingOutcome(\r\n  params: RoutingOutcomeInput\r\n): Promise<void> {\r\n  const { facilitator_id, chain_id, payment_id, success, latency_ms, http_status } = params;\r\n\r\n  // 1. Compute score from outcome\r\n  const score = computeScoreDelta({ success, latency_ms, http_status });\r\n\r\n  logger.debug({\r\n    facilitator_id,\r\n    chain_id,\r\n    payment_id,\r\n    success,\r\n    latency_ms,\r\n    http_status,\r\n    computed_score: score,\r\n  }, 'Recording routing outcome');\r\n\r\n  // 2. Update persistent score with decay\r\n  await upsertFacilitatorScore({\r\n    facilitator_id,\r\n    chain_id,\r\n    score,\r\n    confidence: 0.9, // High confidence for actual routing outcomes\r\n    sample_size: 1,\r\n  });\r\n\r\n  // 3. Check if this payment was routed via an experiment\r\n  const experiment = await getRunningExperiment(facilitator_id, chain_id);\r\n\r\n  if (experiment) {\r\n    await recordPaymentExperimentAssignment({\r\n      payment_id,\r\n      experiment_id: experiment.id,\r\n      outcome: success ? 'success' : 'failed',\r\n      latency_ms,\r\n    });\r\n\r\n    logger.debug({\r\n      payment_id,\r\n      experiment_id: experiment.id,\r\n      experiment_name: experiment.name,\r\n      outcome: success ? 'success' : 'failed',\r\n    }, 'Recorded experiment assignment');\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// EFFECTIVE SCORE RETRIEVAL\r\n// =============================================================================\r\n\r\n/**\r\n * Get the effective score for a facilitator/chain combination\r\n * Returns persisted score + confidence for routing decisions\r\n */\r\nexport async function getEffectiveScore(\r\n  params: {\r\n    facilitator_id: string;\r\n    chain_id: string;\r\n  }\r\n): Promise<EffectiveScore | null> {\r\n  const { facilitator_id, chain_id } = params;\r\n\r\n  const score = await getPersistedScore(facilitator_id, chain_id);\r\n\r\n  if (!score) {\r\n    return null;\r\n  }\r\n\r\n  return {\r\n    score: score.score,\r\n    confidence: score.confidence,\r\n  };\r\n}\r\n\r\n/**\r\n * Get the full facilitator score record\r\n */\r\nexport async function getFacilitatorScoreRecord(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<FacilitatorScore | null> {\r\n  return getPersistedScore(facilitator_id, chain_id);\r\n}\r\n\r\n// =============================================================================\r\n// EXPERIMENT HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Check if there's an active experiment affecting routing for this facilitator/chain\r\n */\r\nexport async function hasActiveExperiment(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<boolean> {\r\n  const experiment = await getRunningExperiment(facilitator_id, chain_id);\r\n  return experiment !== null;\r\n}\r\n\r\n/**\r\n * Get experiment traffic adjustment for scoring\r\n * Returns a small bonus if experiment is running\r\n */\r\nexport async function getExperimentTrafficAdjustment(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<{ adjustment: number; experiment_name: string | null }> {\r\n  const experiment = await getRunningExperiment(facilitator_id, chain_id);\r\n\r\n  if (!experiment || experiment.status !== 'running') {\r\n    return { adjustment: 0, experiment_name: null };\r\n  }\r\n\r\n  // Small bonus based on traffic share (e.g., 10% traffic share = +1 score)\r\n  const adjustment = experiment.traffic_share * 10;\r\n\r\n  return {\r\n    adjustment,\r\n    experiment_name: experiment.name,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// BATCH OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Record multiple routing outcomes in batch\r\n * Useful for bulk processing\r\n */\r\nexport async function recordRoutingOutcomesBatch(\r\n  outcomes: RoutingOutcomeInput[]\r\n): Promise<void> {\r\n  for (const outcome of outcomes) {\r\n    await recordRoutingOutcome(outcome);\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,sBAAsB;AACtB,gFAAgF;AAChF,4EAA4E;AAC5E,2DAA2D;;;;;;;;;;;;;;;;;AAE3D;AACA;AAYA;;;;;;;;AAEA,MAAM,SAAS,IAAA,sIAAY,EAAC;IAAE,WAAW;AAAa;AAU/C,SAAS,kBACd,MAIC,EACD,SAA2B,qKAA0B;IAErD,IAAI;IAEJ,IAAI,OAAO,OAAO,EAAE;QAClB,uCAAuC;QACvC,QAAQ,OAAO,WAAW;QAE1B,wBAAwB;QACxB,IAAI,OAAO,UAAU,GAAG,KAAK;YAC3B,SAAS,OAAO,eAAe;QACjC,OAAO,IAAI,OAAO,UAAU,GAAG,MAAM;YACnC,SAAS,OAAO,kBAAkB;QACpC;IACF,OAAO;QACL,uCAAuC;QACvC,QAAQ,OAAO,WAAW;QAE1B,0CAA0C;QAC1C,IAAI,OAAO,UAAU,GAAG,MAAM;YAC5B,SAAS,OAAO,kBAAkB;QACpC;QAEA,kCAAkC;QAClC,IAAI,OAAO,WAAW,IAAI,OAAO,WAAW,IAAI,KAAK;YACnD,SAAS,OAAO,kBAAkB;QACpC;IACF;IAEA,iBAAiB;IACjB,OAAO,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,KAAK;AACnC;AAcO,eAAe,qBACpB,MAA2B;IAE3B,MAAM,EAAE,cAAc,EAAE,QAAQ,EAAE,UAAU,EAAE,OAAO,EAAE,UAAU,EAAE,WAAW,EAAE,GAAG;IAEnF,gCAAgC;IAChC,MAAM,QAAQ,kBAAkB;QAAE;QAAS;QAAY;IAAY;IAEnE,OAAO,KAAK,CAAC;QACX;QACA;QACA;QACA;QACA;QACA;QACA,gBAAgB;IAClB,GAAG;IAEH,wCAAwC;IACxC,MAAM,IAAA,8JAAsB,EAAC;QAC3B;QACA;QACA;QACA,YAAY;QACZ,aAAa;IACf;IAEA,wDAAwD;IACxD,MAAM,aAAa,MAAM,IAAA,4JAAoB,EAAC,gBAAgB;IAE9D,IAAI,YAAY;QACd,MAAM,IAAA,yKAAiC,EAAC;YACtC;YACA,eAAe,WAAW,EAAE;YAC5B,SAAS,UAAU,YAAY;YAC/B;QACF;QAEA,OAAO,KAAK,CAAC;YACX;YACA,eAAe,WAAW,EAAE;YAC5B,iBAAiB,WAAW,IAAI;YAChC,SAAS,UAAU,YAAY;QACjC,GAAG;IACL;AACF;AAUO,eAAe,kBACpB,MAGC;IAED,MAAM,EAAE,cAAc,EAAE,QAAQ,EAAE,GAAG;IAErC,MAAM,QAAQ,MAAM,IAAA,2JAAiB,EAAC,gBAAgB;IAEtD,IAAI,CAAC,OAAO;QACV,OAAO;IACT;IAEA,OAAO;QACL,OAAO,MAAM,KAAK;QAClB,YAAY,MAAM,UAAU;IAC9B;AACF;AAKO,eAAe,0BACpB,cAAsB,EACtB,QAAgB;IAEhB,OAAO,IAAA,2JAAiB,EAAC,gBAAgB;AAC3C;AASO,eAAe,oBACpB,cAAsB,EACtB,QAAgB;IAEhB,MAAM,aAAa,MAAM,IAAA,4JAAoB,EAAC,gBAAgB;IAC9D,OAAO,eAAe;AACxB;AAMO,eAAe,+BACpB,cAAsB,EACtB,QAAgB;IAEhB,MAAM,aAAa,MAAM,IAAA,4JAAoB,EAAC,gBAAgB;IAE9D,IAAI,CAAC,cAAc,WAAW,MAAM,KAAK,WAAW;QAClD,OAAO;YAAE,YAAY;YAAG,iBAAiB;QAAK;IAChD;IAEA,0EAA0E;IAC1E,MAAM,aAAa,WAAW,aAAa,GAAG;IAE9C,OAAO;QACL;QACA,iBAAiB,WAAW,IAAI;IAClC;AACF;AAUO,eAAe,2BACpB,QAA+B;IAE/B,KAAK,MAAM,WAAW,SAAU;QAC9B,MAAM,qBAAqB;IAC7B;AACF"}},
    {"offset": {"line": 10287, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/dummy-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// DUMMY FACILITATOR (FOR TESTING)\r\n// =============================================================================\r\n// Test facilitator that wraps CDP or provides mock behavior\r\n// Used to test routing logic, priority ties, failover, etc.\r\n\r\nimport { BaseFacilitator, type IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorHealth, type FacilitatorConfig } from './base-facilitator';\r\nimport { getCDPFacilitatorAdapter } from './cdp-facilitator-adapter';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'DummyFacilitator' });\r\n\r\n/**\r\n * Dummy Facilitator\r\n * \r\n * Can be configured to:\r\n * - Wrap CDP (for testing routing with same backend)\r\n * - Provide mock behavior (for testing without real payments)\r\n * - Simulate failures (for testing failover)\r\n */\r\nexport class DummyFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id: string;\r\n  readonly name: string;\r\n  readonly config: FacilitatorConfig;\r\n  \r\n  private wrapCDP: boolean;\r\n  private mockBehavior?: 'success' | 'failure' | 'timeout';\r\n  private cdpAdapter?: ReturnType<typeof getCDPFacilitatorAdapter>;\r\n\r\n  constructor(\r\n    id: string = 'dummy',\r\n    name: string = 'Dummy Facilitator',\r\n    config: Partial<FacilitatorConfig> = {},\r\n    options: {\r\n      wrapCDP?: boolean; // If true, wraps CDP adapter\r\n      mockBehavior?: 'success' | 'failure' | 'timeout'; // Mock behavior if not wrapping CDP\r\n    } = {}\r\n  ) {\r\n    super();\r\n    this.id = id;\r\n    this.name = name;\r\n    this.wrapCDP = options.wrapCDP ?? false;\r\n    this.mockBehavior = options.mockBehavior;\r\n\r\n    // Default config (can be overridden)\r\n    this.config = {\r\n      id: this.id,\r\n      name: this.name,\r\n      enabled: true,\r\n      priority: 2, // Lower priority than CDP (for testing priority-based routing)\r\n      networks: ['base'],\r\n      networksCAIP: ['eip155:8453'], // CAIP-2: Base mainnet\r\n      assets: ['0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // USDC on Base\r\n      assetsCAIP: ['eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // CAIP-19: USDC on Base\r\n      schemes: ['exact', 'x402'],\r\n      settlementModes: ['immediate'], // Default to immediate settlement\r\n      ...config,\r\n    };\r\n\r\n    if (this.wrapCDP) {\r\n      this.cdpAdapter = getCDPFacilitatorAdapter();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify payment\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    // If wrapping CDP, delegate to CDP\r\n    if (this.wrapCDP && this.cdpAdapter) {\r\n      logger.info({ payment: payment.substring(0, 20) + '...' }, 'Dummy facilitator delegating to CDP');\r\n      return await this.cdpAdapter.verify(payment, requirements);\r\n    }\r\n\r\n    // Mock behavior for testing\r\n    if (this.mockBehavior === 'failure') {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: 'Mock failure for testing',\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    if (this.mockBehavior === 'timeout') {\r\n      await new Promise((resolve) => setTimeout(resolve, 10000)); // 10 second delay\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: 'Mock timeout for testing',\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    // Mock success\r\n    return {\r\n      success: true,\r\n      valid: true,\r\n      transactionHash: `0x${Math.random().toString(16).substring(2, 66)}`,\r\n      kytStatus: 'passed',\r\n      ofacStatus: 'passed',\r\n      facilitatorId: this.id,\r\n      verifiedAt: new Date().toISOString(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get health status\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    // If wrapping CDP, delegate to CDP\r\n    if (this.wrapCDP && this.cdpAdapter) {\r\n      return await this.cdpAdapter.getHealth();\r\n    }\r\n\r\n    // Mock health (always healthy for testing)\r\n    return {\r\n      healthy: true,\r\n      latency: 50, // Mock low latency\r\n      lastChecked: new Date().toISOString(),\r\n      capabilities: {\r\n        networks: this.config.networks,\r\n        assets: this.config.assets,\r\n        schemes: this.config.schemes,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: string): boolean {\r\n    return super.supports(network, asset, scheme, settlementMode as any);\r\n  }\r\n\r\n  /**\r\n   * Get pricing (mock)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    if (this.wrapCDP && this.cdpAdapter) {\r\n      return await this.cdpAdapter.getPricing(network, asset);\r\n    }\r\n\r\n    // Mock pricing (slightly higher than CDP to test cost optimization)\r\n    if (network === 'base' && asset === '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913') {\r\n      return {\r\n        network: 'base',\r\n        asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n        baseFee: '1000', // Slightly higher than CDP\r\n        percentageFee: 0.001, // 0.1%\r\n        estimatedGas: '21000',\r\n        currency: 'USDC',\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Create a dummy facilitator for testing\r\n */\r\nexport function createDummyFacilitator(\r\n  id: string = 'dummy',\r\n  options?: {\r\n    wrapCDP?: boolean;\r\n    mockBehavior?: 'success' | 'failure' | 'timeout';\r\n    priority?: number;\r\n  }\r\n): DummyFacilitator {\r\n  return new DummyFacilitator(\r\n    id,\r\n    `Dummy Facilitator (${id})`,\r\n    {\r\n      priority: options?.priority ?? 2,\r\n    },\r\n    {\r\n      wrapCDP: options?.wrapCDP ?? false,\r\n      mockBehavior: options?.mockBehavior,\r\n    }\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 10461, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/facilitator-router.ts"],"sourcesContent":["// =============================================================================\n// FACILITATOR ROUTER\n// =============================================================================\n// Smart routing logic for selecting the best facilitator based on policy\n// Implements \"meta-facilitator\" pattern: SDK expresses preferences, SMF owns policy\n\nimport { IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorConfig, type CAIPNetworkId, type CAIPAssetId, type SettlementMode } from './base-facilitator';\nimport { getCDPFacilitatorAdapter } from './cdp-facilitator-adapter';\nimport { getPayAIFacilitator } from './payai-facilitator';\nimport { getX402rsFacilitator } from './x402rs-facilitator';\nimport { getDexterFacilitator } from './dexter-facilitator';\nimport { getCronosFacilitator } from './cronos-facilitator';\nimport { createLogger } from '@/lib/logger';\nimport { getCurrentHealth } from './health-aggregator';\nimport { getFacilitatorCapabilities } from '@/db/smf';\nimport type { FacilitatorId } from './facilitator-registry';\nimport {\n  getFacilitatorScore,\n  getFacilitatorExplainer,\n  type FacilitatorScore,\n  type FacilitatorExplanation,\n} from '@/services/facilitator-metrics-reader';\nimport type { FacilitatorPathMetricsTimeframe } from '@/infra/x402scan/types';\nimport {\n  getScatteringMetricsForFacilitator,\n  computeActivityScore,\n} from '@/services/facilitator-volume-service';\nimport type { ScatteringFacilitatorMetrics } from '@/infra/scattering/types';\nimport {\n  getEffectiveScore as getPersistedScore,\n  getExperimentTrafficAdjustment,\n} from '@/services/smf/scoring';\n\nconst logger = createLogger({ component: 'FacilitatorRouter' });\n\n// =============================================================================\n// X402SCAN METRICS INTEGRATION CONFIG\n// =============================================================================\n\n/**\n * Configuration for trusting x402scan metrics in routing decisions\n * Metrics are only used if they meet these freshness/confidence thresholds\n */\nexport interface X402ScanMetricsTrustConfig {\n  /** Maximum age of data to trust (hours) */\n  maxDataAgeHours: number;\n  /** Minimum invocations required for high confidence */\n  minInvocationsHighConfidence: number;\n  /** Minimum invocations required for medium confidence */\n  minInvocationsMediumConfidence: number;\n  /** Weight applied to x402scan score in overall routing (0-1) */\n  x402scanScoreWeight: number;\n  /** Timeframe to use for metrics */\n  timeframe: FacilitatorPathMetricsTimeframe;\n  /** Whether to log detailed explanations */\n  logExplanations: boolean;\n}\n\n/**\n * Default x402scan metrics trust configuration\n * Can be overridden via environment variables\n */\nconst DEFAULT_X402SCAN_TRUST_CONFIG: X402ScanMetricsTrustConfig = {\n  maxDataAgeHours: parseFloat(process.env.X402SCAN_MAX_DATA_AGE_HOURS ?? '4'),\n  minInvocationsHighConfidence: parseInt(process.env.X402SCAN_MIN_INVOCATIONS_HIGH ?? '1000', 10),\n  minInvocationsMediumConfidence: parseInt(process.env.X402SCAN_MIN_INVOCATIONS_MEDIUM ?? '100', 10),\n  x402scanScoreWeight: parseFloat(process.env.X402SCAN_SCORE_WEIGHT ?? '0.3'), // 30% weight\n  timeframe: (process.env.X402SCAN_TIMEFRAME ?? '1d') as FacilitatorPathMetricsTimeframe,\n  logExplanations: process.env.X402SCAN_LOG_EXPLANATIONS !== 'false',\n};\n\n// =============================================================================\n// SCATTERING / DUNE METRICS INTEGRATION CONFIG\n// =============================================================================\n\n/**\n * Configuration for Scattering/Dune activity metrics in routing decisions\n */\nexport interface ScatteringMetricsTrustConfig {\n  /** Weight applied to Scattering score in overall routing (0-1) */\n  scatteringScoreWeight: number;\n  /** Minimum 3-day transaction count to trust metrics */\n  minTxCount3d: number;\n  /** Maximum age of data to trust (hours) */\n  maxDataAgeHours: number;\n  /** Whether to log Scattering metrics */\n  logScatteringMetrics: boolean;\n}\n\n/**\n * Default Scattering metrics configuration\n */\nconst DEFAULT_SCATTERING_CONFIG: ScatteringMetricsTrustConfig = {\n  scatteringScoreWeight: parseFloat(process.env.SCATTERING_SCORE_WEIGHT ?? '0.2'), // 20% weight\n  minTxCount3d: parseInt(process.env.SCATTERING_MIN_TX_3D ?? '100', 10),\n  maxDataAgeHours: parseFloat(process.env.SCATTERING_MAX_DATA_AGE_HOURS ?? '24'),\n  logScatteringMetrics: process.env.SCATTERING_LOG_METRICS !== 'false',\n};\n\n// =============================================================================\n// PERSISTED SCORE CONFIG (Stage 5: Score Persistence + Decay)\n// =============================================================================\n\n/**\n * Configuration for persisted score integration\n * Persisted scores blend with real-time metrics for routing decisions\n */\nexport interface PersistedScoreConfig {\n  /** Weight applied to persisted score (0-1), rest goes to real-time metrics */\n  persistedScoreWeight: number;\n  /** Minimum confidence required to use persisted score */\n  minConfidence: number;\n  /** Whether to apply experiment traffic adjustments */\n  enableExperimentAdjustments: boolean;\n  /** Log persisted score integration */\n  logPersistedScore: boolean;\n}\n\n/**\n * Default persisted score configuration\n */\nconst DEFAULT_PERSISTED_SCORE_CONFIG: PersistedScoreConfig = {\n  persistedScoreWeight: parseFloat(process.env.PERSISTED_SCORE_WEIGHT ?? '0.3'), // 30% weight\n  minConfidence: parseFloat(process.env.PERSISTED_SCORE_MIN_CONFIDENCE ?? '0.5'),\n  enableExperimentAdjustments: process.env.ENABLE_EXPERIMENT_ADJUSTMENTS !== 'false',\n  logPersistedScore: process.env.LOG_PERSISTED_SCORE !== 'false',\n};\n\n/**\n * Check if Scattering metrics should be trusted based on freshness and activity\n */\nfunction shouldTrustScatteringMetrics(\n  metrics: ScatteringFacilitatorMetrics | null,\n  config: ScatteringMetricsTrustConfig = DEFAULT_SCATTERING_CONFIG\n): { trust: boolean; reason: string } {\n  if (!metrics) {\n    return { trust: false, reason: 'no-scattering-data' };\n  }\n\n  // Check data freshness\n  const dataAgeHours = (Date.now() - new Date(metrics.fetchedAt).getTime()) / (1000 * 60 * 60);\n  if (dataAgeHours > config.maxDataAgeHours) {\n    return { trust: false, reason: `data-too-old:${dataAgeHours.toFixed(1)}h` };\n  }\n\n  // Check minimum activity\n  if (metrics.txCount3d < config.minTxCount3d) {\n    return { trust: false, reason: `low-activity:${metrics.txCount3d}-txns` };\n  }\n\n  return { trust: true, reason: 'active' };\n}\n\n/**\n * Check if x402scan metrics should be trusted based on freshness/confidence\n */\nfunction shouldTrustX402ScanMetrics(\n  score: FacilitatorScore | null,\n  config: X402ScanMetricsTrustConfig = DEFAULT_X402SCAN_TRUST_CONFIG\n): { trust: boolean; reason: string } {\n  if (!score) {\n    return { trust: false, reason: 'no-x402scan-data' };\n  }\n\n  // Check data freshness\n  if (score.dataFreshness > config.maxDataAgeHours) {\n    return { trust: false, reason: `data-too-old:${score.dataFreshness.toFixed(1)}h` };\n  }\n\n  // Check minimum invocations for medium confidence\n  if (score.totalInvocations < config.minInvocationsMediumConfidence) {\n    return { trust: false, reason: `insufficient-data:${score.totalInvocations}-invocations` };\n  }\n\n  // Trust with appropriate confidence level\n  if (score.totalInvocations >= config.minInvocationsHighConfidence) {\n    return { trust: true, reason: 'high-confidence' };\n  }\n\n  return { trust: true, reason: 'medium-confidence' };\n}\n\n/**\n * Facilitator strategy for routing decisions\n * \n * - \"auto\": SMF chooses optimal facilitator based on health, cost, and policy\n * - \"cdp\": Force routing through Coinbase Developer Platform\n * - \"payai\": Force routing through PayAI facilitator\n * - \"x402rs\": Force routing through X402rs (Rust community facilitator)\n * - \"dexter\": Force routing through Dexter (Solana-native facilitator)\n * - \"cronos\": Force routing through Cronos x402 Facilitator (https://facilitator.cronoslabs.org)\n */\nexport type FacilitatorStrategy = 'auto' | 'cdp' | 'payai' | 'x402rs' | 'dexter' | 'cronos';\n\n/**\n * Routing preferences (from SDK/agent)\n * SDK expresses preferences, SMF owns policy\n */\nexport interface RoutingPreferences {\n  preferredNetworks?: string[]; // Legacy: e.g., ['solana', 'base']\n  preferredNetworksCAIP?: CAIPNetworkId[]; // CAIP-2 network identifiers\n  preferredAssets?: string[]; // Legacy: e.g., ['USDC']\n  preferredAssetsCAIP?: CAIPAssetId[]; // CAIP-19 asset identifiers\n  avoidNetworks?: string[]; // Legacy: e.g., ['ethereum'] (mainnet too expensive)\n  avoidNetworksCAIP?: CAIPNetworkId[]; // CAIP-2 networks to avoid\n  maxCost?: number; // Maximum cost in USD\n  requireCompliance?: boolean; // Require KYT/OFAC\n  priority?: 'cost' | 'speed' | 'reliability' | 'compliance';\n  jurisdiction?: string; // ISO country code (e.g., 'US', 'GB')\n  settlementMode?: SettlementMode; // Preferred settlement mode\n  /** Facilitator strategy - explicit facilitator selection or auto */\n  facilitatorStrategy?: FacilitatorStrategy;\n}\n\n/**\n * Routing policy (SMF business logic)\n * SMF owns higher-level policy above raw settlement\n */\nexport interface RoutingPolicy {\n  // Risk rules\n  riskThreshold?: number; // Max risk score (0-100)\n  requireKYC?: boolean; // Require KYC for certain amounts\n  \n  // Cost optimization\n  preferCheapest?: boolean; // Prefer cheapest facilitator\n  maxCostMultiplier?: number; // Max cost vs cheapest (1.5 = 50% premium)\n  \n  // Compliance rules\n  jurisdictionRules?: JurisdictionRule[];\n  \n  // Reliability\n  requireHealthCheck?: boolean; // Only route to healthy facilitators\n  minUptime?: number; // Minimum uptime percentage (0-1)\n  \n  // Custom rules\n  customRules?: (facilitator: IFacilitator, requirements: PaymentRequirements) => boolean;\n}\n\n/**\n * Jurisdiction-based routing rules\n */\nexport interface JurisdictionRule {\n  country?: string; // ISO country code\n  region?: string; // Region name\n  allowedNetworks?: string[];\n  requiredKYC?: boolean;\n  maxAmount?: string; // Max amount in smallest units\n  blockedFacilitators?: string[]; // Facilitator IDs to avoid\n}\n\n/**\n * Facilitator router\n * Implements smart routing based on preferences and policy\n */\nexport class FacilitatorRouter {\n  private facilitators: Map<string, IFacilitator> = new Map();\n  private facilitatorHealth: Map<string, { healthy: boolean; lastChecked: number }> = new Map();\n  private healthCheckInterval: NodeJS.Timeout | null = null;\n\n  constructor() {\n    // Register default facilitators\n    this.registerFacilitator(getCDPFacilitatorAdapter());\n    \n    // Register PayAI facilitator (multi-chain support)\n    this.registerFacilitator(getPayAIFacilitator());\n    \n    // Register X402rs facilitator (Rust-based community facilitator)\n    // Supports: Base Sepolia, Base mainnet, XDC mainnet\n    if (process.env.X402RS_ENABLED !== 'false') {\n      this.registerFacilitator(getX402rsFacilitator());\n      logger.info({ facilitatorId: 'x402rs', url: 'https://facilitator.x402.rs' }, 'X402rs facilitator registered');\n    }\n    \n    // Register Dexter facilitator (Solana-native x402 facilitator)\n    // Supports: Solana mainnet, Solana devnet\n    if (process.env.DEXTER_ENABLED !== 'false') {\n      this.registerFacilitator(getDexterFacilitator());\n      logger.info({ facilitatorId: 'dexter', url: 'https://facilitator.dexter.cash' }, 'Dexter facilitator registered');\n    }\n    \n    // Register Cronos x402 Facilitator\n    // Cronos x402 facilitator (https://facilitator.cronoslabs.org)  see Cronos x402 Facilitator docs for details.\n    // Supports: Cronos mainnet (chain ID 25), Cronos testnet (chain ID 338)\n    // Documentation: https://docs.cronos.org/cronos-x402-facilitator\n    if (process.env.CRONOS_ENABLED !== 'false') {\n      this.registerFacilitator(getCronosFacilitator());\n      logger.info({ facilitatorId: 'cronos', url: 'https://facilitator.cronoslabs.org' }, 'Cronos x402 facilitator registered');\n    }\n    \n    // Register dummy facilitator for testing (wraps CDP, different priority)\n    // This allows testing routing logic, priority ties, failover, etc.\n    // SAFETY: Only enabled in non-production environments\n    if (process.env.ENABLE_DUMMY_FACILITATOR === 'true' && process.env.NODE_ENV !== 'production') {\n      const { createDummyFacilitator } = require('./dummy-facilitator');\n      const dummy = createDummyFacilitator('dummy', {\n        wrapCDP: true, // Wrap CDP for realistic testing\n        priority: 2, // Lower priority than CDP\n      });\n      this.registerFacilitator(dummy);\n      logger.warn('Dummy facilitator registered (development only)');\n    } else if (process.env.ENABLE_DUMMY_FACILITATOR === 'true' && process.env.NODE_ENV === 'production') {\n      logger.error('ENABLE_DUMMY_FACILITATOR is set but ignored in production environment');\n    }\n    \n    // Start health check interval (every 5 minutes)\n    this.startHealthChecks();\n  }\n\n  /**\n   * Register a facilitator\n   */\n  registerFacilitator(facilitator: IFacilitator): void {\n    this.facilitators.set(facilitator.id, facilitator);\n    logger.info({ facilitatorId: facilitator.id, name: facilitator.name }, 'Facilitator registered');\n  }\n\n  /**\n   * Unregister a facilitator\n   */\n  unregisterFacilitator(facilitatorId: string): void {\n    this.facilitators.delete(facilitatorId);\n    this.facilitatorHealth.delete(facilitatorId);\n    logger.info({ facilitatorId }, 'Facilitator unregistered');\n  }\n\n  /**\n   * Get all registered facilitators\n   */\n  getFacilitators(): IFacilitator[] {\n    return Array.from(this.facilitators.values());\n  }\n\n  /**\n   * Route payment to best facilitator\n   * \n   * @param requirements - Payment requirements\n   * @param preferences - SDK/agent preferences\n   * @param policy - SMF business logic policy\n   */\n  async routePayment(\n    requirements: PaymentRequirements,\n    preferences?: RoutingPreferences,\n    policy?: RoutingPolicy\n  ): Promise<IFacilitator> {\n    // ==========================================================================\n    // Handle explicit facilitator strategy (non-auto)\n    // ==========================================================================\n    if (preferences?.facilitatorStrategy && preferences.facilitatorStrategy !== 'auto') {\n      const explicitFacilitator = this.facilitators.get(preferences.facilitatorStrategy);\n      \n      if (explicitFacilitator && explicitFacilitator.config.enabled) {\n        // Check if explicit facilitator supports the requested network/asset\n        if (explicitFacilitator.supports(requirements.network, requirements.asset, requirements.scheme, requirements.settlementMode)) {\n          logger.info({\n            facilitatorId: explicitFacilitator.id,\n            facilitatorUrl: explicitFacilitator.config.healthCheckUrl,\n            strategy: preferences.facilitatorStrategy,\n            network: requirements.network,\n            asset: requirements.asset,\n            mode: 'explicit',\n            msg: 'Facilitator selected via explicit strategy',\n          });\n          return explicitFacilitator;\n        } else {\n          logger.warn({\n            facilitatorId: preferences.facilitatorStrategy,\n            network: requirements.network,\n            asset: requirements.asset,\n            msg: 'Explicit facilitator does not support requested network/asset, falling back to auto',\n          });\n          // Fall through to auto selection\n        }\n      } else {\n        logger.warn({\n          facilitatorId: preferences.facilitatorStrategy,\n          enabled: explicitFacilitator?.config.enabled,\n          msg: 'Explicit facilitator not found or disabled, falling back to auto',\n        });\n        // Fall through to auto selection\n      }\n    }\n\n    // ==========================================================================\n    // Auto selection: Get eligible facilitators\n    // ==========================================================================\n    const eligible = this.getEligibleFacilitators(requirements, preferences, policy);\n\n    if (eligible.length === 0) {\n      throw new Error(\n        `No eligible facilitator found for ${requirements.network}/${requirements.asset}/${requirements.scheme}`\n      );\n    }\n\n    // Score and rank facilitators\n    const scored = await this.scoreFacilitators(eligible, requirements, preferences, policy);\n\n    // Select best facilitator\n    const best = scored[0].facilitator;\n    const bestExplanation = scored[0].x402scanExplanation;\n    \n    // =======================================================================\n    // Log x402scan explanation for the selected facilitator (if available)\n    // =======================================================================\n    if (bestExplanation && DEFAULT_X402SCAN_TRUST_CONFIG.logExplanations) {\n      logger.info({\n        facilitatorId: best.id,\n        x402scan: {\n          selected: true,\n          score: bestExplanation.score,\n          confidence: bestExplanation.confidence,\n          shortReason: bestExplanation.shortReason,\n          metrics: bestExplanation.metrics,\n        },\n        msg: 'x402scan routing explanation',\n      });\n    }\n\n    // Log alternatives with their x402scan data (for debugging/ML)\n    if (scored.length > 1 && DEFAULT_X402SCAN_TRUST_CONFIG.logExplanations) {\n      const alternatives = scored.slice(1, 4).map((s) => ({\n        id: s.facilitator.id,\n        score: s.score,\n        x402scan: s.x402scanExplanation ? {\n          score: s.x402scanExplanation.score,\n          confidence: s.x402scanExplanation.confidence,\n          shortReason: s.x402scanExplanation.shortReason,\n        } : null,\n      }));\n      logger.debug({ alternatives, msg: 'Alternative facilitators considered' });\n    }\n    \n    // Log decision trace (compact format for explainer/debugger UI)\n    // Include facilitatorUrl for per-facilitator logging\n    logger.info({\n      facilitatorId: best.id,\n      facilitatorUrl: best.config.healthCheckUrl,\n      score: scored[0].score,\n      x402scanScore: bestExplanation?.score,\n      x402scanConfidence: bestExplanation?.confidence,\n      alternatives: scored.length - 1,\n      reasons: scored[0].reasons,\n      strategy: preferences?.facilitatorStrategy || 'auto',\n      mode: 'auto',\n      constraints: {\n        preferences: preferences ? {\n          priority: preferences.priority,\n          preferredNetworks: preferences.preferredNetworks,\n          preferredAssets: preferences.preferredAssets,\n          facilitatorStrategy: preferences.facilitatorStrategy,\n        } : undefined,\n        settlementMode: requirements.settlementMode,\n      },\n      candidates: scored.map((s) => ({\n        id: s.facilitator.id,\n        url: s.facilitator.config.healthCheckUrl,\n        score: s.score,\n        reasons: s.reasons,\n      })),\n      msg: 'Facilitator selected',\n    });\n\n    return best;\n  }\n\n  /**\n   * Get eligible facilitators based on requirements, preferences, and policy\n   * Extended to support CAIP identifiers and settlement modes\n   */\n  private getEligibleFacilitators(\n    requirements: PaymentRequirements,\n    preferences?: RoutingPreferences,\n    policy?: RoutingPolicy\n  ): IFacilitator[] {\n    const facilitators = Array.from(this.facilitators.values());\n\n    return facilitators.filter((facilitator) => {\n      // 1. Check basic support (legacy or CAIP)\n      let supportsNetwork = false;\n      let supportsAsset = false;\n\n      // Check network support\n      if (requirements.networks && requirements.networks.length > 0) {\n        // CAIP networks\n        supportsNetwork = requirements.networks.some((n) =>\n          facilitator.supportsCAIPNetwork(n)\n        );\n      } else {\n        // Legacy network\n        supportsNetwork = facilitator.config.networks.includes(requirements.network);\n      }\n\n      // Check asset support\n      if (requirements.assets && requirements.assets.length > 0) {\n        // CAIP assets\n        supportsAsset = requirements.assets.some((a) =>\n          facilitator.supportsCAIPAsset(a)\n        );\n      } else {\n        // Legacy asset\n        supportsAsset = facilitator.config.assets.includes(requirements.asset);\n      }\n\n      if (\n        !supportsNetwork ||\n        !supportsAsset ||\n        !facilitator.supports(\n          requirements.network,\n          requirements.asset,\n          requirements.scheme,\n          requirements.settlementMode\n        )\n      ) {\n        return false;\n      }\n\n      // 2. Check if enabled\n      if (!facilitator.config.enabled) {\n        return false;\n      }\n\n      // 3. Check preferences (SDK preferences) - support both legacy and CAIP\n      const preferredNetworks = [\n        ...(preferences?.preferredNetworks || []),\n        ...(preferences?.preferredNetworksCAIP || []),\n      ];\n      if (preferredNetworks.length > 0) {\n        const facilitatorNetworks = [\n          ...facilitator.config.networks,\n          ...(facilitator.config.networksCAIP || []),\n        ];\n        if (!preferredNetworks.some((p) => facilitatorNetworks.some((n) => n.includes(p) || p.includes(n)))) {\n          return false;\n        }\n      }\n\n      const avoidedNetworks = [\n        ...(preferences?.avoidNetworks || []),\n        ...(preferences?.avoidNetworksCAIP || []),\n      ];\n      if (avoidedNetworks.length > 0) {\n        const facilitatorNetworks = [\n          ...facilitator.config.networks,\n          ...(facilitator.config.networksCAIP || []),\n        ];\n        if (avoidedNetworks.some((a) => facilitatorNetworks.some((n) => n.includes(a) || a.includes(n)))) {\n          return false;\n        }\n      }\n\n      const preferredAssets = [\n        ...(preferences?.preferredAssets || []),\n        ...(preferences?.preferredAssetsCAIP || []),\n      ];\n      if (preferredAssets.length > 0) {\n        const facilitatorAssets = [\n          ...facilitator.config.assets,\n          ...(facilitator.config.assetsCAIP || []),\n        ];\n        if (!preferredAssets.some((p) => facilitatorAssets.some((a) => a.includes(p) || p.includes(a)))) {\n          return false;\n        }\n      }\n\n      // 3b. Check jurisdiction (if specified)\n      if (preferences?.jurisdiction) {\n        // This would integrate with jurisdiction rules\n        // For now, pass through (can be enhanced later)\n      }\n\n      // 3c. Check settlement mode preference\n      if (preferences?.settlementMode) {\n        if (facilitator.config.settlementModes && !facilitator.config.settlementModes.includes(preferences.settlementMode)) {\n          return false;\n        }\n      }\n\n      // 4. Check policy (SMF business logic)\n      if (policy?.requireHealthCheck) {\n        const health = this.facilitatorHealth.get(facilitator.id);\n        if (!health || !health.healthy) {\n          return false;\n        }\n      }\n\n      // Note: Database health snapshot check is done in scoreFacilitators (async)\n      // to avoid blocking the synchronous filter operation\n\n      if (policy?.customRules) {\n        if (!policy.customRules(facilitator, requirements)) {\n          return false;\n        }\n      }\n\n      // 5. Check compliance requirements\n      if (preferences?.requireCompliance || policy?.requireKYC) {\n        // Check if facilitator supports compliance\n        const metadata = facilitator.config.metadata;\n        if (!metadata?.kytEnabled && !metadata?.ofacEnabled) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Score facilitators based on preferences and policy\n   * Uses real health metrics from database AND x402scan ecosystem data for accurate scoring\n   * Handles priority ties with randomization\n   * Exposed for decision trace building\n   */\n  public async scoreFacilitators(\n    facilitators: IFacilitator[],\n    requirements: PaymentRequirements,\n    preferences?: RoutingPreferences,\n    policy?: RoutingPolicy\n  ): Promise<Array<{ facilitator: IFacilitator; score: number; reasons: string[]; x402scanExplanation?: FacilitatorExplanation }>> {\n    const x402scanConfig = DEFAULT_X402SCAN_TRUST_CONFIG;\n    \n    const scored = await Promise.all(\n      facilitators.map(async (facilitator) => {\n        let score = 100; // Start with base score\n        const reasons: string[] = [];\n        let x402scanExplanation: FacilitatorExplanation | undefined;\n\n        // 1. Base priority (lower priority number = higher priority)\n        const basePriority = facilitator.config.priority;\n        score += basePriority * 10;\n        reasons.push(`priority:${basePriority}`);\n\n        // 2. Get real health metrics from database\n        const network = requirements.network;\n        const token = requirements.asset;\n        let healthMetrics;\n        try {\n          healthMetrics = await getCurrentHealth(facilitator.id, network, token, 15);\n        } catch (error) {\n          logger.warn({ error, facilitatorId: facilitator.id, network, token }, 'Failed to get health metrics, using defaults');\n          healthMetrics = {\n            successRate: 1.0,\n            p95LatencyMs: null,\n            errorRate: 0.0,\n            status: 'healthy' as const,\n          };\n        }\n\n        // =======================================================================\n        // 2b. Get x402scan ecosystem metrics (if available and trusted)\n        // =======================================================================\n        let x402scanScore: FacilitatorScore | null = null;\n        let x402scanTrust = { trust: false, reason: 'not-fetched' };\n        \n        try {\n          x402scanScore = await getFacilitatorScore({\n            facilitatorId: facilitator.id,\n            timeframe: x402scanConfig.timeframe,\n          });\n          x402scanTrust = shouldTrustX402ScanMetrics(x402scanScore, x402scanConfig);\n          \n          // Get detailed explanation for logging\n          if (x402scanConfig.logExplanations) {\n            x402scanExplanation = await getFacilitatorExplainer(facilitator.id, {\n              timeframe: x402scanConfig.timeframe,\n            });\n          }\n        } catch (error) {\n          logger.debug({ error, facilitatorId: facilitator.id }, 'Failed to get x402scan metrics');\n          x402scanTrust = { trust: false, reason: 'fetch-error' };\n        }\n\n        // 3. Success rate scoring (w1 * successRate)\n        const w1 = 50; // Weight for success rate\n        const successRateScore = healthMetrics.successRate * w1;\n        score += successRateScore;\n        reasons.push(`success-rate:${(healthMetrics.successRate * 100).toFixed(1)}%`);\n\n        // 4. Latency scoring (w2 * p95LatencyMs) - lower is better\n        const w2 = 0.1; // Weight for latency penalty\n        if (healthMetrics.p95LatencyMs !== null) {\n          const latencyPenalty = healthMetrics.p95LatencyMs * w2;\n          score -= latencyPenalty;\n          reasons.push(`p95-latency:${healthMetrics.p95LatencyMs}ms`);\n        }\n\n        // 5. Fee scoring (w3 * feeBps) - get from capabilities\n        const w3 = 0.5; // Weight for fee penalty\n        try {\n          const capabilities = await getFacilitatorCapabilities(facilitator.id, network, token);\n          const capability = capabilities[0];\n          if (capability) {\n            const feePenalty = capability.fee_bps * w3;\n            score -= feePenalty;\n            reasons.push(`fee:${capability.fee_bps}bps`);\n          }\n        } catch (error) {\n          logger.debug({ error, facilitatorId: facilitator.id }, 'Failed to get capabilities for fee scoring');\n        }\n\n        // 6. Risk penalty (w4 * riskPenalty) - based on error rate and status\n        const w4 = 30; // Weight for risk penalty\n        const riskPenalty = healthMetrics.errorRate * w4;\n        score -= riskPenalty;\n        if (healthMetrics.status === 'down') {\n          // Refuse routing to down facilitators (set score to very low value)\n          score = -1000; // Effectively prevents routing\n          reasons.push('status:down');\n          logger.warn(\n            { facilitatorId: facilitator.id, network: requirements.network, token: requirements.asset },\n            'Refusing to route - facilitator is down'\n          );\n        } else if (healthMetrics.status === 'degraded') {\n          score -= 25; // Moderate penalty for degraded\n          reasons.push('status:degraded');\n          logger.warn(\n            { facilitatorId: facilitator.id, network: requirements.network, token: requirements.asset },\n            'Facilitator is degraded - routing with caution'\n          );\n        }\n\n        // 7. Health status check (cached)\n        const health = this.facilitatorHealth.get(facilitator.id);\n        if (health && !health.healthy) {\n          score -= 30; // Additional penalty for unhealthy in cache\n          reasons.push('cache-unhealthy');\n        }\n\n        // =======================================================================\n        // 8. X402SCAN ECOSYSTEM METRICS INTEGRATION\n        // =======================================================================\n        if (x402scanTrust.trust && x402scanScore) {\n          // Apply x402scan score as weighted bonus/penalty\n          // x402scan score is 0-100, normalize to contribute proportionally\n          const x402scanNormalized = (x402scanScore.score - 50) / 50; // -1 to +1\n          const x402scanBonus = x402scanNormalized * 30 * x402scanConfig.x402scanScoreWeight;\n          score += x402scanBonus;\n          reasons.push(`x402scan:${x402scanScore.score}/${x402scanTrust.reason}`);\n\n          // Extra bonus for high success rate in ecosystem data\n          if (x402scanScore.successRate >= 0.99) {\n            score += 10 * x402scanConfig.x402scanScoreWeight;\n            reasons.push('x402scan-excellent');\n          } else if (x402scanScore.successRate < 0.90) {\n            score -= 15 * x402scanConfig.x402scanScoreWeight;\n            reasons.push('x402scan-degraded');\n          }\n\n          // Latency bonus/penalty from ecosystem data\n          if (x402scanScore.p95LatencyMs !== undefined) {\n            if (x402scanScore.p95LatencyMs < 200) {\n              score += 5 * x402scanConfig.x402scanScoreWeight;\n              reasons.push(`x402scan-fast:${x402scanScore.p95LatencyMs.toFixed(0)}ms`);\n            } else if (x402scanScore.p95LatencyMs > 1000) {\n              score -= 10 * x402scanConfig.x402scanScoreWeight;\n              reasons.push(`x402scan-slow:${x402scanScore.p95LatencyMs.toFixed(0)}ms`);\n            }\n          }\n        } else {\n          // Log why x402scan data wasn't trusted\n          reasons.push(`x402scan-skipped:${x402scanTrust.reason}`);\n        }\n\n        // =======================================================================\n        // 8b. SCATTERING / DUNE ACTIVITY METRICS INTEGRATION\n        // =======================================================================\n        const scatteringConfig = DEFAULT_SCATTERING_CONFIG;\n        let scatteringMetrics: ScatteringFacilitatorMetrics | null = null;\n        let scatteringTrust = { trust: false, reason: 'not-fetched' };\n\n        try {\n          scatteringMetrics = await getScatteringMetricsForFacilitator(facilitator.id);\n          scatteringTrust = shouldTrustScatteringMetrics(scatteringMetrics, scatteringConfig);\n        } catch (error) {\n          logger.debug({ error, facilitatorId: facilitator.id }, 'Failed to get Scattering metrics');\n          scatteringTrust = { trust: false, reason: 'fetch-error' };\n        }\n\n        if (scatteringTrust.trust && scatteringMetrics) {\n          // Compute activity score (0-1)\n          const activityScore = computeActivityScore(scatteringMetrics);\n          \n          // Apply as weighted bonus (activity score 0.5+ is good, higher is better)\n          const activityBonus = (activityScore - 0.3) * 100 * scatteringConfig.scatteringScoreWeight;\n          score += activityBonus;\n          reasons.push(`scattering-activity:${(activityScore * 100).toFixed(1)}%`);\n\n          // Volume bonus for high-volume facilitators\n          if (scatteringMetrics.volumeUsd3d >= 100_000) {\n            score += 10 * scatteringConfig.scatteringScoreWeight;\n            reasons.push(`scattering-high-volume:$${(scatteringMetrics.volumeUsd3d / 1000).toFixed(1)}K`);\n          }\n\n          // User diversity bonus (more unique buyers = more trusted)\n          if (scatteringMetrics.uniqueBuyers3d >= 1000) {\n            score += 5 * scatteringConfig.scatteringScoreWeight;\n            reasons.push(`scattering-high-adoption:${scatteringMetrics.uniqueBuyers3d}-buyers`);\n          }\n\n          // Growth bonus/penalty\n          if (scatteringMetrics.volumeChangeRate !== undefined) {\n            if (scatteringMetrics.volumeChangeRate > 20) {\n              // Growing facilitator\n              score += 5 * scatteringConfig.scatteringScoreWeight;\n              reasons.push(`scattering-growing:+${scatteringMetrics.volumeChangeRate.toFixed(0)}%`);\n            } else if (scatteringMetrics.volumeChangeRate < -50) {\n              // Declining significantly\n              score -= 10 * scatteringConfig.scatteringScoreWeight;\n              reasons.push(`scattering-declining:${scatteringMetrics.volumeChangeRate.toFixed(0)}%`);\n            }\n          }\n\n          // Log Scattering metrics if enabled\n          if (scatteringConfig.logScatteringMetrics) {\n            logger.debug({\n              facilitatorId: facilitator.id,\n              scattering: {\n                volumeUsd3d: scatteringMetrics.volumeUsd3d,\n                txCount3d: scatteringMetrics.txCount3d,\n                uniqueBuyers3d: scatteringMetrics.uniqueBuyers3d,\n                activityScore: activityScore.toFixed(3),\n                volumeChangeRate: scatteringMetrics.volumeChangeRate,\n              },\n              msg: 'Scattering metrics applied',\n            });\n          }\n        } else {\n          reasons.push(`scattering-skipped:${scatteringTrust.reason}`);\n        }\n\n        // =======================================================================\n        // 8c. PERSISTED SCORE INTEGRATION (Stage 5)\n        // =======================================================================\n        // Blend historical scores with real-time metrics for routing decisions\n        // Persisted scores use time-based decay (1-hour half-life)\n        const persistedConfig = DEFAULT_PERSISTED_SCORE_CONFIG;\n        \n        try {\n          const persistedScore = await getPersistedScore({\n            facilitator_id: facilitator.id,\n            chain_id: network,\n          });\n\n          if (persistedScore && persistedScore.confidence >= persistedConfig.minConfidence) {\n            // Blend persisted score into current score\n            // Persisted score is 0-100, current score varies but centered around ~100-150\n            // Normalize persisted score contribution: (persistedScore - 50) gives -50 to +50 range\n            const persistedContribution = (persistedScore.score - 50) * persistedConfig.persistedScoreWeight;\n            score += persistedContribution;\n            reasons.push(`persisted:${persistedScore.score.toFixed(0)}/${persistedScore.confidence.toFixed(2)}`);\n\n            if (persistedConfig.logPersistedScore) {\n              logger.debug({\n                facilitatorId: facilitator.id,\n                chain_id: network,\n                persisted: {\n                  score: persistedScore.score,\n                  confidence: persistedScore.confidence,\n                  contribution: persistedContribution,\n                },\n                msg: 'Persisted score applied',\n              });\n            }\n          } else if (persistedScore) {\n            reasons.push(`persisted-low-confidence:${persistedScore.confidence.toFixed(2)}`);\n          } else {\n            reasons.push('persisted-none');\n          }\n\n          // Check for running experiments and apply traffic adjustments\n          if (persistedConfig.enableExperimentAdjustments) {\n            const experimentAdjustment = await getExperimentTrafficAdjustment(\n              facilitator.id,\n              network\n            );\n\n            if (experimentAdjustment.adjustment > 0) {\n              score += experimentAdjustment.adjustment;\n              reasons.push(`experiment:${experimentAdjustment.experiment_name}:+${experimentAdjustment.adjustment.toFixed(1)}`);\n              \n              if (persistedConfig.logPersistedScore) {\n                logger.debug({\n                  facilitatorId: facilitator.id,\n                  experiment: experimentAdjustment.experiment_name,\n                  adjustment: experimentAdjustment.adjustment,\n                  msg: 'Experiment traffic adjustment applied',\n                });\n              }\n            }\n          }\n        } catch (error) {\n          logger.debug({ error, facilitatorId: facilitator.id }, 'Failed to get persisted score');\n          reasons.push('persisted-error');\n        }\n\n        // 9. Cost optimization (if policy requires)\n        if (policy?.preferCheapest || preferences?.priority === 'cost') {\n          const pricing = await facilitator.getPricing(requirements.network, requirements.asset);\n          if (pricing) {\n            // Lower cost = higher score (normalize)\n            score += 20; // Bonus for having pricing info\n            reasons.push('has-pricing');\n          }\n        }\n\n        // 10. Speed optimization (if preference)\n        if (preferences?.priority === 'speed') {\n          if (healthMetrics.p95LatencyMs !== null) {\n            // Lower latency = higher score\n            const latencyBonus = Math.max(0, 30 - healthMetrics.p95LatencyMs / 10);\n            score += latencyBonus;\n            reasons.push(`speed-optimized:${healthMetrics.p95LatencyMs}ms`);\n          }\n          // Also factor in x402scan latency for speed priority\n          if (x402scanTrust.trust && x402scanScore?.p95LatencyMs !== undefined) {\n            const x402LatencyBonus = Math.max(0, 20 - x402scanScore.p95LatencyMs / 25);\n            score += x402LatencyBonus * x402scanConfig.x402scanScoreWeight;\n          }\n        }\n\n        // 11. Compliance optimization\n        if (preferences?.priority === 'compliance' || policy?.requireKYC) {\n          const metadata = facilitator.config.metadata;\n          if (metadata?.kytEnabled && metadata?.ofacEnabled) {\n            score += 30; // Bonus for compliance\n            reasons.push('compliance-enabled');\n          }\n        }\n\n        // 12. Reliability optimization - strongly weight x402scan for reliability priority\n        if (preferences?.priority === 'reliability') {\n          if (healthMetrics.status === 'healthy' && healthMetrics.successRate > 0.95) {\n            score += 25;\n            reasons.push('high-reliability');\n          }\n          // Double weight x402scan for reliability priority\n          if (x402scanTrust.trust && x402scanScore) {\n            if (x402scanScore.successRate >= 0.98 && x402scanScore.confidence === 'high') {\n              score += 20; // Strong bonus for proven reliability\n              reasons.push('x402scan-proven-reliable');\n            }\n          }\n        }\n\n        // 13. Settlement mode optimization\n        if (requirements.settlementMode) {\n          if (facilitator.config.settlementModes?.includes(requirements.settlementMode)) {\n            score += 15; // Bonus for supporting requested settlement mode\n            reasons.push(`settlement:${requirements.settlementMode}`);\n          }\n        }\n\n        return { facilitator, score, reasons, x402scanExplanation };\n      })\n    );\n\n    // Sort by score (highest first)\n    const sorted = scored.sort((a, b) => b.score - a.score);\n\n    // Handle priority ties with randomization\n    // If top scores are within 5 points, randomize order\n    if (sorted.length > 1) {\n      const topScore = sorted[0].score;\n      const tied = sorted.filter((s) => Math.abs(s.score - topScore) <= 5);\n      \n      if (tied.length > 1) {\n        // Shuffle tied facilitators\n        for (let i = tied.length - 1; i > 0; i--) {\n          const j = Math.floor(Math.random() * (i + 1));\n          [tied[i], tied[j]] = [tied[j], tied[i]];\n        }\n        // Rebuild sorted array with shuffled ties\n        const rest = sorted.filter((s) => Math.abs(s.score - topScore) > 5);\n        return [...tied, ...rest];\n      }\n    }\n\n    return sorted;\n  }\n\n  /**\n   * Start periodic health checks\n   */\n  private startHealthChecks(): void {\n    this.healthCheckInterval = setInterval(async () => {\n      await this.checkAllFacilitators();\n    }, 5 * 60 * 1000); // Every 5 minutes\n\n    // Initial health check\n    this.checkAllFacilitators();\n  }\n\n  /**\n   * Check health of all facilitators\n   */\n  private async checkAllFacilitators(): Promise<void> {\n    const facilitators = Array.from(this.facilitators.values());\n    \n    await Promise.all(\n      facilitators.map(async (facilitator) => {\n        try {\n          const health = await facilitator.getHealth();\n          this.facilitatorHealth.set(facilitator.id, {\n            healthy: health.healthy,\n            lastChecked: Date.now(),\n          });\n        } catch (error) {\n          logger.error({ facilitatorId: facilitator.id, error }, 'Health check failed');\n          this.facilitatorHealth.set(facilitator.id, {\n            healthy: false,\n            lastChecked: Date.now(),\n          });\n        }\n      })\n    );\n  }\n\n  /**\n   * Get facilitator by ID\n   */\n  getFacilitator(id: string): IFacilitator | undefined {\n    return this.facilitators.get(id);\n  }\n\n  /**\n   * Get facilitator health status\n   */\n  getFacilitatorHealth(id: string): { healthy: boolean; lastChecked: number } | undefined {\n    return this.facilitatorHealth.get(id);\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n    }\n  }\n}\n\n// Singleton instance\nlet router: FacilitatorRouter | null = null;\n\n/**\n * Get facilitator router instance\n */\nexport function getFacilitatorRouter(): FacilitatorRouter {\n  if (!router) {\n    router = new FacilitatorRouter();\n  }\n  return router;\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 11326, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/route-context.ts"],"sourcesContent":["// =============================================================================\r\n// ROUTE CONTEXT\r\n// =============================================================================\r\n// Normalized request context for SMF routing\r\n// Ensures all facilitators receive consistent, x402-spec-compliant requests\r\n\r\nimport type { PaymentRequirements } from './base-facilitator';\r\n\r\n/**\r\n * RouteContext - Normalized request context for SMF routing\r\n * \r\n * This type ensures all facilitators receive consistent, x402-spec-compliant\r\n * requests regardless of how the request originated (API, SDK, etc.)\r\n */\r\nexport interface RouteContext {\r\n  // Payment details (x402 spec compliant)\r\n  network: string; // Legacy network identifier (e.g., 'base', 'ethereum')\r\n  token: string; // Token address (e.g., '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913')\r\n  amount: string; // Amount in atomic units (string to avoid precision loss)\r\n  \r\n  // CAIP identifiers (preferred for multi-chain)\r\n  networkCAIP?: string; // CAIP-2 network identifier (e.g., 'eip155:8453')\r\n  tokenCAIP?: string; // CAIP-19 asset identifier (e.g., 'eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913')\r\n  \r\n  // x402 version\r\n  x402Version: number; // x402 protocol version (currently 1 or 2)\r\n  \r\n  // Caller identification\r\n  callerId?: string; // Agent/merchant identifier\r\n  clientId?: string; // Client application identifier\r\n  \r\n  // Optional routing preferences\r\n  region?: string; // Geographic region (e.g., 'us-east', 'eu-west')\r\n  riskLevel?: 'low' | 'medium' | 'high'; // Risk assessment level\r\n  watchLevel?: 'normal' | 'enhanced' | 'strict'; // Compliance watch level\r\n  \r\n  // Additional context\r\n  preferences?: {\r\n    priority?: 'cost' | 'speed' | 'reliability' | 'compliance';\r\n    requireKYC?: boolean;\r\n    requireOFAC?: boolean;\r\n    maxLatencyMs?: number;\r\n    maxFeeBps?: number;\r\n  };\r\n  \r\n  // Original payment requirements (for compatibility)\r\n  requirements: PaymentRequirements;\r\n}\r\n\r\n/**\r\n * Convert RouteContext to facilitator request format\r\n * \r\n * This ensures all facilitators receive x402-spec-compliant requests\r\n */\r\nexport function routeContextToFacilitatorRequest(\r\n  context: RouteContext\r\n): {\r\n  version: number;\r\n  amount: string;\r\n  network: string;\r\n  token: string;\r\n  networkCAIP?: string;\r\n  tokenCAIP?: string;\r\n} {\r\n  return {\r\n    version: context.x402Version,\r\n    amount: context.amount,\r\n    network: context.network,\r\n    token: context.token,\r\n    networkCAIP: context.networkCAIP,\r\n    tokenCAIP: context.tokenCAIP,\r\n  };\r\n}\r\n\r\n/**\r\n * Create RouteContext from PaymentRequirements\r\n * \r\n * Normalizes various input formats into consistent RouteContext\r\n */\r\nexport function createRouteContext(\r\n  requirements: PaymentRequirements,\r\n  options?: {\r\n    callerId?: string;\r\n    clientId?: string;\r\n    region?: string;\r\n    riskLevel?: 'low' | 'medium' | 'high';\r\n    watchLevel?: 'normal' | 'enhanced' | 'strict';\r\n    x402Version?: number;\r\n  }\r\n): RouteContext {\r\n  // Extract network (legacy or CAIP)\r\n  const network = requirements.network || requirements.networks?.[0] || '';\r\n  const networkCAIP = requirements.networks?.[0]?.startsWith('eip155:') \r\n    ? requirements.networks[0] \r\n    : undefined;\r\n  \r\n  // Extract token/asset (legacy or CAIP)\r\n  const token = requirements.asset || requirements.assets?.[0] || '';\r\n  const tokenCAIP = requirements.assets?.[0]?.includes('/') \r\n    ? requirements.assets[0] \r\n    : undefined;\r\n  \r\n  return {\r\n    network,\r\n    token,\r\n    amount: requirements.maxAmountRequired || '0',\r\n    networkCAIP,\r\n    tokenCAIP,\r\n    x402Version: options?.x402Version || 1, // Default to v1, upgrade to v2 when ready\r\n    callerId: options?.callerId,\r\n    clientId: options?.clientId,\r\n    region: options?.region,\r\n    riskLevel: options?.riskLevel,\r\n    watchLevel: options?.watchLevel,\r\n    requirements,\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,gBAAgB;AAChB,gFAAgF;AAChF,6CAA6C;AAC7C,4EAA4E;;;;;;;AAkDrE,SAAS,iCACd,OAAqB;IASrB,OAAO;QACL,SAAS,QAAQ,WAAW;QAC5B,QAAQ,QAAQ,MAAM;QACtB,SAAS,QAAQ,OAAO;QACxB,OAAO,QAAQ,KAAK;QACpB,aAAa,QAAQ,WAAW;QAChC,WAAW,QAAQ,SAAS;IAC9B;AACF;AAOO,SAAS,mBACd,YAAiC,EACjC,OAOC;IAED,mCAAmC;IACnC,MAAM,UAAU,aAAa,OAAO,IAAI,aAAa,QAAQ,EAAE,CAAC,EAAE,IAAI;IACtE,MAAM,cAAc,aAAa,QAAQ,EAAE,CAAC,EAAE,EAAE,WAAW,aACvD,aAAa,QAAQ,CAAC,EAAE,GACxB;IAEJ,uCAAuC;IACvC,MAAM,QAAQ,aAAa,KAAK,IAAI,aAAa,MAAM,EAAE,CAAC,EAAE,IAAI;IAChE,MAAM,YAAY,aAAa,MAAM,EAAE,CAAC,EAAE,EAAE,SAAS,OACjD,aAAa,MAAM,CAAC,EAAE,GACtB;IAEJ,OAAO;QACL;QACA;QACA,QAAQ,aAAa,iBAAiB,IAAI;QAC1C;QACA;QACA,aAAa,SAAS,eAAe;QACrC,UAAU,SAAS;QACnB,UAAU,SAAS;QACnB,QAAQ,SAAS;QACjB,WAAW,SAAS;QACpB,YAAY,SAAS;QACrB;IACF;AACF"}},
    {"offset": {"line": 11375, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/orchestrator/meta-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// META-FACILITATOR ORCHESTRATION ENGINE\r\n// =============================================================================\r\n// High-level orchestration layer that sits above individual facilitators\r\n// Owns business logic, routing policy, and risk management\r\n\r\nimport { getFacilitatorRouter, type RoutingPreferences, type RoutingPolicy } from '../facilitators/facilitator-router';\r\nimport { type PaymentRequirements, type VerificationResult, type IFacilitator } from '../facilitators/base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { createRoute, updateRouteStatus, createRouteAttempt } from '@/db/smf';\r\nimport { createRouteContext } from '../facilitators/route-context';\r\n\r\n// Re-export for convenience\r\nexport { getFacilitatorRouter };\r\n\r\nconst logger = createLogger({ component: 'MetaFacilitator' });\r\n\r\n/**\r\n * Meta-facilitator orchestration result\r\n */\r\n/**\r\n * Decision trace for routing decisions\r\n * Enables explainer/debugger UI in NexFlow\r\n */\r\nexport interface DecisionTrace {\r\n  timestamp: string;\r\n  reason: string;\r\n  constraints: {\r\n    preferences?: RoutingPreferences;\r\n    policy?: Partial<RoutingPolicy>;\r\n    requirements: PaymentRequirements;\r\n  };\r\n  candidates: Array<{\r\n    facilitatorId: string;\r\n    facilitatorName: string;\r\n    score: number;\r\n    eligible: boolean;\r\n    reasons: string[];\r\n  }>;\r\n  selected: {\r\n    facilitatorId: string;\r\n    score: number;\r\n    alternativesConsidered: number;\r\n  };\r\n}\r\n\r\nexport interface OrchestrationResult extends VerificationResult {\r\n  facilitatorUsed: string;\r\n  routingReason: string;\r\n  alternativesConsidered: number;\r\n  decisionTrace?: DecisionTrace; // Compact decision trace for debugging\r\n  orchestrationMetadata?: {\r\n    cost?: number;\r\n    latency?: number;\r\n    complianceScore?: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Meta-Facilitator\r\n * Orchestrates multiple facilitators with business logic above raw settlement\r\n */\r\nexport class MetaFacilitator {\r\n  private router = getFacilitatorRouter();\r\n\r\n  /**\r\n   * Verify payment with orchestration\r\n   * \r\n   * This is the main entry point for payment verification.\r\n   * It handles:\r\n   * 1. Facilitator selection based on policy\r\n   * 2. Payment routing\r\n   * 3. Failover handling\r\n   * 4. Result aggregation\r\n   * 5. Business logic application\r\n   */\r\n  async verifyPayment(\r\n    payment: string,\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy,\r\n    context?: {\r\n      requestId?: string;\r\n      correlationId?: string;\r\n      clientId?: string;\r\n      agentId?: string;\r\n    }\r\n  ): Promise<OrchestrationResult> {\r\n    const startTime = Date.now();\r\n    let routeId: string | null = null;\r\n\r\n    try {\r\n      // 1. Create route context and route record\r\n      const routeContext = createRouteContext(requirements, {\r\n        callerId: context?.clientId || context?.agentId,\r\n        clientId: context?.clientId,\r\n        x402Version: 1, // Default to v1, can be upgraded\r\n      });\r\n\r\n      // 2. Select best facilitator based on policy\r\n      const facilitator = await this.router.routePayment(requirements, preferences, policy);\r\n\r\n      // 3. Create route record with selected facilitator\r\n      const route = await createRoute({\r\n        request_id: context?.requestId || null,\r\n        correlation_id: context?.correlationId || null,\r\n        client_id: context?.clientId || null,\r\n        agent_id: context?.agentId || null,\r\n        network: routeContext.network,\r\n        token: routeContext.token,\r\n        amount: routeContext.amount,\r\n        selected_facilitator_id: facilitator.id,\r\n        status: 'verifying',\r\n      });\r\n      routeId = route.id;\r\n\r\n      // Log decision trace (compact format)\r\n      logger.info({\r\n        routeId,\r\n        facilitatorId: facilitator.id,\r\n        network: requirements.network,\r\n        asset: requirements.asset,\r\n        settlementMode: requirements.settlementMode,\r\n        preferences: preferences ? {\r\n          priority: preferences.priority,\r\n          jurisdiction: preferences.jurisdiction,\r\n        } : undefined,\r\n      }, 'Routing payment to facilitator');\r\n\r\n      // 3. Verify payment with selected facilitator\r\n      const verifyStartTime = Date.now();\r\n      let result: VerificationResult;\r\n      let attemptResult: 'success' | 'failure' | 'timeout' | 'rate_limited' | 'insufficient_liquidity' | 'invalid_request' | 'network_error' = 'success';\r\n      let errorCode: string | null = null;\r\n      let rawStatus: number | null = null;\r\n\r\n      try {\r\n        result = await facilitator.verify(payment, requirements);\r\n        const verifyLatency = Date.now() - verifyStartTime;\r\n\r\n        // Determine attempt result\r\n        if (!result.success || !result.valid) {\r\n          attemptResult = 'failure';\r\n          errorCode = result.error || 'verification_failed';\r\n        }\r\n\r\n        // Log route attempt\r\n        await createRouteAttempt({\r\n          route_id: routeId,\r\n          facilitator_id: facilitator.id,\r\n          phase: 'verify',\r\n          result: attemptResult,\r\n          latency_ms: verifyLatency,\r\n          error_code: errorCode,\r\n          raw_status: rawStatus,\r\n          is_probe: false,\r\n        });\r\n      } catch (error) {\r\n        const verifyLatency = Date.now() - verifyStartTime;\r\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n\r\n        // Determine error type\r\n        if (errorMessage.includes('timeout') || errorMessage.includes('TIMEOUT')) {\r\n          attemptResult = 'timeout';\r\n        } else if (errorMessage.includes('rate') || errorMessage.includes('429')) {\r\n          attemptResult = 'rate_limited';\r\n          rawStatus = 429;\r\n        } else if (errorMessage.includes('network') || errorMessage.includes('ECONNREFUSED')) {\r\n          attemptResult = 'network_error';\r\n        } else {\r\n          attemptResult = 'failure';\r\n        }\r\n\r\n        errorCode = errorMessage;\r\n\r\n        // Log failed attempt\r\n        await createRouteAttempt({\r\n          route_id: routeId,\r\n          facilitator_id: facilitator.id,\r\n          phase: 'verify',\r\n          result: attemptResult,\r\n          latency_ms: verifyLatency,\r\n          error_code: errorCode,\r\n          raw_status: rawStatus,\r\n          is_probe: false,\r\n        });\r\n\r\n        // Create failure result\r\n        result = {\r\n          success: false,\r\n          valid: false,\r\n          error: errorMessage,\r\n          facilitatorId: facilitator.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // 4. Apply business logic (risk rules, compliance, etc.)\r\n      const orchestrated = this.applyBusinessLogic(result, requirements, policy);\r\n\r\n      // 5. Update route status\r\n      if (orchestrated.success && orchestrated.valid) {\r\n        await updateRouteStatus(routeId, 'settled', new Date().toISOString());\r\n      } else {\r\n        await updateRouteStatus(routeId, 'failed', new Date().toISOString());\r\n      }\r\n\r\n      // 6. Calculate orchestration metadata\r\n      const latency = Date.now() - startTime;\r\n      const metadata = {\r\n        latency,\r\n        complianceScore: this.calculateComplianceScore(result),\r\n      };\r\n\r\n      // 7. Build decision trace (for explainer/debugger UI)\r\n      const eligible = this.router.getFacilitators().filter((f) =>\r\n        f.supports(requirements.network, requirements.asset, requirements.scheme, requirements.settlementMode) && f.config.enabled\r\n      );\r\n      const decisionTrace = await this.buildDecisionTrace(\r\n        facilitator,\r\n        eligible,\r\n        requirements,\r\n        preferences,\r\n        policy\r\n      );\r\n\r\n      return {\r\n        ...orchestrated,\r\n        facilitatorUsed: facilitator.id,\r\n        routingReason: this.getRoutingReason(facilitator, preferences, policy),\r\n        alternativesConsidered: eligible.length - 1,\r\n        decisionTrace,\r\n        orchestrationMetadata: metadata,\r\n      };\r\n    } catch (error) {\r\n      logger.error({ error, requirements, routeId }, 'Orchestration error');\r\n\r\n      // Update route status to failed\r\n      if (routeId) {\r\n        await updateRouteStatus(routeId, 'failed', new Date().toISOString());\r\n      }\r\n\r\n      // Try failover if available\r\n      if (policy?.requireHealthCheck !== false) {\r\n        return await this.handleFailover(payment, requirements, preferences, policy, error, routeId);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply business logic to verification result\r\n   * SMF owns higher-level policy above raw settlement\r\n   */\r\n  private applyBusinessLogic(\r\n    result: VerificationResult,\r\n    requirements: PaymentRequirements,\r\n    policy?: RoutingPolicy\r\n  ): VerificationResult {\r\n    // 1. Risk rules\r\n    if (policy?.riskThreshold !== undefined) {\r\n      const riskScore = this.calculateRiskScore(result);\r\n      if (riskScore > policy.riskThreshold) {\r\n        return {\r\n          ...result,\r\n          valid: false,\r\n          error: `Risk score ${riskScore} exceeds threshold ${policy.riskThreshold}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // 2. Compliance rules\r\n    if (policy?.requireKYC) {\r\n      // Check if KYC is required for this amount\r\n      const amount = BigInt(requirements.maxAmountRequired);\r\n      const kycThreshold = BigInt('1000000000'); // 1000 USDC in smallest units\r\n      \r\n      if (amount > kycThreshold && result.kytStatus !== 'passed') {\r\n        return {\r\n          ...result,\r\n          valid: false,\r\n          error: 'KYC required for this amount',\r\n        };\r\n      }\r\n    }\r\n\r\n    // 3. Jurisdiction rules\r\n    if (policy?.jurisdictionRules) {\r\n      // Apply jurisdiction-specific rules\r\n      // This would integrate with geo-detection\r\n      // For now, pass through\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Calculate risk score (0-100)\r\n   */\r\n  private calculateRiskScore(result: VerificationResult): number {\r\n    let score = 0;\r\n\r\n    // KYT status\r\n    if (result.kytStatus === 'blocked') score += 50;\r\n    else if (result.kytStatus === 'flagged') score += 25;\r\n\r\n    // OFAC status\r\n    if (result.ofacStatus === 'blocked') score += 50;\r\n    else if (result.ofacStatus === 'flagged') score += 25;\r\n\r\n    // Error status\r\n    if (!result.success || !result.valid) score += 30;\r\n\r\n    return Math.min(100, score);\r\n  }\r\n\r\n  /**\r\n   * Calculate compliance score (0-100)\r\n   */\r\n  private calculateComplianceScore(result: VerificationResult): number {\r\n    let score = 100;\r\n\r\n    // Deduct for compliance issues\r\n    if (result.kytStatus === 'blocked') score -= 50;\r\n    else if (result.kytStatus === 'flagged') score -= 25;\r\n\r\n    if (result.ofacStatus === 'blocked') score -= 50;\r\n    else if (result.ofacStatus === 'flagged') score -= 25;\r\n\r\n    return Math.max(0, score);\r\n  }\r\n\r\n  /**\r\n   * Build decision trace for explainer/debugger UI\r\n   * Compact format for logging and future UI display\r\n   */\r\n  private async buildDecisionTrace(\r\n    selected: IFacilitator,\r\n    eligible: IFacilitator[],\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): Promise<DecisionTrace> {\r\n    // Score candidates to get detailed info\r\n    const router = getFacilitatorRouter();\r\n    const scored = await router.scoreFacilitators(\r\n      eligible,\r\n      requirements,\r\n      preferences,\r\n      policy\r\n    );\r\n\r\n    const candidates = eligible.map((f) => {\r\n      const scoredEntry = scored.find((s: any) => s.facilitator.id === f.id);\r\n      const score = scoredEntry?.score || 0;\r\n      const reasons = scoredEntry?.reasons || [];\r\n\r\n      return {\r\n        facilitatorId: f.id,\r\n        facilitatorName: f.name,\r\n        score,\r\n        eligible: true,\r\n        reasons,\r\n      };\r\n    });\r\n\r\n    return {\r\n      timestamp: new Date().toISOString(),\r\n      reason: this.getRoutingReason(selected, preferences, policy),\r\n      constraints: {\r\n        preferences,\r\n        policy: policy ? {\r\n          requireHealthCheck: policy.requireHealthCheck,\r\n          preferCheapest: policy.preferCheapest,\r\n          requireKYC: policy.requireKYC,\r\n        } : undefined,\r\n        requirements,\r\n      },\r\n      candidates,\r\n      selected: {\r\n        facilitatorId: selected.id,\r\n        score: scored.find((s: any) => s.facilitator.id === selected.id)?.score || 100,\r\n        alternativesConsidered: eligible.length - 1,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get routing reason for logging/analytics\r\n   */\r\n  private getRoutingReason(\r\n    facilitator: any,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): string {\r\n    const reasons: string[] = [];\r\n\r\n    if (preferences?.priority === 'cost') reasons.push('cost-optimized');\r\n    if (preferences?.priority === 'speed') reasons.push('speed-optimized');\r\n    if (preferences?.priority === 'compliance') reasons.push('compliance-optimized');\r\n    if (preferences?.priority === 'reliability') reasons.push('reliability-optimized');\r\n    if (preferences?.preferredNetworks) reasons.push('network-preference');\r\n    if (policy?.preferCheapest) reasons.push('cheapest-selected');\r\n    if (facilitator.config.priority === 1) reasons.push('primary-facilitator');\r\n\r\n    return reasons.join(', ') || 'default-routing';\r\n  }\r\n\r\n  /**\r\n   * Handle failover to alternative facilitator\r\n   */\r\n  private async handleFailover(\r\n    payment: string,\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy,\r\n    originalError?: any,\r\n    routeId?: string | null\r\n  ): Promise<OrchestrationResult> {\r\n    logger.warn({ originalError, requirements }, 'Attempting failover');\r\n\r\n    // Get all facilitators\r\n    const facilitators = this.router.getFacilitators();\r\n    const eligible = facilitators.filter((f) =>\r\n      f.supports(requirements.network, requirements.asset, requirements.scheme, requirements.settlementMode) && f.config.enabled\r\n    );\r\n\r\n    // Try each facilitator in order of priority\r\n    for (const facilitator of eligible.sort((a, b) => a.config.priority - b.config.priority)) {\r\n      const attemptStartTime = Date.now();\r\n      try {\r\n        const result = await facilitator.verify(payment, requirements);\r\n        const attemptLatency = Date.now() - attemptStartTime;\r\n        \r\n        // Log failover attempt\r\n        if (routeId) {\r\n          await createRouteAttempt({\r\n            route_id: routeId,\r\n            facilitator_id: facilitator.id,\r\n            phase: 'verify',\r\n            result: result.success && result.valid ? 'success' : 'failure',\r\n            latency_ms: attemptLatency,\r\n            is_probe: false,\r\n            error_code: result.error || null,\r\n            raw_status: null,\r\n          });\r\n        }\r\n        \r\n        if (result.success && result.valid) {\r\n          logger.info({ facilitatorId: facilitator.id, routeId }, 'Failover successful');\r\n          \r\n          // Update route with successful facilitator\r\n          if (routeId) {\r\n            await updateRouteStatus(routeId, 'settled', new Date().toISOString());\r\n          }\r\n          \r\n          return {\r\n            ...result,\r\n            facilitatorUsed: facilitator.id,\r\n            routingReason: 'failover',\r\n            alternativesConsidered: eligible.length - 1,\r\n          };\r\n        }\r\n      } catch (error) {\r\n        const attemptLatency = Date.now() - attemptStartTime;\r\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n        \r\n        // Log failed failover attempt\r\n        if (routeId) {\r\n          let attemptResult: 'timeout' | 'rate_limited' | 'network_error' | 'failure' = 'failure';\r\n          if (errorMessage.includes('timeout')) {\r\n            attemptResult = 'timeout';\r\n          } else if (errorMessage.includes('rate') || errorMessage.includes('429')) {\r\n            attemptResult = 'rate_limited';\r\n          } else if (errorMessage.includes('network') || errorMessage.includes('ECONNREFUSED')) {\r\n            attemptResult = 'network_error';\r\n          }\r\n          \r\n          await createRouteAttempt({\r\n            route_id: routeId,\r\n            facilitator_id: facilitator.id,\r\n            phase: 'verify',\r\n            result: attemptResult,\r\n            latency_ms: attemptLatency,\r\n            is_probe: false,\r\n            error_code: errorMessage,\r\n            raw_status: null,\r\n          });\r\n        }\r\n        \r\n        logger.warn({ facilitatorId: facilitator.id, error, routeId }, 'Failover attempt failed');\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // All facilitators failed\r\n    throw new Error(\r\n      `All facilitators failed. Original error: ${originalError instanceof Error ? originalError.message : 'Unknown error'}`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get orchestrator status\r\n   * Fixed: Aligns health semantics with facilitator health checks\r\n   */\r\n  async getStatus(): Promise<{\r\n    facilitators: number;\r\n    healthy: number;\r\n    networks: string[];\r\n    assets: string[];\r\n    facilitatorDetails: Array<{\r\n      id: string;\r\n      name: string;\r\n      healthy: boolean;\r\n      lastChecked?: string;\r\n    }>;\r\n  }> {\r\n    const facilitators = this.router.getFacilitators();\r\n    \r\n    // Check health of all facilitators (use actual health checks, not cached)\r\n    const healthChecks = await Promise.all(\r\n      facilitators.map(async (f) => {\r\n        try {\r\n          const health = await f.getHealth();\r\n          return {\r\n            id: f.id,\r\n            name: f.name,\r\n            healthy: health.healthy,\r\n            lastChecked: health.lastChecked,\r\n          };\r\n        } catch (error) {\r\n          return {\r\n            id: f.id,\r\n            name: f.name,\r\n            healthy: false,\r\n            lastChecked: new Date().toISOString(),\r\n          };\r\n        }\r\n      })\r\n    );\r\n\r\n    const healthy = healthChecks.filter((h) => h.healthy);\r\n\r\n    const networks = new Set<string>();\r\n    const assets = new Set<string>();\r\n\r\n    facilitators.forEach((f) => {\r\n      f.config.networks.forEach((n) => networks.add(n));\r\n      f.config.assets.forEach((a) => assets.add(a));\r\n    });\r\n\r\n    return {\r\n      facilitators: facilitators.length,\r\n      healthy: healthy.length,\r\n      networks: Array.from(networks),\r\n      assets: Array.from(assets),\r\n      facilitatorDetails: healthChecks,\r\n    };\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet metaFacilitator: MetaFacilitator | null = null;\r\n\r\n/**\r\n * Get meta-facilitator instance\r\n */\r\nexport function getMetaFacilitator(): MetaFacilitator {\r\n  if (!metaFacilitator) {\r\n    metaFacilitator = new MetaFacilitator();\r\n  }\r\n  return metaFacilitator;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 11800, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/sessions/wallet-session.ts"],"sourcesContent":["// =============================================================================\r\n// WALLET SESSION MANAGER\r\n// =============================================================================\r\n// Manages wallet-based sessions for reusable payment authorizations\r\n// Supports subscription/session patterns, not just one-off payments\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { PaymentAuthorization } from '../signature-verifier';\r\n\r\nconst logger = createLogger({ component: 'WalletSession' });\r\n\r\n/**\r\n * Wallet Session\r\n * \r\n * Represents a reusable payment authorization that can be used\r\n * for multiple API calls within a session window.\r\n */\r\nexport interface WalletSession {\r\n  id: string; // Session ID (UUID)\r\n  walletAddress: string; // Wallet address that authorized payment\r\n  authorizedAmount: string; // Total amount authorized (in wei/smallest unit)\r\n  spentAmount: string; // Amount already spent in this session\r\n  validUntil: number; // Unix timestamp when session expires\r\n  validFrom: number; // Unix timestamp when session starts\r\n  network: string; // Network (e.g., 'base', 'ethereum')\r\n  asset: string; // Asset address (e.g., USDC address)\r\n  reusable: boolean; // Whether this session can be reused\r\n  nonce: string; // Original payment nonce\r\n  signature: string; // Original payment signature\r\n  authorization: PaymentAuthorization; // Full authorization object\r\n  endpointId?: string; // Optional: specific endpoint this session is for\r\n  agentId?: string; // Optional: agent using this session\r\n  createdAt: number; // Unix timestamp when session was created\r\n  lastUsedAt: number; // Unix timestamp when session was last used\r\n  usageCount: number; // Number of times this session has been used\r\n}\r\n\r\n/**\r\n * Session Creation Options\r\n */\r\nexport interface SessionOptions {\r\n  walletAddress: string;\r\n  authorizedAmount: string;\r\n  validUntil: number;\r\n  validFrom?: number;\r\n  network: string;\r\n  asset: string;\r\n  nonce: string;\r\n  signature: string;\r\n  authorization: PaymentAuthorization;\r\n  endpointId?: string;\r\n  agentId?: string;\r\n  reusable?: boolean; // Default: true\r\n}\r\n\r\n/**\r\n * Session Validation Result\r\n */\r\nexport interface SessionValidationResult {\r\n  valid: boolean;\r\n  session?: WalletSession;\r\n  error?: string;\r\n  remainingAmount?: string;\r\n}\r\n\r\n/**\r\n * Wallet Session Manager\r\n * \r\n * Manages wallet-based sessions for reusable payment authorizations.\r\n * Sessions allow agents to make multiple API calls with a single payment authorization.\r\n */\r\nexport class WalletSessionManager {\r\n  private sessions: Map<string, WalletSession> = new Map();\r\n  private walletSessions: Map<string, Set<string>> = new Map(); // wallet -> session IDs\r\n\r\n  /**\r\n   * Create a new wallet session from a payment authorization\r\n   */\r\n  createSession(options: SessionOptions): WalletSession {\r\n    const sessionId = this.generateSessionId();\r\n    const now = Math.floor(Date.now() / 1000);\r\n\r\n    const session: WalletSession = {\r\n      id: sessionId,\r\n      walletAddress: options.walletAddress.toLowerCase(),\r\n      authorizedAmount: options.authorizedAmount,\r\n      spentAmount: '0',\r\n      validUntil: options.validUntil,\r\n      validFrom: options.validFrom || now,\r\n      network: options.network,\r\n      asset: options.asset,\r\n      reusable: options.reusable !== false, // Default to true\r\n      nonce: options.nonce,\r\n      signature: options.signature,\r\n      authorization: options.authorization,\r\n      endpointId: options.endpointId,\r\n      agentId: options.agentId,\r\n      createdAt: now,\r\n      lastUsedAt: now,\r\n      usageCount: 0,\r\n    };\r\n\r\n    // Store session\r\n    this.sessions.set(sessionId, session);\r\n\r\n    // Index by wallet address\r\n    const walletKey = session.walletAddress;\r\n    if (!this.walletSessions.has(walletKey)) {\r\n      this.walletSessions.set(walletKey, new Set());\r\n    }\r\n    this.walletSessions.get(walletKey)!.add(sessionId);\r\n\r\n    logger.info(\r\n      {\r\n        sessionId,\r\n        walletAddress: session.walletAddress,\r\n        authorizedAmount: session.authorizedAmount,\r\n        validUntil: session.validUntil,\r\n      },\r\n      'Wallet session created'\r\n    );\r\n\r\n    return session;\r\n  }\r\n\r\n  /**\r\n   * Validate and retrieve a session\r\n   */\r\n  validateSession(sessionId: string): SessionValidationResult {\r\n    const session = this.sessions.get(sessionId);\r\n\r\n    if (!session) {\r\n      return {\r\n        valid: false,\r\n        error: 'Session not found',\r\n      };\r\n    }\r\n\r\n    // Check if session has expired\r\n    const now = Math.floor(Date.now() / 1000);\r\n    if (now > session.validUntil) {\r\n      this.sessions.delete(sessionId);\r\n      this.walletSessions.get(session.walletAddress)?.delete(sessionId);\r\n      return {\r\n        valid: false,\r\n        error: 'Session expired',\r\n      };\r\n    }\r\n\r\n    // Check if session has started\r\n    if (now < session.validFrom) {\r\n      return {\r\n        valid: false,\r\n        error: 'Session not yet valid',\r\n      };\r\n    }\r\n\r\n    // Calculate remaining amount\r\n    const authorized = BigInt(session.authorizedAmount);\r\n    const spent = BigInt(session.spentAmount);\r\n    const remaining = authorized > spent ? authorized - spent : BigInt(0);\r\n\r\n    return {\r\n      valid: true,\r\n      session,\r\n      remainingAmount: remaining.toString(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Use a session (deduct amount)\r\n   */\r\n  useSession(sessionId: string, amount: string): SessionValidationResult {\r\n    const validation = this.validateSession(sessionId);\r\n\r\n    if (!validation.valid || !validation.session) {\r\n      return validation;\r\n    }\r\n\r\n    const session = validation.session;\r\n    const amountToSpend = BigInt(amount);\r\n    const remaining = BigInt(validation.remainingAmount || '0');\r\n\r\n    // Check if session has enough remaining balance\r\n    if (amountToSpend > remaining) {\r\n      return {\r\n        valid: false,\r\n        session,\r\n        error: 'Insufficient session balance',\r\n        remainingAmount: remaining.toString(),\r\n      };\r\n    }\r\n\r\n    // Update session\r\n    const newSpent = BigInt(session.spentAmount) + amountToSpend;\r\n    session.spentAmount = newSpent.toString();\r\n    session.lastUsedAt = Math.floor(Date.now() / 1000);\r\n    session.usageCount += 1;\r\n\r\n    const newRemaining = remaining - amountToSpend;\r\n\r\n    logger.info(\r\n      {\r\n        sessionId,\r\n        amount,\r\n        remainingAmount: newRemaining.toString(),\r\n        usageCount: session.usageCount,\r\n      },\r\n      'Session used'\r\n    );\r\n\r\n    return {\r\n      valid: true,\r\n      session,\r\n      remainingAmount: newRemaining.toString(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get active sessions for a wallet\r\n   */\r\n  getWalletSessions(walletAddress: string): WalletSession[] {\r\n    const walletKey = walletAddress.toLowerCase();\r\n    const sessionIds = this.walletSessions.get(walletKey) || new Set();\r\n\r\n    const sessions: WalletSession[] = [];\r\n    for (const sessionId of sessionIds) {\r\n      const session = this.sessions.get(sessionId);\r\n      if (session) {\r\n        const now = Math.floor(Date.now() / 1000);\r\n        if (now <= session.validUntil && now >= session.validFrom) {\r\n          sessions.push(session);\r\n        }\r\n      }\r\n    }\r\n\r\n    return sessions;\r\n  }\r\n\r\n  /**\r\n   * Get session by ID\r\n   */\r\n  getSession(sessionId: string): WalletSession | undefined {\r\n    return this.sessions.get(sessionId);\r\n  }\r\n\r\n  /**\r\n   * Revoke a session\r\n   */\r\n  revokeSession(sessionId: string): boolean {\r\n    const session = this.sessions.get(sessionId);\r\n    if (!session) {\r\n      return false;\r\n    }\r\n\r\n    this.sessions.delete(sessionId);\r\n    this.walletSessions.get(session.walletAddress)?.delete(sessionId);\r\n\r\n    logger.info({ sessionId }, 'Session revoked');\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Clean up expired sessions\r\n   */\r\n  cleanupExpiredSessions(): number {\r\n    const now = Math.floor(Date.now() / 1000);\r\n    let cleaned = 0;\r\n\r\n    for (const [sessionId, session] of this.sessions.entries()) {\r\n      if (now > session.validUntil) {\r\n        this.sessions.delete(sessionId);\r\n        this.walletSessions.get(session.walletAddress)?.delete(sessionId);\r\n        cleaned++;\r\n      }\r\n    }\r\n\r\n    if (cleaned > 0) {\r\n      logger.info({ cleaned }, 'Expired sessions cleaned up');\r\n    }\r\n\r\n    return cleaned;\r\n  }\r\n\r\n  /**\r\n   * Generate a unique session ID\r\n   */\r\n  private generateSessionId(): string {\r\n    // Generate UUID v4\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n      const r = (Math.random() * 16) | 0;\r\n      const v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n      return v.toString(16);\r\n    });\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet sessionManager: WalletSessionManager | null = null;\r\n\r\n/**\r\n * Get wallet session manager instance\r\n */\r\nexport function getWalletSessionManager(): WalletSessionManager {\r\n  if (!sessionManager) {\r\n    sessionManager = new WalletSessionManager();\r\n    \r\n    // Clean up expired sessions every 5 minutes\r\n    setInterval(() => {\r\n      sessionManager?.cleanupExpiredSessions();\r\n    }, 5 * 60 * 1000);\r\n  }\r\n\r\n  return sessionManager;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 12015, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/sessions/subscription-manager.ts"],"sourcesContent":["// =============================================================================\r\n// SUBSCRIPTION MANAGER\r\n// =============================================================================\r\n// Manages subscription billing patterns for recurring payments\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport { getWalletSessionManager, type WalletSession } from './wallet-session';\r\n\r\nconst logger = createLogger({ component: 'SubscriptionManager' });\r\n\r\n/**\r\n * Subscription Plan\r\n */\r\nexport interface SubscriptionPlan {\r\n  id: string;\r\n  name: string;\r\n  endpointId: string;\r\n  price: string; // Price per billing period\r\n  billingPeriod: 'hourly' | 'daily' | 'weekly' | 'monthly';\r\n  maxUsage?: number; // Optional: max API calls per period\r\n  network: string;\r\n  asset: string;\r\n}\r\n\r\n/**\r\n * Active Subscription\r\n */\r\nexport interface ActiveSubscription {\r\n  id: string;\r\n  planId: string;\r\n  walletAddress: string;\r\n  endpointId: string;\r\n  status: 'active' | 'paused' | 'cancelled' | 'expired';\r\n  currentPeriodStart: number; // Unix timestamp\r\n  currentPeriodEnd: number; // Unix timestamp\r\n  usageCount: number; // API calls in current period\r\n  sessionId?: string; // Associated wallet session\r\n  createdAt: number;\r\n  updatedAt: number;\r\n}\r\n\r\n/**\r\n * Subscription Manager\r\n * \r\n * Manages subscription billing patterns for recurring payments.\r\n * Integrates with wallet sessions for payment authorization.\r\n */\r\nexport class SubscriptionManager {\r\n  private subscriptions: Map<string, ActiveSubscription> = new Map();\r\n  private walletSubscriptions: Map<string, Set<string>> = new Map(); // wallet -> subscription IDs\r\n  private plans: Map<string, SubscriptionPlan> = new Map();\r\n\r\n  /**\r\n   * Create a subscription plan\r\n   */\r\n  createPlan(plan: SubscriptionPlan): SubscriptionPlan {\r\n    this.plans.set(plan.id, plan);\r\n    logger.info({ planId: plan.id, name: plan.name }, 'Subscription plan created');\r\n    return plan;\r\n  }\r\n\r\n  /**\r\n   * Get subscription plan\r\n   */\r\n  getPlan(planId: string): SubscriptionPlan | undefined {\r\n    return this.plans.get(planId);\r\n  }\r\n\r\n  /**\r\n   * Create an active subscription\r\n   */\r\n  createSubscription(\r\n    planId: string,\r\n    walletAddress: string,\r\n    sessionId?: string\r\n  ): ActiveSubscription | null {\r\n    const plan = this.getPlan(planId);\r\n    if (!plan) {\r\n      logger.warn({ planId }, 'Subscription plan not found');\r\n      return null;\r\n    }\r\n\r\n    const subscriptionId = this.generateSubscriptionId();\r\n    const now = Math.floor(Date.now() / 1000);\r\n    const periodEnd = this.calculatePeriodEnd(now, plan.billingPeriod);\r\n\r\n    const subscription: ActiveSubscription = {\r\n      id: subscriptionId,\r\n      planId: plan.id,\r\n      walletAddress: walletAddress.toLowerCase(),\r\n      endpointId: plan.endpointId,\r\n      status: 'active',\r\n      currentPeriodStart: now,\r\n      currentPeriodEnd: periodEnd,\r\n      usageCount: 0,\r\n      sessionId,\r\n      createdAt: now,\r\n      updatedAt: now,\r\n    };\r\n\r\n    this.subscriptions.set(subscriptionId, subscription);\r\n\r\n    // Index by wallet\r\n    const walletKey = subscription.walletAddress;\r\n    if (!this.walletSubscriptions.has(walletKey)) {\r\n      this.walletSubscriptions.set(walletKey, new Set());\r\n    }\r\n    this.walletSubscriptions.get(walletKey)!.add(subscriptionId);\r\n\r\n    logger.info(\r\n      {\r\n        subscriptionId,\r\n        planId,\r\n        walletAddress: subscription.walletAddress,\r\n        periodEnd: subscription.currentPeriodEnd,\r\n      },\r\n      'Subscription created'\r\n    );\r\n\r\n    return subscription;\r\n  }\r\n\r\n  /**\r\n   * Check if subscription is active and valid\r\n   */\r\n  validateSubscription(subscriptionId: string): {\r\n    valid: boolean;\r\n    subscription?: ActiveSubscription;\r\n    error?: string;\r\n  } {\r\n    const subscription = this.subscriptions.get(subscriptionId);\r\n\r\n    if (!subscription) {\r\n      return {\r\n        valid: false,\r\n        error: 'Subscription not found',\r\n      };\r\n    }\r\n\r\n    if (subscription.status !== 'active') {\r\n      return {\r\n        valid: false,\r\n        subscription,\r\n        error: `Subscription is ${subscription.status}`,\r\n      };\r\n    }\r\n\r\n    const now = Math.floor(Date.now() / 1000);\r\n\r\n    // Check if period has expired\r\n    if (now > subscription.currentPeriodEnd) {\r\n      subscription.status = 'expired';\r\n      subscription.updatedAt = now;\r\n      return {\r\n        valid: false,\r\n        subscription,\r\n        error: 'Subscription period expired',\r\n      };\r\n    }\r\n\r\n    // Check usage limits\r\n    const plan = this.getPlan(subscription.planId);\r\n    if (plan?.maxUsage && subscription.usageCount >= plan.maxUsage) {\r\n      return {\r\n        valid: false,\r\n        subscription,\r\n        error: 'Subscription usage limit reached',\r\n      };\r\n    }\r\n\r\n    return {\r\n      valid: true,\r\n      subscription,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Record subscription usage\r\n   */\r\n  recordUsage(subscriptionId: string): boolean {\r\n    const validation = this.validateSubscription(subscriptionId);\r\n    if (!validation.valid || !validation.subscription) {\r\n      return false;\r\n    }\r\n\r\n    const subscription = validation.subscription;\r\n    subscription.usageCount += 1;\r\n    subscription.updatedAt = Math.floor(Date.now() / 1000);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Renew subscription period\r\n   */\r\n  renewSubscription(subscriptionId: string, sessionId?: string): boolean {\r\n    const subscription = this.subscriptions.get(subscriptionId);\r\n    if (!subscription) {\r\n      return false;\r\n    }\r\n\r\n    const plan = this.getPlan(subscription.planId);\r\n    if (!plan) {\r\n      return false;\r\n    }\r\n\r\n    const now = Math.floor(Date.now() / 1000);\r\n    const periodEnd = this.calculatePeriodEnd(now, plan.billingPeriod);\r\n\r\n    subscription.currentPeriodStart = now;\r\n    subscription.currentPeriodEnd = periodEnd;\r\n    subscription.usageCount = 0;\r\n    subscription.sessionId = sessionId;\r\n    subscription.updatedAt = now;\r\n\r\n    if (subscription.status === 'expired') {\r\n      subscription.status = 'active';\r\n    }\r\n\r\n    logger.info(\r\n      {\r\n        subscriptionId,\r\n        newPeriodEnd: periodEnd,\r\n      },\r\n      'Subscription renewed'\r\n    );\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Cancel subscription\r\n   */\r\n  cancelSubscription(subscriptionId: string): boolean {\r\n    const subscription = this.subscriptions.get(subscriptionId);\r\n    if (!subscription) {\r\n      return false;\r\n    }\r\n\r\n    subscription.status = 'cancelled';\r\n    subscription.updatedAt = Math.floor(Date.now() / 1000);\r\n\r\n    logger.info({ subscriptionId }, 'Subscription cancelled');\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get active subscriptions for a wallet\r\n   */\r\n  getWalletSubscriptions(walletAddress: string): ActiveSubscription[] {\r\n    const walletKey = walletAddress.toLowerCase();\r\n    const subscriptionIds = this.walletSubscriptions.get(walletKey) || new Set();\r\n\r\n    const subscriptions: ActiveSubscription[] = [];\r\n    for (const subscriptionId of subscriptionIds) {\r\n      const subscription = this.subscriptions.get(subscriptionId);\r\n      if (subscription && subscription.status === 'active') {\r\n        subscriptions.push(subscription);\r\n      }\r\n    }\r\n\r\n    return subscriptions;\r\n  }\r\n\r\n  /**\r\n   * Get subscription by ID\r\n   */\r\n  getSubscription(subscriptionId: string): ActiveSubscription | undefined {\r\n    return this.subscriptions.get(subscriptionId);\r\n  }\r\n\r\n  /**\r\n   * Calculate period end timestamp\r\n   */\r\n  private calculatePeriodEnd(start: number, period: SubscriptionPlan['billingPeriod']): number {\r\n    const periods: Record<SubscriptionPlan['billingPeriod'], number> = {\r\n      hourly: 3600,\r\n      daily: 86400,\r\n      weekly: 604800,\r\n      monthly: 2592000, // 30 days\r\n    };\r\n\r\n    return start + periods[period];\r\n  }\r\n\r\n  /**\r\n   * Generate subscription ID\r\n   */\r\n  private generateSubscriptionId(): string {\r\n    return `sub_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet subscriptionManager: SubscriptionManager | null = null;\r\n\r\n/**\r\n * Get subscription manager instance\r\n */\r\nexport function getSubscriptionManager(): SubscriptionManager {\r\n  if (!subscriptionManager) {\r\n    subscriptionManager = new SubscriptionManager();\r\n  }\r\n\r\n  return subscriptionManager;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 12233, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/sessions/session-cache.ts"],"sourcesContent":["// =============================================================================\r\n// SESSION CACHE\r\n// =============================================================================\r\n// In-memory and persistent cache for session state management\r\n// Can be extended to use Redis or other distributed cache\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { WalletSession } from './wallet-session';\r\nimport type { ActiveSubscription } from './subscription-manager';\r\n\r\nconst logger = createLogger({ component: 'SessionCache' });\r\n\r\n/**\r\n * Cache Configuration\r\n */\r\nexport interface CacheConfig {\r\n  ttl?: number; // Time to live in seconds (default: 3600 = 1 hour)\r\n  maxSize?: number; // Maximum number of entries (default: 10000)\r\n}\r\n\r\n/**\r\n * Session Cache\r\n * \r\n * Provides caching layer for sessions and subscriptions.\r\n * Currently in-memory, can be extended to use Redis or other distributed cache.\r\n */\r\nexport class SessionCache {\r\n  private sessions: Map<string, { data: WalletSession; expires: number }> = new Map();\r\n  private subscriptions: Map<string, { data: ActiveSubscription; expires: number }> = new Map();\r\n  private config: Required<CacheConfig>;\r\n\r\n  constructor(config: CacheConfig = {}) {\r\n    this.config = {\r\n      ttl: config.ttl || 3600, // 1 hour default\r\n      maxSize: config.maxSize || 10000,\r\n    };\r\n\r\n    // Clean up expired entries every minute\r\n    setInterval(() => {\r\n      this.cleanup();\r\n    }, 60 * 1000);\r\n  }\r\n\r\n  /**\r\n   * Store a session in cache\r\n   */\r\n  setSession(session: WalletSession): void {\r\n    // Check cache size\r\n    if (this.sessions.size >= this.config.maxSize) {\r\n      this.evictOldestSession();\r\n    }\r\n\r\n    const expires = Date.now() + this.config.ttl * 1000;\r\n    this.sessions.set(session.id, { data: session, expires });\r\n\r\n    logger.debug({ sessionId: session.id }, 'Session cached');\r\n  }\r\n\r\n  /**\r\n   * Get a session from cache\r\n   */\r\n  getSession(sessionId: string): WalletSession | null {\r\n    const entry = this.sessions.get(sessionId);\r\n\r\n    if (!entry) {\r\n      return null;\r\n    }\r\n\r\n    // Check if expired\r\n    if (Date.now() > entry.expires) {\r\n      this.sessions.delete(sessionId);\r\n      return null;\r\n    }\r\n\r\n    return entry.data;\r\n  }\r\n\r\n  /**\r\n   * Remove a session from cache\r\n   */\r\n  deleteSession(sessionId: string): void {\r\n    this.sessions.delete(sessionId);\r\n    logger.debug({ sessionId }, 'Session removed from cache');\r\n  }\r\n\r\n  /**\r\n   * Store a subscription in cache\r\n   */\r\n  setSubscription(subscription: ActiveSubscription): void {\r\n    // Check cache size\r\n    if (this.subscriptions.size >= this.config.maxSize) {\r\n      this.evictOldestSubscription();\r\n    }\r\n\r\n    const expires = Date.now() + this.config.ttl * 1000;\r\n    this.subscriptions.set(subscription.id, { data: subscription, expires });\r\n\r\n    logger.debug({ subscriptionId: subscription.id }, 'Subscription cached');\r\n  }\r\n\r\n  /**\r\n   * Get a subscription from cache\r\n   */\r\n  getSubscription(subscriptionId: string): ActiveSubscription | null {\r\n    const entry = this.subscriptions.get(subscriptionId);\r\n\r\n    if (!entry) {\r\n      return null;\r\n    }\r\n\r\n    // Check if expired\r\n    if (Date.now() > entry.expires) {\r\n      this.subscriptions.delete(subscriptionId);\r\n      return null;\r\n    }\r\n\r\n    return entry.data;\r\n  }\r\n\r\n  /**\r\n   * Remove a subscription from cache\r\n   */\r\n  deleteSubscription(subscriptionId: string): void {\r\n    this.subscriptions.delete(subscriptionId);\r\n    logger.debug({ subscriptionId }, 'Subscription removed from cache');\r\n  }\r\n\r\n  /**\r\n   * Clear all cached sessions\r\n   */\r\n  clearSessions(): void {\r\n    this.sessions.clear();\r\n    logger.info('All sessions cleared from cache');\r\n  }\r\n\r\n  /**\r\n   * Clear all cached subscriptions\r\n   */\r\n  clearSubscriptions(): void {\r\n    this.subscriptions.clear();\r\n    logger.info('All subscriptions cleared from cache');\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  getStats(): {\r\n    sessions: number;\r\n    subscriptions: number;\r\n    maxSize: number;\r\n  } {\r\n    return {\r\n      sessions: this.sessions.size,\r\n      subscriptions: this.subscriptions.size,\r\n      maxSize: this.config.maxSize,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clean up expired entries\r\n   */\r\n  private cleanup(): void {\r\n    const now = Date.now();\r\n    let cleanedSessions = 0;\r\n    let cleanedSubscriptions = 0;\r\n\r\n    // Clean expired sessions\r\n    for (const [sessionId, entry] of this.sessions.entries()) {\r\n      if (now > entry.expires) {\r\n        this.sessions.delete(sessionId);\r\n        cleanedSessions++;\r\n      }\r\n    }\r\n\r\n    // Clean expired subscriptions\r\n    for (const [subscriptionId, entry] of this.subscriptions.entries()) {\r\n      if (now > entry.expires) {\r\n        this.subscriptions.delete(subscriptionId);\r\n        cleanedSubscriptions++;\r\n      }\r\n    }\r\n\r\n    if (cleanedSessions > 0 || cleanedSubscriptions > 0) {\r\n      logger.debug(\r\n        { cleanedSessions, cleanedSubscriptions },\r\n        'Cache cleanup completed'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evict oldest session (LRU-like)\r\n   */\r\n  private evictOldestSession(): void {\r\n    let oldestId: string | null = null;\r\n    let oldestExpires = Infinity;\r\n\r\n    for (const [sessionId, entry] of this.sessions.entries()) {\r\n      if (entry.expires < oldestExpires) {\r\n        oldestExpires = entry.expires;\r\n        oldestId = sessionId;\r\n      }\r\n    }\r\n\r\n    if (oldestId) {\r\n      this.sessions.delete(oldestId);\r\n      logger.debug({ sessionId: oldestId }, 'Evicted oldest session from cache');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evict oldest subscription (LRU-like)\r\n   */\r\n  private evictOldestSubscription(): void {\r\n    let oldestId: string | null = null;\r\n    let oldestExpires = Infinity;\r\n\r\n    for (const [subscriptionId, entry] of this.subscriptions.entries()) {\r\n      if (entry.expires < oldestExpires) {\r\n        oldestExpires = entry.expires;\r\n        oldestId = subscriptionId;\r\n      }\r\n    }\r\n\r\n    if (oldestId) {\r\n      this.subscriptions.delete(oldestId);\r\n      logger.debug({ subscriptionId: oldestId }, 'Evicted oldest subscription from cache');\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet sessionCache: SessionCache | null = null;\r\n\r\n/**\r\n * Get session cache instance\r\n */\r\nexport function getSessionCache(): SessionCache {\r\n  if (!sessionCache) {\r\n    sessionCache = new SessionCache();\r\n  }\r\n\r\n  return sessionCache;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 12442, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/sessions/session-tokens.ts"],"sourcesContent":["// =============================================================================\r\n// SESSION TOKEN GENERATION\r\n// =============================================================================\r\n// JWT-based session tokens for wallet sessions\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { WalletSession } from './wallet-session';\r\n\r\nconst logger = createLogger({ component: 'SessionTokens' });\r\n\r\n/**\r\n * Session Token Payload\r\n */\r\nexport interface SessionTokenPayload {\r\n  sessionId: string;\r\n  walletAddress: string;\r\n  endpointId?: string;\r\n  agentId?: string;\r\n  iat: number; // Issued at\r\n  exp: number; // Expiration\r\n}\r\n\r\n/**\r\n * Session Token Result\r\n */\r\nexport interface SessionTokenResult {\r\n  token: string;\r\n  expiresAt: number;\r\n  sessionId: string;\r\n}\r\n\r\n/**\r\n * Session Token Manager\r\n * \r\n * Generates and validates JWT tokens for wallet sessions.\r\n * Uses a simple secret-based signing (can be upgraded to asymmetric keys).\r\n */\r\nexport class SessionTokenManager {\r\n  private secret: string;\r\n\r\n  constructor(secret?: string) {\r\n    // Use environment variable or generate a default (not secure for production!)\r\n    this.secret = secret || process.env.SESSION_TOKEN_SECRET || 'change-me-in-production';\r\n    \r\n    if (this.secret === 'change-me-in-production') {\r\n      logger.warn('Using default session token secret - set SESSION_TOKEN_SECRET in production!');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a session token from a wallet session\r\n   */\r\n  generateToken(session: WalletSession): SessionTokenResult {\r\n    const now = Math.floor(Date.now() / 1000);\r\n    \r\n    // Token expires when session expires (or 24 hours, whichever is sooner)\r\n    const maxTokenExpiry = now + (24 * 60 * 60); // 24 hours\r\n    const tokenExpiry = Math.min(session.validUntil, maxTokenExpiry);\r\n\r\n    const payload: SessionTokenPayload = {\r\n      sessionId: session.id,\r\n      walletAddress: session.walletAddress,\r\n      endpointId: session.endpointId,\r\n      agentId: session.agentId,\r\n      iat: now,\r\n      exp: tokenExpiry,\r\n    };\r\n\r\n    // Simple base64 encoding for now (can upgrade to proper JWT library)\r\n    // In production, use a proper JWT library like 'jsonwebtoken'\r\n    const token = this.encodeToken(payload);\r\n\r\n    logger.debug(\r\n      {\r\n        sessionId: session.id,\r\n        walletAddress: session.walletAddress,\r\n        expiresAt: tokenExpiry,\r\n      },\r\n      'Session token generated'\r\n    );\r\n\r\n    return {\r\n      token,\r\n      expiresAt: tokenExpiry,\r\n      sessionId: session.id,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate and decode a session token\r\n   */\r\n  validateToken(token: string): {\r\n    valid: boolean;\r\n    payload?: SessionTokenPayload;\r\n    error?: string;\r\n  } {\r\n    try {\r\n      const payload = this.decodeToken(token);\r\n\r\n      if (!payload) {\r\n        return {\r\n          valid: false,\r\n          error: 'Invalid token format',\r\n        };\r\n      }\r\n\r\n      // Check expiration\r\n      const now = Math.floor(Date.now() / 1000);\r\n      if (payload.exp < now) {\r\n        return {\r\n          valid: false,\r\n          error: 'Token expired',\r\n        };\r\n      }\r\n\r\n      return {\r\n        valid: true,\r\n        payload,\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        valid: false,\r\n        error: error instanceof Error ? error.message : 'Token validation failed',\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode token payload (simple base64 + HMAC for now)\r\n   * TODO: Upgrade to proper JWT library (jsonwebtoken) in production\r\n   */\r\n  private encodeToken(payload: SessionTokenPayload): string {\r\n    // Simple encoding: base64(payload) + '.' + HMAC signature\r\n    const payloadJson = JSON.stringify(payload);\r\n    const payloadB64 = Buffer.from(payloadJson).toString('base64url');\r\n    \r\n    // Create HMAC signature\r\n    const crypto = require('crypto');\r\n    const hmac = crypto.createHmac('sha256', this.secret);\r\n    hmac.update(payloadB64);\r\n    const signature = hmac.digest('base64url');\r\n\r\n    return `${payloadB64}.${signature}`;\r\n  }\r\n\r\n  /**\r\n   * Decode and verify token\r\n   */\r\n  private decodeToken(token: string): SessionTokenPayload | null {\r\n    try {\r\n      const parts = token.split('.');\r\n      if (parts.length !== 2) {\r\n        return null;\r\n      }\r\n\r\n      const [payloadB64, signature] = parts;\r\n\r\n      // Verify signature\r\n      const crypto = require('crypto');\r\n      const hmac = crypto.createHmac('sha256', this.secret);\r\n      hmac.update(payloadB64);\r\n      const expectedSignature = hmac.digest('base64url');\r\n\r\n      if (signature !== expectedSignature) {\r\n        logger.warn('Token signature mismatch');\r\n        return null;\r\n      }\r\n\r\n      // Decode payload\r\n      const payloadJson = Buffer.from(payloadB64, 'base64url').toString('utf-8');\r\n      const payload = JSON.parse(payloadJson) as SessionTokenPayload;\r\n\r\n      return payload;\r\n    } catch (error) {\r\n      logger.error({ error }, 'Failed to decode token');\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet tokenManager: SessionTokenManager | null = null;\r\n\r\n/**\r\n * Get session token manager instance\r\n */\r\nexport function getSessionTokenManager(): SessionTokenManager {\r\n  if (!tokenManager) {\r\n    tokenManager = new SessionTokenManager();\r\n  }\r\n\r\n  return tokenManager;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 12581, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/sessions/session-middleware.ts"],"sourcesContent":["// =============================================================================\r\n// SESSION MIDDLEWARE\r\n// =============================================================================\r\n// Middleware for checking and validating sessions in requests\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { getWalletSessionManager } from './wallet-session';\r\nimport { getSessionTokenManager } from './session-tokens';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'SessionMiddleware' });\r\n\r\n/**\r\n * Session Check Result\r\n */\r\nexport interface SessionCheckResult {\r\n  hasSession: boolean;\r\n  sessionId?: string;\r\n  walletAddress?: string;\r\n  valid?: boolean;\r\n  error?: string;\r\n  remainingAmount?: string;\r\n}\r\n\r\n/**\r\n * Check for session token in request\r\n */\r\nexport function checkSessionToken(request: NextRequest): SessionCheckResult {\r\n  // Check for session token in headers\r\n  const sessionToken = \r\n    request.headers.get('x-session-token') || \r\n    request.headers.get('authorization')?.replace('Bearer ', '');\r\n\r\n  if (!sessionToken) {\r\n    return {\r\n      hasSession: false,\r\n    };\r\n  }\r\n\r\n  // Validate token\r\n  const tokenManager = getSessionTokenManager();\r\n  const tokenValidation = tokenManager.validateToken(sessionToken);\r\n\r\n  if (!tokenValidation.valid || !tokenValidation.payload) {\r\n    return {\r\n      hasSession: true,\r\n      valid: false,\r\n      error: tokenValidation.error || 'Invalid session token',\r\n    };\r\n  }\r\n\r\n  const payload = tokenValidation.payload;\r\n\r\n  // Validate session exists and is still valid\r\n  const sessionManager = getWalletSessionManager();\r\n  const sessionValidation = sessionManager.validateSession(payload.sessionId);\r\n\r\n  if (!sessionValidation.valid || !sessionValidation.session) {\r\n    return {\r\n      hasSession: true,\r\n      sessionId: payload.sessionId,\r\n      walletAddress: payload.walletAddress,\r\n      valid: false,\r\n      error: sessionValidation.error || 'Session invalid',\r\n    };\r\n  }\r\n\r\n  return {\r\n    hasSession: true,\r\n    sessionId: payload.sessionId,\r\n    walletAddress: payload.walletAddress,\r\n    valid: true,\r\n    remainingAmount: sessionValidation.remainingAmount,\r\n  };\r\n}\r\n\r\n/**\r\n * Use session for a payment (deduct amount)\r\n */\r\nexport function useSessionForPayment(\r\n  sessionId: string,\r\n  amount: string\r\n): {\r\n  success: boolean;\r\n  remainingAmount?: string;\r\n  error?: string;\r\n} {\r\n  const sessionManager = getWalletSessionManager();\r\n  const result = sessionManager.useSession(sessionId, amount);\r\n\r\n  if (!result.valid) {\r\n    return {\r\n      success: false,\r\n      error: result.error,\r\n      remainingAmount: result.remainingAmount,\r\n    };\r\n  }\r\n\r\n  return {\r\n    success: true,\r\n    remainingAmount: result.remainingAmount,\r\n  };\r\n}\r\n\r\n/**\r\n * Create session from payment header\r\n * \r\n * This should be called after a payment is verified.\r\n * Creates a reusable session that can be used for subsequent requests.\r\n */\r\nexport async function createSessionFromPayment(\r\n  paymentHeader: string,\r\n  endpointId: string,\r\n  agentId?: string\r\n): Promise<{\r\n  success: boolean;\r\n  sessionId?: string;\r\n  token?: string;\r\n  expiresAt?: number;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Parse and verify payment\r\n    const { parseAndVerifyPaymentHeader } = await import('../payment-header-parser');\r\n    const parsed = await parseAndVerifyPaymentHeader(paymentHeader);\r\n\r\n    if (!parsed.valid || !parsed.payment) {\r\n      return {\r\n        success: false,\r\n        error: parsed.error || 'Invalid payment header',\r\n      };\r\n    }\r\n\r\n    const payment = parsed.payment;\r\n\r\n    // Create session\r\n    const sessionManager = getWalletSessionManager();\r\n    const session = sessionManager.createSession({\r\n      walletAddress: payment.authorization.from,\r\n      authorizedAmount: payment.authorization.value,\r\n      validUntil: parseInt(payment.authorization.validBefore),\r\n      validFrom: parseInt(payment.authorization.validAfter || Math.floor(Date.now() / 1000).toString()),\r\n      network: payment.network,\r\n      asset: payment.authorization.to, // This should be the token address, may need adjustment\r\n      nonce: payment.authorization.nonce,\r\n      signature: payment.signature,\r\n      authorization: payment.authorization,\r\n      endpointId,\r\n      agentId,\r\n      reusable: true,\r\n    });\r\n\r\n    // Generate token\r\n    const tokenManager = getSessionTokenManager();\r\n    const tokenResult = tokenManager.generateToken(session);\r\n\r\n    logger.info(\r\n      {\r\n        sessionId: session.id,\r\n        walletAddress: session.walletAddress,\r\n        endpointId,\r\n      },\r\n      'Session created from payment'\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      sessionId: session.id,\r\n      token: tokenResult.token,\r\n      expiresAt: tokenResult.expiresAt,\r\n    };\r\n  } catch (error) {\r\n    logger.error({ error }, 'Failed to create session from payment');\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 12712, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/sessions/index.ts"],"sourcesContent":["// =============================================================================\r\n// SESSIONS MODULE EXPORTS\r\n// =============================================================================\r\n\r\nexport {\r\n  getWalletSessionManager,\r\n  type WalletSession,\r\n  type SessionOptions,\r\n  type SessionValidationResult,\r\n} from './wallet-session';\r\n\r\nexport {\r\n  getSubscriptionManager,\r\n  type SubscriptionPlan,\r\n  type ActiveSubscription,\r\n} from './subscription-manager';\r\n\r\nexport {\r\n  getSessionCache,\r\n  type CacheConfig,\r\n} from './session-cache';\r\n\r\nexport {\r\n  getSessionTokenManager,\r\n  type SessionTokenPayload,\r\n  type SessionTokenResult,\r\n} from './session-tokens';\r\n\r\nexport {\r\n  checkSessionToken,\r\n  useSessionForPayment,\r\n  createSessionFromPayment,\r\n  type SessionCheckResult,\r\n} from './session-middleware';\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;AAC1B,gFAAgF;;AAEhF;AAOA;AAMA;AAKA;AAMA"}},
    {"offset": {"line": 12730, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/caip-utils.ts"],"sourcesContent":["// =============================================================================\r\n// CAIP (Chain Agnostic Improvement Proposals) Utilities\r\n// =============================================================================\r\n// Utilities for parsing, formatting, and validating CAIP identifiers\r\n// CAIP-2: Blockchain ID Specification\r\n// CAIP-19: Asset ID Specification\r\n\r\n/**\r\n * CAIP-2 Network Identifier\r\n * Format: <namespace>:<reference>\r\n * Examples:\r\n * - eip155:1 (Ethereum Mainnet)\r\n * - eip155:8453 (Base)\r\n * - eip155:56 (BNB Chain)\r\n * - eip155:137 (Polygon)\r\n * - solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp (Solana Mainnet)\r\n */\r\nexport type CAIPNetworkId = string;\r\n\r\n/**\r\n * CAIP-19 Asset Identifier\r\n * Format: <namespace>:<reference>/<asset_namespace>:<asset_reference>\r\n * Examples:\r\n * - eip155:1/erc20:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 (USDC on Ethereum)\r\n * - eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913 (USDC on Base)\r\n * - eip155:1/slip44:60 (ETH on Ethereum)\r\n */\r\nexport type CAIPAssetId = string;\r\n\r\n/**\r\n * Parsed CAIP-2 Network Identifier\r\n */\r\nexport interface ParsedCAIPNetwork {\r\n  namespace: string; // e.g., 'eip155', 'solana'\r\n  reference: string; // e.g., '8453', '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp'\r\n  chainId?: number; // For EVM chains, the numeric chain ID\r\n}\r\n\r\n/**\r\n * Parsed CAIP-19 Asset Identifier\r\n */\r\nexport interface ParsedCAIPAsset {\r\n  network: ParsedCAIPNetwork;\r\n  assetNamespace: string; // e.g., 'erc20', 'slip44'\r\n  assetReference: string; // e.g., '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', '60'\r\n  address?: string; // For ERC20 tokens, the contract address\r\n}\r\n\r\n/**\r\n * Parse a CAIP-2 network identifier\r\n */\r\nexport function parseCAIPNetwork(caip: CAIPNetworkId): ParsedCAIPNetwork | null {\r\n  try {\r\n    const [namespace, reference] = caip.split(':');\r\n    if (!namespace || !reference) {\r\n      return null;\r\n    }\r\n\r\n    // For EVM chains (eip155), reference is the chain ID\r\n    let chainId: number | undefined;\r\n    if (namespace === 'eip155') {\r\n      chainId = parseInt(reference, 10);\r\n      if (isNaN(chainId)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return {\r\n      namespace,\r\n      reference,\r\n      chainId,\r\n    };\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Format a CAIP-2 network identifier\r\n */\r\nexport function formatCAIPNetwork(namespace: string, reference: string | number): CAIPNetworkId {\r\n  return `${namespace}:${reference}`;\r\n}\r\n\r\n/**\r\n * Parse a CAIP-19 asset identifier\r\n */\r\nexport function parseCAIPAsset(caip: CAIPAssetId): ParsedCAIPAsset | null {\r\n  try {\r\n    const parts = caip.split('/');\r\n    if (parts.length !== 2) {\r\n      return null;\r\n    }\r\n\r\n    const networkPart = parts[0];\r\n    const assetPart = parts[1];\r\n\r\n    const network = parseCAIPNetwork(networkPart);\r\n    if (!network) {\r\n      return null;\r\n    }\r\n\r\n    const [assetNamespace, assetReference] = assetPart.split(':');\r\n    if (!assetNamespace || !assetReference) {\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      network,\r\n      assetNamespace,\r\n      assetReference,\r\n      address: assetNamespace === 'erc20' ? assetReference : undefined,\r\n    };\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Format a CAIP-19 asset identifier\r\n */\r\nexport function formatCAIPAsset(\r\n  network: CAIPNetworkId,\r\n  assetNamespace: string,\r\n  assetReference: string\r\n): CAIPAssetId {\r\n  return `${network}/${assetNamespace}:${assetReference}`;\r\n}\r\n\r\n/**\r\n * Convert legacy network name to CAIP-2\r\n */\r\nexport function networkToCAIP(network: string): CAIPNetworkId | null {\r\n  const networkMap: Record<string, CAIPNetworkId> = {\r\n    ethereum: 'eip155:1',\r\n    mainnet: 'eip155:1',\r\n    base: 'eip155:8453',\r\n    'base-mainnet': 'eip155:8453',\r\n    bnb: 'eip155:56',\r\n    'bnb-chain': 'eip155:56',\r\n    'bsc': 'eip155:56',\r\n    polygon: 'eip155:137',\r\n    'polygon-mainnet': 'eip155:137',\r\n    arbitrum: 'eip155:42161',\r\n    'arbitrum-one': 'eip155:42161',\r\n    optimism: 'eip155:10',\r\n    'optimism-mainnet': 'eip155:10',\r\n    avalanche: 'eip155:43114',\r\n    'avalanche-mainnet': 'eip155:43114',\r\n    solana: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',\r\n    'solana-mainnet': 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',\r\n    // Cronos networks - see https://docs.cronos.org/cronos-x402-facilitator\r\n    cronos: 'eip155:25',\r\n    'cronos-mainnet': 'eip155:25',\r\n    'cronos-testnet': 'eip155:338',\r\n  };\r\n\r\n  const normalized = network.toLowerCase().replace(/_/g, '-');\r\n  return networkMap[normalized] || null;\r\n}\r\n\r\n/**\r\n * Convert CAIP-2 to legacy network name\r\n */\r\nexport function caipToNetwork(caip: CAIPNetworkId): string | null {\r\n  const parsed = parseCAIPNetwork(caip);\r\n  if (!parsed) {\r\n    return null;\r\n  }\r\n\r\n  if (parsed.namespace === 'eip155') {\r\n    const chainIdMap: Record<number, string> = {\r\n      1: 'ethereum',\r\n      8453: 'base',\r\n      56: 'bnb',\r\n      137: 'polygon',\r\n      42161: 'arbitrum',\r\n      10: 'optimism',\r\n      43114: 'avalanche',\r\n      // Cronos networks - see https://docs.cronos.org/cronos-x402-facilitator\r\n      25: 'cronos',\r\n      338: 'cronos-testnet',\r\n    };\r\n    return chainIdMap[parsed.chainId!] || null;\r\n  }\r\n\r\n  if (parsed.namespace === 'solana') {\r\n    return 'solana';\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Get chain ID from CAIP-2 network identifier (EVM only)\r\n */\r\nexport function getChainId(caip: CAIPNetworkId): number | null {\r\n  const parsed = parseCAIPNetwork(caip);\r\n  if (parsed?.namespace === 'eip155' && parsed.chainId) {\r\n    return parsed.chainId;\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Check if CAIP network is EVM-compatible\r\n */\r\nexport function isEVMNetwork(caip: CAIPNetworkId): boolean {\r\n  const parsed = parseCAIPNetwork(caip);\r\n  return parsed?.namespace === 'eip155' || false;\r\n}\r\n\r\n/**\r\n * Check if CAIP network is Solana\r\n */\r\nexport function isSolanaNetwork(caip: CAIPNetworkId): boolean {\r\n  const parsed = parseCAIPNetwork(caip);\r\n  return parsed?.namespace === 'solana' || false;\r\n}\r\n\r\n/**\r\n * Validate CAIP-2 network identifier format\r\n */\r\nexport function validateCAIPNetwork(caip: CAIPNetworkId): boolean {\r\n  return parseCAIPNetwork(caip) !== null;\r\n}\r\n\r\n/**\r\n * Validate CAIP-19 asset identifier format\r\n */\r\nexport function validateCAIPAsset(caip: CAIPAssetId): boolean {\r\n  return parseCAIPAsset(caip) !== null;\r\n}\r\n\r\n/**\r\n * Get token address from CAIP-19 asset identifier (ERC20 only)\r\n */\r\nexport function getTokenAddress(caip: CAIPAssetId): string | null {\r\n  const parsed = parseCAIPAsset(caip);\r\n  if (parsed?.assetNamespace === 'erc20') {\r\n    return parsed.address || null;\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Convert legacy network + token address to CAIP-19\r\n */\r\nexport function tokenToCAIP(network: string, tokenAddress: string): CAIPAssetId | null {\r\n  const networkCAIP = networkToCAIP(network);\r\n  if (!networkCAIP) {\r\n    return null;\r\n  }\r\n  return formatCAIPAsset(networkCAIP, 'erc20', tokenAddress);\r\n}\r\n\r\n/**\r\n * Common CAIP network identifiers\r\n */\r\nexport const CAIP_NETWORKS = {\r\n  ETHEREUM: 'eip155:1',\r\n  BASE: 'eip155:8453',\r\n  BNB_CHAIN: 'eip155:56',\r\n  POLYGON: 'eip155:137',\r\n  ARBITRUM: 'eip155:42161',\r\n  OPTIMISM: 'eip155:10',\r\n  AVALANCHE: 'eip155:43114',\r\n  SOLANA: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',\r\n  // Cronos networks - see https://docs.cronos.org/cronos-x402-facilitator\r\n  CRONOS: 'eip155:25',           // Cronos mainnet (chain ID 25)\r\n  CRONOS_TESTNET: 'eip155:338',  // Cronos testnet (chain ID 338)\r\n} as const;\r\n\r\n/**\r\n * Common CAIP asset identifiers (USDC on various chains)\r\n */\r\nexport const CAIP_ASSETS = {\r\n  USDC_ETHEREUM: 'eip155:1/erc20:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\r\n  USDC_BASE: 'eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n  USDC_POLYGON: 'eip155:137/erc20:0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\r\n  USDC_ARBITRUM: 'eip155:42161/erc20:0xaf88d065e77c8cC2239327C5EDb3A432268e5831',\r\n  USDC_OPTIMISM: 'eip155:10/erc20:0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85',\r\n  ETH_ETHEREUM: 'eip155:1/slip44:60',\r\n} as const;\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 12944, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/chain-registry.ts"],"sourcesContent":["// =============================================================================\r\n// CHAIN REGISTRY\r\n// =============================================================================\r\n// Registry of supported blockchain networks with metadata\r\n\r\nimport { CAIP_NETWORKS, type CAIPNetworkId } from './caip-utils';\r\n\r\n/**\r\n * Network metadata\r\n */\r\nexport interface NetworkMetadata {\r\n  caip: CAIPNetworkId;\r\n  name: string;\r\n  displayName: string;\r\n  chainId: number | null; // For EVM chains\r\n  nativeCurrency: {\r\n    name: string;\r\n    symbol: string;\r\n    decimals: number;\r\n  };\r\n  rpcUrls?: string[];\r\n  blockExplorers?: {\r\n    name: string;\r\n    url: string;\r\n  }[];\r\n  isTestnet: boolean;\r\n  isEVM: boolean;\r\n  isSolana: boolean;\r\n  supportsEIP1559?: boolean; // For EVM chains\r\n  averageGasPrice?: string; // In wei/gwei\r\n  averageBlockTime?: number; // In seconds\r\n}\r\n\r\n/**\r\n * Chain Registry\r\n * \r\n * Central registry of all supported blockchain networks\r\n */\r\nexport class ChainRegistry {\r\n  private networks: Map<CAIPNetworkId, NetworkMetadata> = new Map();\r\n\r\n  constructor() {\r\n    this.registerDefaultNetworks();\r\n  }\r\n\r\n  /**\r\n   * Register a network\r\n   */\r\n  register(network: NetworkMetadata): void {\r\n    this.networks.set(network.caip, network);\r\n  }\r\n\r\n  /**\r\n   * Get network metadata by CAIP identifier\r\n   */\r\n  get(caip: CAIPNetworkId): NetworkMetadata | undefined {\r\n    return this.networks.get(caip);\r\n  }\r\n\r\n  /**\r\n   * Get network by legacy name\r\n   */\r\n  getByLegacyName(name: string): NetworkMetadata | undefined {\r\n    for (const network of this.networks.values()) {\r\n      if (network.name.toLowerCase() === name.toLowerCase()) {\r\n        return network;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Get all registered networks\r\n   */\r\n  getAll(): NetworkMetadata[] {\r\n    return Array.from(this.networks.values());\r\n  }\r\n\r\n  /**\r\n   * Get all EVM networks\r\n   */\r\n  getEVMs(): NetworkMetadata[] {\r\n    return Array.from(this.networks.values()).filter((n) => n.isEVM);\r\n  }\r\n\r\n  /**\r\n   * Get all Solana networks\r\n   */\r\n  getSolanas(): NetworkMetadata[] {\r\n    return Array.from(this.networks.values()).filter((n) => n.isSolana);\r\n  }\r\n\r\n  /**\r\n   * Check if network is registered\r\n   */\r\n  has(caip: CAIPNetworkId): boolean {\r\n    return this.networks.has(caip);\r\n  }\r\n\r\n  /**\r\n   * Register default networks\r\n   */\r\n  private registerDefaultNetworks(): void {\r\n    // Ethereum Mainnet\r\n    this.register({\r\n      caip: CAIP_NETWORKS.ETHEREUM,\r\n      name: 'ethereum',\r\n      displayName: 'Ethereum',\r\n      chainId: 1,\r\n      nativeCurrency: {\r\n        name: 'Ether',\r\n        symbol: 'ETH',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://eth.llamarpc.com'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Etherscan',\r\n          url: 'https://etherscan.io',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '30000000000', // 30 gwei\r\n      averageBlockTime: 12,\r\n    });\r\n\r\n    // Base\r\n    this.register({\r\n      caip: CAIP_NETWORKS.BASE,\r\n      name: 'base',\r\n      displayName: 'Base',\r\n      chainId: 8453,\r\n      nativeCurrency: {\r\n        name: 'Ether',\r\n        symbol: 'ETH',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://mainnet.base.org'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'BaseScan',\r\n          url: 'https://basescan.org',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '1000000', // 0.001 gwei (very cheap)\r\n      averageBlockTime: 2,\r\n    });\r\n\r\n    // BNB Chain\r\n    this.register({\r\n      caip: CAIP_NETWORKS.BNB_CHAIN,\r\n      name: 'bnb',\r\n      displayName: 'BNB Chain',\r\n      chainId: 56,\r\n      nativeCurrency: {\r\n        name: 'BNB',\r\n        symbol: 'BNB',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://bsc-dataseed.binance.org'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'BscScan',\r\n          url: 'https://bscscan.com',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: false,\r\n      averageGasPrice: '3000000000', // 3 gwei\r\n      averageBlockTime: 3,\r\n    });\r\n\r\n    // Polygon\r\n    this.register({\r\n      caip: CAIP_NETWORKS.POLYGON,\r\n      name: 'polygon',\r\n      displayName: 'Polygon',\r\n      chainId: 137,\r\n      nativeCurrency: {\r\n        name: 'MATIC',\r\n        symbol: 'MATIC',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://polygon-rpc.com'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'PolygonScan',\r\n          url: 'https://polygonscan.com',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '30000000000', // 30 gwei\r\n      averageBlockTime: 2,\r\n    });\r\n\r\n    // Arbitrum One\r\n    this.register({\r\n      caip: CAIP_NETWORKS.ARBITRUM,\r\n      name: 'arbitrum',\r\n      displayName: 'Arbitrum One',\r\n      chainId: 42161,\r\n      nativeCurrency: {\r\n        name: 'Ether',\r\n        symbol: 'ETH',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://arb1.arbitrum.io/rpc'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Arbiscan',\r\n          url: 'https://arbiscan.io',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '100000000', // 0.1 gwei\r\n      averageBlockTime: 0.25,\r\n    });\r\n\r\n    // Optimism\r\n    this.register({\r\n      caip: CAIP_NETWORKS.OPTIMISM,\r\n      name: 'optimism',\r\n      displayName: 'Optimism',\r\n      chainId: 10,\r\n      nativeCurrency: {\r\n        name: 'Ether',\r\n        symbol: 'ETH',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://mainnet.optimism.io'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Optimistic Etherscan',\r\n          url: 'https://optimistic.etherscan.io',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '1000000', // 0.001 gwei\r\n      averageBlockTime: 2,\r\n    });\r\n\r\n    // Avalanche\r\n    this.register({\r\n      caip: CAIP_NETWORKS.AVALANCHE,\r\n      name: 'avalanche',\r\n      displayName: 'Avalanche',\r\n      chainId: 43114,\r\n      nativeCurrency: {\r\n        name: 'AVAX',\r\n        symbol: 'AVAX',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://api.avax.network/ext/bc/C/rpc'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Snowtrace',\r\n          url: 'https://snowtrace.io',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '25000000000', // 25 nAVAX\r\n      averageBlockTime: 2,\r\n    });\r\n\r\n    // Solana Mainnet (placeholder - full support when SDK available)\r\n    this.register({\r\n      caip: CAIP_NETWORKS.SOLANA,\r\n      name: 'solana',\r\n      displayName: 'Solana',\r\n      chainId: null,\r\n      nativeCurrency: {\r\n        name: 'SOL',\r\n        symbol: 'SOL',\r\n        decimals: 9,\r\n      },\r\n      rpcUrls: ['https://api.mainnet-beta.solana.com'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Solana Explorer',\r\n          url: 'https://explorer.solana.com',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: false,\r\n      isSolana: true,\r\n      averageBlockTime: 0.4,\r\n    });\r\n\r\n    // Cronos Mainnet\r\n    // Cronos x402 facilitator: https://docs.cronos.org/cronos-x402-facilitator\r\n    this.register({\r\n      caip: CAIP_NETWORKS.CRONOS,\r\n      name: 'cronos',\r\n      displayName: 'Cronos',\r\n      chainId: 25,\r\n      nativeCurrency: {\r\n        name: 'CRO',\r\n        symbol: 'CRO',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://evm.cronos.org'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Cronoscan',\r\n          url: 'https://cronoscan.com',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '5000000000000', // 5000 gwei\r\n      averageBlockTime: 6,\r\n    });\r\n\r\n    // Cronos Testnet\r\n    this.register({\r\n      caip: CAIP_NETWORKS.CRONOS_TESTNET,\r\n      name: 'cronos-testnet',\r\n      displayName: 'Cronos Testnet',\r\n      chainId: 338,\r\n      nativeCurrency: {\r\n        name: 'Test CRO',\r\n        symbol: 'TCRO',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://evm-t3.cronos.org'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Cronos Testnet Explorer',\r\n          url: 'https://testnet.cronoscan.com',\r\n        },\r\n      ],\r\n      isTestnet: true,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '5000000000000', // 5000 gwei\r\n      averageBlockTime: 6,\r\n    });\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet chainRegistry: ChainRegistry | null = null;\r\n\r\n/**\r\n * Get chain registry instance\r\n */\r\nexport function getChainRegistry(): ChainRegistry {\r\n  if (!chainRegistry) {\r\n    chainRegistry = new ChainRegistry();\r\n  }\r\n  return chainRegistry;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 13287, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/chain-detection.ts"],"sourcesContent":["// =============================================================================\n// CHAIN DETECTION AND VALIDATION\n// =============================================================================\n// Utilities for detecting and validating blockchain networks\n\nimport { getChainRegistry } from './chain-registry';\nimport {\n  parseCAIPNetwork,\n  parseCAIPAsset,\n  networkToCAIP,\n  validateCAIPNetwork,\n  validateCAIPAsset,\n  isEVMNetwork,\n  type CAIPNetworkId,\n  type CAIPAssetId,\n} from './caip-utils';\n\n/**\n * Chain detection result\n */\nexport interface ChainDetectionResult {\n  detected: boolean;\n  network?: CAIPNetworkId;\n  legacyName?: string;\n  chainId?: number;\n  isEVM?: boolean;\n  isSolana?: boolean;\n  error?: string;\n}\n\n/**\n * Detect chain from various input formats\n */\nexport function detectChain(input: string | number): ChainDetectionResult {\n  const chainRegistry = getChainRegistry();\n\n  // Try as CAIP identifier first\n  if (typeof input === 'string' && input.includes(':')) {\n    if (validateCAIPNetwork(input)) {\n      const parsed = parseCAIPNetwork(input);\n      const network = chainRegistry.get(input);\n      return {\n        detected: true,\n        network: input,\n        legacyName: network?.name,\n        chainId: parsed?.chainId || undefined,\n        isEVM: parsed?.namespace === 'eip155',\n        isSolana: parsed?.namespace === 'solana',\n      };\n    }\n  }\n\n  // Try as legacy network name\n  if (typeof input === 'string') {\n    const caip = networkToCAIP(input);\n    if (caip) {\n      const parsed = parseCAIPNetwork(caip);\n      const network = chainRegistry.get(caip);\n      return {\n        detected: true,\n        network: caip,\n        legacyName: input.toLowerCase(),\n        chainId: parsed?.chainId || undefined,\n        isEVM: parsed?.namespace === 'eip155',\n        isSolana: parsed?.namespace === 'solana',\n      };\n    }\n  }\n\n  // Try as chain ID (EVM only)\n  if (typeof input === 'number') {\n    const network = chainRegistry.getAll().find((n) => n.chainId === input);\n    if (network) {\n      return {\n        detected: true,\n        network: network.caip,\n        legacyName: network.name,\n        chainId: input,\n        isEVM: network.isEVM,\n        isSolana: network.isSolana,\n      };\n    }\n  }\n\n  return {\n    detected: false,\n    error: `Could not detect chain from input: ${input}`,\n  };\n}\n\n/**\n * Validate chain is supported\n */\nexport function validateChain(caip: CAIPNetworkId): {\n  valid: boolean;\n  supported: boolean;\n  network?: ReturnType<typeof getChainRegistry>['get'];\n  error?: string;\n} {\n  if (!validateCAIPNetwork(caip)) {\n    return {\n      valid: false,\n      supported: false,\n      error: 'Invalid CAIP-2 network identifier format',\n    };\n  }\n\n  const chainRegistry = getChainRegistry();\n  const network = chainRegistry.get(caip);\n\n  if (!network) {\n    return {\n      valid: true,\n      supported: false,\n      error: 'Network not supported',\n    };\n  }\n\n  return {\n    valid: true,\n    supported: true,\n    network,\n  };\n}\n\n/**\n * Validate asset is supported on a network\n */\nexport function validateAssetOnNetwork(\n  asset: CAIPAssetId,\n  network: CAIPNetworkId\n): {\n  valid: boolean;\n  supported: boolean;\n  error?: string;\n} {\n  if (!validateCAIPAsset(asset)) {\n    return {\n      valid: false,\n      supported: false,\n      error: 'Invalid CAIP-19 asset identifier format',\n    };\n  }\n\n  const parsed = parseCAIPAsset(asset);\n  if (!parsed) {\n    return {\n      valid: false,\n      supported: false,\n      error: 'Could not parse CAIP-19 asset identifier',\n    };\n  }\n\n  // Check if asset network matches requested network\n  // parsed.network is a ParsedCAIPNetwork object, need to reconstruct CAIP\n  const assetNetworkCAIP = `${parsed.network.namespace}:${parsed.network.reference}`;\n  if (assetNetworkCAIP !== network) {\n    return {\n      valid: true,\n      supported: false,\n      error: `Asset network ${assetNetworkCAIP} does not match requested network ${network}`,\n    };\n  }\n\n  return {\n    valid: true,\n    supported: true,\n  };\n}\n\n/**\n * Get compatible networks for an asset\n */\nexport function getCompatibleNetworks(asset: CAIPAssetId): CAIPNetworkId[] {\n  const parsed = parseCAIPAsset(asset);\n  if (!parsed) {\n    return [];\n  }\n\n  const chainRegistry = getChainRegistry();\n  const compatible: CAIPNetworkId[] = [];\n\n  // For ERC20 tokens, find all EVM networks that might support this token\n  if (parsed.assetNamespace === 'erc20') {\n    const evmNetworks = chainRegistry.getEVMs();\n    for (const network of evmNetworks) {\n      // In a real implementation, you'd check if the token contract exists on that network\n      // For now, we'll return all EVM networks as potentially compatible\n      compatible.push(network.caip);\n    }\n  }\n\n  return compatible;\n}\n\n/**\n * Normalize chain identifier to CAIP format\n */\nexport function normalizeToCAIP(input: string | number): CAIPNetworkId | null {\n  const detection = detectChain(input);\n  return detection.detected ? detection.network || null : null;\n}\n\n/**\n * Check if two networks are compatible (same chain family)\n */\nexport function areNetworksCompatible(\n  network1: CAIPNetworkId,\n  network2: CAIPNetworkId\n): boolean {\n  const parsed1 = parseCAIPNetwork(network1);\n  const parsed2 = parseCAIPNetwork(network2);\n\n  if (!parsed1 || !parsed2) {\n    return false;\n  }\n\n  // Same namespace means compatible (e.g., both EVM, both Solana)\n  return parsed1.namespace === parsed2.namespace;\n}\n\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,iCAAiC;AACjC,gFAAgF;AAChF,6DAA6D;;;;;;;;;;;;;;;AAE7D;AACA;;;AA2BO,SAAS,YAAY,KAAsB;IAChD,MAAM,gBAAgB,IAAA,sKAAgB;IAEtC,+BAA+B;IAC/B,IAAI,OAAO,UAAU,YAAY,MAAM,QAAQ,CAAC,MAAM;QACpD,IAAI,IAAA,qKAAmB,EAAC,QAAQ;YAC9B,MAAM,SAAS,IAAA,kKAAgB,EAAC;YAChC,MAAM,UAAU,cAAc,GAAG,CAAC;YAClC,OAAO;gBACL,UAAU;gBACV,SAAS;gBACT,YAAY,SAAS;gBACrB,SAAS,QAAQ,WAAW;gBAC5B,OAAO,QAAQ,cAAc;gBAC7B,UAAU,QAAQ,cAAc;YAClC;QACF;IACF;IAEA,6BAA6B;IAC7B,IAAI,OAAO,UAAU,UAAU;QAC7B,MAAM,OAAO,IAAA,+JAAa,EAAC;QAC3B,IAAI,MAAM;YACR,MAAM,SAAS,IAAA,kKAAgB,EAAC;YAChC,MAAM,UAAU,cAAc,GAAG,CAAC;YAClC,OAAO;gBACL,UAAU;gBACV,SAAS;gBACT,YAAY,MAAM,WAAW;gBAC7B,SAAS,QAAQ,WAAW;gBAC5B,OAAO,QAAQ,cAAc;gBAC7B,UAAU,QAAQ,cAAc;YAClC;QACF;IACF;IAEA,6BAA6B;IAC7B,IAAI,OAAO,UAAU,UAAU;QAC7B,MAAM,UAAU,cAAc,MAAM,GAAG,IAAI,CAAC,CAAC,IAAM,EAAE,OAAO,KAAK;QACjE,IAAI,SAAS;YACX,OAAO;gBACL,UAAU;gBACV,SAAS,QAAQ,IAAI;gBACrB,YAAY,QAAQ,IAAI;gBACxB,SAAS;gBACT,OAAO,QAAQ,KAAK;gBACpB,UAAU,QAAQ,QAAQ;YAC5B;QACF;IACF;IAEA,OAAO;QACL,UAAU;QACV,OAAO,CAAC,mCAAmC,EAAE,OAAO;IACtD;AACF;AAKO,SAAS,cAAc,IAAmB;IAM/C,IAAI,CAAC,IAAA,qKAAmB,EAAC,OAAO;QAC9B,OAAO;YACL,OAAO;YACP,WAAW;YACX,OAAO;QACT;IACF;IAEA,MAAM,gBAAgB,IAAA,sKAAgB;IACtC,MAAM,UAAU,cAAc,GAAG,CAAC;IAElC,IAAI,CAAC,SAAS;QACZ,OAAO;YACL,OAAO;YACP,WAAW;YACX,OAAO;QACT;IACF;IAEA,OAAO;QACL,OAAO;QACP,WAAW;QACX;IACF;AACF;AAKO,SAAS,uBACd,KAAkB,EAClB,OAAsB;IAMtB,IAAI,CAAC,IAAA,mKAAiB,EAAC,QAAQ;QAC7B,OAAO;YACL,OAAO;YACP,WAAW;YACX,OAAO;QACT;IACF;IAEA,MAAM,SAAS,IAAA,gKAAc,EAAC;IAC9B,IAAI,CAAC,QAAQ;QACX,OAAO;YACL,OAAO;YACP,WAAW;YACX,OAAO;QACT;IACF;IAEA,mDAAmD;IACnD,yEAAyE;IACzE,MAAM,mBAAmB,GAAG,OAAO,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,OAAO,OAAO,CAAC,SAAS,EAAE;IAClF,IAAI,qBAAqB,SAAS;QAChC,OAAO;YACL,OAAO;YACP,WAAW;YACX,OAAO,CAAC,cAAc,EAAE,iBAAiB,kCAAkC,EAAE,SAAS;QACxF;IACF;IAEA,OAAO;QACL,OAAO;QACP,WAAW;IACb;AACF;AAKO,SAAS,sBAAsB,KAAkB;IACtD,MAAM,SAAS,IAAA,gKAAc,EAAC;IAC9B,IAAI,CAAC,QAAQ;QACX,OAAO,EAAE;IACX;IAEA,MAAM,gBAAgB,IAAA,sKAAgB;IACtC,MAAM,aAA8B,EAAE;IAEtC,wEAAwE;IACxE,IAAI,OAAO,cAAc,KAAK,SAAS;QACrC,MAAM,cAAc,cAAc,OAAO;QACzC,KAAK,MAAM,WAAW,YAAa;YACjC,qFAAqF;YACrF,mEAAmE;YACnE,WAAW,IAAI,CAAC,QAAQ,IAAI;QAC9B;IACF;IAEA,OAAO;AACT;AAKO,SAAS,gBAAgB,KAAsB;IACpD,MAAM,YAAY,YAAY;IAC9B,OAAO,UAAU,QAAQ,GAAG,UAAU,OAAO,IAAI,OAAO;AAC1D;AAKO,SAAS,sBACd,QAAuB,EACvB,QAAuB;IAEvB,MAAM,UAAU,IAAA,kKAAgB,EAAC;IACjC,MAAM,UAAU,IAAA,kKAAgB,EAAC;IAEjC,IAAI,CAAC,WAAW,CAAC,SAAS;QACxB,OAAO;IACT;IAEA,gEAAgE;IAChE,OAAO,QAAQ,SAAS,KAAK,QAAQ,SAAS;AAChD"}},
    {"offset": {"line": 13450, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/test-verification.ts"],"sourcesContent":["// =============================================================================\r\n// TEST-ONLY X402 VERIFICATION\r\n// =============================================================================\r\n// Fake x402 verification helper for safe testing without real funds\r\n// DO NOT USE IN PRODUCTION - This bypasses all real payment verification\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'TestX402Verification' });\r\n\r\n/**\r\n * Test-only verification result\r\n */\r\nexport interface TestVerificationResult {\r\n  success: boolean;\r\n  x402TxHash?: string;\r\n  facilitator?: string;\r\n  errorCode?: string;\r\n}\r\n\r\n/**\r\n * Test token header name\r\n */\r\nexport const TEST_TOKEN_HEADER = 'x-easepay-test-token';\r\n\r\n/**\r\n * Test token value that enables fake verification\r\n */\r\nexport const TEST_TOKEN_VALUE = 'demo-ok';\r\n\r\n/**\r\n * Verify payment in test mode only\r\n * \r\n * Checks for test header or config flag and returns fake success\r\n * DO NOT call real CDP/x402 verify in this path\r\n * \r\n * @param request - Next.js request object\r\n * @returns Test verification result\r\n */\r\nexport function verifyPaymentTestOnly(request: NextRequest): TestVerificationResult {\r\n  // Check for test token header\r\n  const testToken = request.headers.get(TEST_TOKEN_HEADER) || \r\n                    request.headers.get(TEST_TOKEN_HEADER.toUpperCase());\r\n  \r\n  // Check for config flag (environment variable)\r\n  const testModeEnabled = process.env.X402_TEST_MODE === 'true' || \r\n                         process.env.EASEPAY_TEST_MODE === 'true';\r\n  \r\n  if (testToken === TEST_TOKEN_VALUE || testModeEnabled) {\r\n    logger.info('Test payment verification passed', {\r\n      testToken: testToken === TEST_TOKEN_VALUE ? 'present' : 'missing',\r\n      testModeEnabled,\r\n    });\r\n    \r\n    return {\r\n      success: true,\r\n      x402TxHash: 'TEST_TX_HASH',\r\n      facilitator: 'TEST_FACILITATOR',\r\n    };\r\n  }\r\n  \r\n  // No test token or flag - payment required\r\n  logger.info('Test payment verification failed - no test token', {\r\n    testToken: testToken || 'missing',\r\n    testModeEnabled,\r\n  });\r\n  \r\n  return {\r\n    success: false,\r\n    errorCode: 'PAYMENT_REQUIRED',\r\n  };\r\n}\r\n\r\n/**\r\n * Check if test mode is enabled\r\n */\r\nexport function isTestModeEnabled(): boolean {\r\n  return process.env.X402_TEST_MODE === 'true' || \r\n         process.env.EASEPAY_TEST_MODE === 'true';\r\n}\r\n\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,8BAA8B;AAC9B,gFAAgF;AAChF,oEAAoE;AACpE,yEAAyE;;;;;;;;;;;AAGzE;;AAEA,MAAM,SAAS,IAAA,sIAAY,EAAC;IAAE,WAAW;AAAuB;AAezD,MAAM,oBAAoB;AAK1B,MAAM,mBAAmB;AAWzB,SAAS,sBAAsB,OAAoB;IACxD,8BAA8B;IAC9B,MAAM,YAAY,QAAQ,OAAO,CAAC,GAAG,CAAC,sBACpB,QAAQ,OAAO,CAAC,GAAG,CAAC,kBAAkB,WAAW;IAEnE,+CAA+C;IAC/C,MAAM,kBAAkB,QAAQ,GAAG,CAAC,cAAc,KAAK,UAChC,QAAQ,GAAG,CAAC,iBAAiB,KAAK;IAEzD,IAAI,cAAc,oBAAoB,iBAAiB;QACrD,OAAO,IAAI,CAAC,oCAAoC;YAC9C,WAAW,cAAc,mBAAmB,YAAY;YACxD;QACF;QAEA,OAAO;YACL,SAAS;YACT,YAAY;YACZ,aAAa;QACf;IACF;IAEA,2CAA2C;IAC3C,OAAO,IAAI,CAAC,oDAAoD;QAC9D,WAAW,aAAa;QACxB;IACF;IAEA,OAAO;QACL,SAAS;QACT,WAAW;IACb;AACF;AAKO,SAAS;IACd,OAAO,QAAQ,GAAG,CAAC,cAAc,KAAK,UAC/B,QAAQ,GAAG,CAAC,iBAAiB,KAAK;AAC3C"}},
    {"offset": {"line": 13507, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/x402-call-log.ts"],"sourcesContent":["// =============================================================================\n// X402 CALL LOG\n// =============================================================================\n// Canonical x402 log event interface and logging utilities\n// Maps to UsageLog in database for persistence\n\nimport { createUsageLog, listUsageLogs, type UsageLog } from '@/db/metered-endpoints';\nimport { createLogger } from '@/lib/logger';\n\nconst logger = createLogger({ component: 'X402CallLog' });\n\n/**\n * Canonical x402 call log event\n * This interface represents the complete x402 payment flow for a single API call\n */\nexport interface X402CallLog {\n  id: string;\n  timestamp: string;\n  customerId: string | null;\n  endpointId: string;\n  agentId: string | null;\n  facilitator: string;\n  chainId: string;\n  asset: string;\n  amount: string;\n  status: 'success' | 'failed';\n  errorCode?: string;\n  x402TxHash?: string;\n  latencyMs: number;\n  resource: string;\n}\n\n/**\n * Convert X402CallLog to UsageLog for database persistence\n */\nfunction x402CallLogToUsageLog(x402Log: Omit<X402CallLog, 'id' | 'timestamp'>): Omit<UsageLog, 'id' | 'timestamp'> {\n  return {\n    endpointId: x402Log.endpointId,\n    method: 'POST', // Default for metered endpoints\n    path: new URL(x402Log.resource).pathname,\n    statusCode: x402Log.status === 'success' ? 200 : (x402Log.errorCode === 'PAYMENT_REQUIRED' ? 402 : 400),\n    responseTime: x402Log.latencyMs,\n    units: 1, // 1 unit per call\n    conversationId: x402Log.customerId || undefined,\n    agentId: x402Log.agentId || undefined,\n    x402TxHash: x402Log.x402TxHash || undefined,\n    failureCode: x402Log.status === 'failed' ? (x402Log.errorCode || 'UNKNOWN_ERROR') : undefined,\n  };\n}\n\n/**\n * Convert UsageLog back to X402CallLog for retrieval\n * This reconstructs the X402CallLog from the stored UsageLog\n */\nexport function usageLogToX402CallLog(usageLog: UsageLog, metadata?: {\n  facilitator?: string;\n  chainId?: string;\n  asset?: string;\n  amount?: string;\n  resource?: string;\n}): X402CallLog {\n  // Determine status from statusCode and failureCode\n  const status: 'success' | 'failed' = usageLog.statusCode === 200 && !usageLog.failureCode ? 'success' : 'failed';\n  \n  // Reconstruct resource URL from path\n  const appUrl = process.env.NEXT_PUBLIC_APP_URL;\n  const baseUrl = appUrl || (process.env.NODE_ENV === 'production' ? '' : 'http://localhost:3001');\n  // Ensure path starts with / (fix for paths like \"3001/api/...\" that should be \"/api/...\")\n  const normalizedPath = usageLog.path.startsWith('/') ? usageLog.path : `/${usageLog.path.replace(/^\\d+\\//, '')}`;\n  const resource = metadata?.resource || `${baseUrl}${normalizedPath}`;\n  \n  // Infer facilitator from verify mode if not provided in metadata\n  // This handles cases where facilitator wasn't stored in the database\n  let facilitator = metadata?.facilitator;\n  if (!facilitator) {\n    const verifyMode = process.env.X402_VERIFY_MODE?.toLowerCase();\n    if (verifyMode === 'cdp') {\n      facilitator = 'CDP';\n    } else if (verifyMode === 'test') {\n      facilitator = 'TEST_FACILITATOR';\n    } else {\n      facilitator = 'UNKNOWN';\n    }\n  }\n  \n  return {\n    id: usageLog.id,\n    timestamp: usageLog.timestamp,\n    customerId: usageLog.conversationId || null,\n    endpointId: usageLog.endpointId,\n    agentId: usageLog.agentId || null,\n    facilitator,\n    chainId: metadata?.chainId || 'eip155:8453',\n    asset: metadata?.asset || 'USDC_TEST',\n    amount: metadata?.amount || '10000',\n    status,\n    errorCode: usageLog.failureCode,\n    x402TxHash: usageLog.x402TxHash,\n    latencyMs: usageLog.responseTime,\n    resource,\n  };\n}\n\n/**\n * Query X402CallLog entries from the database\n * Filters by endpointId and optionally limits results\n */\nexport async function getX402CallLogs(\n  endpointId: string,\n  options?: {\n    limit?: number;\n    startDate?: string;\n    endDate?: string;\n  }\n): Promise<X402CallLog[]> {\n  try {\n    const usageLogs = await listUsageLogs({ endpointId });\n    \n    // Sort by timestamp descending (most recent first)\n    usageLogs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n    \n    // Apply date filters if provided\n    let filtered = usageLogs;\n    if (options?.startDate) {\n      filtered = filtered.filter(log => log.timestamp >= options.startDate!);\n    }\n    if (options?.endDate) {\n      filtered = filtered.filter(log => log.timestamp <= options.endDate!);\n    }\n    \n    // Apply limit\n    if (options?.limit) {\n      filtered = filtered.slice(0, options.limit);\n    }\n    \n    // Convert to X402CallLog\n    // Note: We lose some metadata (facilitator, chainId, asset, amount, resource) when converting back\n    // In a production system, we'd store these in the UsageLog or a separate metadata table\n    // For now, we use verify mode and heuristics to reconstruct:\n    // - Infer from X402_VERIFY_MODE first (most reliable) - ALWAYS use this when set\n    // - Test facilitator: if x402TxHash starts with 'TEST_'\n    // - CDP facilitator: if x402TxHash is a real transaction hash (starts with '0x')\n    // - Unknown: only if we can't determine from verify mode or txHash\n    const verifyMode = process.env.X402_VERIFY_MODE?.toLowerCase();\n    return filtered.map(log => {\n      let facilitator: string | undefined;\n      \n      // ALWAYS infer from verify mode first (most reliable)\n      // This ensures that when X402_VERIFY_MODE=cdp, all logs show facilitator: \"CDP\"\n      // even if there's no txHash (e.g., on errors)\n      if (verifyMode === 'cdp') {\n        facilitator = 'CDP';\n      } else if (verifyMode === 'test') {\n        facilitator = 'TEST_FACILITATOR';\n      }\n      \n      // If verify mode didn't set it, use heuristics from txHash as fallback\n      // (This handles cases where verify mode isn't set but we can infer from txHash)\n      if (!facilitator && log.x402TxHash) {\n        if (log.x402TxHash.startsWith('TEST_')) {\n          facilitator = 'TEST_FACILITATOR';\n        } else if (log.x402TxHash.startsWith('0x')) {\n          facilitator = 'CDP';\n        }\n      }\n      \n      // If still not set, usageLogToX402CallLog will infer from verify mode\n      // But we should have set it above if verify mode is configured\n      \n      return usageLogToX402CallLog(log, {\n        facilitator,\n        chainId: 'eip155:8453',\n        asset: 'USDC_TEST',\n        amount: '10000',\n        resource: (() => {\n          const appUrl = process.env.NEXT_PUBLIC_APP_URL;\n          const baseUrl = appUrl || (process.env.NODE_ENV === 'production' ? '' : 'http://localhost:3001');\n          const normalizedPath = log.path.startsWith('/') ? log.path : `/${log.path.replace(/^\\d+\\//, '')}`;\n          return `${baseUrl}${normalizedPath}`;\n        })(),\n      });\n    });\n  } catch (error) {\n    logger.error('Error querying x402 call logs', { error, endpointId });\n    throw error;\n  }\n}\n\n/**\n * Log an x402 call event to the database and structured logger\n * This is the canonical way to record x402 payment flows\n */\nexport async function logX402Call(x402Log: Omit<X402CallLog, 'id' | 'timestamp'>): Promise<X402CallLog> {\n  const timestamp = new Date().toISOString();\n  \n  // Log to structured logger (Pino)\n  logger.info('x402 call', {\n    endpointId: x402Log.endpointId,\n    facilitator: x402Log.facilitator,\n    chainId: x402Log.chainId,\n    asset: x402Log.asset,\n    amount: x402Log.amount,\n    status: x402Log.status,\n    errorCode: x402Log.errorCode,\n    x402TxHash: x402Log.x402TxHash,\n    latencyMs: x402Log.latencyMs,\n    resource: x402Log.resource,\n    customerId: x402Log.customerId,\n    agentId: x402Log.agentId,\n  });\n\n  // Persist to database via UsageLog\n  try {\n    const usageLogData = x402CallLogToUsageLog(x402Log);\n    console.log('X402_LOG_DEBUG', JSON.stringify(usageLogData, null, 2));\n    const usageLog = await createUsageLog(usageLogData);\n    \n    return {\n      id: usageLog.id,\n      timestamp: usageLog.timestamp,\n      customerId: x402Log.customerId,\n      endpointId: x402Log.endpointId,\n      agentId: x402Log.agentId,\n      facilitator: x402Log.facilitator,\n      chainId: x402Log.chainId,\n      asset: x402Log.asset,\n      amount: x402Log.amount,\n      status: x402Log.status,\n      errorCode: x402Log.errorCode,\n      x402TxHash: x402Log.x402TxHash,\n      latencyMs: x402Log.latencyMs,\n      resource: x402Log.resource,\n    };\n  } catch (error) {\n    // Log error but don't fail the request\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const errorDetails = error instanceof Error ? { \n      message: error.message, \n      stack: error.stack,\n      name: error.name \n    } : { error };\n    \n    console.error('X402_LOG_DB_ERROR', {\n      error: errorMessage,\n      errorDetails,\n      x402Log: {\n        endpointId: x402Log.endpointId,\n        status: x402Log.status,\n        facilitator: x402Log.facilitator,\n      }\n    });\n    \n    logger.error('Failed to persist x402 call log', { \n      error: errorMessage,\n      errorDetails,\n      x402Log: {\n        endpointId: x402Log.endpointId,\n        status: x402Log.status,\n        facilitator: x402Log.facilitator,\n      }\n    });\n    \n    // Return log with generated ID (for consistency, even if DB write failed)\n    return {\n      id: `temp-${Date.now()}`,\n      timestamp,\n      ...x402Log,\n    };\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 13737, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/query-helper.ts"],"sourcesContent":["// =============================================================================\r\n// DATABASE QUERY HELPER\r\n// =============================================================================\r\n// Helper functions for executing raw SQL queries that work with both SQLite and PostgreSQL\r\n// This is used for new tables that aren't yet in the adapter interface\r\n\r\nimport { getDb } from './client';\r\n\r\n/**\r\n * Execute a raw SQL query (works with both SQLite and PostgreSQL)\r\n */\r\nexport async function executeQuery<T = any>(\r\n  query: string,\r\n  params: any[] = []\r\n): Promise<T[]> {\r\n  const db = getDb();\r\n  \r\n  // Check if it's PostgreSQL adapter\r\n  if ('pool' in db && typeof (db as any).pool?.query === 'function') {\r\n    const pool = (db as any).pool;\r\n    const result = await pool.query(query, params);\r\n    return result.rows;\r\n  }\r\n  \r\n  // Check if it's SQLite adapter\r\n  if ('db' in db && typeof (db as any).db?.prepare === 'function') {\r\n    const dbInstance = (db as any).db;\r\n    const stmt = dbInstance.prepare(query);\r\n    return stmt.all(...params) as T[];\r\n  }\r\n  \r\n  // Fallback: try direct access\r\n  if (typeof (db as any).query === 'function') {\r\n    const result = await (db as any).query(query, params);\r\n    return result.rows || result;\r\n  }\r\n  \r\n  if (typeof (db as any).prepare === 'function') {\r\n    const stmt = (db as any).prepare(query);\r\n    return stmt.all(...params) as T[];\r\n  }\r\n  \r\n  throw new Error('Unable to execute query: database adapter not recognized');\r\n}\r\n\r\n/**\r\n * Execute a raw SQL query that returns a single row\r\n */\r\nexport async function executeQueryOne<T = any>(\r\n  query: string,\r\n  params: any[] = []\r\n): Promise<T | null> {\r\n  const results = await executeQuery<T>(query, params);\r\n  return results.length > 0 ? results[0] : null;\r\n}\r\n\r\n/**\r\n * Execute a raw SQL query that doesn't return results (INSERT, UPDATE, DELETE)\r\n */\r\nexport async function executeUpdate(\r\n  query: string,\r\n  params: any[] = []\r\n): Promise<{ rowCount?: number; changes?: number }> {\r\n  const db = getDb();\r\n  \r\n  // Check if it's PostgreSQL adapter\r\n  if ('pool' in db && typeof (db as any).pool?.query === 'function') {\r\n    const pool = (db as any).pool;\r\n    const result = await pool.query(query, params);\r\n    return { rowCount: result.rowCount };\r\n  }\r\n  \r\n  // Check if it's SQLite adapter\r\n  if ('db' in db && typeof (db as any).db?.prepare === 'function') {\r\n    const dbInstance = (db as any).db;\r\n    const stmt = dbInstance.prepare(query);\r\n    const result = stmt.run(...params);\r\n    return { changes: (result as any).changes };\r\n  }\r\n  \r\n  // Fallback\r\n  if (typeof (db as any).query === 'function') {\r\n    const result = await (db as any).query(query, params);\r\n    return { rowCount: result.rowCount };\r\n  }\r\n  \r\n  if (typeof (db as any).prepare === 'function') {\r\n    const stmt = (db as any).prepare(query);\r\n    const result = stmt.run(...params);\r\n    return { changes: (result as any).changes };\r\n  }\r\n  \r\n  throw new Error('Unable to execute update: database adapter not recognized');\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,wBAAwB;AACxB,gFAAgF;AAChF,2FAA2F;AAC3F,uEAAuE;;;;;;;;;AAEvE;;;;;;AAKO,eAAe,aACpB,KAAa,EACb,SAAgB,EAAE;IAElB,MAAM,KAAK,IAAA,8HAAK;IAEhB,mCAAmC;IACnC,IAAI,UAAU,MAAM,OAAO,AAAC,GAAW,IAAI,EAAE,UAAU,YAAY;QACjE,MAAM,OAAO,AAAC,GAAW,IAAI;QAC7B,MAAM,SAAS,MAAM,KAAK,KAAK,CAAC,OAAO;QACvC,OAAO,OAAO,IAAI;IACpB;IAEA,+BAA+B;IAC/B,IAAI,QAAQ,MAAM,OAAO,AAAC,GAAW,EAAE,EAAE,YAAY,YAAY;QAC/D,MAAM,aAAa,AAAC,GAAW,EAAE;QACjC,MAAM,OAAO,WAAW,OAAO,CAAC;QAChC,OAAO,KAAK,GAAG,IAAI;IACrB;IAEA,8BAA8B;IAC9B,IAAI,OAAO,AAAC,GAAW,KAAK,KAAK,YAAY;QAC3C,MAAM,SAAS,MAAM,AAAC,GAAW,KAAK,CAAC,OAAO;QAC9C,OAAO,OAAO,IAAI,IAAI;IACxB;IAEA,IAAI,OAAO,AAAC,GAAW,OAAO,KAAK,YAAY;QAC7C,MAAM,OAAO,AAAC,GAAW,OAAO,CAAC;QACjC,OAAO,KAAK,GAAG,IAAI;IACrB;IAEA,MAAM,IAAI,MAAM;AAClB;AAKO,eAAe,gBACpB,KAAa,EACb,SAAgB,EAAE;IAElB,MAAM,UAAU,MAAM,aAAgB,OAAO;IAC7C,OAAO,QAAQ,MAAM,GAAG,IAAI,OAAO,CAAC,EAAE,GAAG;AAC3C;AAKO,eAAe,cACpB,KAAa,EACb,SAAgB,EAAE;IAElB,MAAM,KAAK,IAAA,8HAAK;IAEhB,mCAAmC;IACnC,IAAI,UAAU,MAAM,OAAO,AAAC,GAAW,IAAI,EAAE,UAAU,YAAY;QACjE,MAAM,OAAO,AAAC,GAAW,IAAI;QAC7B,MAAM,SAAS,MAAM,KAAK,KAAK,CAAC,OAAO;QACvC,OAAO;YAAE,UAAU,OAAO,QAAQ;QAAC;IACrC;IAEA,+BAA+B;IAC/B,IAAI,QAAQ,MAAM,OAAO,AAAC,GAAW,EAAE,EAAE,YAAY,YAAY;QAC/D,MAAM,aAAa,AAAC,GAAW,EAAE;QACjC,MAAM,OAAO,WAAW,OAAO,CAAC;QAChC,MAAM,SAAS,KAAK,GAAG,IAAI;QAC3B,OAAO;YAAE,SAAS,AAAC,OAAe,OAAO;QAAC;IAC5C;IAEA,WAAW;IACX,IAAI,OAAO,AAAC,GAAW,KAAK,KAAK,YAAY;QAC3C,MAAM,SAAS,MAAM,AAAC,GAAW,KAAK,CAAC,OAAO;QAC9C,OAAO;YAAE,UAAU,OAAO,QAAQ;QAAC;IACrC;IAEA,IAAI,OAAO,AAAC,GAAW,OAAO,KAAK,YAAY;QAC7C,MAAM,OAAO,AAAC,GAAW,OAAO,CAAC;QACjC,MAAM,SAAS,KAAK,GAAG,IAAI;QAC3B,OAAO;YAAE,SAAS,AAAC,OAAe,OAAO;QAAC;IAC5C;IAEA,MAAM,IAAI,MAAM;AAClB"}},
    {"offset": {"line": 13827, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/metrics.ts"],"sourcesContent":["// =============================================================================\r\n// METRICS DATABASE\r\n// =============================================================================\r\n// Database operations for metrics storage\r\n\r\nimport { executeQuery, executeQueryOne, executeUpdate } from './query-helper';\r\nimport type { Metric, AggregatedMetric } from '@/lib/metrics-collector';\r\n\r\nexport interface MetricRow {\r\n  id: string;\r\n  name: string;\r\n  value: string; // Stored as numeric in DB, but returned as string for precision\r\n  timestamp: string; // BigInt in DB, string for JS\r\n  tags: string | Record<string, string>; // JSONB in PostgreSQL, TEXT in SQLite\r\n  created_at: string;\r\n}\r\n\r\n/**\r\n * Convert database row to Metric\r\n */\r\nfunction rowToMetric(row: MetricRow): Metric {\r\n  return {\r\n    name: row.name,\r\n    value: parseFloat(row.value),\r\n    timestamp: parseInt(row.timestamp),\r\n    tags: typeof row.tags === 'string' ? JSON.parse(row.tags) : row.tags,\r\n  };\r\n}\r\n\r\n/**\r\n * Record a metric\r\n */\r\nexport async function recordMetric(metric: Metric & { id?: string }): Promise<void> {\r\n  const id = metric.id || `m_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n  const db = require('./client').getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  const query = isPostgres\r\n    ? `INSERT INTO metrics (id, name, value, timestamp, tags, created_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6)`\r\n    : `INSERT INTO metrics (id, name, value, timestamp, tags, created_at)\r\n       VALUES (?, ?, ?, ?, ?, ?)`;\r\n  \r\n  const params = [\r\n    id,\r\n    metric.name,\r\n    metric.value.toString(),\r\n    metric.timestamp.toString(),\r\n    JSON.stringify(metric.tags || {}),\r\n    new Date().toISOString(),\r\n  ];\r\n\r\n  await executeUpdate(query, params);\r\n}\r\n\r\n/**\r\n * Record multiple metrics\r\n */\r\nexport async function recordMetrics(metrics: Metric[]): Promise<void> {\r\n  // Batch insert for better performance\r\n  for (const metric of metrics) {\r\n    await recordMetric(metric);\r\n  }\r\n}\r\n\r\n/**\r\n * Get metrics for a time range\r\n */\r\nexport async function getMetrics(\r\n  name: string,\r\n  startTime?: number,\r\n  endTime?: number,\r\n  tags?: Record<string, string>\r\n): Promise<Metric[]> {\r\n  const db = require('./client').getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  let query = 'SELECT * FROM metrics WHERE name = ';\r\n  const params: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (isPostgres) {\r\n    query += `$${paramIndex++}`;\r\n  } else {\r\n    query += '?';\r\n  }\r\n  params.push(name);\r\n\r\n  if (startTime !== undefined) {\r\n    if (isPostgres) {\r\n      query += ` AND timestamp >= $${paramIndex++}`;\r\n    } else {\r\n      query += ' AND timestamp >= ?';\r\n    }\r\n    params.push(startTime.toString());\r\n  }\r\n\r\n  if (endTime !== undefined) {\r\n    if (isPostgres) {\r\n      query += ` AND timestamp <= $${paramIndex++}`;\r\n    } else {\r\n      query += ' AND timestamp <= ?';\r\n    }\r\n    params.push(endTime.toString());\r\n  }\r\n\r\n  // Tag filtering (simplified - for complex queries, consider using JSONB operators in PostgreSQL)\r\n  if (tags && Object.keys(tags).length > 0) {\r\n    // This is a simplified approach - for production, use proper JSONB queries\r\n    query += ' AND tags IS NOT NULL';\r\n  }\r\n\r\n  query += ' ORDER BY timestamp DESC LIMIT 10000'; // Limit to prevent memory issues\r\n\r\n  const rows = await executeQuery<MetricRow>(query, params);\r\n  return rows.map(rowToMetric);\r\n}\r\n\r\n/**\r\n * Get aggregated metrics\r\n */\r\nexport async function getAggregatedMetrics(\r\n  name: string,\r\n  startTime?: number,\r\n  endTime?: number,\r\n  tags?: Record<string, string>\r\n): Promise<AggregatedMetric | null> {\r\n  const metrics = await getMetrics(name, startTime, endTime, tags);\r\n  \r\n  if (metrics.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  // Filter by tags if provided\r\n  let filtered = metrics;\r\n  if (tags) {\r\n    filtered = metrics.filter(m => {\r\n      if (!m.tags) return false;\r\n      return Object.entries(tags).every(([key, value]) => m.tags![key] === value);\r\n    });\r\n  }\r\n\r\n  if (filtered.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  // Calculate aggregations\r\n  const values = filtered.map(m => m.value).sort((a, b) => a - b);\r\n  const count = values.length;\r\n  const sum = values.reduce((a, b) => a + b, 0);\r\n  const min = values[0];\r\n  const max = values[values.length - 1];\r\n  const average = sum / count;\r\n\r\n  // Calculate percentiles\r\n  const p50Index = Math.floor(count * 0.5);\r\n  const p95Index = Math.floor(count * 0.95);\r\n  const p99Index = Math.floor(count * 0.99);\r\n\r\n  return {\r\n    name,\r\n    count,\r\n    sum,\r\n    min,\r\n    max,\r\n    average,\r\n    p50: values[p50Index] || average,\r\n    p95: values[p95Index] || max,\r\n    p99: values[p99Index] || max,\r\n    tags: tags || filtered[0]?.tags,\r\n  };\r\n}\r\n\r\n/**\r\n * Clean up old metrics (keep only recent ones)\r\n */\r\nexport async function cleanupOldMetrics(olderThanDays: number = 30): Promise<number> {\r\n  const cutoffTime = Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);\r\n  const db = require('./client').getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  const query = isPostgres\r\n    ? `DELETE FROM metrics WHERE timestamp < $1`\r\n    : `DELETE FROM metrics WHERE timestamp < ?`;\r\n  \r\n  const result = await executeUpdate(query, [cutoffTime.toString()]);\r\n  return result.rowCount ?? result.changes ?? 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 13976, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/metrics-collector.ts"],"sourcesContent":["// =============================================================================\r\n// Metrics Collector\r\n// =============================================================================\r\n// Collects and aggregates metrics for monitoring and observability\r\n// In-memory metrics store (can be extended to Redis for distributed systems)\r\n\r\nimport { createLogger } from './logger';\r\nimport * as metricsDb from '@/db/metrics';\r\n\r\nconst logger = createLogger({ component: 'MetricsCollector' });\r\n\r\nexport interface Metric {\r\n  name: string;\r\n  value: number;\r\n  timestamp: number;\r\n  tags?: Record<string, string>;\r\n}\r\n\r\nexport interface AggregatedMetric {\r\n  name: string;\r\n  count: number;\r\n  sum: number;\r\n  min: number;\r\n  max: number;\r\n  average: number;\r\n  p50: number;\r\n  p95: number;\r\n  p99: number;\r\n  tags?: Record<string, string>;\r\n}\r\n\r\n/**\r\n * Record a metric (async, uses database)\r\n */\r\nexport async function recordMetric(metric: Metric): Promise<void> {\r\n  try {\r\n    await metricsDb.recordMetric(metric);\r\n  } catch (error) {\r\n    logger.error('Failed to record metric', { metric, error });\r\n  }\r\n}\r\n\r\n/**\r\n * Record multiple metrics at once (async, uses database)\r\n */\r\nexport async function recordMetrics(metrics: Metric[]): Promise<void> {\r\n  try {\r\n    await metricsDb.recordMetrics(metrics);\r\n  } catch (error) {\r\n    logger.error('Failed to record metrics', { count: metrics.length, error });\r\n  }\r\n}\r\n\r\n/**\r\n * Get aggregated metrics for a time range (async, uses database)\r\n */\r\nexport async function getAggregatedMetrics(\r\n  name: string,\r\n  startTime?: number,\r\n  endTime?: number,\r\n  tags?: Record<string, string>\r\n): Promise<AggregatedMetric | null> {\r\n  return metricsDb.getAggregatedMetrics(name, startTime, endTime, tags);\r\n  \r\n  return {\r\n    name,\r\n    count,\r\n    sum,\r\n    min,\r\n    max,\r\n    average,\r\n    p50,\r\n    p95,\r\n    p99,\r\n    tags,\r\n  };\r\n}\r\n\r\n/**\r\n * Get all metric names\r\n */\r\nexport function getMetricNames(): string[] {\r\n  return Array.from(metricsStore.keys());\r\n}\r\n\r\n/**\r\n * Get recent metrics for a name\r\n */\r\nexport function getRecentMetrics(name: string, limit: number = 100): Metric[] {\r\n  const metrics = metricsStore.get(name);\r\n  if (!metrics) {\r\n    return [];\r\n  }\r\n  \r\n  return metrics.slice(-limit);\r\n}\r\n\r\n/**\r\n * Clear metrics (for testing or reset)\r\n */\r\nexport function clearMetrics(name?: string): void {\r\n  if (name) {\r\n    metricsStore.delete(name);\r\n  } else {\r\n    metricsStore.clear();\r\n  }\r\n}\r\n\r\n/**\r\n * Helper functions for common metrics\r\n */\r\n\r\nexport async function recordRequestMetric(\r\n  endpoint: string,\r\n  method: string,\r\n  statusCode: number,\r\n  durationMs: number,\r\n  tags?: Record<string, string>\r\n): Promise<void> {\r\n  await recordMetric({\r\n    name: 'http.request',\r\n    value: durationMs,\r\n    timestamp: Date.now(),\r\n    tags: {\r\n      endpoint,\r\n      method,\r\n      statusCode: statusCode.toString(),\r\n      ...tags,\r\n    },\r\n  });\r\n  \r\n  // Record status code count\r\n  await recordMetric({\r\n    name: 'http.request.count',\r\n    value: 1,\r\n    timestamp: Date.now(),\r\n    tags: {\r\n      endpoint,\r\n      method,\r\n      statusCode: statusCode.toString(),\r\n      ...tags,\r\n    },\r\n  });\r\n}\r\n\r\nexport async function recordPaymentMetric(\r\n  endpointId: string,\r\n  facilitator: string,\r\n  amount: string,\r\n  success: boolean,\r\n  durationMs: number\r\n): Promise<void> {\r\n  await recordMetric({\r\n    name: 'payment.verification',\r\n    value: durationMs,\r\n    timestamp: Date.now(),\r\n    tags: {\r\n      endpointId,\r\n      facilitator,\r\n      success: success.toString(),\r\n    },\r\n  });\r\n  \r\n  if (success) {\r\n    await recordMetric({\r\n      name: 'payment.amount',\r\n      value: parseFloat(amount) / 1e6, // Convert atomic units to USDC\r\n      timestamp: Date.now(),\r\n      tags: {\r\n        endpointId,\r\n        facilitator,\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport async function recordErrorMetric(\r\n  errorCode: string,\r\n  endpoint?: string,\r\n  tags?: Record<string, string>\r\n): Promise<void> {\r\n  await recordMetric({\r\n    name: 'error.count',\r\n    value: 1,\r\n    timestamp: Date.now(),\r\n    tags: {\r\n      errorCode,\r\n      endpoint: endpoint || 'unknown',\r\n      ...tags,\r\n    },\r\n  });\r\n}\r\n\r\nexport async function recordCircuitBreakerMetric(\r\n  upstreamUrl: string,\r\n  state: 'open' | 'closed' | 'half-open'\r\n): Promise<void> {\r\n  await recordMetric({\r\n    name: 'circuit_breaker.state',\r\n    value: state === 'open' ? 1 : 0,\r\n    timestamp: Date.now(),\r\n    tags: {\r\n      upstreamUrl,\r\n      state,\r\n    },\r\n  });\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,oBAAoB;AACpB,gFAAgF;AAChF,mEAAmE;AACnE,6EAA6E;;;;;;;;;;;;;;;;;;;;;;;AAE7E;AACA;;;;;;;AAEA,MAAM,SAAS,IAAA,sIAAY,EAAC;IAAE,WAAW;AAAmB;AAyBrD,eAAe,aAAa,MAAc;IAC/C,IAAI;QACF,MAAM,sIAAsB,CAAC;IAC/B,EAAE,OAAO,OAAO;QACd,OAAO,KAAK,CAAC,2BAA2B;YAAE;YAAQ;QAAM;IAC1D;AACF;AAKO,eAAe,cAAc,OAAiB;IACnD,IAAI;QACF,MAAM,uIAAuB,CAAC;IAChC,EAAE,OAAO,OAAO;QACd,OAAO,KAAK,CAAC,4BAA4B;YAAE,OAAO,QAAQ,MAAM;YAAE;QAAM;IAC1E;AACF;AAKO,eAAe,qBACpB,IAAY,EACZ,SAAkB,EAClB,OAAgB,EAChB,IAA6B;IAE7B,OAAO,8IAA8B,CAAC,MAAM,WAAW,SAAS;;;AAclE;AAKO,SAAS;IACd,OAAO,MAAM,IAAI,CAAC,aAAa,IAAI;AACrC;AAKO,SAAS,iBAAiB,IAAY,EAAE,QAAgB,GAAG;IAChE,MAAM,UAAU,aAAa,GAAG,CAAC;IACjC,IAAI,CAAC,SAAS;QACZ,OAAO,EAAE;IACX;IAEA,OAAO,QAAQ,KAAK,CAAC,CAAC;AACxB;AAKO,SAAS,aAAa,IAAa;IACxC,IAAI,MAAM;QACR,aAAa,MAAM,CAAC;IACtB,OAAO;QACL,aAAa,KAAK;IACpB;AACF;AAMO,eAAe,oBACpB,QAAgB,EAChB,MAAc,EACd,UAAkB,EAClB,UAAkB,EAClB,IAA6B;IAE7B,MAAM,aAAa;QACjB,MAAM;QACN,OAAO;QACP,WAAW,KAAK,GAAG;QACnB,MAAM;YACJ;YACA;YACA,YAAY,WAAW,QAAQ;YAC/B,GAAG,IAAI;QACT;IACF;IAEA,2BAA2B;IAC3B,MAAM,aAAa;QACjB,MAAM;QACN,OAAO;QACP,WAAW,KAAK,GAAG;QACnB,MAAM;YACJ;YACA;YACA,YAAY,WAAW,QAAQ;YAC/B,GAAG,IAAI;QACT;IACF;AACF;AAEO,eAAe,oBACpB,UAAkB,EAClB,WAAmB,EACnB,MAAc,EACd,OAAgB,EAChB,UAAkB;IAElB,MAAM,aAAa;QACjB,MAAM;QACN,OAAO;QACP,WAAW,KAAK,GAAG;QACnB,MAAM;YACJ;YACA;YACA,SAAS,QAAQ,QAAQ;QAC3B;IACF;IAEA,IAAI,SAAS;QACX,MAAM,aAAa;YACjB,MAAM;YACN,OAAO,WAAW,UAAU;YAC5B,WAAW,KAAK,GAAG;YACnB,MAAM;gBACJ;gBACA;YACF;QACF;IACF;AACF;AAEO,eAAe,kBACpB,SAAiB,EACjB,QAAiB,EACjB,IAA6B;IAE7B,MAAM,aAAa;QACjB,MAAM;QACN,OAAO;QACP,WAAW,KAAK,GAAG;QACnB,MAAM;YACJ;YACA,UAAU,YAAY;YACtB,GAAG,IAAI;QACT;IACF;AACF;AAEO,eAAe,2BACpB,WAAmB,EACnB,KAAsC;IAEtC,MAAM,aAAa;QACjB,MAAM;QACN,OAAO,UAAU,SAAS,IAAI;QAC9B,WAAW,KAAK,GAAG;QACnB,MAAM;YACJ;YACA;QACF;IACF;AACF"}},
    {"offset": {"line": 14134, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/webhook-deliveries.ts"],"sourcesContent":["// =============================================================================\r\n// WEBHOOK DELIVERIES DATABASE\r\n// =============================================================================\r\n// Database operations for webhook delivery logs\r\n\r\nimport { executeQuery, executeQueryOne, executeUpdate } from './query-helper';\r\n\r\nexport interface WebhookDeliveryRow {\r\n  id: string;\r\n  webhook_config_id: string;\r\n  event_id: string;\r\n  event_type: string;\r\n  url: string;\r\n  payload: string;\r\n  signature: string;\r\n  status: string;\r\n  attempts: number;\r\n  max_attempts: number;\r\n  next_retry_at: string | null;\r\n  last_attempt_at: string | null;\r\n  last_response_code: number | null;\r\n  last_response_body: string | null;\r\n  error_message: string | null;\r\n  delivered_at: string | null;\r\n  created_at: string;\r\n}\r\n\r\n/**\r\n * Create webhook delivery record\r\n */\r\nexport async function createDeliveryRecord(data: {\r\n  webhookConfigId: string;\r\n  eventId: string;\r\n  eventType: string;\r\n  url: string;\r\n  payload: string;\r\n  signature: string;\r\n  maxAttempts?: number;\r\n}): Promise<string> {\r\n  const id = `wd_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n  const { getDb } = await import('./client');\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  const query = isPostgres\r\n    ? `INSERT INTO webhook_deliveries (id, webhook_config_id, event_id, event_type, url, payload, signature, status, attempts, max_attempts, created_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)`\r\n    : `INSERT INTO webhook_deliveries (id, webhook_config_id, event_id, event_type, url, payload, signature, status, attempts, max_attempts, created_at)\r\n       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;\r\n  \r\n  const params = [\r\n    id,\r\n    data.webhookConfigId,\r\n    data.eventId,\r\n    data.eventType,\r\n    data.url,\r\n    data.payload,\r\n    data.signature,\r\n    'pending',\r\n    0,\r\n    data.maxAttempts || 3,\r\n    new Date().toISOString(),\r\n  ];\r\n\r\n  await executeUpdate(query, params);\r\n  return id;\r\n}\r\n\r\n/**\r\n * Update delivery attempt\r\n */\r\nexport async function updateDeliveryAttempt(\r\n  webhookConfigId: string,\r\n  eventId: string,\r\n  updates: {\r\n    attempt: number;\r\n    lastAttemptAt: string;\r\n  }\r\n): Promise<void> {\r\n  const { getDb } = await import('./client');\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  const query = isPostgres\r\n    ? `UPDATE webhook_deliveries \r\n       SET attempts = $1, last_attempt_at = $2 \r\n       WHERE webhook_config_id = $3 AND event_id = $4`\r\n    : `UPDATE webhook_deliveries \r\n       SET attempts = ?, last_attempt_at = ? \r\n       WHERE webhook_config_id = ? AND event_id = ?`;\r\n  \r\n  await executeUpdate(query, [\r\n    updates.attempt,\r\n    updates.lastAttemptAt,\r\n    webhookConfigId,\r\n    eventId,\r\n  ]);\r\n}\r\n\r\n/**\r\n * Mark delivery as successful\r\n */\r\nexport async function markDeliverySuccess(\r\n  webhookConfigId: string,\r\n  eventId: string,\r\n  result: {\r\n    statusCode?: number;\r\n    responseBody?: string;\r\n  }\r\n): Promise<void> {\r\n  const { getDb } = await import('./client');\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  const now = new Date().toISOString();\r\n  \r\n  const query = isPostgres\r\n    ? `UPDATE webhook_deliveries \r\n       SET status = 'delivered', delivered_at = $1, last_response_code = $2, last_response_body = $3\r\n       WHERE webhook_config_id = $4 AND event_id = $5`\r\n    : `UPDATE webhook_deliveries \r\n       SET status = 'delivered', delivered_at = ?, last_response_code = ?, last_response_body = ?\r\n       WHERE webhook_config_id = ? AND event_id = ?`;\r\n  \r\n  await executeUpdate(query, [\r\n    now,\r\n    result.statusCode || null,\r\n    result.responseBody || null,\r\n    webhookConfigId,\r\n    eventId,\r\n  ]);\r\n}\r\n\r\n/**\r\n * Mark delivery as failed\r\n */\r\nexport async function markDeliveryFailed(\r\n  webhookConfigId: string,\r\n  eventId: string,\r\n  result: {\r\n    attempt: number;\r\n    statusCode?: number;\r\n    responseBody?: string;\r\n    errorMessage?: string;\r\n    nextRetryAt?: string;\r\n  }\r\n): Promise<void> {\r\n  const { getDb } = await import('./client');\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  const status = result.nextRetryAt ? 'pending' : 'failed';\r\n  \r\n  const query = isPostgres\r\n    ? `UPDATE webhook_deliveries \r\n       SET status = $1, attempts = $2, last_response_code = $3, last_response_body = $4, \r\n           error_message = $5, next_retry_at = $6, last_attempt_at = $7\r\n       WHERE webhook_config_id = $8 AND event_id = $9`\r\n    : `UPDATE webhook_deliveries \r\n       SET status = ?, attempts = ?, last_response_code = ?, last_response_body = ?, \r\n           error_message = ?, next_retry_at = ?, last_attempt_at = ?\r\n       WHERE webhook_config_id = ? AND event_id = ?`;\r\n  \r\n  await executeUpdate(query, [\r\n    status,\r\n    result.attempt,\r\n    result.statusCode || null,\r\n    result.responseBody || null,\r\n    result.errorMessage || null,\r\n    result.nextRetryAt || null,\r\n    new Date().toISOString(),\r\n    webhookConfigId,\r\n    eventId,\r\n  ]);\r\n}\r\n\r\n/**\r\n * List webhook deliveries with optional filters\r\n */\r\nexport async function listWebhookDeliveries(\r\n  filters?: {\r\n    webhookConfigId?: string;\r\n    eventType?: string;\r\n    status?: string;\r\n    limit?: number;\r\n  }\r\n): Promise<WebhookDeliveryRow[]> {\r\n  const { getDb } = await import('./client');\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  let query = 'SELECT * FROM webhook_deliveries WHERE 1=1';\r\n  const params: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (filters?.webhookConfigId) {\r\n    if (isPostgres) {\r\n      query += ` AND webhook_config_id = $${paramIndex++}`;\r\n    } else {\r\n      query += ' AND webhook_config_id = ?';\r\n    }\r\n    params.push(filters.webhookConfigId);\r\n  }\r\n\r\n  if (filters?.eventType) {\r\n    if (isPostgres) {\r\n      query += ` AND event_type = $${paramIndex++}`;\r\n    } else {\r\n      query += ' AND event_type = ?';\r\n    }\r\n    params.push(filters.eventType);\r\n  }\r\n\r\n  if (filters?.status) {\r\n    if (isPostgres) {\r\n      query += ` AND status = $${paramIndex++}`;\r\n    } else {\r\n      query += ' AND status = ?';\r\n    }\r\n    params.push(filters.status);\r\n  }\r\n\r\n  query += ' ORDER BY created_at DESC';\r\n\r\n  if (filters?.limit) {\r\n    query += ` LIMIT ${filters.limit}`;\r\n  } else {\r\n    query += ' LIMIT 100';\r\n  }\r\n\r\n  return executeQuery<WebhookDeliveryRow>(query, params);\r\n}\r\n\r\n/**\r\n * Get delivery records for a webhook\r\n */\r\nexport async function getDeliveryRecords(\r\n  webhookConfigId: string,\r\n  filters?: {\r\n    status?: string;\r\n    limit?: number;\r\n  }\r\n): Promise<WebhookDeliveryRow[]> {\r\n  return listWebhookDeliveries({\r\n    webhookConfigId,\r\n    ...filters,\r\n  });\r\n}\r\n\r\n/**\r\n * Get delivery record by ID\r\n */\r\nexport async function getDeliveryRecord(id: string): Promise<WebhookDeliveryRow | null> {\r\n  const { getDb } = await import('./client');\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  const query = isPostgres\r\n    ? 'SELECT * FROM webhook_deliveries WHERE id = $1'\r\n    : 'SELECT * FROM webhook_deliveries WHERE id = ?';\r\n  \r\n  return executeQueryOne<WebhookDeliveryRow>(query, [id]);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 14303, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/webhook-delivery.ts"],"sourcesContent":["// =============================================================================\r\n// Webhook Delivery System\r\n// =============================================================================\r\n// Handles webhook event delivery with retry logic, HMAC signing, and status tracking\r\n//\r\n// Features:\r\n// - Exponential backoff with jitter\r\n// - Dead letter queue (DLQ) for failed webhooks\r\n// - Delivery metrics tracking\r\n// - Circuit breaker per endpoint\r\n// - Structured logging\r\n\r\nimport crypto from 'crypto';\r\nimport { createLogger } from './logger';\r\nimport * as webhookDeliveriesDb from '@/db/webhook-deliveries';\r\n\r\n// Lazy import to avoid blocking if bullmq is not available\r\nasync function getWebhookQueue() {\r\n  try {\r\n    const { enqueueWebhookDelivery } = await import('./webhook-queue');\r\n    return enqueueWebhookDelivery;\r\n  } catch (error) {\r\n    logger.warn('Webhook queue not available (bullmq may not be installed)', { error });\r\n    return null;\r\n  }\r\n}\r\n\r\nconst logger = createLogger({ component: 'WebhookDelivery' });\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\nexport const WEBHOOK_CONFIG = {\r\n  /** Maximum number of delivery attempts */\r\n  maxAttempts: parseInt(process.env.WEBHOOK_MAX_ATTEMPTS || '5', 10),\r\n  \r\n  /** Base delay for exponential backoff (ms) */\r\n  baseDelay: parseInt(process.env.WEBHOOK_BASE_DELAY_MS || '1000', 10),\r\n  \r\n  /** Maximum delay between retries (ms) */\r\n  maxDelay: parseInt(process.env.WEBHOOK_MAX_DELAY_MS || '300000', 10), // 5 minutes\r\n  \r\n  /** Request timeout (ms) */\r\n  requestTimeout: parseInt(process.env.WEBHOOK_TIMEOUT_MS || '10000', 10),\r\n  \r\n  /** Enable dead letter queue for failed webhooks */\r\n  enableDLQ: process.env.WEBHOOK_ENABLE_DLQ !== 'false',\r\n  \r\n  /** Jitter factor (0-1) for randomizing delays */\r\n  jitterFactor: parseFloat(process.env.WEBHOOK_JITTER_FACTOR || '0.2'),\r\n};\r\n\r\n// =============================================================================\r\n// METRICS\r\n// =============================================================================\r\n\r\ninterface WebhookMetrics {\r\n  delivered: number;\r\n  failed: number;\r\n  retried: number;\r\n  dlqCount: number;\r\n  byEndpoint: Map<string, { delivered: number; failed: number }>;\r\n  lastReset: number;\r\n}\r\n\r\nconst metrics: WebhookMetrics = {\r\n  delivered: 0,\r\n  failed: 0,\r\n  retried: 0,\r\n  dlqCount: 0,\r\n  byEndpoint: new Map(),\r\n  lastReset: Date.now(),\r\n};\r\n\r\nconst METRICS_RESET_INTERVAL = 60 * 60 * 1000; // 1 hour\r\n\r\nfunction recordDeliveryMetric(url: string, success: boolean, isRetry: boolean = false): void {\r\n  // Reset metrics hourly\r\n  if (Date.now() - metrics.lastReset > METRICS_RESET_INTERVAL) {\r\n    metrics.delivered = 0;\r\n    metrics.failed = 0;\r\n    metrics.retried = 0;\r\n    metrics.byEndpoint.clear();\r\n    metrics.lastReset = Date.now();\r\n  }\r\n  \r\n  if (success) {\r\n    metrics.delivered++;\r\n  } else {\r\n    metrics.failed++;\r\n  }\r\n  \r\n  if (isRetry) {\r\n    metrics.retried++;\r\n  }\r\n  \r\n  // Track by endpoint (use hostname only)\r\n  try {\r\n    const hostname = new URL(url).hostname;\r\n    const endpointMetrics = metrics.byEndpoint.get(hostname) || { delivered: 0, failed: 0 };\r\n    if (success) {\r\n      endpointMetrics.delivered++;\r\n    } else {\r\n      endpointMetrics.failed++;\r\n    }\r\n    metrics.byEndpoint.set(hostname, endpointMetrics);\r\n  } catch {\r\n    // Invalid URL, skip endpoint tracking\r\n  }\r\n}\r\n\r\n/**\r\n * Get webhook delivery metrics\r\n */\r\nexport function getWebhookMetrics(): {\r\n  delivered: number;\r\n  failed: number;\r\n  retried: number;\r\n  dlqCount: number;\r\n  successRate: string;\r\n  byEndpoint: Record<string, { delivered: number; failed: number; successRate: string }>;\r\n  lastReset: string;\r\n} {\r\n  const total = metrics.delivered + metrics.failed;\r\n  const byEndpoint: Record<string, any> = {};\r\n  \r\n  metrics.byEndpoint.forEach((stats, hostname) => {\r\n    const endpointTotal = stats.delivered + stats.failed;\r\n    byEndpoint[hostname] = {\r\n      ...stats,\r\n      successRate: endpointTotal > 0 \r\n        ? ((stats.delivered / endpointTotal) * 100).toFixed(2) + '%'\r\n        : '0%',\r\n    };\r\n  });\r\n  \r\n  return {\r\n    delivered: metrics.delivered,\r\n    failed: metrics.failed,\r\n    retried: metrics.retried,\r\n    dlqCount: metrics.dlqCount,\r\n    successRate: total > 0 \r\n      ? ((metrics.delivered / total) * 100).toFixed(2) + '%'\r\n      : '0%',\r\n    byEndpoint,\r\n    lastReset: new Date(metrics.lastReset).toISOString(),\r\n  };\r\n}\r\n\r\nexport type WebhookEventType =\r\n  | 'payment.verified'\r\n  | 'payment.failed'\r\n  | 'usage.recorded'\r\n  | 'session.completed'\r\n  | 'endpoint.created'\r\n  | 'endpoint.updated'\r\n  | 'endpoint.deleted';\r\n\r\nexport interface WebhookEvent {\r\n  id: string;\r\n  event: WebhookEventType;\r\n  timestamp: string;\r\n  data: Record<string, any>;\r\n}\r\n\r\nexport interface WebhookConfig {\r\n  id: string;\r\n  endpointId?: string; // Optional: webhook for specific endpoint\r\n  url: string;\r\n  secret: string; // For HMAC signing\r\n  events: WebhookEventType[];\r\n  enabled: boolean;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\nexport interface WebhookDelivery {\r\n  id: string;\r\n  webhookConfigId: string;\r\n  eventId: string;\r\n  url: string;\r\n  payload: string;\r\n  signature: string;\r\n  status: 'pending' | 'delivered' | 'failed';\r\n  attempts: number;\r\n  maxAttempts: number;\r\n  nextRetryAt?: string;\r\n  lastAttemptAt?: string;\r\n  lastResponseCode?: number;\r\n  lastResponseBody?: string;\r\n  deliveredAt?: string;\r\n  createdAt: string;\r\n}\r\n\r\n/**\r\n * Generate HMAC signature for webhook payload\r\n */\r\nexport function generateWebhookSignature(\r\n  payload: string,\r\n  secret: string\r\n): string {\r\n  return crypto\r\n    .createHmac('sha256', secret)\r\n    .update(payload)\r\n    .digest('hex');\r\n}\r\n\r\n/**\r\n * Verify webhook signature\r\n */\r\nexport function verifyWebhookSignature(\r\n  payload: string,\r\n  signature: string,\r\n  secret: string\r\n): boolean {\r\n  const expectedSignature = generateWebhookSignature(payload, secret);\r\n  return crypto.timingSafeEqual(\r\n    Buffer.from(signature),\r\n    Buffer.from(expectedSignature)\r\n  );\r\n}\r\n\r\n/**\r\n * Create webhook event\r\n */\r\nexport function createWebhookEvent(\r\n  event: WebhookEventType,\r\n  data: Record<string, any>\r\n): WebhookEvent {\r\n  return {\r\n    id: `evt_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,\r\n    event,\r\n    timestamp: new Date().toISOString(),\r\n    data,\r\n  };\r\n}\r\n\r\n/**\r\n * Deliver webhook event with enhanced error handling and metrics\r\n */\r\nexport async function deliverWebhook(\r\n  config: WebhookConfig,\r\n  event: WebhookEvent,\r\n  attempt: number = 1\r\n): Promise<{ \r\n  success: boolean; \r\n  statusCode?: number; \r\n  error?: string;\r\n  retryable?: boolean;\r\n  retryDelay?: number;\r\n}> {\r\n  const payload = JSON.stringify(event);\r\n  const signature = generateWebhookSignature(payload, config.secret);\r\n  const isRetry = attempt > 1;\r\n  \r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    const response = await fetch(config.url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'X-Webhook-Signature': signature,\r\n        'X-Webhook-Event': event.event,\r\n        'X-Webhook-Timestamp': event.timestamp,\r\n        'X-Webhook-Delivery-Id': event.id,\r\n        'X-Webhook-Attempt': attempt.toString(),\r\n        'User-Agent': 'NexFlow-Webhooks/1.0',\r\n      },\r\n      body: payload,\r\n      signal: AbortSignal.timeout(WEBHOOK_CONFIG.requestTimeout),\r\n    });\r\n    \r\n    const responseBody = await response.text().catch(() => '');\r\n    const latencyMs = Date.now() - startTime;\r\n    \r\n    if (response.ok) {\r\n      recordDeliveryMetric(config.url, true, isRetry);\r\n      \r\n      logger.info({\r\n        webhookConfigId: config.id,\r\n        eventId: event.id,\r\n        eventType: event.event,\r\n        statusCode: response.status,\r\n        latencyMs,\r\n        attempt,\r\n      }, 'Webhook delivered successfully');\r\n      \r\n      return {\r\n        success: true,\r\n        statusCode: response.status,\r\n      };\r\n    } else {\r\n      const retryable = isRetryableStatus(response.status);\r\n      const retryDelay = retryable ? calculateRetryDelay(attempt - 1) : undefined;\r\n      \r\n      recordDeliveryMetric(config.url, false, isRetry);\r\n      \r\n      logger.warn({\r\n        webhookConfigId: config.id,\r\n        eventId: event.id,\r\n        eventType: event.event,\r\n        statusCode: response.status,\r\n        responseBody: responseBody.substring(0, 200),\r\n        latencyMs,\r\n        attempt,\r\n        retryable,\r\n        retryDelay,\r\n      }, 'Webhook delivery failed');\r\n      \r\n      return {\r\n        success: false,\r\n        statusCode: response.status,\r\n        error: `HTTP ${response.status}: ${responseBody.substring(0, 100)}`,\r\n        retryable,\r\n        retryDelay,\r\n      };\r\n    }\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n    const retryable = error instanceof Error && isRetryableError(error);\r\n    const retryDelay = retryable ? calculateRetryDelay(attempt - 1) : undefined;\r\n    const latencyMs = Date.now() - startTime;\r\n    \r\n    recordDeliveryMetric(config.url, false, isRetry);\r\n    \r\n    logger.error({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      eventType: event.event,\r\n      error: errorMessage,\r\n      latencyMs,\r\n      attempt,\r\n      retryable,\r\n      retryDelay,\r\n    }, 'Webhook delivery error');\r\n    \r\n    return {\r\n      success: false,\r\n      error: errorMessage,\r\n      retryable,\r\n      retryDelay,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate next retry delay with exponential backoff and jitter\r\n * \r\n * Formula: delay = min(maxDelay, baseDelay * 2^attempt) * (1 + random * jitter)\r\n * \r\n * @param attempt - Current attempt number (0-indexed)\r\n * @returns Delay in milliseconds\r\n */\r\nfunction calculateRetryDelay(attempt: number): number {\r\n  const { baseDelay, maxDelay, jitterFactor } = WEBHOOK_CONFIG;\r\n  \r\n  // Exponential backoff\r\n  const exponentialDelay = baseDelay * Math.pow(2, attempt);\r\n  const cappedDelay = Math.min(exponentialDelay, maxDelay);\r\n  \r\n  // Add jitter (random variance to prevent thundering herd)\r\n  const jitter = 1 + (Math.random() * jitterFactor * 2 - jitterFactor);\r\n  \r\n  return Math.round(cappedDelay * jitter);\r\n}\r\n\r\n/**\r\n * Determine if an HTTP status code is retryable\r\n */\r\nfunction isRetryableStatus(statusCode: number): boolean {\r\n  // Retry on server errors (5xx) and some client errors\r\n  if (statusCode >= 500 && statusCode < 600) return true;\r\n  if (statusCode === 408) return true; // Request Timeout\r\n  if (statusCode === 429) return true; // Too Many Requests\r\n  return false;\r\n}\r\n\r\n/**\r\n * Determine if an error is retryable\r\n */\r\nfunction isRetryableError(error: Error): boolean {\r\n  const message = error.message.toLowerCase();\r\n  return (\r\n    message.includes('timeout') ||\r\n    message.includes('econnrefused') ||\r\n    message.includes('econnreset') ||\r\n    message.includes('enotfound') ||\r\n    message.includes('socket hang up') ||\r\n    message.includes('network')\r\n  );\r\n}\r\n\r\n/**\r\n * Queue webhook for delivery with retry logic (uses BullMQ)\r\n */\r\nexport async function queueWebhookDelivery(\r\n  config: WebhookConfig,\r\n  event: WebhookEvent\r\n): Promise<void> {\r\n  try {\r\n    const payload = JSON.stringify(event);\r\n    const signature = generateWebhookSignature(payload, config.secret);\r\n    \r\n    // Create delivery record in database\r\n    await webhookDeliveriesDb.createDeliveryRecord({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      eventType: event.event,\r\n      url: config.url,\r\n      payload,\r\n      signature,\r\n      maxAttempts: WEBHOOK_CONFIG.maxAttempts,\r\n    });\r\n    \r\n    // Enqueue job in BullMQ (lazy import)\r\n    const enqueueWebhookDelivery = await getWebhookQueue();\r\n    if (enqueueWebhookDelivery) {\r\n      await enqueueWebhookDelivery({\r\n        webhookConfigId: config.id,\r\n        eventId: event.id,\r\n        eventType: event.event,\r\n        url: config.url,\r\n        payload,\r\n        signature,\r\n      });\r\n      \r\n      logger.info({\r\n        webhookConfigId: config.id,\r\n        eventId: event.id,\r\n        eventType: event.event,\r\n        url: config.url,\r\n        maxAttempts: WEBHOOK_CONFIG.maxAttempts,\r\n      }, 'Webhook queued for delivery');\r\n    } else {\r\n      // Fallback: deliver with retry logic inline\r\n      logger.warn({\r\n        webhookConfigId: config.id,\r\n        eventId: event.id,\r\n      }, 'Webhook queue not available, delivering with inline retry');\r\n      \r\n      await deliverWithRetry(config, event);\r\n    }\r\n  } catch (error) {\r\n    logger.error({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      error,\r\n    }, 'Failed to queue webhook delivery');\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Deliver webhook with retry logic (inline, without queue)\r\n */\r\nasync function deliverWithRetry(\r\n  config: WebhookConfig,\r\n  event: WebhookEvent\r\n): Promise<void> {\r\n  let attempt = 1;\r\n  \r\n  while (attempt <= WEBHOOK_CONFIG.maxAttempts) {\r\n    const result = await deliverWebhook(config, event, attempt);\r\n    \r\n    if (result.success) {\r\n      return;\r\n    }\r\n    \r\n    // Check if we should retry\r\n    if (!result.retryable || attempt >= WEBHOOK_CONFIG.maxAttempts) {\r\n      // No retry - check if should go to DLQ\r\n      if (WEBHOOK_CONFIG.enableDLQ) {\r\n        await sendToDeadLetterQueue(config, event, result.error || 'Unknown error', attempt);\r\n      }\r\n      \r\n      logger.error({\r\n        webhookConfigId: config.id,\r\n        eventId: event.id,\r\n        eventType: event.event,\r\n        attempts: attempt,\r\n        error: result.error,\r\n        sentToDLQ: WEBHOOK_CONFIG.enableDLQ,\r\n      }, 'Webhook delivery failed permanently');\r\n      \r\n      return;\r\n    }\r\n    \r\n    // Wait before retry\r\n    const delay = result.retryDelay || calculateRetryDelay(attempt - 1);\r\n    logger.info({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      attempt,\r\n      nextAttempt: attempt + 1,\r\n      delayMs: delay,\r\n    }, 'Scheduling webhook retry');\r\n    \r\n    await new Promise(resolve => setTimeout(resolve, delay));\r\n    attempt++;\r\n  }\r\n}\r\n\r\n/**\r\n * Send failed webhook to dead letter queue for manual review\r\n */\r\nasync function sendToDeadLetterQueue(\r\n  config: WebhookConfig,\r\n  event: WebhookEvent,\r\n  error: string,\r\n  attempts: number\r\n): Promise<void> {\r\n  metrics.dlqCount++;\r\n  \r\n  try {\r\n    await webhookDeliveriesDb.markDeliveryFailed({\r\n      eventId: event.id,\r\n      webhookConfigId: config.id,\r\n      error,\r\n      attempts,\r\n      sentToDLQ: true,\r\n    });\r\n    \r\n    logger.warn({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      eventType: event.event,\r\n      error,\r\n      attempts,\r\n    }, 'Webhook sent to dead letter queue');\r\n  } catch (dlqError) {\r\n    logger.error({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      dlqError,\r\n    }, 'Failed to send webhook to dead letter queue');\r\n  }\r\n}\r\n\r\n/**\r\n * Attempt webhook delivery with retry logic (used by BullMQ worker)\r\n */\r\nasync function attemptWebhookDelivery(\r\n  config: WebhookConfig,\r\n  event: WebhookEvent,\r\n  delivery: Omit<WebhookDelivery, 'id' | 'createdAt'>\r\n): Promise<void> {\r\n  delivery.attempts++;\r\n  const result = await deliverWebhook(config, event, delivery.attempts);\r\n  \r\n  delivery.lastAttemptAt = new Date().toISOString();\r\n  delivery.lastResponseCode = result.statusCode;\r\n  \r\n  if (result.success) {\r\n    delivery.status = 'delivered';\r\n    delivery.deliveredAt = new Date().toISOString();\r\n    \r\n    logger.info({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      attempts: delivery.attempts,\r\n    }, 'Webhook delivered');\r\n    \r\n    return;\r\n  }\r\n  \r\n  // Check if we should retry\r\n  const canRetry = result.retryable && delivery.attempts < delivery.maxAttempts;\r\n  \r\n  if (!canRetry) {\r\n    delivery.status = 'failed';\r\n    \r\n    // Send to DLQ if enabled\r\n    if (WEBHOOK_CONFIG.enableDLQ) {\r\n      await sendToDeadLetterQueue(config, event, result.error || 'Unknown error', delivery.attempts);\r\n    }\r\n    \r\n    logger.error({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      attempts: delivery.attempts,\r\n      maxAttempts: delivery.maxAttempts,\r\n      error: result.error,\r\n      retryable: result.retryable,\r\n      sentToDLQ: WEBHOOK_CONFIG.enableDLQ,\r\n    }, 'Webhook delivery failed after max attempts');\r\n    \r\n    return;\r\n  }\r\n  \r\n  // Schedule retry\r\n  const retryDelay = result.retryDelay || calculateRetryDelay(delivery.attempts - 1);\r\n  delivery.nextRetryAt = new Date(Date.now() + retryDelay).toISOString();\r\n  delivery.status = 'pending';\r\n  \r\n  logger.info({\r\n    webhookConfigId: config.id,\r\n    eventId: event.id,\r\n    attempts: delivery.attempts,\r\n    maxAttempts: delivery.maxAttempts,\r\n    nextRetryAt: delivery.nextRetryAt,\r\n    retryDelayMs: retryDelay,\r\n  }, 'Webhook scheduled for retry');\r\n  \r\n  // Schedule retry (in production, BullMQ handles this)\r\n  setTimeout(async () => {\r\n    await attemptWebhookDelivery(config, event, delivery);\r\n  }, retryDelay);\r\n}\r\n\r\n/**\r\n * Get webhook configs for an event type\r\n */\r\nexport async function getWebhookConfigsForEvent(\r\n  eventType: WebhookEventType,\r\n  endpointId?: string\r\n): Promise<WebhookConfig[]> {\r\n  try {\r\n    const { getWebhookConfigs } = await import('./webhook-config-store');\r\n    const allConfigs = await getWebhookConfigs({\r\n      endpointId: endpointId || undefined,\r\n      enabled: true,\r\n    });\r\n    \r\n    return allConfigs.filter(config => {\r\n      if (!config.enabled) return false;\r\n      if (!config.events.includes(eventType)) return false;\r\n      if (endpointId && config.endpointId && config.endpointId !== endpointId) return false;\r\n      return true;\r\n    });\r\n  } catch (error) {\r\n    logger.error('Failed to get webhook configs', { eventType, endpointId, error });\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Trigger webhook for an event\r\n */\r\nexport async function triggerWebhook(\r\n  eventType: WebhookEventType,\r\n  data: Record<string, any>,\r\n  endpointId?: string\r\n): Promise<void> {\r\n  try {\r\n    const event = createWebhookEvent(eventType, data);\r\n    const configs = await getWebhookConfigsForEvent(eventType, endpointId);\r\n    \r\n    // Filter enabled configs\r\n    const enabledConfigs = configs.filter(c => c.enabled);\r\n    \r\n    // Filter by endpoint if specified\r\n    const relevantConfigs = endpointId\r\n      ? enabledConfigs.filter(c => !c.endpointId || c.endpointId === endpointId)\r\n      : enabledConfigs.filter(c => !c.endpointId);\r\n    \r\n    // Queue delivery for each config\r\n    for (const config of relevantConfigs) {\r\n      await queueWebhookDelivery(config, event);\r\n    }\r\n    \r\n    logger.info('Webhooks triggered', {\r\n      eventType,\r\n      endpointId,\r\n      configCount: relevantConfigs.length,\r\n    });\r\n  } catch (error) {\r\n    logger.error('Failed to trigger webhook', {\r\n      eventType,\r\n      endpointId,\r\n      error,\r\n    });\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;AAC1B,gFAAgF;AAChF,qFAAqF;AACrF,EAAE;AACF,YAAY;AACZ,oCAAoC;AACpC,gDAAgD;AAChD,8BAA8B;AAC9B,iCAAiC;AACjC,uBAAuB;;;;;;;;;;;;;;;;;;;;;AAEvB;AACA;AACA;;;;;;;;AAEA,2DAA2D;AAC3D,eAAe;IACb,IAAI;QACF,MAAM,EAAE,sBAAsB,EAAE,GAAG;QACnC,OAAO;IACT,EAAE,OAAO,OAAO;QACd,OAAO,IAAI,CAAC,6DAA6D;YAAE;QAAM;QACjF,OAAO;IACT;AACF;AAEA,MAAM,SAAS,IAAA,sIAAY,EAAC;IAAE,WAAW;AAAkB;AAMpD,MAAM,iBAAiB;IAC5B,wCAAwC,GACxC,aAAa,SAAS,QAAQ,GAAG,CAAC,oBAAoB,IAAI,KAAK;IAE/D,4CAA4C,GAC5C,WAAW,SAAS,QAAQ,GAAG,CAAC,qBAAqB,IAAI,QAAQ;IAEjE,uCAAuC,GACvC,UAAU,SAAS,QAAQ,GAAG,CAAC,oBAAoB,IAAI,UAAU;IAEjE,yBAAyB,GACzB,gBAAgB,SAAS,QAAQ,GAAG,CAAC,kBAAkB,IAAI,SAAS;IAEpE,iDAAiD,GACjD,WAAW,QAAQ,GAAG,CAAC,kBAAkB,KAAK;IAE9C,+CAA+C,GAC/C,cAAc,WAAW,QAAQ,GAAG,CAAC,qBAAqB,IAAI;AAChE;AAeA,MAAM,UAA0B;IAC9B,WAAW;IACX,QAAQ;IACR,SAAS;IACT,UAAU;IACV,YAAY,IAAI;IAChB,WAAW,KAAK,GAAG;AACrB;AAEA,MAAM,yBAAyB,KAAK,KAAK,MAAM,SAAS;AAExD,SAAS,qBAAqB,GAAW,EAAE,OAAgB,EAAE,UAAmB,KAAK;IACnF,uBAAuB;IACvB,IAAI,KAAK,GAAG,KAAK,QAAQ,SAAS,GAAG,wBAAwB;QAC3D,QAAQ,SAAS,GAAG;QACpB,QAAQ,MAAM,GAAG;QACjB,QAAQ,OAAO,GAAG;QAClB,QAAQ,UAAU,CAAC,KAAK;QACxB,QAAQ,SAAS,GAAG,KAAK,GAAG;IAC9B;IAEA,IAAI,SAAS;QACX,QAAQ,SAAS;IACnB,OAAO;QACL,QAAQ,MAAM;IAChB;IAEA,IAAI,SAAS;QACX,QAAQ,OAAO;IACjB;IAEA,wCAAwC;IACxC,IAAI;QACF,MAAM,WAAW,IAAI,IAAI,KAAK,QAAQ;QACtC,MAAM,kBAAkB,QAAQ,UAAU,CAAC,GAAG,CAAC,aAAa;YAAE,WAAW;YAAG,QAAQ;QAAE;QACtF,IAAI,SAAS;YACX,gBAAgB,SAAS;QAC3B,OAAO;YACL,gBAAgB,MAAM;QACxB;QACA,QAAQ,UAAU,CAAC,GAAG,CAAC,UAAU;IACnC,EAAE,OAAM;IACN,sCAAsC;IACxC;AACF;AAKO,SAAS;IASd,MAAM,QAAQ,QAAQ,SAAS,GAAG,QAAQ,MAAM;IAChD,MAAM,aAAkC,CAAC;IAEzC,QAAQ,UAAU,CAAC,OAAO,CAAC,CAAC,OAAO;QACjC,MAAM,gBAAgB,MAAM,SAAS,GAAG,MAAM,MAAM;QACpD,UAAU,CAAC,SAAS,GAAG;YACrB,GAAG,KAAK;YACR,aAAa,gBAAgB,IACzB,CAAC,AAAC,MAAM,SAAS,GAAG,gBAAiB,GAAG,EAAE,OAAO,CAAC,KAAK,MACvD;QACN;IACF;IAEA,OAAO;QACL,WAAW,QAAQ,SAAS;QAC5B,QAAQ,QAAQ,MAAM;QACtB,SAAS,QAAQ,OAAO;QACxB,UAAU,QAAQ,QAAQ;QAC1B,aAAa,QAAQ,IACjB,CAAC,AAAC,QAAQ,SAAS,GAAG,QAAS,GAAG,EAAE,OAAO,CAAC,KAAK,MACjD;QACJ;QACA,WAAW,IAAI,KAAK,QAAQ,SAAS,EAAE,WAAW;IACpD;AACF;AAkDO,SAAS,yBACd,OAAe,EACf,MAAc;IAEd,OAAO,gHAAM,CACV,UAAU,CAAC,UAAU,QACrB,MAAM,CAAC,SACP,MAAM,CAAC;AACZ;AAKO,SAAS,uBACd,OAAe,EACf,SAAiB,EACjB,MAAc;IAEd,MAAM,oBAAoB,yBAAyB,SAAS;IAC5D,OAAO,gHAAM,CAAC,eAAe,CAC3B,OAAO,IAAI,CAAC,YACZ,OAAO,IAAI,CAAC;AAEhB;AAKO,SAAS,mBACd,KAAuB,EACvB,IAAyB;IAEzB,OAAO;QACL,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,IAAI;QACrE;QACA,WAAW,IAAI,OAAO,WAAW;QACjC;IACF;AACF;AAKO,eAAe,eACpB,MAAqB,EACrB,KAAmB,EACnB,UAAkB,CAAC;IAQnB,MAAM,UAAU,KAAK,SAAS,CAAC;IAC/B,MAAM,YAAY,yBAAyB,SAAS,OAAO,MAAM;IACjE,MAAM,UAAU,UAAU;IAE1B,MAAM,YAAY,KAAK,GAAG;IAE1B,IAAI;QACF,MAAM,WAAW,MAAM,MAAM,OAAO,GAAG,EAAE;YACvC,QAAQ;YACR,SAAS;gBACP,gBAAgB;gBAChB,uBAAuB;gBACvB,mBAAmB,MAAM,KAAK;gBAC9B,uBAAuB,MAAM,SAAS;gBACtC,yBAAyB,MAAM,EAAE;gBACjC,qBAAqB,QAAQ,QAAQ;gBACrC,cAAc;YAChB;YACA,MAAM;YACN,QAAQ,YAAY,OAAO,CAAC,eAAe,cAAc;QAC3D;QAEA,MAAM,eAAe,MAAM,SAAS,IAAI,GAAG,KAAK,CAAC,IAAM;QACvD,MAAM,YAAY,KAAK,GAAG,KAAK;QAE/B,IAAI,SAAS,EAAE,EAAE;YACf,qBAAqB,OAAO,GAAG,EAAE,MAAM;YAEvC,OAAO,IAAI,CAAC;gBACV,iBAAiB,OAAO,EAAE;gBAC1B,SAAS,MAAM,EAAE;gBACjB,WAAW,MAAM,KAAK;gBACtB,YAAY,SAAS,MAAM;gBAC3B;gBACA;YACF,GAAG;YAEH,OAAO;gBACL,SAAS;gBACT,YAAY,SAAS,MAAM;YAC7B;QACF,OAAO;YACL,MAAM,YAAY,kBAAkB,SAAS,MAAM;YACnD,MAAM,aAAa,YAAY,oBAAoB,UAAU,KAAK;YAElE,qBAAqB,OAAO,GAAG,EAAE,OAAO;YAExC,OAAO,IAAI,CAAC;gBACV,iBAAiB,OAAO,EAAE;gBAC1B,SAAS,MAAM,EAAE;gBACjB,WAAW,MAAM,KAAK;gBACtB,YAAY,SAAS,MAAM;gBAC3B,cAAc,aAAa,SAAS,CAAC,GAAG;gBACxC;gBACA;gBACA;gBACA;YACF,GAAG;YAEH,OAAO;gBACL,SAAS;gBACT,YAAY,SAAS,MAAM;gBAC3B,OAAO,CAAC,KAAK,EAAE,SAAS,MAAM,CAAC,EAAE,EAAE,aAAa,SAAS,CAAC,GAAG,MAAM;gBACnE;gBACA;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAC9D,MAAM,YAAY,iBAAiB,SAAS,iBAAiB;QAC7D,MAAM,aAAa,YAAY,oBAAoB,UAAU,KAAK;QAClE,MAAM,YAAY,KAAK,GAAG,KAAK;QAE/B,qBAAqB,OAAO,GAAG,EAAE,OAAO;QAExC,OAAO,KAAK,CAAC;YACX,iBAAiB,OAAO,EAAE;YAC1B,SAAS,MAAM,EAAE;YACjB,WAAW,MAAM,KAAK;YACtB,OAAO;YACP;YACA;YACA;YACA;QACF,GAAG;QAEH,OAAO;YACL,SAAS;YACT,OAAO;YACP;YACA;QACF;IACF;AACF;AAEA;;;;;;;CAOC,GACD,SAAS,oBAAoB,OAAe;IAC1C,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,YAAY,EAAE,GAAG;IAE9C,sBAAsB;IACtB,MAAM,mBAAmB,YAAY,KAAK,GAAG,CAAC,GAAG;IACjD,MAAM,cAAc,KAAK,GAAG,CAAC,kBAAkB;IAE/C,0DAA0D;IAC1D,MAAM,SAAS,IAAI,CAAC,KAAK,MAAM,KAAK,eAAe,IAAI,YAAY;IAEnE,OAAO,KAAK,KAAK,CAAC,cAAc;AAClC;AAEA;;CAEC,GACD,SAAS,kBAAkB,UAAkB;IAC3C,sDAAsD;IACtD,IAAI,cAAc,OAAO,aAAa,KAAK,OAAO;IAClD,IAAI,eAAe,KAAK,OAAO,MAAM,kBAAkB;IACvD,IAAI,eAAe,KAAK,OAAO,MAAM,oBAAoB;IACzD,OAAO;AACT;AAEA;;CAEC,GACD,SAAS,iBAAiB,KAAY;IACpC,MAAM,UAAU,MAAM,OAAO,CAAC,WAAW;IACzC,OACE,QAAQ,QAAQ,CAAC,cACjB,QAAQ,QAAQ,CAAC,mBACjB,QAAQ,QAAQ,CAAC,iBACjB,QAAQ,QAAQ,CAAC,gBACjB,QAAQ,QAAQ,CAAC,qBACjB,QAAQ,QAAQ,CAAC;AAErB;AAKO,eAAe,qBACpB,MAAqB,EACrB,KAAmB;IAEnB,IAAI;QACF,MAAM,UAAU,KAAK,SAAS,CAAC;QAC/B,MAAM,YAAY,yBAAyB,SAAS,OAAO,MAAM;QAEjE,qCAAqC;QACrC,MAAM,4JAAwC,CAAC;YAC7C,iBAAiB,OAAO,EAAE;YAC1B,SAAS,MAAM,EAAE;YACjB,WAAW,MAAM,KAAK;YACtB,KAAK,OAAO,GAAG;YACf;YACA;YACA,aAAa,eAAe,WAAW;QACzC;QAEA,sCAAsC;QACtC,MAAM,yBAAyB,MAAM;QACrC,IAAI,wBAAwB;YAC1B,MAAM,uBAAuB;gBAC3B,iBAAiB,OAAO,EAAE;gBAC1B,SAAS,MAAM,EAAE;gBACjB,WAAW,MAAM,KAAK;gBACtB,KAAK,OAAO,GAAG;gBACf;gBACA;YACF;YAEA,OAAO,IAAI,CAAC;gBACV,iBAAiB,OAAO,EAAE;gBAC1B,SAAS,MAAM,EAAE;gBACjB,WAAW,MAAM,KAAK;gBACtB,KAAK,OAAO,GAAG;gBACf,aAAa,eAAe,WAAW;YACzC,GAAG;QACL,OAAO;YACL,4CAA4C;YAC5C,OAAO,IAAI,CAAC;gBACV,iBAAiB,OAAO,EAAE;gBAC1B,SAAS,MAAM,EAAE;YACnB,GAAG;YAEH,MAAM,iBAAiB,QAAQ;QACjC;IACF,EAAE,OAAO,OAAO;QACd,OAAO,KAAK,CAAC;YACX,iBAAiB,OAAO,EAAE;YAC1B,SAAS,MAAM,EAAE;YACjB;QACF,GAAG;QACH,MAAM;IACR;AACF;AAEA;;CAEC,GACD,eAAe,iBACb,MAAqB,EACrB,KAAmB;IAEnB,IAAI,UAAU;IAEd,MAAO,WAAW,eAAe,WAAW,CAAE;QAC5C,MAAM,SAAS,MAAM,eAAe,QAAQ,OAAO;QAEnD,IAAI,OAAO,OAAO,EAAE;YAClB;QACF;QAEA,2BAA2B;QAC3B,IAAI,CAAC,OAAO,SAAS,IAAI,WAAW,eAAe,WAAW,EAAE;YAC9D,uCAAuC;YACvC,IAAI,eAAe,SAAS,EAAE;gBAC5B,MAAM,sBAAsB,QAAQ,OAAO,OAAO,KAAK,IAAI,iBAAiB;YAC9E;YAEA,OAAO,KAAK,CAAC;gBACX,iBAAiB,OAAO,EAAE;gBAC1B,SAAS,MAAM,EAAE;gBACjB,WAAW,MAAM,KAAK;gBACtB,UAAU;gBACV,OAAO,OAAO,KAAK;gBACnB,WAAW,eAAe,SAAS;YACrC,GAAG;YAEH;QACF;QAEA,oBAAoB;QACpB,MAAM,QAAQ,OAAO,UAAU,IAAI,oBAAoB,UAAU;QACjE,OAAO,IAAI,CAAC;YACV,iBAAiB,OAAO,EAAE;YAC1B,SAAS,MAAM,EAAE;YACjB;YACA,aAAa,UAAU;YACvB,SAAS;QACX,GAAG;QAEH,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;QACjD;IACF;AACF;AAEA;;CAEC,GACD,eAAe,sBACb,MAAqB,EACrB,KAAmB,EACnB,KAAa,EACb,QAAgB;IAEhB,QAAQ,QAAQ;IAEhB,IAAI;QACF,MAAM,0JAAsC,CAAC;YAC3C,SAAS,MAAM,EAAE;YACjB,iBAAiB,OAAO,EAAE;YAC1B;YACA;YACA,WAAW;QACb;QAEA,OAAO,IAAI,CAAC;YACV,iBAAiB,OAAO,EAAE;YAC1B,SAAS,MAAM,EAAE;YACjB,WAAW,MAAM,KAAK;YACtB;YACA;QACF,GAAG;IACL,EAAE,OAAO,UAAU;QACjB,OAAO,KAAK,CAAC;YACX,iBAAiB,OAAO,EAAE;YAC1B,SAAS,MAAM,EAAE;YACjB;QACF,GAAG;IACL;AACF;AAEA;;CAEC,GACD,eAAe,uBACb,MAAqB,EACrB,KAAmB,EACnB,QAAmD;IAEnD,SAAS,QAAQ;IACjB,MAAM,SAAS,MAAM,eAAe,QAAQ,OAAO,SAAS,QAAQ;IAEpE,SAAS,aAAa,GAAG,IAAI,OAAO,WAAW;IAC/C,SAAS,gBAAgB,GAAG,OAAO,UAAU;IAE7C,IAAI,OAAO,OAAO,EAAE;QAClB,SAAS,MAAM,GAAG;QAClB,SAAS,WAAW,GAAG,IAAI,OAAO,WAAW;QAE7C,OAAO,IAAI,CAAC;YACV,iBAAiB,OAAO,EAAE;YAC1B,SAAS,MAAM,EAAE;YACjB,UAAU,SAAS,QAAQ;QAC7B,GAAG;QAEH;IACF;IAEA,2BAA2B;IAC3B,MAAM,WAAW,OAAO,SAAS,IAAI,SAAS,QAAQ,GAAG,SAAS,WAAW;IAE7E,IAAI,CAAC,UAAU;QACb,SAAS,MAAM,GAAG;QAElB,yBAAyB;QACzB,IAAI,eAAe,SAAS,EAAE;YAC5B,MAAM,sBAAsB,QAAQ,OAAO,OAAO,KAAK,IAAI,iBAAiB,SAAS,QAAQ;QAC/F;QAEA,OAAO,KAAK,CAAC;YACX,iBAAiB,OAAO,EAAE;YAC1B,SAAS,MAAM,EAAE;YACjB,UAAU,SAAS,QAAQ;YAC3B,aAAa,SAAS,WAAW;YACjC,OAAO,OAAO,KAAK;YACnB,WAAW,OAAO,SAAS;YAC3B,WAAW,eAAe,SAAS;QACrC,GAAG;QAEH;IACF;IAEA,iBAAiB;IACjB,MAAM,aAAa,OAAO,UAAU,IAAI,oBAAoB,SAAS,QAAQ,GAAG;IAChF,SAAS,WAAW,GAAG,IAAI,KAAK,KAAK,GAAG,KAAK,YAAY,WAAW;IACpE,SAAS,MAAM,GAAG;IAElB,OAAO,IAAI,CAAC;QACV,iBAAiB,OAAO,EAAE;QAC1B,SAAS,MAAM,EAAE;QACjB,UAAU,SAAS,QAAQ;QAC3B,aAAa,SAAS,WAAW;QACjC,aAAa,SAAS,WAAW;QACjC,cAAc;IAChB,GAAG;IAEH,sDAAsD;IACtD,WAAW;QACT,MAAM,uBAAuB,QAAQ,OAAO;IAC9C,GAAG;AACL;AAKO,eAAe,0BACpB,SAA2B,EAC3B,UAAmB;IAEnB,IAAI;QACF,MAAM,EAAE,iBAAiB,EAAE,GAAG;QAC9B,MAAM,aAAa,MAAM,kBAAkB;YACzC,YAAY,cAAc;YAC1B,SAAS;QACX;QAEA,OAAO,WAAW,MAAM,CAAC,CAAA;YACvB,IAAI,CAAC,OAAO,OAAO,EAAE,OAAO;YAC5B,IAAI,CAAC,OAAO,MAAM,CAAC,QAAQ,CAAC,YAAY,OAAO;YAC/C,IAAI,cAAc,OAAO,UAAU,IAAI,OAAO,UAAU,KAAK,YAAY,OAAO;YAChF,OAAO;QACT;IACF,EAAE,OAAO,OAAO;QACd,OAAO,KAAK,CAAC,iCAAiC;YAAE;YAAW;YAAY;QAAM;QAC7E,OAAO,EAAE;IACX;AACF;AAKO,eAAe,eACpB,SAA2B,EAC3B,IAAyB,EACzB,UAAmB;IAEnB,IAAI;QACF,MAAM,QAAQ,mBAAmB,WAAW;QAC5C,MAAM,UAAU,MAAM,0BAA0B,WAAW;QAE3D,yBAAyB;QACzB,MAAM,iBAAiB,QAAQ,MAAM,CAAC,CAAA,IAAK,EAAE,OAAO;QAEpD,kCAAkC;QAClC,MAAM,kBAAkB,aACpB,eAAe,MAAM,CAAC,CAAA,IAAK,CAAC,EAAE,UAAU,IAAI,EAAE,UAAU,KAAK,cAC7D,eAAe,MAAM,CAAC,CAAA,IAAK,CAAC,EAAE,UAAU;QAE5C,iCAAiC;QACjC,KAAK,MAAM,UAAU,gBAAiB;YACpC,MAAM,qBAAqB,QAAQ;QACrC;QAEA,OAAO,IAAI,CAAC,sBAAsB;YAChC;YACA;YACA,aAAa,gBAAgB,MAAM;QACrC;IACF,EAAE,OAAO,OAAO;QACd,OAAO,KAAK,CAAC,6BAA6B;YACxC;YACA;YACA;QACF;IACF;AACF"}},
    {"offset": {"line": 14778, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/concurrent-request-limiter.ts"],"sourcesContent":["// =============================================================================\r\n// Concurrent Request Limiter\r\n// =============================================================================\r\n// Prevents resource exhaustion by limiting concurrent requests per user/IP/endpoint\r\n// Uses in-memory semaphore pattern (can upgrade to Redis for multi-instance)\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'ConcurrentRequestLimiter' });\r\n\r\nexport interface ConcurrentLimitConfig {\r\n  maxConcurrent: number; // Maximum concurrent requests\r\n  windowMs?: number; // Time window for tracking (default: 1 minute)\r\n  identifier: string; // Unique identifier (e.g., \"ip:1.2.3.4\" or \"endpoint:ep_123:ip:1.2.3.4\")\r\n}\r\n\r\ninterface RequestTracker {\r\n  count: number;\r\n  lastReset: number;\r\n  activeRequests: Set<string>; // Track active request IDs\r\n}\r\n\r\n// In-memory store: { identifier: RequestTracker }\r\nconst requestTrackers = new Map<string, RequestTracker>();\r\n\r\n// Cleanup old trackers every 5 minutes\r\nsetInterval(() => {\r\n  const now = Date.now();\r\n  const maxAge = 5 * 60 * 1000; // 5 minutes\r\n  const keysToDelete: string[] = [];\r\n  \r\n  requestTrackers.forEach((tracker, key) => {\r\n    // Delete if no active requests and last reset was more than maxAge ago\r\n    if (tracker.activeRequests.size === 0 && now - tracker.lastReset > maxAge) {\r\n      keysToDelete.push(key);\r\n    }\r\n  });\r\n  \r\n  keysToDelete.forEach(key => requestTrackers.delete(key));\r\n}, 5 * 60 * 1000);\r\n\r\n/**\r\n * Check if a new request can proceed (not exceeding concurrent limit)\r\n * Returns true if allowed, false if limit exceeded\r\n */\r\nexport function checkConcurrentLimit(config: ConcurrentLimitConfig): {\r\n  allowed: boolean;\r\n  current: number;\r\n  limit: number;\r\n  identifier: string;\r\n} {\r\n  const windowMs = config.windowMs || 60 * 1000; // Default 1 minute\r\n  const now = Date.now();\r\n  const identifier = config.identifier;\r\n  \r\n  let tracker = requestTrackers.get(identifier);\r\n  \r\n  // Initialize tracker if it doesn't exist\r\n  if (!tracker) {\r\n    tracker = {\r\n      count: 0,\r\n      lastReset: now,\r\n      activeRequests: new Set(),\r\n    };\r\n    requestTrackers.set(identifier, tracker);\r\n  }\r\n  \r\n  // Reset count if window expired\r\n  if (now - tracker.lastReset > windowMs) {\r\n    tracker.count = 0;\r\n    tracker.lastReset = now;\r\n    tracker.activeRequests.clear();\r\n  }\r\n  \r\n  // Check if we're at the limit\r\n  const currentActive = tracker.activeRequests.size;\r\n  const allowed = currentActive < config.maxConcurrent;\r\n  \r\n  return {\r\n    allowed,\r\n    current: currentActive,\r\n    limit: config.maxConcurrent,\r\n    identifier,\r\n  };\r\n}\r\n\r\n/**\r\n * Register a request as starting (increment counter)\r\n * Returns a release function that must be called when request completes\r\n */\r\nexport function acquireConcurrentSlot(config: ConcurrentLimitConfig, requestId: string): {\r\n  success: boolean;\r\n  release: () => void;\r\n  current: number;\r\n  limit: number;\r\n} {\r\n  const check = checkConcurrentLimit(config);\r\n  \r\n  if (!check.allowed) {\r\n    logger.warn('Concurrent request limit exceeded', {\r\n      identifier: config.identifier,\r\n      current: check.current,\r\n      limit: check.limit,\r\n      requestId,\r\n    });\r\n    \r\n    return {\r\n      success: false,\r\n      release: () => {}, // No-op release function\r\n      current: check.current,\r\n      limit: check.limit,\r\n    };\r\n  }\r\n  \r\n  // Acquire slot\r\n  const tracker = requestTrackers.get(config.identifier)!;\r\n  tracker.activeRequests.add(requestId);\r\n  tracker.count++;\r\n  \r\n  logger.debug('Concurrent request slot acquired', {\r\n    identifier: config.identifier,\r\n    current: tracker.activeRequests.size,\r\n    limit: config.maxConcurrent,\r\n    requestId,\r\n  });\r\n  \r\n  // Return release function\r\n  return {\r\n    success: true,\r\n    release: () => {\r\n      const currentTracker = requestTrackers.get(config.identifier);\r\n      if (currentTracker) {\r\n        currentTracker.activeRequests.delete(requestId);\r\n        // Don't decrement count - let it reset with the window\r\n      }\r\n    },\r\n    current: tracker.activeRequests.size,\r\n    limit: config.maxConcurrent,\r\n  };\r\n}\r\n\r\n/**\r\n * Get concurrent request limits for different scopes\r\n */\r\nexport function getConcurrentLimits(): {\r\n  global: number; // Global per-IP limit\r\n  endpoint: number; // Per-endpoint per-IP limit\r\n  user: number; // Per-user (API key) limit\r\n} {\r\n  return {\r\n    global: parseInt(process.env.MAX_CONCURRENT_REQUESTS_GLOBAL || '50', 10),\r\n    endpoint: parseInt(process.env.MAX_CONCURRENT_REQUESTS_ENDPOINT || '20', 10),\r\n    user: parseInt(process.env.MAX_CONCURRENT_REQUESTS_USER || '30', 10),\r\n  };\r\n}\r\n\r\n/**\r\n * Create identifier for global IP-based limit\r\n */\r\nexport function createGlobalIdentifier(ip: string): string {\r\n  return `global:ip:${ip}`;\r\n}\r\n\r\n/**\r\n * Create identifier for endpoint-based limit\r\n */\r\nexport function createEndpointIdentifier(endpointId: string, ip: string): string {\r\n  return `endpoint:${endpointId}:ip:${ip}`;\r\n}\r\n\r\n/**\r\n * Create identifier for user-based limit (API key)\r\n */\r\nexport function createUserIdentifier(apiKeyHash: string): string {\r\n  return `user:${apiKeyHash}`;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 14909, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/app/api/v1/metered/%5BendpointId%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { getCDPFacilitator, type CDPVerifyRequest } from '@/integrations/x402/cdp-facilitator';\r\nimport { getEndpoint, createPayment, createUsageLog } from '@/db/metered-endpoints';\r\nimport { proxyRequest } from '@/lib/upstream-proxy';\r\nimport { proxyRequestWithRetry } from '@/lib/upstream-proxy-enhanced';\r\nimport { getOrCreateRequestId, createRequestLogger } from '@/lib/request-id';\r\nimport { addRequestIdToResponse } from '@/lib/request-id';\r\nimport { getRateLimitHeaders, addRateLimitHeaders } from '@/lib/rate-limit-unified';\r\nimport { create402Response } from '@/integrations/x402/nextjs-adapter';\r\nimport { getX402ResourceServer } from '@/integrations/x402/resource-server';\r\nimport { validateEndpointId, validatePaymentHeader } from '@/lib/input-validator';\r\nimport { getMetaFacilitator, type OrchestrationResult } from '@/integrations/x402/orchestrator/meta-facilitator';\r\nimport type { PaymentRequirements } from '@/integrations/x402/facilitators/base-facilitator';\r\nimport { checkSessionToken, useSessionForPayment, createSessionFromPayment } from '@/integrations/x402/sessions';\r\nimport { networkToCAIP, tokenToCAIP } from '@/integrations/x402/caip-utils';\r\nimport { normalizeToCAIP } from '@/integrations/x402/chain-detection';\r\nimport { verifyPaymentTestOnly, TEST_TOKEN_HEADER, TEST_TOKEN_VALUE } from '@/integrations/x402/test-verification';\r\nimport { logX402Call } from '@/integrations/x402/x402-call-log';\r\nimport { normalizeNetwork } from '@/integrations/x402/amount-utils';\r\nimport { recordRequestMetric, recordPaymentMetric, recordErrorMetric } from '@/lib/metrics-collector';\r\nimport { triggerWebhook } from '@/lib/webhook-delivery';\r\nimport { \r\n  acquireConcurrentSlot, \r\n  createGlobalIdentifier, \r\n  createEndpointIdentifier,\r\n  createUserIdentifier,\r\n  getConcurrentLimits \r\n} from '@/lib/concurrent-request-limiter';\r\n\r\n// Maximum request body size (10MB default, configurable via env)\r\nconst MAX_REQUEST_BODY_SIZE = parseInt(process.env.MAX_REQUEST_BODY_SIZE || '10485760', 10); // 10MB in bytes\r\n\r\n/**\r\n * POST /api/v1/metered/[endpointId]\r\n * \r\n * Metered endpoint that requires x402 payment verification\r\n * \r\n * Headers:\r\n * - Authorization: Bearer <api_key>\r\n * - x-payment: <x402_payment_header>\r\n */\r\nexport async function POST(\r\n  request: NextRequest,\r\n  { params }: { params: Promise<{ endpointId: string }> }\r\n) {\r\n  const requestId = getOrCreateRequestId(request);\r\n  const logger = createRequestLogger(requestId);\r\n  const { endpointId } = await params; // Next.js 15+ requires awaiting params\r\n  const startTime = Date.now();\r\n  \r\n  // Extract tracing fields early for error logging\r\n  const conversationId = request.headers.get('x-conversation-id') || \r\n                       request.headers.get('x-request-id') || \r\n                       requestId;\r\n  const agentId = request.headers.get('x-agent-id') || undefined;\r\n  \r\n  // Extract IP and API key for concurrent limiting\r\n  const ip = request.ip || request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';\r\n  const authHeader = request.headers.get('authorization');\r\n  const apiKeyToken = authHeader?.startsWith('Bearer ') \r\n    ? authHeader.substring(7).trim() \r\n    : authHeader?.trim() || null;\r\n  const apiKeyHash = apiKeyToken ? apiKeyToken.substring(0, 16) : null;\r\n  \r\n  // SECURITY: Check request body size before processing\r\n  const contentLength = request.headers.get('content-length');\r\n  if (contentLength) {\r\n    const bodySize = parseInt(contentLength, 10);\r\n    if (bodySize > MAX_REQUEST_BODY_SIZE) {\r\n      logger.warn('Request body too large', { \r\n        bodySize, \r\n        maxSize: MAX_REQUEST_BODY_SIZE,\r\n        endpointId,\r\n        ip,\r\n      });\r\n      return NextResponse.json(\r\n        {\r\n          error: 'Request body too large',\r\n          code: 'REQUEST_TOO_LARGE',\r\n          maxSize: MAX_REQUEST_BODY_SIZE,\r\n          receivedSize: bodySize,\r\n        },\r\n        { status: 413 }\r\n      );\r\n    }\r\n  }\r\n  \r\n  // SECURITY: Check concurrent request limits\r\n  const concurrentLimits = getConcurrentLimits();\r\n  let concurrentSlot: { success: boolean; release: () => void } | null = null;\r\n  \r\n  // Check global IP limit first\r\n  const globalSlot = acquireConcurrentSlot(\r\n    {\r\n      maxConcurrent: concurrentLimits.global,\r\n      identifier: createGlobalIdentifier(ip),\r\n    },\r\n    requestId\r\n  );\r\n  \r\n  if (!globalSlot.success) {\r\n    logger.warn('Global concurrent request limit exceeded', {\r\n      ip,\r\n      current: globalSlot.current,\r\n      limit: globalSlot.limit,\r\n      endpointId,\r\n    });\r\n    return NextResponse.json(\r\n      {\r\n        error: 'Too many concurrent requests',\r\n        code: 'CONCURRENT_LIMIT_EXCEEDED',\r\n        message: `Maximum ${globalSlot.limit} concurrent requests allowed per IP`,\r\n        retryAfter: 60, // Suggest retry after 1 minute\r\n      },\r\n      { status: 429 }\r\n    );\r\n  }\r\n  \r\n  // Check endpoint-specific limit\r\n  const endpointSlot = acquireConcurrentSlot(\r\n    {\r\n      maxConcurrent: concurrentLimits.endpoint,\r\n      identifier: createEndpointIdentifier(endpointId, ip),\r\n    },\r\n    requestId\r\n  );\r\n  \r\n  if (!endpointSlot.success) {\r\n    globalSlot.release(); // Release global slot\r\n    logger.warn('Endpoint concurrent request limit exceeded', {\r\n      endpointId,\r\n      ip,\r\n      current: endpointSlot.current,\r\n      limit: endpointSlot.limit,\r\n    });\r\n    return NextResponse.json(\r\n      {\r\n        error: 'Too many concurrent requests for this endpoint',\r\n        code: 'ENDPOINT_CONCURRENT_LIMIT_EXCEEDED',\r\n        message: `Maximum ${endpointSlot.limit} concurrent requests allowed per endpoint per IP`,\r\n        retryAfter: 60,\r\n      },\r\n      { status: 429 }\r\n    );\r\n  }\r\n  \r\n  // Check user-specific limit (if API key provided)\r\n  if (apiKeyHash) {\r\n    const userSlot = acquireConcurrentSlot(\r\n      {\r\n        maxConcurrent: concurrentLimits.user,\r\n        identifier: createUserIdentifier(apiKeyHash),\r\n      },\r\n      requestId\r\n    );\r\n    \r\n    if (!userSlot.success) {\r\n      globalSlot.release(); // Release global slot\r\n      endpointSlot.release(); // Release endpoint slot\r\n      logger.warn('User concurrent request limit exceeded', {\r\n        apiKeyHash,\r\n        current: userSlot.current,\r\n        limit: userSlot.limit,\r\n      });\r\n      return NextResponse.json(\r\n        {\r\n          error: 'Too many concurrent requests for this API key',\r\n          code: 'USER_CONCURRENT_LIMIT_EXCEEDED',\r\n          message: `Maximum ${userSlot.limit} concurrent requests allowed per API key`,\r\n          retryAfter: 60,\r\n        },\r\n        { status: 429 }\r\n      );\r\n    }\r\n    \r\n    concurrentSlot = userSlot;\r\n  } else {\r\n    concurrentSlot = endpointSlot;\r\n  }\r\n  \r\n  // Release function that releases all acquired slots\r\n  const releaseAllSlots = () => {\r\n    globalSlot.release();\r\n    endpointSlot.release();\r\n    if (concurrentSlot && concurrentSlot !== endpointSlot) {\r\n      concurrentSlot.release();\r\n    }\r\n  };\r\n  \r\n  try {\r\n    // SECURITY: Validate endpoint ID\r\n    const endpointIdValidation = validateEndpointId(endpointId);\r\n    if (!endpointIdValidation.valid) {\r\n      logger.warn('Invalid endpoint ID', { endpointId, errors: endpointIdValidation.errors });\r\n      return NextResponse.json(\r\n        {\r\n          error: 'Invalid endpoint ID',\r\n          code: 'INVALID_ENDPOINT_ID',\r\n          details: endpointIdValidation.errors,\r\n        },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Get endpoint from database\r\n    const endpoint = await getEndpoint(endpointId);\r\n\r\n    if (!endpoint) {\r\n      return NextResponse.json(\r\n        {\r\n          error: 'Endpoint not found',\r\n          code: 'NOT_FOUND',\r\n        },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    if (endpoint.status !== 'active') {\r\n      return NextResponse.json(\r\n        {\r\n          error: 'Endpoint is not active',\r\n          code: 'ENDPOINT_INACTIVE',\r\n          status: endpoint.status,\r\n        },\r\n        { status: 403 }\r\n      );\r\n    }\r\n\r\n    // PHASE 1.2: Check for session token first (wallet-based sessions)\r\n    const sessionCheck = checkSessionToken(request);\r\n    let paymentVerified = false;\r\n    let sessionUsed = false;\r\n    let transactionHash: string | undefined;\r\n    let paymentId: string | undefined; // Declare at function scope for usage logging\r\n    let verifyResult: OrchestrationResult | undefined; // Declare at function scope for metrics\r\n\r\n    if (sessionCheck.hasSession && sessionCheck.valid && sessionCheck.sessionId) {\r\n      // Session exists and is valid - use session balance\r\n      const useResult = useSessionForPayment(sessionCheck.sessionId, endpoint.price);\r\n      \r\n      if (useResult.success && useResult.remainingAmount) {\r\n        paymentVerified = true;\r\n        sessionUsed = true;\r\n        logger.info('Payment via session', {\r\n          sessionId: sessionCheck.sessionId,\r\n          walletAddress: sessionCheck.walletAddress,\r\n          amount: endpoint.price,\r\n          remainingAmount: useResult.remainingAmount,\r\n        });\r\n      } else {\r\n        // Session doesn't have enough balance\r\n        return NextResponse.json(\r\n          {\r\n            error: 'Insufficient session balance',\r\n            code: 'INSUFFICIENT_SESSION_BALANCE',\r\n            remainingAmount: useResult.remainingAmount,\r\n            details: useResult.error,\r\n          },\r\n          { status: 402 }\r\n        );\r\n      }\r\n    }\r\n\r\n    // Check for test token ONLY if in test mode\r\n    // In CDP mode, test tokens should be ignored and real payment required\r\n    const verifyMode = process.env.X402_VERIFY_MODE?.toLowerCase();\r\n    const testToken = request.headers.get(TEST_TOKEN_HEADER) || \r\n                     request.headers.get(TEST_TOKEN_HEADER.toUpperCase());\r\n    const testModeEnabled = verifyMode === 'test';\r\n    \r\n    // Only use test verification if explicitly in test mode\r\n    // In CDP mode, ignore test tokens and require real payment\r\n    if (!paymentVerified && testModeEnabled && testToken === TEST_TOKEN_VALUE) {\r\n      // Test mode: bypass payment verification\r\n      const testResult = verifyPaymentTestOnly(request);\r\n      if (testResult.success) {\r\n        paymentVerified = true;\r\n        transactionHash = testResult.x402TxHash;\r\n        logger.info('Payment bypassed via test token (test mode)', {\r\n          testToken: testToken,\r\n          facilitator: testResult.facilitator,\r\n        });\r\n        \r\n        // Log test mode success\r\n        const testLatencyMs = Date.now() - startTime;\r\n        try {\r\n          const networkCAIP = normalizeNetwork(endpoint.network);\r\n          const chainId = networkCAIP.split(':')[1] || '8453';\r\n          await logX402Call({\r\n            customerId: conversationId || null,\r\n            endpointId: endpoint.id,\r\n            agentId,\r\n            facilitator: testResult.facilitator || 'TEST_FACILITATOR',\r\n            chainId,\r\n            asset: endpoint.tokenAddress || 'USDC',\r\n            amount: endpoint.price,\r\n            status: 'success',\r\n            x402TxHash: testResult.x402TxHash,\r\n            latencyMs: testLatencyMs,\r\n            resource: `${request.headers.get('host') || 'localhost:3001'}${request.nextUrl.pathname}`,\r\n          });\r\n        } catch (logError) {\r\n          logger.error('Failed to log test mode success', { error: logError });\r\n        }\r\n        \r\n        // Create payment entry for test mode (for E2E testing)\r\n        if (testResult.x402TxHash) {\r\n          logger.info('Creating test mode payment entry', {\r\n            txHash: testResult.x402TxHash,\r\n            endpointId: endpoint.id,\r\n            testModeEnabled,\r\n            testToken: testToken || 'missing',\r\n          });\r\n          try {\r\n            // Extract from address from test token or use a default\r\n            const testFromAddress = request.headers.get('x-test-from-address') || '0x0000000000000000000000000000000000000000';\r\n            logger.info('Calling createPayment', {\r\n              endpointId: endpoint.id,\r\n              txHash: testResult.x402TxHash,\r\n              fromAddress: testFromAddress,\r\n              toAddress: endpoint.recipientAddress,\r\n              amount: endpoint.price,\r\n              tokenAddress: endpoint.tokenAddress,\r\n              network: endpoint.network,\r\n            });\r\n            const payment = await createPayment({\r\n              endpointId: endpoint.id,\r\n              txHash: testResult.x402TxHash,\r\n              fromAddress: testFromAddress,\r\n              toAddress: endpoint.recipientAddress,\r\n              amount: endpoint.price,\r\n              tokenAddress: endpoint.tokenAddress,\r\n              network: endpoint.network,\r\n              kytStatus: 'passed',\r\n              ofacStatus: 'passed',\r\n              facilitator: (testResult.facilitator || 'TEST_FACILITATOR').toLowerCase(),\r\n            });\r\n            paymentId = payment.id;\r\n            \r\n            // Also log to console for visibility in test output\r\n            console.log('[TEST MODE] Payment created:', {\r\n              paymentId: payment.id,\r\n              endpointId: endpoint.id,\r\n              txHash: testResult.x402TxHash,\r\n            });\r\n            \r\n            // Create mock verifyResult for metrics (test mode)\r\n            verifyResult = {\r\n              valid: true,\r\n              success: true,\r\n              transactionHash: testResult.x402TxHash,\r\n              facilitatorId: (testResult.facilitator || 'TEST_FACILITATOR').toLowerCase(),\r\n              verifiedAt: new Date().toISOString(),\r\n              kytStatus: 'passed' as const,\r\n              ofacStatus: 'passed' as const,\r\n              facilitatorUsed: testResult.facilitator || 'TEST_FACILITATOR',\r\n              routingReason: 'Test mode - bypass verification',\r\n              alternativesConsidered: 0,\r\n            };\r\n            \r\n            logger.info('Test mode payment entry created successfully', {\r\n              paymentId: payment.id,\r\n              txHash: testResult.x402TxHash,\r\n              endpointId: endpoint.id,\r\n            });\r\n          } catch (error) {\r\n            const errorMsg = error instanceof Error ? error.message : String(error);\r\n            const errorStack = error instanceof Error ? error.stack : undefined;\r\n            logger.error('Failed to create test mode payment entry', { \r\n              error: errorMsg,\r\n              stack: errorStack,\r\n              endpointId: endpoint.id,\r\n              txHash: testResult.x402TxHash,\r\n            });\r\n            // Also log to console for visibility in server output\r\n            console.error('[TEST MODE] Payment creation ERROR:', errorMsg);\r\n            if (errorStack) {\r\n              console.error('[TEST MODE] Stack:', errorStack);\r\n            }\r\n            // Continue even if payment recording fails\r\n          }\r\n        } else {\r\n          logger.warn('Test mode payment not created - no x402TxHash', {\r\n            testResult,\r\n            endpointId: endpoint.id,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // If no valid session and no test token, check for payment header\r\n    const paymentHeaderRaw = request.headers.get('x-payment') || request.headers.get('X-Payment');\r\n\r\n    if (!paymentVerified && !paymentHeaderRaw) {\r\n      // No session, no test token, and no payment - return 402\r\n      // Log the 402 response\r\n      const latencyMs = Date.now() - startTime;\r\n      try {\r\n        const networkCAIP = normalizeNetwork(endpoint.network);\r\n        const chainId = networkCAIP.split(':')[1] || '8453';\r\n        await logX402Call({\r\n          customerId: conversationId || null,\r\n          endpointId: endpoint.id,\r\n          agentId,\r\n          facilitator: 'NONE',\r\n          chainId,\r\n          asset: endpoint.tokenAddress || 'USDC',\r\n          amount: endpoint.price,\r\n          status: 'failed',\r\n          errorCode: 'PAYMENT_REQUIRED',\r\n          latencyMs,\r\n          resource: `${request.headers.get('host') || 'localhost:3001'}${request.nextUrl.pathname}`,\r\n        });\r\n      } catch (logError) {\r\n        logger.error('Failed to log 402 response', { error: logError });\r\n      }\r\n      \r\n      // Initialize resource server (registers Bazaar extension)\r\n      getX402ResourceServer();\r\n      \r\n      // Return 402 Payment Required with x402 v2 Bazaar-compliant response\r\n      // This includes discovery metadata for Bazaar cataloging\r\n      return await create402Response(request, endpoint);\r\n    }\r\n\r\n    // If we have a payment header but no session, verify payment and optionally create session\r\n    if (!paymentVerified && paymentHeaderRaw) {\r\n      // SECURITY: Validate payment header\r\n      const paymentHeaderValidation = validatePaymentHeader(paymentHeaderRaw);\r\n      if (!paymentHeaderValidation.valid) {\r\n        logger.warn('Invalid payment header', { errors: paymentHeaderValidation.errors });\r\n        return NextResponse.json(\r\n          {\r\n            error: 'Invalid payment header',\r\n            code: 'INVALID_PAYMENT_HEADER',\r\n            details: paymentHeaderValidation.errors,\r\n          },\r\n          { status: 400 }\r\n        );\r\n      }\r\n\r\n      const paymentHeader = paymentHeaderValidation.sanitized || paymentHeaderRaw;\r\n\r\n      // Parse payment header (don't verify yet - meta-facilitator will handle verification)\r\n      const { parseX402Header } = await import('@/integrations/x402/payment-header-parser');\r\n      const parseResult = parseX402Header(paymentHeader);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return NextResponse.json(\r\n          {\r\n            error: 'Invalid payment header',\r\n            code: 'INVALID_PAYMENT_HEADER',\r\n            details: parseResult.error,\r\n          },\r\n          { status: 400 }\r\n        );\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Use meta-facilitator for orchestration (supports multi-facilitator routing)\r\n      const metaFacilitator = getMetaFacilitator();\r\n      \r\n      // Build payment requirements with CAIP support\r\n      const baseUrl = process.env.NEXT_PUBLIC_APP_URL || \r\n                     (request.headers.get('x-forwarded-proto') === 'https' ? 'https' : 'http') + \r\n                     '://' + (request.headers.get('host') || 'localhost:3001');\r\n      const resourceUrl = `${baseUrl}/api/v1/metered/${endpoint.id}`;\r\n      \r\n      // Convert legacy network/asset to CAIP if needed\r\n      const networkCAIP = networkToCAIP(endpoint.network) || normalizeToCAIP(endpoint.network);\r\n      const assetCAIP = tokenToCAIP(endpoint.network, endpoint.tokenAddress);\r\n      \r\n      // Extract routing preferences from headers (if provided by agent/SDK)\r\n      // Support both legacy and CAIP formats\r\n      const preferredNetworksRaw = request.headers.get('x-preferred-networks')?.split(',').map(n => n.trim()) || [];\r\n      const preferredNetworksCAIP = preferredNetworksRaw.map(n => normalizeToCAIP(n)).filter((n): n is string => n !== null);\r\n      const preferredNetworks = preferredNetworksRaw.filter(n => !n.includes(':')); // Legacy format\r\n      \r\n      const preferredAssetsRaw = request.headers.get('x-preferred-assets')?.split(',').map(a => a.trim()) || [];\r\n      const preferredAssetsCAIP = preferredAssetsRaw.filter(a => a.includes('/')); // CAIP-19 format\r\n      const preferredAssets = preferredAssetsRaw.filter(a => !a.includes('/')); // Legacy format\r\n      \r\n      const avoidNetworksRaw = request.headers.get('x-avoid-networks')?.split(',').map(n => n.trim()) || [];\r\n      const avoidNetworksCAIP = avoidNetworksRaw.map(n => normalizeToCAIP(n)).filter((n): n is string => n !== null);\r\n      const avoidNetworks = avoidNetworksRaw.filter(n => !n.includes(':')); // Legacy format\r\n      \r\n      const routingPriority = request.headers.get('x-routing-priority') as 'cost' | 'speed' | 'reliability' | 'compliance' | undefined;\r\n      \r\n      // Build payment requirements with both legacy and CAIP support\r\n      const paymentRequirements: PaymentRequirements = {\r\n        scheme: 'exact',\r\n        network: endpoint.network as string, // Legacy\r\n        networks: networkCAIP ? [networkCAIP] : undefined, // CAIP\r\n        maxAmountRequired: endpoint.price,\r\n        resource: resourceUrl,\r\n        description: endpoint.description || endpoint.name,\r\n        mimeType: 'application/json',\r\n        payTo: endpoint.recipientAddress,\r\n        maxTimeoutSeconds: 300,\r\n        asset: endpoint.tokenAddress, // Legacy\r\n        assets: assetCAIP ? [assetCAIP] : undefined, // CAIP\r\n      };\r\n\r\n      // Verify payment using meta-facilitator (handles routing, failover, business logic)\r\n      logger.debug('Calling meta-facilitator.verifyPayment', {\r\n        hasPaymentHeader: !!paymentHeader,\r\n        paymentRequirements: {\r\n          scheme: paymentRequirements.scheme,\r\n          network: paymentRequirements.network,\r\n          payTo: paymentRequirements.payTo,\r\n          maxAmountRequired: paymentRequirements.maxAmountRequired,\r\n          resource: paymentRequirements.resource,\r\n        },\r\n      });\r\n      \r\n      try {\r\n        verifyResult = await metaFacilitator.verifyPayment(\r\n          paymentHeader,\r\n          paymentRequirements,\r\n          {\r\n            preferredNetworks: preferredNetworks.length > 0 ? preferredNetworks : undefined,\r\n            preferredNetworksCAIP: preferredNetworksCAIP.length > 0 ? preferredNetworksCAIP : undefined,\r\n            preferredAssets: preferredAssets.length > 0 ? preferredAssets : undefined,\r\n            preferredAssetsCAIP: preferredAssetsCAIP.length > 0 ? preferredAssetsCAIP : undefined,\r\n            avoidNetworks: avoidNetworks.length > 0 ? avoidNetworks : undefined,\r\n            avoidNetworksCAIP: avoidNetworksCAIP.length > 0 ? avoidNetworksCAIP : undefined,\r\n            priority: routingPriority,\r\n            requireCompliance: true, // Always require compliance for production\r\n          },\r\n          {\r\n            requireHealthCheck: true,\r\n            preferCheapest: routingPriority === 'cost',\r\n            requireKYC: false, // Can be enabled per endpoint\r\n          },\r\n          {\r\n            requestId,\r\n            correlationId: conversationId,\r\n            clientId: apiKeyHash, // Use API key hash as client identifier\r\n            agentId,\r\n          }\r\n        );\r\n      } catch (verifyError) {\r\n        logger.error('Meta-facilitator verification threw error', {\r\n          error: verifyError,\r\n          stack: verifyError instanceof Error ? verifyError.stack : undefined,\r\n        });\r\n        throw verifyError;\r\n      }\r\n\r\n      if (!verifyResult.valid || !verifyResult.success) {\r\n        // Log detailed error for debugging\r\n        const facilitator = verifyResult.facilitatorUsed || 'CDP';\r\n        logger.error('Payment verification failed', {\r\n          error: verifyResult.error,\r\n          errorDetails: verifyResult.errorDetails,\r\n          kytStatus: verifyResult.kytStatus,\r\n          ofacStatus: verifyResult.ofacStatus,\r\n          facilitatorUsed: facilitator,\r\n          routingReason: verifyResult.routingReason,\r\n        });\r\n\r\n        // Log x402 call with correct facilitator (even on failure)\r\n        const latencyMs = Date.now() - startTime;\r\n        try {\r\n          const networkCAIP = normalizeNetwork(endpoint.network);\r\n          const chainId = networkCAIP.split(':')[1] || '8453';\r\n          await logX402Call({\r\n            customerId: conversationId || null,\r\n            endpointId: endpoint.id,\r\n            agentId,\r\n            facilitator,\r\n            chainId,\r\n            asset: endpoint.tokenAddress || 'USDC',\r\n            amount: endpoint.price,\r\n            status: 'failed',\r\n            errorCode: verifyResult.error || 'VERIFICATION_FAILED',\r\n            latencyMs,\r\n            resource: `${request.headers.get('host') || 'localhost:3001'}${request.nextUrl.pathname}`,\r\n          });\r\n        } catch (logError) {\r\n          logger.error('Failed to log CDP verification failure', { error: logError });\r\n        }\r\n\r\n        return NextResponse.json(\r\n          {\r\n            error: 'Payment verification failed',\r\n            code: verifyResult.error || 'VERIFICATION_FAILED',\r\n            details: verifyResult.error,\r\n            errorDetails: verifyResult.errorDetails, // Include full CDP response\r\n            kytStatus: verifyResult.kytStatus,\r\n            ofacStatus: verifyResult.ofacStatus,\r\n          },\r\n          { status: 400 }\r\n        );\r\n      }\r\n\r\n      // Check KYT/OFAC status\r\n      if (verifyResult.kytStatus === 'blocked' || verifyResult.ofacStatus === 'blocked') {\r\n        return NextResponse.json(\r\n          {\r\n            error: 'Payment blocked by compliance check',\r\n            code: 'COMPLIANCE_BLOCKED',\r\n            kytStatus: verifyResult.kytStatus,\r\n            ofacStatus: verifyResult.ofacStatus,\r\n          },\r\n          { status: 403 }\r\n        );\r\n      }\r\n\r\n      // Verify payment amount matches endpoint price (optional - can be flexible)\r\n      const paidAmount = BigInt(parsed.authorization.value);\r\n      const requiredAmount = BigInt(endpoint.price);\r\n      if (paidAmount < requiredAmount) {\r\n        return NextResponse.json(\r\n          {\r\n            error: 'Insufficient payment',\r\n            code: 'INSUFFICIENT_PAYMENT',\r\n            required: endpoint.price,\r\n            paid: parsed.authorization.value,\r\n          },\r\n          { status: 400 }\r\n        );\r\n      }\r\n\r\n      // PHASE 1.2: Optionally create session from payment for future reuse\r\n      // Check if client wants session (via header)\r\n      const createSession = request.headers.get('x-create-session') === 'true';\r\n      if (createSession) {\r\n        const sessionResult = await createSessionFromPayment(paymentHeader, endpoint.id, agentId);\r\n        if (sessionResult.success && sessionResult.token) {\r\n          // Include session token in response headers\r\n          logger.info('Session created from payment', {\r\n            sessionId: sessionResult.sessionId,\r\n            walletAddress: parsed.authorization.from,\r\n          });\r\n        }\r\n      }\r\n\r\n      paymentVerified = true;\r\n      transactionHash = verifyResult.transactionHash;\r\n\r\n      // Log successful CDP verification\r\n      const facilitator = verifyResult.facilitatorUsed || 'CDP';\r\n      logger.info('Payment verified via meta-facilitator', {\r\n        facilitator,\r\n        transactionHash: verifyResult.transactionHash,\r\n        kytStatus: verifyResult.kytStatus,\r\n        ofacStatus: verifyResult.ofacStatus,\r\n      });\r\n\r\n      // Log x402 call with correct facilitator\r\n      const latencyMs = Date.now() - startTime;\r\n      try {\r\n        const networkCAIP = normalizeNetwork(endpoint.network);\r\n        const chainId = networkCAIP.split(':')[1] || '8453';\r\n        await logX402Call({\r\n          customerId: conversationId || null,\r\n          endpointId: endpoint.id,\r\n          agentId,\r\n          facilitator,\r\n          chainId,\r\n          asset: endpoint.tokenAddress || 'USDC',\r\n          amount: endpoint.price,\r\n          status: 'success',\r\n          x402TxHash: verifyResult.transactionHash || undefined,\r\n          latencyMs,\r\n          resource: `${request.headers.get('host') || 'localhost:3001'}${request.nextUrl.pathname}`,\r\n        });\r\n      } catch (logError) {\r\n        logger.error('Failed to log CDP verification success', { error: logError });\r\n      }\r\n\r\n      // Record payment in database\r\n      if (verifyResult.transactionHash) {\r\n        try {\r\n          const payment = await createPayment({\r\n            endpointId: endpoint.id,\r\n            txHash: verifyResult.transactionHash,\r\n            fromAddress: parsed.authorization.from,\r\n            toAddress: parsed.authorization.to,\r\n            amount: parsed.authorization.value,\r\n            tokenAddress: endpoint.tokenAddress,\r\n            network: endpoint.network,\r\n            kytStatus: verifyResult.kytStatus,\r\n            ofacStatus: verifyResult.ofacStatus,\r\n            facilitator: facilitator.toLowerCase(),\r\n          });\r\n          paymentId = payment.id;\r\n          \r\n          // Trigger webhook for payment verified\r\n          await triggerWebhook('payment.verified', {\r\n            paymentId: payment.id,\r\n            endpointId: endpoint.id,\r\n            txHash: verifyResult.transactionHash,\r\n            amount: parsed.authorization.value,\r\n            tokenAddress: endpoint.tokenAddress,\r\n            network: endpoint.network,\r\n            facilitator: facilitator.toLowerCase(),\r\n            fromAddress: parsed.authorization.from,\r\n            toAddress: parsed.authorization.to,\r\n          }, endpoint.id);\r\n        } catch (error) {\r\n          logger.error('Failed to record payment', { error });\r\n          // Continue even if payment recording fails\r\n        }\r\n      }\r\n    }\r\n\r\n    // At this point, payment should be verified (either via session or payment header)\r\n    if (!paymentVerified) {\r\n      return NextResponse.json(\r\n        {\r\n          error: 'Payment required',\r\n          code: 'PAYMENT_REQUIRED',\r\n        },\r\n        { status: 402 }\r\n      );\r\n    }\r\n\r\n    // Get request body for proxying\r\n    // SECURITY: Check body size again after reading (Content-Length header might be missing or incorrect)\r\n    let requestBody: string | null = null;\r\n    try {\r\n      const bodyText = await request.text();\r\n      const bodySize = new TextEncoder().encode(bodyText).length;\r\n      \r\n      if (bodySize > MAX_REQUEST_BODY_SIZE) {\r\n        logger.warn('Request body too large (after reading)', {\r\n          bodySize,\r\n          maxSize: MAX_REQUEST_BODY_SIZE,\r\n          endpointId,\r\n          ip,\r\n        });\r\n        releaseAllSlots();\r\n        return NextResponse.json(\r\n          {\r\n            error: 'Request body too large',\r\n            code: 'REQUEST_TOO_LARGE',\r\n            maxSize: MAX_REQUEST_BODY_SIZE,\r\n            receivedSize: bodySize,\r\n          },\r\n          { status: 413 }\r\n        );\r\n      }\r\n      \r\n      requestBody = bodyText || null;\r\n    } catch (error) {\r\n      // If body reading fails, continue with null (GET requests don't have bodies)\r\n      requestBody = null;\r\n    }\r\n\r\n    // Proxy request to upstream with retry logic and circuit breaker\r\n    // Use enhanced proxy for production reliability\r\n    const useEnhancedProxy = process.env.USE_ENHANCED_PROXY !== 'false'; // Default to true\r\n    const proxyResult = useEnhancedProxy\r\n      ? await proxyRequestWithRetry({\r\n          upstreamUrl: endpoint.upstreamUrl,\r\n          method: request.method,\r\n          headers: request.headers,\r\n          body: requestBody,\r\n          timeout: 30000, // 30 seconds\r\n          maxRetries: 3,\r\n          retryDelay: 1000,\r\n          retryableStatusCodes: [502, 503, 504, 408, 429],\r\n        })\r\n      : await proxyRequest({\r\n          upstreamUrl: endpoint.upstreamUrl,\r\n          method: request.method,\r\n          headers: request.headers,\r\n          body: requestBody,\r\n          timeout: 30000, // 30 seconds\r\n        });\r\n\r\n    // Extract x402 tx hash (from payment or session)\r\n    const x402TxHash = transactionHash || undefined;\r\n    const failureCode = proxyResult.statusCode >= 400 ? `HTTP_${proxyResult.statusCode}` : undefined;\r\n\r\n    // Log usage with tracing\r\n    try {\r\n      const usageLog = await createUsageLog({\r\n        endpointId: endpoint.id,\r\n        paymentId,\r\n        method: request.method,\r\n        path: new URL(request.url).pathname,\r\n        statusCode: proxyResult.statusCode,\r\n        responseTime: proxyResult.responseTime,\r\n        units: 1, // 1 unit per API call (can be customized)\r\n        ipAddress: request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || undefined,\r\n        userAgent: request.headers.get('user-agent') || undefined,\r\n        // Observability fields\r\n        conversationId,\r\n        agentId,\r\n        x402TxHash,\r\n        failureCode,\r\n      });\r\n      \r\n      // Trigger webhook for usage recorded\r\n      await triggerWebhook('usage.recorded', {\r\n        usageLogId: usageLog.id,\r\n        endpointId: endpoint.id,\r\n        paymentId,\r\n        method: request.method,\r\n        statusCode: proxyResult.statusCode,\r\n        responseTime: proxyResult.responseTime,\r\n        units: 1,\r\n      }, endpoint.id);\r\n    } catch (error) {\r\n      logger.error('Failed to log usage', { error });\r\n      // Continue even if logging fails\r\n    }\r\n\r\n    // Return upstream response with x402 verification info in headers\r\n    const responseHeaders: Record<string, string> = {\r\n      ...proxyResult.headers,\r\n      'X-x402-Verified': 'true',\r\n      'X-x402-Payment-Method': sessionUsed ? 'session' : 'payment',\r\n    };\r\n\r\n    // Add payment-specific headers if payment was used (not session)\r\n    if (!sessionUsed && transactionHash) {\r\n      responseHeaders['X-x402-TxHash'] = transactionHash;\r\n      // Note: verifyResult and parsed are only available in payment flow\r\n      // For session flow, we don't have these details\r\n    }\r\n\r\n    const response = new NextResponse(proxyResult.body, {\r\n      status: proxyResult.statusCode,\r\n      headers: responseHeaders,\r\n    });\r\n\r\n    addRequestIdToResponse(response, requestId);\r\n    \r\n    // Add rate limit headers\r\n    const rateLimitHeaders = await getRateLimitHeaders(request, endpointId);\r\n    if (rateLimitHeaders) {\r\n      addRateLimitHeaders(response, rateLimitHeaders);\r\n    }\r\n\r\n    const totalDuration = Date.now() - startTime;\r\n    logger.info('Request completed successfully', { \r\n      responseTime: totalDuration,\r\n      statusCode: proxyResult.statusCode,\r\n    });\r\n    \r\n    // Record metrics (fire and forget - don't block response)\r\n    recordRequestMetric(\r\n      `/api/v1/metered/${endpointId}`,\r\n      request.method,\r\n      proxyResult.statusCode,\r\n      totalDuration,\r\n      {\r\n        endpointId,\r\n        paymentMethod: sessionUsed ? 'session' : 'payment',\r\n      }\r\n    ).catch(err => logger.error('Failed to record request metric', { error: err }));\r\n    \r\n    if (paymentVerified && transactionHash && verifyResult) {\r\n      recordPaymentMetric(\r\n        endpointId,\r\n        verifyResult.facilitatorUsed || 'UNKNOWN',\r\n        endpoint.price,\r\n        true,\r\n        totalDuration\r\n      ).catch(err => logger.error('Failed to record payment metric', { error: err }));\r\n    }\r\n\r\n    return response;\r\n  } catch (error) {\r\n    // Determine facilitator and error code based on verify mode\r\n    // If we're in CDP mode, the error likely occurred during CDP verification\r\n    const verifyMode = process.env.X402_VERIFY_MODE?.toLowerCase();\r\n    const facilitator = verifyMode === 'cdp' ? 'CDP' : 'UNKNOWN';\r\n    \r\n    // Use CDP-specific error code when in CDP mode\r\n    // This distinguishes CDP internal errors from other system errors\r\n    const failureCode = verifyMode === 'cdp' ? 'CDP_INTERNAL_ERROR' : 'INTERNAL_ERROR';\r\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n    \r\n    // Try to extract CDP-specific error details if available\r\n    let cdpErrorCode = failureCode;\r\n    if (verifyMode === 'cdp' && error instanceof Error) {\r\n      // Check if error message contains CDP-specific error indicators\r\n      const errorMsg = error.message.toLowerCase();\r\n      if (errorMsg.includes('invalidreason') || errorMsg.includes('invalid_reason')) {\r\n        // Try to extract the actual CDP error code from the error\r\n        cdpErrorCode = error.message.includes('CDP_') ? error.message : 'CDP_VERIFICATION_ERROR';\r\n      } else if (errorMsg.includes('network') || errorMsg.includes('fetch')) {\r\n        cdpErrorCode = 'CDP_NETWORK_ERROR';\r\n      } else if (errorMsg.includes('timeout')) {\r\n        cdpErrorCode = 'CDP_REQUEST_TIMEOUT';\r\n      }\r\n    }\r\n    \r\n    // Try to log the failure\r\n    try {\r\n      const endpoint = await getEndpoint(endpointId).catch(() => null);\r\n      if (endpoint) {\r\n        // Log to usage_logs\r\n        await createUsageLog({\r\n          endpointId: endpoint.id,\r\n          method: request.method,\r\n          path: new URL(request.url).pathname,\r\n          statusCode: 500,\r\n          responseTime: Date.now() - startTime,\r\n          units: 0,\r\n          conversationId,\r\n          agentId,\r\n          failureCode: cdpErrorCode,\r\n        });\r\n        \r\n        // Log to x402_call_logs with correct facilitator and CDP-specific error code\r\n        const latencyMs = Date.now() - startTime;\r\n        const networkCAIP = normalizeNetwork(endpoint.network);\r\n        const chainId = networkCAIP.split(':')[1] || '8453';\r\n        await logX402Call({\r\n          customerId: conversationId || null,\r\n          endpointId: endpoint.id,\r\n          agentId,\r\n          facilitator,\r\n          chainId,\r\n          asset: endpoint.tokenAddress || 'USDC',\r\n          amount: endpoint.price,\r\n          status: 'failed',\r\n          errorCode: cdpErrorCode,\r\n          latencyMs,\r\n          resource: `${request.headers.get('host') || 'localhost:3001'}${request.nextUrl.pathname}`,\r\n        });\r\n      }\r\n    } catch (logError) {\r\n      // Ignore logging errors\r\n      logger.error('Failed to log error', { logError });\r\n    }\r\n    \r\n    const errorDuration = Date.now() - startTime;\r\n    const ip = request.ip || request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';\r\n    const userAgent = request.headers.get('user-agent') || undefined;\r\n    \r\n    // Enhanced error logging with full context\r\n    logger.error('Metered endpoint error', { \r\n      error,\r\n      responseTime: errorDuration,\r\n      failureCode,\r\n      stack: error instanceof Error ? error.stack : undefined,\r\n      endpointId,\r\n      method: request.method,\r\n      path: new URL(request.url).pathname,\r\n      ip,\r\n      userAgent,\r\n      conversationId,\r\n      agentId,\r\n      facilitator,\r\n      component: 'metered-endpoint',\r\n    });\r\n    \r\n    // Record error metric (fire and forget)\r\n    recordErrorMetric(failureCode, endpointId, {\r\n      endpointId,\r\n      method: request.method,\r\n    }).catch(err => logger.error('Failed to record error metric', { error: err }));\r\n    \r\n    // Record failed request metric (fire and forget)\r\n    recordRequestMetric(\r\n      `/api/v1/metered/${endpointId}`,\r\n      request.method,\r\n      500,\r\n      errorDuration,\r\n      {\r\n        endpointId,\r\n        error: failureCode,\r\n      }\r\n    );\r\n    \r\n    const response = NextResponse.json(\r\n      {\r\n        error: 'Internal server error',\r\n        code: failureCode,\r\n        details: errorMessage,\r\n        requestId,\r\n      },\r\n      { status: 500 }\r\n    );\r\n    \r\n    addRequestIdToResponse(response, requestId);\r\n    \r\n    // Release concurrent request slots\r\n    releaseAllSlots();\r\n    \r\n    return response;\r\n  } finally {\r\n    // Ensure slots are released even if something goes wrong\r\n    try {\r\n      releaseAllSlots();\r\n    } catch (releaseError) {\r\n      // Ignore release errors\r\n      logger.error('Failed to release concurrent slots', { error: releaseError });\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * GET /api/v1/metered/[endpointId]\r\n * \r\n * Get endpoint information (no payment required)\r\n */\r\nexport async function GET(\r\n  request: NextRequest,\r\n  { params }: { params: Promise<{ endpointId: string }> }\r\n) {\r\n  const { endpointId } = await params; // Next.js 15+ requires awaiting params\r\n\r\n  // Get endpoint from database\r\n  const endpoint = await getEndpoint(endpointId);\r\n\r\n  if (!endpoint) {\r\n    return NextResponse.json(\r\n      {\r\n        error: 'Endpoint not found',\r\n        code: 'NOT_FOUND',\r\n      },\r\n      { status: 404 }\r\n    );\r\n  }\r\n\r\n  return NextResponse.json({\r\n    endpointId: endpoint.id,\r\n    name: endpoint.name,\r\n    description: endpoint.description,\r\n    paymentRequired: true,\r\n    scheme: 'x402',\r\n    network: endpoint.network,\r\n    chainId: endpoint.chainId,\r\n    token: endpoint.tokenSymbol,\r\n    tokenAddress: endpoint.tokenAddress,\r\n    recipientAddress: endpoint.recipientAddress,\r\n    price: endpoint.price,\r\n    status: endpoint.status,\r\n  });\r\n}\r\n\r\n"],"names":[],"mappings":"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"}}]
}