module.exports = [
"[project]/node_modules/@noble/hashes/esm/_u64.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */ __turbopack_context__.s([
    "add",
    ()=>add,
    "add3H",
    ()=>add3H,
    "add3L",
    ()=>add3L,
    "add4H",
    ()=>add4H,
    "add4L",
    ()=>add4L,
    "add5H",
    ()=>add5H,
    "add5L",
    ()=>add5L,
    "default",
    ()=>__TURBOPACK__default__export__,
    "fromBig",
    ()=>fromBig,
    "rotlBH",
    ()=>rotlBH,
    "rotlBL",
    ()=>rotlBL,
    "rotlSH",
    ()=>rotlSH,
    "rotlSL",
    ()=>rotlSL,
    "rotr32H",
    ()=>rotr32H,
    "rotr32L",
    ()=>rotr32L,
    "rotrBH",
    ()=>rotrBH,
    "rotrBL",
    ()=>rotrBL,
    "rotrSH",
    ()=>rotrSH,
    "rotrSL",
    ()=>rotrSL,
    "shrSH",
    ()=>shrSH,
    "shrSL",
    ()=>shrSL,
    "split",
    ()=>split,
    "toBig",
    ()=>toBig
]);
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for(let i = 0; i < len; i++){
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [
            h,
            l
        ];
    }
    return [
        Ah,
        Al
    ];
}
const toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, _l, s)=>h >>> s;
const shrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s)=>h >>> s | l << 32 - s;
const rotrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;
const rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l)=>l;
const rotr32L = (h, _l)=>h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s)=>h << s | l >>> 32 - s;
const rotlSL = (h, l, s)=>l << s | h >>> 32 - s;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;
const rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: l | 0
    };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
;
// prettier-ignore
const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
const __TURBOPACK__default__export__ = u64;
 //# sourceMappingURL=_u64.js.map
}),
"[project]/node_modules/@noble/hashes/esm/cryptoNode.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Internal webcrypto alias.
 * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.
 * Falls back to Node.js built-in crypto for Node.js <=v14.
 * See utils.ts for details.
 * @module
 */ // @ts-ignore
__turbopack_context__.s([
    "crypto",
    ()=>crypto
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
;
const crypto = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ && typeof __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ === 'object' && 'webcrypto' in __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ ? __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__.webcrypto : __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ && typeof __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ === 'object' && 'randomBytes' in __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ ? __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ : undefined; //# sourceMappingURL=cryptoNode.js.map
}),
"[project]/node_modules/@noble/hashes/esm/utils.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
__turbopack_context__.s([
    "Hash",
    ()=>Hash,
    "abytes",
    ()=>abytes,
    "aexists",
    ()=>aexists,
    "ahash",
    ()=>ahash,
    "anumber",
    ()=>anumber,
    "aoutput",
    ()=>aoutput,
    "asyncLoop",
    ()=>asyncLoop,
    "byteSwap",
    ()=>byteSwap,
    "byteSwap32",
    ()=>byteSwap32,
    "byteSwapIfBE",
    ()=>byteSwapIfBE,
    "bytesToHex",
    ()=>bytesToHex,
    "bytesToUtf8",
    ()=>bytesToUtf8,
    "checkOpts",
    ()=>checkOpts,
    "clean",
    ()=>clean,
    "concatBytes",
    ()=>concatBytes,
    "createHasher",
    ()=>createHasher,
    "createOptHasher",
    ()=>createOptHasher,
    "createView",
    ()=>createView,
    "createXOFer",
    ()=>createXOFer,
    "hexToBytes",
    ()=>hexToBytes,
    "isBytes",
    ()=>isBytes,
    "isLE",
    ()=>isLE,
    "kdfInputToBytes",
    ()=>kdfInputToBytes,
    "nextTick",
    ()=>nextTick,
    "randomBytes",
    ()=>randomBytes,
    "rotl",
    ()=>rotl,
    "rotr",
    ()=>rotr,
    "swap32IfBE",
    ()=>swap32IfBE,
    "swap8IfBE",
    ()=>swap8IfBE,
    "toBytes",
    ()=>toBytes,
    "u32",
    ()=>u32,
    "u8",
    ()=>u8,
    "utf8ToBytes",
    ()=>utf8ToBytes,
    "wrapConstructor",
    ()=>wrapConstructor,
    "wrapConstructorWithOpts",
    ()=>wrapConstructorWithOpts,
    "wrapXOFConstructorWithOpts",
    ()=>wrapXOFConstructorWithOpts
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$cryptoNode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/cryptoNode.js [app-route] (ecmascript)");
;
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);
}
function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
    for(let i = 0; i < arrays.length; i++){
        arrays[i].fill(0);
    }
}
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
}
function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
}
const isLE = /* @__PURE__ */ (()=>new Uint8Array(new Uint32Array([
        0x11223344
    ]).buffer)[0] === 0x44)();
function byteSwap(word) {
    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
}
const swap8IfBE = isLE ? (n)=>n : (n)=>byteSwap(n);
const byteSwapIfBE = swap8IfBE;
function byteSwap32(arr) {
    for(let i = 0; i < arr.length; i++){
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
const swap32IfBE = isLE ? (u)=>u : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore
    typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin) return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for(let i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin) return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
const nextTick = async ()=>{};
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await nextTick();
        ts += diff;
    }
}
function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
function toBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
function kdfInputToBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && ({}).toString.call(opts) !== '[object Object]') throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
class Hash {
}
function createHasher(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
const wrapConstructor = createHasher;
const wrapConstructorWithOpts = createOptHasher;
const wrapXOFConstructorWithOpts = createXOFer;
function randomBytes(bytesLength = 32) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$cryptoNode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["crypto"] && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$cryptoNode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["crypto"].getRandomValues === 'function') {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$cryptoNode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["crypto"].getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$cryptoNode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["crypto"] && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$cryptoNode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["crypto"].randomBytes === 'function') {
        return Uint8Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$cryptoNode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["crypto"].randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@noble/hashes/esm/sha3.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * SHA3 (keccak) hash function, based on a new "Sponge function" design.
 * Different from older hashes, the internal state is bigger than output size.
 *
 * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
 * [Website](https://keccak.team/keccak.html),
 * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
 *
 * Check out `sha3-addons` module for cSHAKE, k12, and others.
 * @module
 */ __turbopack_context__.s([
    "Keccak",
    ()=>Keccak,
    "keccakP",
    ()=>keccakP,
    "keccak_224",
    ()=>keccak_224,
    "keccak_256",
    ()=>keccak_256,
    "keccak_384",
    ()=>keccak_384,
    "keccak_512",
    ()=>keccak_512,
    "sha3_224",
    ()=>sha3_224,
    "sha3_256",
    ()=>sha3_256,
    "sha3_384",
    ()=>sha3_384,
    "sha3_512",
    ()=>sha3_512,
    "shake128",
    ()=>shake128,
    "shake256",
    ()=>shake256
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/_u64.js [app-route] (ecmascript)");
// prettier-ignore
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-route] (ecmascript)");
;
;
// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){
    // Pi
    [x, y] = [
        y,
        (2 * x + 3 * y) % 5
    ];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    // Iota
    let t = _0n;
    for(let j = 0; j < 7; j++){
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
}
const IOTAS = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["split"])(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s)=>s > 32 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotlBH"])(h, l, s) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotlSH"])(h, l, s);
const rotlL = (h, l, s)=>s > 32 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotlBL"])(h, l, s) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotlSL"])(h, l, s);
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for(let round = 24 - rounds; round < 24; round++){
        // Theta θ
        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for(let x = 0; x < 10; x += 2){
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for(let y = 0; y < 50; y += 10){
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for(let t = 0; t < 24; t++){
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for(let y = 0; y < 50; y += 10){
            for(let x = 0; x < 10; x++)B[x] = s[y + x];
            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clean"])(B);
}
class Keccak extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Hash"] {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        // Can be passed from user as dkLen
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["anumber"])(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        // 0 < blockLen < 200
        if (!(0 < blockLen && blockLen < 200)) throw new Error('only keccak-f1600 function is supported');
        this.state = new Uint8Array(200);
        this.state32 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["u32"])(this.state);
    }
    clone() {
        return this._cloneInto();
    }
    keccak() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["swap32IfBE"])(this.state32);
        keccakP(this.state32, this.rounds);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["swap32IfBE"])(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["aexists"])(this);
        data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toBytes"])(data);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["abytes"])(data);
        const { blockLen, state } = this;
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen) this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished) return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["aexists"])(this, false);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["abytes"])(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for(let pos = 0, len = out.length; pos < len;){
            if (this.posOut >= blockLen) this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["anumber"])(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["aoutput"])(out, this);
        if (this.finished) throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clean"])(this.state);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
const gen = (suffix, blockLen, outputLen)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createHasher"])(()=>new Keccak(blockLen, suffix, outputLen));
const sha3_224 = /* @__PURE__ */ (()=>gen(0x06, 144, 224 / 8))();
const sha3_256 = /* @__PURE__ */ (()=>gen(0x06, 136, 256 / 8))();
const sha3_384 = /* @__PURE__ */ (()=>gen(0x06, 104, 384 / 8))();
const sha3_512 = /* @__PURE__ */ (()=>gen(0x06, 72, 512 / 8))();
const keccak_224 = /* @__PURE__ */ (()=>gen(0x01, 144, 224 / 8))();
const keccak_256 = /* @__PURE__ */ (()=>gen(0x01, 136, 256 / 8))();
const keccak_384 = /* @__PURE__ */ (()=>gen(0x01, 104, 384 / 8))();
const keccak_512 = /* @__PURE__ */ (()=>gen(0x01, 72, 512 / 8))();
const genShake = (suffix, blockLen, outputLen)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createXOFer"])((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
const shake128 = /* @__PURE__ */ (()=>genShake(0x1f, 168, 128 / 8))();
const shake256 = /* @__PURE__ */ (()=>genShake(0x1f, 136, 256 / 8))(); //# sourceMappingURL=sha3.js.map
}),
"[project]/node_modules/@noble/hashes/esm/_md.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */ __turbopack_context__.s([
    "Chi",
    ()=>Chi,
    "HashMD",
    ()=>HashMD,
    "Maj",
    ()=>Maj,
    "SHA224_IV",
    ()=>SHA224_IV,
    "SHA256_IV",
    ()=>SHA256_IV,
    "SHA384_IV",
    ()=>SHA384_IV,
    "SHA512_IV",
    ()=>SHA512_IV,
    "setBigUint64",
    ()=>setBigUint64
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-route] (ecmascript)");
;
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
function Chi(a, b, c) {
    return a & b ^ ~a & c;
}
function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
}
class HashMD extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Hash"] {
    constructor(blockLen, outputLen, padOffset, isLE){
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createView"])(this.buffer);
    }
    update(data) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["aexists"])(this);
        data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toBytes"])(data);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["abytes"])(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createView"])(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["aexists"])(this);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["aoutput"])(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clean"])(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(let i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createView"])(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
const SHA256_IV = /* @__PURE__ */ Uint32Array.from([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
const SHA224_IV = /* @__PURE__ */ Uint32Array.from([
    0xc1059ed8,
    0x367cd507,
    0x3070dd17,
    0xf70e5939,
    0xffc00b31,
    0x68581511,
    0x64f98fa7,
    0xbefa4fa4
]);
const SHA384_IV = /* @__PURE__ */ Uint32Array.from([
    0xcbbb9d5d,
    0xc1059ed8,
    0x629a292a,
    0x367cd507,
    0x9159015a,
    0x3070dd17,
    0x152fecd8,
    0xf70e5939,
    0x67332667,
    0xffc00b31,
    0x8eb44a87,
    0x68581511,
    0xdb0c2e0d,
    0x64f98fa7,
    0x47b5481d,
    0xbefa4fa4
]);
const SHA512_IV = /* @__PURE__ */ Uint32Array.from([
    0x6a09e667,
    0xf3bcc908,
    0xbb67ae85,
    0x84caa73b,
    0x3c6ef372,
    0xfe94f82b,
    0xa54ff53a,
    0x5f1d36f1,
    0x510e527f,
    0xade682d1,
    0x9b05688c,
    0x2b3e6c1f,
    0x1f83d9ab,
    0xfb41bd6b,
    0x5be0cd19,
    0x137e2179
]); //# sourceMappingURL=_md.js.map
}),
"[project]/node_modules/@noble/hashes/esm/sha2.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
 * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */ __turbopack_context__.s([
    "SHA224",
    ()=>SHA224,
    "SHA256",
    ()=>SHA256,
    "SHA384",
    ()=>SHA384,
    "SHA512",
    ()=>SHA512,
    "SHA512_224",
    ()=>SHA512_224,
    "SHA512_256",
    ()=>SHA512_256,
    "sha224",
    ()=>sha224,
    "sha256",
    ()=>sha256,
    "sha384",
    ()=>sha384,
    "sha512",
    ()=>sha512,
    "sha512_224",
    ()=>sha512_224,
    "sha512_256",
    ()=>sha512_256
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/_md.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/_u64.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-route] (ecmascript)");
;
;
;
/**
 * Round constants:
 * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
 */ // prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HashMD"] {
    constructor(outputLen = 32){
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA256_IV"][0] | 0;
        this.B = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA256_IV"][1] | 0;
        this.C = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA256_IV"][2] | 0;
        this.D = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA256_IV"][3] | 0;
        this.E = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA256_IV"][4] | 0;
        this.F = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA256_IV"][5] | 0;
        this.G = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA256_IV"][6] | 0;
        this.H = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA256_IV"][7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 64; i++){
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotr"])(W15, 7) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotr"])(W15, 18) ^ W15 >>> 3;
            const s1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotr"])(W2, 17) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotr"])(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for(let i = 0; i < 64; i++){
            const sigma1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotr"])(E, 6) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotr"])(E, 11) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotr"])(E, 25);
            const T1 = H + sigma1 + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Chi"])(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotr"])(A, 2) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotr"])(A, 13) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotr"])(A, 22);
            const T2 = sigma0 + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Maj"])(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clean"])(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clean"])(this.buffer);
    }
}
class SHA224 extends SHA256 {
    constructor(){
        super(28);
        this.A = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA224_IV"][0] | 0;
        this.B = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA224_IV"][1] | 0;
        this.C = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA224_IV"][2] | 0;
        this.D = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA224_IV"][3] | 0;
        this.E = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA224_IV"][4] | 0;
        this.F = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA224_IV"][5] | 0;
        this.G = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA224_IV"][6] | 0;
        this.H = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA224_IV"][7] | 0;
    }
}
// SHA2-512 is slower than sha256 in js because u64 operations are slow.
// Round contants
// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
// prettier-ignore
const K512 = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["split"]([
        '0x428a2f98d728ae22',
        '0x7137449123ef65cd',
        '0xb5c0fbcfec4d3b2f',
        '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538',
        '0x59f111f1b605d019',
        '0x923f82a4af194f9b',
        '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242',
        '0x12835b0145706fbe',
        '0x243185be4ee4b28c',
        '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f',
        '0x80deb1fe3b1696b1',
        '0x9bdc06a725c71235',
        '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2',
        '0xefbe4786384f25e3',
        '0x0fc19dc68b8cd5b5',
        '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275',
        '0x4a7484aa6ea6e483',
        '0x5cb0a9dcbd41fbd4',
        '0x76f988da831153b5',
        '0x983e5152ee66dfab',
        '0xa831c66d2db43210',
        '0xb00327c898fb213f',
        '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2',
        '0xd5a79147930aa725',
        '0x06ca6351e003826f',
        '0x142929670a0e6e70',
        '0x27b70a8546d22ffc',
        '0x2e1b21385c26c926',
        '0x4d2c6dfc5ac42aed',
        '0x53380d139d95b3df',
        '0x650a73548baf63de',
        '0x766a0abb3c77b2a8',
        '0x81c2c92e47edaee6',
        '0x92722c851482353b',
        '0xa2bfe8a14cf10364',
        '0xa81a664bbc423001',
        '0xc24b8b70d0f89791',
        '0xc76c51a30654be30',
        '0xd192e819d6ef5218',
        '0xd69906245565a910',
        '0xf40e35855771202a',
        '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8',
        '0x1e376c085141ab53',
        '0x2748774cdf8eeb99',
        '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63',
        '0x4ed8aa4ae3418acb',
        '0x5b9cca4f7763e373',
        '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc',
        '0x78a5636f43172f60',
        '0x84c87814a1f0ab72',
        '0x8cc702081a6439ec',
        '0x90befffa23631e28',
        '0xa4506cebde82bde9',
        '0xbef9a3f7b2c67915',
        '0xc67178f2e372532b',
        '0xca273eceea26619c',
        '0xd186b8c721c0c207',
        '0xeada7dd6cde0eb1e',
        '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba',
        '0x0a637dc5a2c898a6',
        '0x113f9804bef90dae',
        '0x1b710b35131c471b',
        '0x28db77f523047d84',
        '0x32caab7b40c72493',
        '0x3c9ebe0a15c9bebc',
        '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6',
        '0x597f299cfc657e2a',
        '0x5fcb6fab3ad6faec',
        '0x6c44198c4a475817'
    ].map((n)=>BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (()=>K512[0])();
const SHA512_Kl = /* @__PURE__ */ (()=>K512[1])();
// Reusable temporary buffers
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HashMD"] {
    constructor(outputLen = 64){
        super(128, outputLen, 16, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][0] | 0;
        this.Al = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][1] | 0;
        this.Bh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][2] | 0;
        this.Bl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][3] | 0;
        this.Ch = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][4] | 0;
        this.Cl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][5] | 0;
        this.Dh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][6] | 0;
        this.Dl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][7] | 0;
        this.Eh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][8] | 0;
        this.El = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][9] | 0;
        this.Fh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][10] | 0;
        this.Fl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][11] | 0;
        this.Gh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][12] | 0;
        this.Gl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][13] | 0;
        this.Hh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][14] | 0;
        this.Hl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA512_IV"][15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
        ];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4){
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for(let i = 16; i < 80; i++){
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrSH"](W15h, W15l, 1) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrSH"](W15h, W15l, 8) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["shrSH"](W15h, W15l, 7);
            const s0l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrSL"](W15h, W15l, 1) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrSL"](W15h, W15l, 8) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["shrSL"](W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrSH"](W2h, W2l, 19) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrBH"](W2h, W2l, 61) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["shrSH"](W2h, W2l, 6);
            const s1l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrSL"](W2h, W2l, 19) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrBL"](W2h, W2l, 61) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["shrSL"](W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add4L"](s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add4H"](SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for(let i = 0; i < 80; i++){
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrSH"](Eh, El, 14) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrSH"](Eh, El, 18) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrBH"](Eh, El, 41);
            const sigma1l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrSL"](Eh, El, 14) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrSL"](Eh, El, 18) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrBL"](Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add5L"](Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add5H"](T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrSH"](Ah, Al, 28) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrBH"](Ah, Al, 34) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrBH"](Ah, Al, 39);
            const sigma0l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrSL"](Ah, Al, 28) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrBL"](Ah, Al, 34) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotrBL"](Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"](Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add3L"](T1l, sigma0l, MAJl);
            Ah = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add3H"](All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"](this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"](this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"](this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"](this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"](this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"](this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"](this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"](this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clean"])(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clean"])(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
class SHA384 extends SHA512 {
    constructor(){
        super(48);
        this.Ah = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][0] | 0;
        this.Al = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][1] | 0;
        this.Bh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][2] | 0;
        this.Bl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][3] | 0;
        this.Ch = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][4] | 0;
        this.Cl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][5] | 0;
        this.Dh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][6] | 0;
        this.Dl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][7] | 0;
        this.Eh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][8] | 0;
        this.El = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][9] | 0;
        this.Fh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][10] | 0;
        this.Fl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][11] | 0;
        this.Gh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][12] | 0;
        this.Gl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][13] | 0;
        this.Hh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][14] | 0;
        this.Hl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA384_IV"][15] | 0;
    }
}
/**
 * Truncated SHA512/256 and SHA512/224.
 * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
 * Then t hashes string to produce result IV.
 * See `test/misc/sha2-gen-iv.js`.
 */ /** SHA512/224 IV */ const T224_IV = /* @__PURE__ */ Uint32Array.from([
    0x8c3d37c8,
    0x19544da2,
    0x73e19966,
    0x89dcd4d6,
    0x1dfab7ae,
    0x32ff9c82,
    0x679dd514,
    0x582f9fcf,
    0x0f6d2b69,
    0x7bd44da8,
    0x77e36f73,
    0x04c48942,
    0x3f9d85a8,
    0x6a1d36c8,
    0x1112e6ad,
    0x91d692a1
]);
/** SHA512/256 IV */ const T256_IV = /* @__PURE__ */ Uint32Array.from([
    0x22312194,
    0xfc2bf72c,
    0x9f555fa3,
    0xc84c64c2,
    0x2393b86b,
    0x6f53b151,
    0x96387719,
    0x5940eabd,
    0x96283ee2,
    0xa88effe3,
    0xbe5e1e25,
    0x53863992,
    0x2b0199fc,
    0x2c85b8aa,
    0x0eb72ddc,
    0x81c52ca2
]);
class SHA512_224 extends SHA512 {
    constructor(){
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
    }
}
class SHA512_256 extends SHA512 {
    constructor(){
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
    }
}
const sha256 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createHasher"])(()=>new SHA256());
const sha224 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createHasher"])(()=>new SHA224());
const sha512 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createHasher"])(()=>new SHA512());
const sha384 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createHasher"])(()=>new SHA384());
const sha512_256 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createHasher"])(()=>new SHA512_256());
const sha512_224 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createHasher"])(()=>new SHA512_224()); //# sourceMappingURL=sha2.js.map
}),
"[project]/node_modules/@noble/hashes/esm/sha256.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.
 *
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 *
 * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 * @deprecated
 */ __turbopack_context__.s([
    "SHA224",
    ()=>SHA224,
    "SHA256",
    ()=>SHA256,
    "sha224",
    ()=>sha224,
    "sha256",
    ()=>sha256
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha2.js [app-route] (ecmascript)");
;
const SHA256 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA256"];
const sha256 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["sha256"];
const SHA224 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SHA224"];
const sha224 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["sha224"]; //# sourceMappingURL=sha256.js.map
}),
"[project]/node_modules/@noble/hashes/esm/hmac.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * HMAC: RFC2104 message authentication code.
 * @module
 */ __turbopack_context__.s([
    "HMAC",
    ()=>HMAC,
    "hmac",
    ()=>hmac
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-route] (ecmascript)");
;
class HMAC extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Hash"] {
    constructor(hash, _key){
        super();
        this.finished = false;
        this.destroyed = false;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ahash"])(hash);
        const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toBytes"])(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clean"])(pad);
    }
    update(buf) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["aexists"])(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["aexists"])(this);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["abytes"])(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map
}),
"[project]/node_modules/viem/node_modules/abitype/dist/esm/regex.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.
// https://twitter.com/GabrielVergnaud/status/1622906834343366657
__turbopack_context__.s([
    "bytesRegex",
    ()=>bytesRegex,
    "execTyped",
    ()=>execTyped,
    "integerRegex",
    ()=>integerRegex,
    "isTupleRegex",
    ()=>isTupleRegex
]);
function execTyped(regex, string) {
    const match = regex.exec(string);
    return match?.groups;
}
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
const isTupleRegex = /^\(.+?\).*?$/; //# sourceMappingURL=regex.js.map
}),
"[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatAbiParameter",
    ()=>formatAbiParameter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/regex.js [app-route] (ecmascript)");
;
// https://regexr.com/7f7rv
const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(abiParameter) {
    let type = abiParameter.type;
    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {
        type = '(';
        const length = abiParameter.components.length;
        for(let i = 0; i < length; i++){
            const component = abiParameter.components[i];
            type += formatAbiParameter(component);
            if (i < length - 1) type += ', ';
        }
        const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["execTyped"])(tupleRegex, abiParameter.type);
        type += `)${result?.array || ''}`;
        return formatAbiParameter({
            ...abiParameter,
            type
        });
    }
    // Add `indexed` to type if in `abiParameter`
    if ('indexed' in abiParameter && abiParameter.indexed) type = `${type} indexed`;
    // Return human-readable ABI parameter
    if (abiParameter.name) return `${type} ${abiParameter.name}`;
    return type;
} //# sourceMappingURL=formatAbiParameter.js.map
}),
"[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatAbiParameters",
    ()=>formatAbiParameters
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameter$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js [app-route] (ecmascript)");
;
function formatAbiParameters(abiParameters) {
    let params = '';
    const length = abiParameters.length;
    for(let i = 0; i < length; i++){
        const abiParameter = abiParameters[i];
        params += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameter$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatAbiParameter"])(abiParameter);
        if (i !== length - 1) params += ', ';
    }
    return params;
} //# sourceMappingURL=formatAbiParameters.js.map
}),
"[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatAbiItem",
    ()=>formatAbiItem
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js [app-route] (ecmascript)");
;
function formatAbiItem(abiItem) {
    if (abiItem.type === 'function') return `function ${abiItem.name}(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable' ? ` ${abiItem.stateMutability}` : ''}${abiItem.outputs?.length ? ` returns (${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.outputs)})` : ''}`;
    if (abiItem.type === 'event') return `event ${abiItem.name}(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.inputs)})`;
    if (abiItem.type === 'error') return `error ${abiItem.name}(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.inputs)})`;
    if (abiItem.type === 'constructor') return `constructor(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;
    if (abiItem.type === 'fallback') return `fallback() external${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;
    return 'receive() external payable';
} //# sourceMappingURL=formatAbiItem.js.map
}),
"[project]/node_modules/pino/lib/caller.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function noOpPrepareStackTrace(_, stack) {
    return stack;
}
module.exports = function getCallers() {
    const originalPrepare = Error.prepareStackTrace;
    Error.prepareStackTrace = noOpPrepareStackTrace;
    const stack = new Error().stack;
    Error.prepareStackTrace = originalPrepare;
    if (!Array.isArray(stack)) {
        return undefined;
    }
    const entries = stack.slice(2);
    const fileNames = [];
    for (const entry of entries){
        if (!entry) {
            continue;
        }
        fileNames.push(entry.getFileName());
    }
    return fileNames;
};
}),
"[project]/node_modules/pino/lib/transport.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { createRequire } = __turbopack_context__.r("[externals]/module [external] (module, cjs)");
const getCallers = __turbopack_context__.r("[project]/node_modules/pino/lib/caller.js [app-route] (ecmascript)");
const { join, isAbsolute, sep } = __turbopack_context__.r("[externals]/node:path [external] (node:path, cjs)");
const sleep = __turbopack_context__.r("[project]/node_modules/atomic-sleep/index.js [app-route] (ecmascript)");
const onExit = __turbopack_context__.r("[project]/node_modules/on-exit-leak-free/index.js [app-route] (ecmascript)");
const ThreadStream = __turbopack_context__.r("[project]/node_modules/thread-stream/index.js [app-route] (ecmascript)");
function setupOnExit(stream) {
    // This is leak free, it does not leave event handlers
    onExit.register(stream, autoEnd);
    onExit.registerBeforeExit(stream, flush);
    stream.on('close', function() {
        onExit.unregister(stream);
    });
}
function buildStream(filename, workerData, workerOpts, sync) {
    const stream = new ThreadStream({
        filename,
        workerData,
        workerOpts,
        sync
    });
    stream.on('ready', onReady);
    stream.on('close', function() {
        process.removeListener('exit', onExit);
    });
    process.on('exit', onExit);
    function onReady() {
        process.removeListener('exit', onExit);
        stream.unref();
        if (workerOpts.autoEnd !== false) {
            setupOnExit(stream);
        }
    }
    function onExit() {
        /* istanbul ignore next */ if (stream.closed) {
            return;
        }
        stream.flushSync();
        // Apparently there is a very sporadic race condition
        // that in certain OS would prevent the messages to be flushed
        // because the thread might not have been created still.
        // Unfortunately we need to sleep(100) in this case.
        sleep(100);
        stream.end();
    }
    return stream;
}
function autoEnd(stream) {
    stream.ref();
    stream.flushSync();
    stream.end();
    stream.once('close', function() {
        stream.unref();
    });
}
function flush(stream) {
    stream.flushSync();
}
function transport(fullOptions) {
    const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions;
    const options = {
        ...fullOptions.options
    };
    // Backwards compatibility
    const callers = typeof caller === 'string' ? [
        caller
    ] : caller;
    // This will be eventually modified by bundlers
    const bundlerOverrides = '__bundlerPathsOverrides' in globalThis ? globalThis.__bundlerPathsOverrides : {};
    let target = fullOptions.target;
    if (target && targets) {
        throw new Error('only one of target or targets can be specified');
    }
    if (targets) {
        target = bundlerOverrides['pino-worker'] || join(("TURBOPACK compile-time value", "/ROOT/node_modules/pino/lib"), 'worker.js');
        options.targets = targets.filter((dest)=>dest.target).map((dest)=>{
            return {
                ...dest,
                target: fixTarget(dest.target)
            };
        });
        options.pipelines = targets.filter((dest)=>dest.pipeline).map((dest)=>{
            return dest.pipeline.map((t)=>{
                return {
                    ...t,
                    level: dest.level,
                    target: fixTarget(t.target)
                };
            });
        });
    } else if (pipeline) {
        target = bundlerOverrides['pino-worker'] || join(("TURBOPACK compile-time value", "/ROOT/node_modules/pino/lib"), 'worker.js');
        options.pipelines = [
            pipeline.map((dest)=>{
                return {
                    ...dest,
                    target: fixTarget(dest.target)
                };
            })
        ];
    }
    if (levels) {
        options.levels = levels;
    }
    if (dedupe) {
        options.dedupe = dedupe;
    }
    options.pinoWillSendConfig = true;
    return buildStream(fixTarget(target), options, worker, sync);
    //TURBOPACK unreachable
    ;
    function fixTarget(origin) {
        origin = bundlerOverrides[origin] || origin;
        if (isAbsolute(origin) || origin.indexOf('file://') === 0) {
            return origin;
        }
        if (origin === 'pino/file') {
            return join(("TURBOPACK compile-time value", "/ROOT/node_modules/pino/lib"), '..', 'file.js');
        }
        let fixTarget;
        for (const filePath of callers){
            try {
                const context = filePath === 'node:repl' ? process.cwd() + sep : filePath;
                fixTarget = createRequire(context).resolve(origin);
                break;
            } catch (err) {
                continue;
            }
        }
        if (!fixTarget) {
            throw new Error(`unable to determine transport target for "${origin}"`);
        }
        return fixTarget;
    }
}
module.exports = transport;
}),
"[project]/node_modules/pino/lib/constants.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Represents default log level values
 *
 * @enum {number}
 */ const DEFAULT_LEVELS = {
    trace: 10,
    debug: 20,
    info: 30,
    warn: 40,
    error: 50,
    fatal: 60
};
/**
 * Represents sort order direction: `ascending` or `descending`
 *
 * @enum {string}
 */ const SORTING_ORDER = {
    ASC: 'ASC',
    DESC: 'DESC'
};
module.exports = {
    DEFAULT_LEVELS,
    SORTING_ORDER
};
}),
"[project]/node_modules/pino/lib/multistream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const metadata = Symbol.for('pino.metadata');
const { DEFAULT_LEVELS } = __turbopack_context__.r("[project]/node_modules/pino/lib/constants.js [app-route] (ecmascript)");
const DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
function multistream(streamsArray, opts) {
    streamsArray = streamsArray || [];
    opts = opts || {
        dedupe: false
    };
    const streamLevels = Object.create(DEFAULT_LEVELS);
    streamLevels.silent = Infinity;
    if (opts.levels && typeof opts.levels === 'object') {
        Object.keys(opts.levels).forEach((i)=>{
            streamLevels[i] = opts.levels[i];
        });
    }
    const res = {
        write,
        add,
        remove,
        emit,
        flushSync,
        end,
        minLevel: 0,
        lastId: 0,
        streams: [],
        clone,
        [metadata]: true,
        streamLevels
    };
    if (Array.isArray(streamsArray)) {
        streamsArray.forEach(add, res);
    } else {
        add.call(res, streamsArray);
    }
    // clean this object up
    // or it will stay allocated forever
    // as it is closed on the following closures
    streamsArray = null;
    return res;
    //TURBOPACK unreachable
    ;
    // we can exit early because the streams are ordered by level
    function write(data) {
        let dest;
        const level = this.lastLevel;
        const { streams } = this;
        // for handling situation when several streams has the same level
        let recordedLevel = 0;
        let stream;
        // if dedupe set to true we send logs to the stream with the highest level
        // therefore, we have to change sorting order
        for(let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)){
            dest = streams[i];
            if (dest.level <= level) {
                if (recordedLevel !== 0 && recordedLevel !== dest.level) {
                    break;
                }
                stream = dest.stream;
                if (stream[metadata]) {
                    const { lastTime, lastMsg, lastObj, lastLogger } = this;
                    stream.lastLevel = level;
                    stream.lastTime = lastTime;
                    stream.lastMsg = lastMsg;
                    stream.lastObj = lastObj;
                    stream.lastLogger = lastLogger;
                }
                stream.write(data);
                if (opts.dedupe) {
                    recordedLevel = dest.level;
                }
            } else if (!opts.dedupe) {
                break;
            }
        }
    }
    function emit(...args) {
        for (const { stream } of this.streams){
            if (typeof stream.emit === 'function') {
                stream.emit(...args);
            }
        }
    }
    function flushSync() {
        for (const { stream } of this.streams){
            if (typeof stream.flushSync === 'function') {
                stream.flushSync();
            }
        }
    }
    function add(dest) {
        if (!dest) {
            return res;
        }
        // Check that dest implements either StreamEntry or DestinationStream
        const isStream = typeof dest.write === 'function' || dest.stream;
        const stream_ = dest.write ? dest : dest.stream;
        // This is necessary to provide a meaningful error message, otherwise it throws somewhere inside write()
        if (!isStream) {
            throw Error('stream object needs to implement either StreamEntry or DestinationStream interface');
        }
        const { streams, streamLevels } = this;
        let level;
        if (typeof dest.levelVal === 'number') {
            level = dest.levelVal;
        } else if (typeof dest.level === 'string') {
            level = streamLevels[dest.level];
        } else if (typeof dest.level === 'number') {
            level = dest.level;
        } else {
            level = DEFAULT_INFO_LEVEL;
        }
        const dest_ = {
            stream: stream_,
            level,
            levelVal: undefined,
            id: ++res.lastId
        };
        streams.unshift(dest_);
        streams.sort(compareByLevel);
        this.minLevel = streams[0].level;
        return res;
    }
    function remove(id) {
        const { streams } = this;
        const index = streams.findIndex((s)=>s.id === id);
        if (index >= 0) {
            streams.splice(index, 1);
            streams.sort(compareByLevel);
            this.minLevel = streams.length > 0 ? streams[0].level : -1;
        }
        return res;
    }
    function end() {
        for (const { stream } of this.streams){
            if (typeof stream.flushSync === 'function') {
                stream.flushSync();
            }
            stream.end();
        }
    }
    function clone(level) {
        const streams = new Array(this.streams.length);
        for(let i = 0; i < streams.length; i++){
            streams[i] = {
                level,
                stream: this.streams[i].stream
            };
        }
        return {
            write,
            add,
            remove,
            minLevel: level,
            streams,
            clone,
            emit,
            flushSync,
            [metadata]: true
        };
    }
}
function compareByLevel(a, b) {
    return a.level - b.level;
}
function initLoopVar(length, dedupe) {
    return dedupe ? length - 1 : 0;
}
function adjustLoopVar(i, dedupe) {
    return dedupe ? i - 1 : i + 1;
}
function checkLoopVar(i, length, dedupe) {
    return dedupe ? i >= 0 : i < length;
}
module.exports = multistream;
}),
"[project]/node_modules/pino/lib/symbols.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const setLevelSym = Symbol('pino.setLevel');
const getLevelSym = Symbol('pino.getLevel');
const levelValSym = Symbol('pino.levelVal');
const levelCompSym = Symbol('pino.levelComp');
const useLevelLabelsSym = Symbol('pino.useLevelLabels');
const useOnlyCustomLevelsSym = Symbol('pino.useOnlyCustomLevels');
const mixinSym = Symbol('pino.mixin');
const lsCacheSym = Symbol('pino.lsCache');
const chindingsSym = Symbol('pino.chindings');
const asJsonSym = Symbol('pino.asJson');
const writeSym = Symbol('pino.write');
const redactFmtSym = Symbol('pino.redactFmt');
const timeSym = Symbol('pino.time');
const timeSliceIndexSym = Symbol('pino.timeSliceIndex');
const streamSym = Symbol('pino.stream');
const stringifySym = Symbol('pino.stringify');
const stringifySafeSym = Symbol('pino.stringifySafe');
const stringifiersSym = Symbol('pino.stringifiers');
const endSym = Symbol('pino.end');
const formatOptsSym = Symbol('pino.formatOpts');
const messageKeySym = Symbol('pino.messageKey');
const errorKeySym = Symbol('pino.errorKey');
const nestedKeySym = Symbol('pino.nestedKey');
const nestedKeyStrSym = Symbol('pino.nestedKeyStr');
const mixinMergeStrategySym = Symbol('pino.mixinMergeStrategy');
const msgPrefixSym = Symbol('pino.msgPrefix');
const wildcardFirstSym = Symbol('pino.wildcardFirst');
// public symbols, no need to use the same pino
// version for these
const serializersSym = Symbol.for('pino.serializers');
const formattersSym = Symbol.for('pino.formatters');
const hooksSym = Symbol.for('pino.hooks');
const needsMetadataGsym = Symbol.for('pino.metadata');
module.exports = {
    setLevelSym,
    getLevelSym,
    levelValSym,
    levelCompSym,
    useLevelLabelsSym,
    mixinSym,
    lsCacheSym,
    chindingsSym,
    asJsonSym,
    writeSym,
    serializersSym,
    redactFmtSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    wildcardFirstSym,
    needsMetadataGsym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
};
}),
"[project]/node_modules/pino/lib/redaction.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Redact = __turbopack_context__.r("[project]/node_modules/@pinojs/redact/index.js [app-route] (ecmascript)");
const { redactFmtSym, wildcardFirstSym } = __turbopack_context__.r("[project]/node_modules/pino/lib/symbols.js [app-route] (ecmascript)");
// Custom rx regex equivalent to fast-redact's rx
const rx = /[^.[\]]+|\[([^[\]]*?)\]/g;
const CENSOR = '[Redacted]';
const strict = false // TODO should this be configurable?
;
function redaction(opts, serialize) {
    const { paths, censor, remove } = handle(opts);
    const shape = paths.reduce((o, str)=>{
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        // ns is the top-level path segment, brackets + quoting removed.
        let ns = first[1] !== undefined ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, '$1') : first[0];
        if (ns === '*') {
            ns = wildcardFirstSym;
        }
        // top level key:
        if (next === null) {
            o[ns] = null;
            return o;
        }
        // path with at least two segments:
        // if ns is already redacted at the top level, ignore lower level redactions
        if (o[ns] === null) {
            return o;
        }
        const { index } = next;
        const nextPath = `${str.substr(index, str.length - 1)}`;
        o[ns] = o[ns] || [];
        // shape is a mix of paths beginning with literal values and wildcard
        // paths [ "a.b.c", "*.b.z" ] should reduce to a shape of
        // { "a": [ "b.c", "b.z" ], *: [ "b.z" ] }
        // note: "b.z" is in both "a" and * arrays because "a" matches the wildcard.
        // (* entry has wildcardFirstSym as key)
        if (ns !== wildcardFirstSym && o[ns].length === 0) {
            // first time ns's get all '*' redactions so far
            o[ns].push(...o[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
            // new * path gets added to all previously registered literal ns's.
            Object.keys(o).forEach(function(k) {
                if (o[k]) {
                    o[k].push(nextPath);
                }
            });
        }
        o[ns].push(nextPath);
        return o;
    }, {});
    // the redactor assigned to the format symbol key
    // provides top level redaction for instances where
    // an object is interpolated into the msg string
    const result = {
        [redactFmtSym]: Redact({
            paths,
            censor,
            serialize,
            strict,
            remove
        })
    };
    const topCensor = (...args)=>{
        return typeof censor === 'function' ? serialize(censor(...args)) : serialize(censor);
    };
    return [
        ...Object.keys(shape),
        ...Object.getOwnPropertySymbols(shape)
    ].reduce((o, k)=>{
        // top level key:
        if (shape[k] === null) {
            o[k] = (value)=>topCensor(value, [
                    k
                ]);
        } else {
            const wrappedCensor = typeof censor === 'function' ? (value, path)=>{
                return censor(value, [
                    k,
                    ...path
                ]);
            } : censor;
            o[k] = Redact({
                paths: shape[k],
                censor: wrappedCensor,
                serialize,
                strict,
                remove
            });
        }
        return o;
    }, result);
}
function handle(opts) {
    if (Array.isArray(opts)) {
        opts = {
            paths: opts,
            censor: CENSOR
        };
        return opts;
    }
    let { paths, censor = CENSOR, remove } = opts;
    if (Array.isArray(paths) === false) {
        throw Error('pino – redact must contain an array of strings');
    }
    if (remove === true) censor = undefined;
    return {
        paths,
        censor,
        remove
    };
}
module.exports = redaction;
}),
"[project]/node_modules/pino/lib/time.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const nullTime = ()=>'';
const epochTime = ()=>`,"time":${Date.now()}`;
const unixTime = ()=>`,"time":${Math.round(Date.now() / 1000.0)}`;
const isoTime = ()=>`,"time":"${new Date(Date.now()).toISOString()}"` // using Date.now() for testability
;
const NS_PER_MS = 1_000_000n;
const NS_PER_SEC = 1_000_000_000n;
const startWallTimeNs = BigInt(Date.now()) * NS_PER_MS;
const startHrTime = process.hrtime.bigint();
const isoTimeNano = ()=>{
    const elapsedNs = process.hrtime.bigint() - startHrTime;
    const currentTimeNs = startWallTimeNs + elapsedNs;
    const secondsSinceEpoch = currentTimeNs / NS_PER_SEC;
    const nanosWithinSecond = currentTimeNs % NS_PER_SEC;
    const msSinceEpoch = Number(secondsSinceEpoch * 1000n + nanosWithinSecond / 1_000_000n);
    const date = new Date(msSinceEpoch);
    const year = date.getUTCFullYear();
    const month = (date.getUTCMonth() + 1).toString().padStart(2, '0');
    const day = date.getUTCDate().toString().padStart(2, '0');
    const hours = date.getUTCHours().toString().padStart(2, '0');
    const minutes = date.getUTCMinutes().toString().padStart(2, '0');
    const seconds = date.getUTCSeconds().toString().padStart(2, '0');
    return `,"time":"${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${nanosWithinSecond.toString().padStart(9, '0')}Z"`;
};
module.exports = {
    nullTime,
    epochTime,
    unixTime,
    isoTime,
    isoTimeNano
};
}),
"[project]/node_modules/pino/lib/tools.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-prototype-builtins: 0 */ const diagChan = __turbopack_context__.r("[externals]/node:diagnostics_channel [external] (node:diagnostics_channel, cjs)");
const format = __turbopack_context__.r("[project]/node_modules/quick-format-unescaped/index.js [app-route] (ecmascript)");
const { mapHttpRequest, mapHttpResponse } = __turbopack_context__.r("[project]/node_modules/pino-std-serializers/index.js [app-route] (ecmascript)");
const SonicBoom = __turbopack_context__.r("[project]/node_modules/sonic-boom/index.js [app-route] (ecmascript)");
const onExit = __turbopack_context__.r("[project]/node_modules/on-exit-leak-free/index.js [app-route] (ecmascript)");
const { lsCacheSym, chindingsSym, writeSym, serializersSym, formatOptsSym, endSym, stringifiersSym, stringifySym, stringifySafeSym, wildcardFirstSym, nestedKeySym, formattersSym, messageKeySym, errorKeySym, nestedKeyStrSym, msgPrefixSym } = __turbopack_context__.r("[project]/node_modules/pino/lib/symbols.js [app-route] (ecmascript)");
const { isMainThread } = __turbopack_context__.r("[externals]/worker_threads [external] (worker_threads, cjs)");
const transport = __turbopack_context__.r("[project]/node_modules/pino/lib/transport.js [app-route] (ecmascript)");
const asJsonChan = diagChan.tracingChannel('pino_asJson');
function noop() {}
function genLog(level, hook) {
    if (!hook) return LOG;
    return function hookWrappedLog(...args) {
        hook.call(this, args, LOG, level);
    };
    //TURBOPACK unreachable
    ;
    function LOG(o, ...n) {
        if (typeof o === 'object') {
            let msg = o;
            if (o !== null) {
                if (o.method && o.headers && o.socket) {
                    o = mapHttpRequest(o);
                } else if (typeof o.setHeader === 'function') {
                    o = mapHttpResponse(o);
                }
            }
            let formatParams;
            if (msg === null && n.length === 0) {
                formatParams = [
                    null
                ];
            } else {
                msg = n.shift();
                formatParams = n;
            }
            // We do not use a coercive check for `msg` as it is
            // measurably slower than the explicit checks.
            if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {
                msg = this[msgPrefixSym] + msg;
            }
            this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);
        } else {
            let msg = o === undefined ? n.shift() : o;
            // We do not use a coercive check for `msg` as it is
            // measurably slower than the explicit checks.
            if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {
                msg = this[msgPrefixSym] + msg;
            }
            this[writeSym](null, format(msg, n, this[formatOptsSym]), level);
        }
    }
}
// magically escape strings for json
// relying on their charCodeAt
// everything below 32 needs JSON.stringify()
// 34 and 92 happens all the time, so we
// have a fast case for them
function asString(str) {
    let result = '';
    let last = 0;
    let found = false;
    let point = 255;
    const l = str.length;
    if (l > 100) {
        return JSON.stringify(str);
    }
    for(var i = 0; i < l && point >= 32; i++){
        point = str.charCodeAt(i);
        if (point === 34 || point === 92) {
            result += str.slice(last, i) + '\\';
            last = i;
            found = true;
        }
    }
    if (!found) {
        result = str;
    } else {
        result += str.slice(last);
    }
    return point < 32 ? JSON.stringify(str) : '"' + result + '"';
}
/**
 * `asJson` wraps `_asJson` in order to facilitate generating diagnostics.
 *
 * @param {object} obj The merging object passed to the log method.
 * @param {string} msg The log message passed to the log method.
 * @param {number} num The log level number.
 * @param {number} time The log time in milliseconds.
 *
 * @returns {string}
 */ function asJson(obj, msg, num, time) {
    if (asJsonChan.hasSubscribers === false) {
        return _asJson.call(this, obj, msg, num, time);
    }
    const store = {
        instance: this,
        arguments
    };
    return asJsonChan.traceSync(_asJson, store, this, obj, msg, num, time);
}
/**
 * `_asJson` parses all collected data and generates the finalized newline
 * delimited JSON string.
 *
 * @param {object} obj The merging object passed to the log method.
 * @param {string} msg The log message passed to the log method.
 * @param {number} num The log level number.
 * @param {number} time The log time in milliseconds.
 *
 * @returns {string} The finalized log string terminated with a newline.
 * @private
 */ function _asJson(obj, msg, num, time) {
    const stringify = this[stringifySym];
    const stringifySafe = this[stringifySafeSym];
    const stringifiers = this[stringifiersSym];
    const end = this[endSym];
    const chindings = this[chindingsSym];
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const messageKey = this[messageKeySym];
    const errorKey = this[errorKeySym];
    let data = this[lsCacheSym][num] + time;
    // we need the child bindings added to the output first so instance logged
    // objects can take precedence when JSON.parse-ing the resulting log line
    data = data + chindings;
    let value;
    if (formatters.log) {
        obj = formatters.log(obj);
    }
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    let propStr = '';
    for(const key in obj){
        value = obj[key];
        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {
            if (serializers[key]) {
                value = serializers[key](value);
            } else if (key === errorKey && serializers.err) {
                value = serializers.err(value);
            }
            const stringifier = stringifiers[key] || wildcardStringifier;
            switch(typeof value){
                case 'undefined':
                case 'function':
                    continue;
                case 'number':
                    /* eslint no-fallthrough: "off" */ if (Number.isFinite(value) === false) {
                        value = null;
                    }
                // this case explicitly falls through to the next one
                case 'boolean':
                    if (stringifier) value = stringifier(value);
                    break;
                case 'string':
                    value = (stringifier || asString)(value);
                    break;
                default:
                    value = (stringifier || stringify)(value, stringifySafe);
            }
            if (value === undefined) continue;
            const strKey = asString(key);
            propStr += ',' + strKey + ':' + value;
        }
    }
    let msgStr = '';
    if (msg !== undefined) {
        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
        const stringifier = stringifiers[messageKey] || wildcardStringifier;
        switch(typeof value){
            case 'function':
                break;
            case 'number':
                if (Number.isFinite(value) === false) {
                    value = null;
                }
            // this case explicitly falls through to the next one
            case 'boolean':
                if (stringifier) value = stringifier(value);
                msgStr = ',"' + messageKey + '":' + value;
                break;
            case 'string':
                value = (stringifier || asString)(value);
                msgStr = ',"' + messageKey + '":' + value;
                break;
            default:
                value = (stringifier || stringify)(value, stringifySafe);
                msgStr = ',"' + messageKey + '":' + value;
        }
    }
    if (this[nestedKeySym] && propStr) {
        // place all the obj properties under the specified key
        // the nested key is already formatted from the constructor
        return data + this[nestedKeyStrSym] + propStr.slice(1) + '}' + msgStr + end;
    } else {
        return data + propStr + msgStr + end;
    }
}
function asChindings(instance, bindings) {
    let value;
    let data = instance[chindingsSym];
    const stringify = instance[stringifySym];
    const stringifySafe = instance[stringifySafeSym];
    const stringifiers = instance[stringifiersSym];
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    const serializers = instance[serializersSym];
    const formatter = instance[formattersSym].bindings;
    bindings = formatter(bindings);
    for(const key in bindings){
        value = bindings[key];
        const valid = (key.length < 5 || key !== 'level' && key !== 'serializers' && key !== 'formatters' && key !== 'customLevels') && bindings.hasOwnProperty(key) && value !== undefined;
        if (valid === true) {
            value = serializers[key] ? serializers[key](value) : value;
            value = (stringifiers[key] || wildcardStringifier || stringify)(value, stringifySafe);
            if (value === undefined) continue;
            data += ',"' + key + '":' + value;
        }
    }
    return data;
}
function hasBeenTampered(stream) {
    return stream.write !== stream.constructor.prototype.write;
}
function buildSafeSonicBoom(opts) {
    const stream = new SonicBoom(opts);
    stream.on('error', filterBrokenPipe);
    // If we are sync: false, we must flush on exit
    if (!opts.sync && isMainThread) {
        onExit.register(stream, autoEnd);
        stream.on('close', function() {
            onExit.unregister(stream);
        });
    }
    return stream;
    //TURBOPACK unreachable
    ;
    function filterBrokenPipe(err) {
        // Impossible to replicate across all operating systems
        /* istanbul ignore next */ if (err.code === 'EPIPE') {
            // If we get EPIPE, we should stop logging here
            // however we have no control to the consumer of
            // SonicBoom, so we just overwrite the write method
            stream.write = noop;
            stream.end = noop;
            stream.flushSync = noop;
            stream.destroy = noop;
            return;
        }
        stream.removeListener('error', filterBrokenPipe);
        stream.emit('error', err);
    }
}
function autoEnd(stream, eventName) {
    // This check is needed only on some platforms
    /* istanbul ignore next */ if (stream.destroyed) {
        return;
    }
    if (eventName === 'beforeExit') {
        // We still have an event loop, let's use it
        stream.flush();
        stream.on('drain', function() {
            stream.end();
        });
    } else {
        // For some reason istanbul is not detecting this, but it's there
        /* istanbul ignore next */ // We do not have an event loop, so flush synchronously
        stream.flushSync();
    }
}
function createArgsNormalizer(defaultOptions) {
    return function normalizeArgs(instance, caller, opts = {}, stream) {
        // support stream as a string
        if (typeof opts === 'string') {
            stream = buildSafeSonicBoom({
                dest: opts
            });
            opts = {};
        } else if (typeof stream === 'string') {
            if (opts && opts.transport) {
                throw Error('only one of option.transport or stream can be specified');
            }
            stream = buildSafeSonicBoom({
                dest: stream
            });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
            stream = opts;
            opts = {};
        } else if (opts.transport) {
            if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
                throw Error('option.transport do not allow stream, please pass to option directly. e.g. pino(transport)');
            }
            if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === 'function') {
                throw Error('option.transport.targets do not allow custom level formatters');
            }
            let customLevels;
            if (opts.customLevels) {
                customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
            }
            stream = transport({
                caller,
                ...opts.transport,
                levels: customLevels
            });
        }
        opts = Object.assign({}, defaultOptions, opts);
        opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
        opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);
        if (opts.prettyPrint) {
            throw new Error('prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)');
        }
        const { enabled, onChild } = opts;
        if (enabled === false) opts.level = 'silent';
        if (!onChild) opts.onChild = noop;
        if (!stream) {
            if (!hasBeenTampered(process.stdout)) {
                // If process.stdout.fd is undefined, it means that we are running
                // in a worker thread. Let's assume we are logging to file descriptor 1.
                stream = buildSafeSonicBoom({
                    fd: process.stdout.fd || 1
                });
            } else {
                stream = process.stdout;
            }
        }
        return {
            opts,
            stream
        };
    };
}
function stringify(obj, stringifySafeFn) {
    try {
        return JSON.stringify(obj);
    } catch (_) {
        try {
            const stringify = stringifySafeFn || this[stringifySafeSym];
            return stringify(obj);
        } catch (_) {
            return '"[unable to serialize, circular reference is too complex to analyze]"';
        }
    }
}
function buildFormatters(level, bindings, log) {
    return {
        level,
        bindings,
        log
    };
}
/**
 * Convert a string integer file descriptor to a proper native integer
 * file descriptor.
 *
 * @param {string} destination The file descriptor string to attempt to convert.
 *
 * @returns {Number}
 */ function normalizeDestFileDescriptor(destination) {
    const fd = Number(destination);
    if (typeof destination === 'string' && Number.isFinite(fd)) {
        return fd;
    }
    // destination could be undefined if we are in a worker
    if (destination === undefined) {
        // This is stdout in UNIX systems
        return 1;
    }
    return destination;
}
module.exports = {
    noop,
    buildSafeSonicBoom,
    asChindings,
    asJson,
    genLog,
    createArgsNormalizer,
    stringify,
    buildFormatters,
    normalizeDestFileDescriptor
};
}),
"[project]/node_modules/pino/lib/levels.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-prototype-builtins: 0 */ const { lsCacheSym, levelValSym, useOnlyCustomLevelsSym, streamSym, formattersSym, hooksSym, levelCompSym } = __turbopack_context__.r("[project]/node_modules/pino/lib/symbols.js [app-route] (ecmascript)");
const { noop, genLog } = __turbopack_context__.r("[project]/node_modules/pino/lib/tools.js [app-route] (ecmascript)");
const { DEFAULT_LEVELS, SORTING_ORDER } = __turbopack_context__.r("[project]/node_modules/pino/lib/constants.js [app-route] (ecmascript)");
const levelMethods = {
    fatal: (hook)=>{
        const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
        return function(...args) {
            const stream = this[streamSym];
            logFatal.call(this, ...args);
            if (typeof stream.flushSync === 'function') {
                try {
                    stream.flushSync();
                } catch (e) {
                // https://github.com/pinojs/pino/pull/740#discussion_r346788313
                }
            }
        };
    },
    error: (hook)=>genLog(DEFAULT_LEVELS.error, hook),
    warn: (hook)=>genLog(DEFAULT_LEVELS.warn, hook),
    info: (hook)=>genLog(DEFAULT_LEVELS.info, hook),
    debug: (hook)=>genLog(DEFAULT_LEVELS.debug, hook),
    trace: (hook)=>genLog(DEFAULT_LEVELS.trace, hook)
};
const nums = Object.keys(DEFAULT_LEVELS).reduce((o, k)=>{
    o[DEFAULT_LEVELS[k]] = k;
    return o;
}, {});
const initialLsCache = Object.keys(nums).reduce((o, k)=>{
    o[k] = '{"level":' + Number(k);
    return o;
}, {});
function genLsCache(instance) {
    const formatter = instance[formattersSym].level;
    const { labels } = instance.levels;
    const cache = {};
    for(const label in labels){
        const level = formatter(labels[label], Number(label));
        cache[label] = JSON.stringify(level).slice(0, -1);
    }
    instance[lsCacheSym] = cache;
    return instance;
}
function isStandardLevel(level, useOnlyCustomLevels) {
    if (useOnlyCustomLevels) {
        return false;
    }
    switch(level){
        case 'fatal':
        case 'error':
        case 'warn':
        case 'info':
        case 'debug':
        case 'trace':
            return true;
        default:
            return false;
    }
}
function setLevel(level) {
    const { labels, values } = this.levels;
    if (typeof level === 'number') {
        if (labels[level] === undefined) throw Error('unknown level value' + level);
        level = labels[level];
    }
    if (values[level] === undefined) throw Error('unknown level ' + level);
    const preLevelVal = this[levelValSym];
    const levelVal = this[levelValSym] = values[level];
    const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
    const levelComparison = this[levelCompSym];
    const hook = this[hooksSym].logMethod;
    for(const key in values){
        if (levelComparison(values[key], levelVal) === false) {
            this[key] = noop;
            continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
    }
    this.emit('level-change', level, levelVal, labels[preLevelVal], preLevelVal, this);
}
function getLevel(level) {
    const { levels, levelVal } = this;
    // protection against potential loss of Pino scope from serializers (edge case with circular refs - https://github.com/pinojs/pino/issues/833)
    return levels && levels.labels ? levels.labels[levelVal] : '';
}
function isLevelEnabled(logLevel) {
    const { values } = this.levels;
    const logLevelVal = values[logLevel];
    return logLevelVal !== undefined && this[levelCompSym](logLevelVal, this[levelValSym]);
}
/**
 * Determine if the given `current` level is enabled by comparing it
 * against the current threshold (`expected`).
 *
 * @param {SORTING_ORDER} direction comparison direction "ASC" or "DESC"
 * @param {number} current current log level number representation
 * @param {number} expected threshold value to compare with
 * @returns {boolean}
 */ function compareLevel(direction, current, expected) {
    if (direction === SORTING_ORDER.DESC) {
        return current <= expected;
    }
    return current >= expected;
}
/**
 * Create a level comparison function based on `levelComparison`
 * it could a default function which compares levels either in "ascending" or "descending" order or custom comparison function
 *
 * @param {SORTING_ORDER | Function} levelComparison sort levels order direction or custom comparison function
 * @returns Function
 */ function genLevelComparison(levelComparison) {
    if (typeof levelComparison === 'string') {
        return compareLevel.bind(null, levelComparison);
    }
    return levelComparison;
}
function mappings(customLevels = null, useOnlyCustomLevels = false) {
    const customNums = customLevels ? Object.keys(customLevels).reduce((o, k)=>{
        o[customLevels[k]] = k;
        return o;
    }, {}) : null;
    /* eslint-enable */ const labels = Object.assign(Object.create(Object.prototype, {
        Infinity: {
            value: 'silent'
        }
    }), useOnlyCustomLevels ? null : nums, customNums);
    const values = Object.assign(Object.create(Object.prototype, {
        silent: {
            value: Infinity
        }
    }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
    return {
        labels,
        values
    };
}
function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
    if (typeof defaultLevel === 'number') {
        const values = [].concat(Object.keys(customLevels || {}).map((key)=>customLevels[key]), useOnlyCustomLevels ? [] : Object.keys(nums).map((level)=>+level), Infinity);
        if (!values.includes(defaultLevel)) {
            throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
    }
    const labels = Object.assign(Object.create(Object.prototype, {
        silent: {
            value: Infinity
        }
    }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
    if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
    }
}
function assertNoLevelCollisions(levels, customLevels) {
    const { labels, values } = levels;
    for(const k in customLevels){
        if (k in values) {
            throw Error('levels cannot be overridden');
        }
        if (customLevels[k] in labels) {
            throw Error('pre-existing level values cannot be used for new levels');
        }
    }
}
/**
 * Validates whether `levelComparison` is correct
 *
 * @throws Error
 * @param {SORTING_ORDER | Function} levelComparison - value to validate
 * @returns
 */ function assertLevelComparison(levelComparison) {
    if (typeof levelComparison === 'function') {
        return;
    }
    if (typeof levelComparison === 'string' && Object.values(SORTING_ORDER).includes(levelComparison)) {
        return;
    }
    throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
}
module.exports = {
    initialLsCache,
    genLsCache,
    levelMethods,
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    assertNoLevelCollisions,
    assertDefaultLevelFound,
    genLevelComparison,
    assertLevelComparison
};
}),
"[project]/node_modules/pino/lib/meta.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    version: '10.1.0'
};
}),
"[project]/node_modules/pino/lib/proto.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-prototype-builtins: 0 */ const { EventEmitter } = __turbopack_context__.r("[externals]/node:events [external] (node:events, cjs)");
const { lsCacheSym, levelValSym, setLevelSym, getLevelSym, chindingsSym, mixinSym, asJsonSym, writeSym, mixinMergeStrategySym, timeSym, timeSliceIndexSym, streamSym, serializersSym, formattersSym, errorKeySym, messageKeySym, useOnlyCustomLevelsSym, needsMetadataGsym, redactFmtSym, stringifySym, formatOptsSym, stringifiersSym, msgPrefixSym, hooksSym } = __turbopack_context__.r("[project]/node_modules/pino/lib/symbols.js [app-route] (ecmascript)");
const { getLevel, setLevel, isLevelEnabled, mappings, initialLsCache, genLsCache, assertNoLevelCollisions } = __turbopack_context__.r("[project]/node_modules/pino/lib/levels.js [app-route] (ecmascript)");
const { asChindings, asJson, buildFormatters, stringify, noop } = __turbopack_context__.r("[project]/node_modules/pino/lib/tools.js [app-route] (ecmascript)");
const { version } = __turbopack_context__.r("[project]/node_modules/pino/lib/meta.js [app-route] (ecmascript)");
const redaction = __turbopack_context__.r("[project]/node_modules/pino/lib/redaction.js [app-route] (ecmascript)");
// note: use of class is satirical
// https://github.com/pinojs/pino/pull/433#pullrequestreview-127703127
const constructor = class Pino {
};
const prototype = {
    constructor,
    child,
    bindings,
    setBindings,
    flush,
    isLevelEnabled,
    version,
    get level () {
        return this[getLevelSym]();
    },
    set level (lvl){
        this[setLevelSym](lvl);
    },
    get levelVal () {
        return this[levelValSym];
    },
    set levelVal (n){
        throw Error('levelVal is read-only');
    },
    get msgPrefix () {
        return this[msgPrefixSym];
    },
    get [Symbol.toStringTag] () {
        return 'Pino';
    },
    [lsCacheSym]: initialLsCache,
    [writeSym]: write,
    [asJsonSym]: asJson,
    [getLevelSym]: getLevel,
    [setLevelSym]: setLevel
};
Object.setPrototypeOf(prototype, EventEmitter.prototype);
// exporting and consuming the prototype object using factory pattern fixes scoping issues with getters when serializing
module.exports = function() {
    return Object.create(prototype);
};
const resetChildingsFormatter = (bindings)=>bindings;
function child(bindings, options) {
    if (!bindings) {
        throw Error('missing bindings for child Pino');
    }
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const instance = Object.create(this);
    // If an `options` object was not supplied, we can improve
    // the performance of child creation by skipping
    // the checks for set options and simply return
    // a baseline instance.
    if (options == null) {
        if (instance[formattersSym].bindings !== resetChildingsFormatter) {
            instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
        }
        instance[chindingsSym] = asChindings(instance, bindings);
        if (this.onChild !== noop) {
            this.onChild(instance);
        }
        return instance;
    }
    if (options.hasOwnProperty('serializers') === true) {
        instance[serializersSym] = Object.create(null);
        for(const k in serializers){
            instance[serializersSym][k] = serializers[k];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        /* eslint no-var: off */ for(var i = 0; i < parentSymbols.length; i++){
            const ks = parentSymbols[i];
            instance[serializersSym][ks] = serializers[ks];
        }
        for(const bk in options.serializers){
            instance[serializersSym][bk] = options.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
        for(var bi = 0; bi < bindingsSymbols.length; bi++){
            const bks = bindingsSymbols[bi];
            instance[serializersSym][bks] = options.serializers[bks];
        }
    } else instance[serializersSym] = serializers;
    if (options.hasOwnProperty('formatters')) {
        const { level, bindings: chindings, log } = options.formatters;
        instance[formattersSym] = buildFormatters(level || formatters.level, chindings || resetChildingsFormatter, log || formatters.log);
    } else {
        instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
    }
    if (options.hasOwnProperty('customLevels') === true) {
        assertNoLevelCollisions(this.levels, options.customLevels);
        instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
    }
    // redact must place before asChindings and only replace if exist
    if (typeof options.redact === 'object' && options.redact !== null || Array.isArray(options.redact)) {
        instance.redact = options.redact; // replace redact directly
        const stringifiers = redaction(instance.redact, stringify);
        const formatOpts = {
            stringify: stringifiers[redactFmtSym]
        };
        instance[stringifySym] = stringify;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
    }
    if (typeof options.msgPrefix === 'string') {
        instance[msgPrefixSym] = (this[msgPrefixSym] || '') + options.msgPrefix;
    }
    instance[chindingsSym] = asChindings(instance, bindings);
    if (options.level !== undefined && options.level !== this.level || options.hasOwnProperty('customLevels')) {
        const childLevel = options.level || this.level;
        instance[setLevelSym](childLevel);
    }
    this.onChild(instance);
    return instance;
}
function bindings() {
    const chindings = this[chindingsSym];
    const chindingsJson = `{${chindings.substr(1)}}` // at least contains ,"pid":7068,"hostname":"myMac"
    ;
    const bindingsFromJson = JSON.parse(chindingsJson);
    delete bindingsFromJson.pid;
    delete bindingsFromJson.hostname;
    return bindingsFromJson;
}
function setBindings(newBindings) {
    const chindings = asChindings(this, newBindings);
    this[chindingsSym] = chindings;
}
/**
 * Default strategy for creating `mergeObject` from arguments and the result from `mixin()`.
 * Fields from `mergeObject` have higher priority in this strategy.
 *
 * @param {Object} mergeObject The object a user has supplied to the logging function.
 * @param {Object} mixinObject The result of the `mixin` method.
 * @return {Object}
 */ function defaultMixinMergeStrategy(mergeObject, mixinObject) {
    return Object.assign(mixinObject, mergeObject);
}
function write(_obj, msg, num) {
    const t = this[timeSym]();
    const mixin = this[mixinSym];
    const errorKey = this[errorKeySym];
    const messageKey = this[messageKeySym];
    const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
    let obj;
    const streamWriteHook = this[hooksSym].streamWrite;
    if (_obj === undefined || _obj === null) {
        obj = {};
    } else if (_obj instanceof Error) {
        obj = {
            [errorKey]: _obj
        };
        if (msg === undefined) {
            msg = _obj.message;
        }
    } else {
        obj = _obj;
        if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {
            msg = _obj[errorKey].message;
        }
    }
    if (mixin) {
        obj = mixinMergeStrategy(obj, mixin(obj, num, this));
    }
    const s = this[asJsonSym](obj, msg, num, t);
    const stream = this[streamSym];
    if (stream[needsMetadataGsym] === true) {
        stream.lastLevel = num;
        stream.lastObj = obj;
        stream.lastMsg = msg;
        stream.lastTime = t.slice(this[timeSliceIndexSym]);
        stream.lastLogger = this; // for child loggers
    }
    stream.write(streamWriteHook ? streamWriteHook(s) : s);
}
function flush(cb) {
    if (cb != null && typeof cb !== 'function') {
        throw Error('callback must be a function');
    }
    const stream = this[streamSym];
    if (typeof stream.flush === 'function') {
        stream.flush(cb || noop);
    } else if (cb) cb();
}
}),
"[project]/node_modules/pino/pino.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const os = __turbopack_context__.r("[externals]/node:os [external] (node:os, cjs)");
const stdSerializers = __turbopack_context__.r("[project]/node_modules/pino-std-serializers/index.js [app-route] (ecmascript)");
const caller = __turbopack_context__.r("[project]/node_modules/pino/lib/caller.js [app-route] (ecmascript)");
const redaction = __turbopack_context__.r("[project]/node_modules/pino/lib/redaction.js [app-route] (ecmascript)");
const time = __turbopack_context__.r("[project]/node_modules/pino/lib/time.js [app-route] (ecmascript)");
const proto = __turbopack_context__.r("[project]/node_modules/pino/lib/proto.js [app-route] (ecmascript)");
const symbols = __turbopack_context__.r("[project]/node_modules/pino/lib/symbols.js [app-route] (ecmascript)");
const { configure } = __turbopack_context__.r("[project]/node_modules/safe-stable-stringify/index.js [app-route] (ecmascript)");
const { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = __turbopack_context__.r("[project]/node_modules/pino/lib/levels.js [app-route] (ecmascript)");
const { DEFAULT_LEVELS, SORTING_ORDER } = __turbopack_context__.r("[project]/node_modules/pino/lib/constants.js [app-route] (ecmascript)");
const { createArgsNormalizer, asChindings, buildSafeSonicBoom, buildFormatters, stringify, normalizeDestFileDescriptor, noop } = __turbopack_context__.r("[project]/node_modules/pino/lib/tools.js [app-route] (ecmascript)");
const { version } = __turbopack_context__.r("[project]/node_modules/pino/lib/meta.js [app-route] (ecmascript)");
const { chindingsSym, redactFmtSym, serializersSym, timeSym, timeSliceIndexSym, streamSym, stringifySym, stringifySafeSym, stringifiersSym, setLevelSym, endSym, formatOptsSym, messageKeySym, errorKeySym, nestedKeySym, mixinSym, levelCompSym, useOnlyCustomLevelsSym, formattersSym, hooksSym, nestedKeyStrSym, mixinMergeStrategySym, msgPrefixSym } = symbols;
const { epochTime, nullTime } = time;
const { pid } = process;
const hostname = os.hostname();
const defaultErrorSerializer = stdSerializers.err;
const defaultOptions = {
    level: 'info',
    levelComparison: SORTING_ORDER.ASC,
    levels: DEFAULT_LEVELS,
    messageKey: 'msg',
    errorKey: 'err',
    nestedKey: null,
    enabled: true,
    base: {
        pid,
        hostname
    },
    serializers: Object.assign(Object.create(null), {
        err: defaultErrorSerializer
    }),
    formatters: Object.assign(Object.create(null), {
        bindings (bindings) {
            return bindings;
        },
        level (label, number) {
            return {
                level: number
            };
        }
    }),
    hooks: {
        logMethod: undefined,
        streamWrite: undefined
    },
    timestamp: epochTime,
    name: undefined,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: false,
    depthLimit: 5,
    edgeLimit: 100
};
const normalize = createArgsNormalizer(defaultOptions);
const serializers = Object.assign(Object.create(null), stdSerializers);
function pino(...args) {
    const instance = {};
    const { opts, stream } = normalize(instance, caller(), ...args);
    if (opts.level && typeof opts.level === 'string' && DEFAULT_LEVELS[opts.level.toLowerCase()] !== undefined) opts.level = opts.level.toLowerCase();
    const { redact, crlf, serializers, timestamp, messageKey, errorKey, nestedKey, base, name, level, customLevels, levelComparison, mixin, mixinMergeStrategy, useOnlyCustomLevels, formatters, hooks, depthLimit, edgeLimit, onChild, msgPrefix } = opts;
    const stringifySafe = configure({
        maximumDepth: depthLimit,
        maximumBreadth: edgeLimit
    });
    const allFormatters = buildFormatters(formatters.level, formatters.bindings, formatters.log);
    const stringifyFn = stringify.bind({
        [stringifySafeSym]: stringifySafe
    });
    const stringifiers = redact ? redaction(redact, stringifyFn) : {};
    const formatOpts = redact ? {
        stringify: stringifiers[redactFmtSym]
    } : {
        stringify: stringifyFn
    };
    const end = '}' + (crlf ? '\r\n' : '\n');
    const coreChindings = asChindings.bind(null, {
        [chindingsSym]: '',
        [serializersSym]: serializers,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [formattersSym]: allFormatters
    });
    let chindings = '';
    if (base !== null) {
        if (name === undefined) {
            chindings = coreChindings(base);
        } else {
            chindings = coreChindings(Object.assign({}, base, {
                name
            }));
        }
    }
    const time = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
    const timeSliceIndex = time().indexOf(':') + 1;
    if (useOnlyCustomLevels && !customLevels) throw Error('customLevels is required if useOnlyCustomLevels is set true');
    if (mixin && typeof mixin !== 'function') throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
    if (msgPrefix && typeof msgPrefix !== 'string') throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
    assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
    const levels = mappings(customLevels, useOnlyCustomLevels);
    if (typeof stream.emit === 'function') {
        stream.emit('message', {
            code: 'PINO_CONFIG',
            config: {
                levels,
                messageKey,
                errorKey
            }
        });
    }
    assertLevelComparison(levelComparison);
    const levelCompFunc = genLevelComparison(levelComparison);
    Object.assign(instance, {
        levels,
        [levelCompSym]: levelCompFunc,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream,
        [timeSym]: time,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [errorKeySym]: errorKey,
        [nestedKeySym]: nestedKey,
        // protect against injection
        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : '',
        [serializersSym]: serializers,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop,
        onChild,
        [msgPrefixSym]: msgPrefix
    });
    Object.setPrototypeOf(instance, proto());
    genLsCache(instance);
    instance[setLevelSym](level);
    return instance;
}
module.exports = pino;
module.exports.destination = (dest = process.stdout.fd)=>{
    if (typeof dest === 'object') {
        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
        return buildSafeSonicBoom(dest);
    } else {
        return buildSafeSonicBoom({
            dest: normalizeDestFileDescriptor(dest),
            minLength: 0
        });
    }
};
module.exports.transport = __turbopack_context__.r("[project]/node_modules/pino/lib/transport.js [app-route] (ecmascript)");
module.exports.multistream = __turbopack_context__.r("[project]/node_modules/pino/lib/multistream.js [app-route] (ecmascript)");
module.exports.levels = mappings();
module.exports.stdSerializers = serializers;
module.exports.stdTimeFunctions = Object.assign({}, time);
module.exports.symbols = symbols;
module.exports.version = version;
// Enables default and name export with TypeScript and Babel
module.exports.default = pino;
module.exports.pino = pino;
}),
"[project]/node_modules/atomic-sleep/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* global SharedArrayBuffer, Atomics */ if (typeof SharedArrayBuffer !== 'undefined' && typeof Atomics !== 'undefined') {
    const nil = new Int32Array(new SharedArrayBuffer(4));
    function sleep(ms) {
        // also filters out NaN, non-number types, including empty strings, but allows bigints
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
            if (typeof ms !== 'number' && typeof ms !== 'bigint') {
                throw TypeError('sleep: ms must be a number');
            }
            throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity');
        }
        Atomics.wait(nil, 0, 0, Number(ms));
    }
    module.exports = sleep;
} else {
    function sleep1(ms) {
        // also filters out NaN, non-number types, including empty strings, but allows bigints
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
            if (typeof ms !== 'number' && typeof ms !== 'bigint') {
                throw TypeError('sleep: ms must be a number');
            }
            throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity');
        }
        const target = Date.now() + Number(ms);
        while(target > Date.now()){}
    }
    module.exports = sleep1;
}
}),
"[project]/node_modules/on-exit-leak-free/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const refs = {
    exit: [],
    beforeExit: []
};
const functions = {
    exit: onExit,
    beforeExit: onBeforeExit
};
let registry;
function ensureRegistry() {
    if (registry === undefined) {
        registry = new FinalizationRegistry(clear);
    }
}
function install(event) {
    if (refs[event].length > 0) {
        return;
    }
    process.on(event, functions[event]);
}
function uninstall(event) {
    if (refs[event].length > 0) {
        return;
    }
    process.removeListener(event, functions[event]);
    if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
        registry = undefined;
    }
}
function onExit() {
    callRefs('exit');
}
function onBeforeExit() {
    callRefs('beforeExit');
}
function callRefs(event) {
    for (const ref of refs[event]){
        const obj = ref.deref();
        const fn = ref.fn;
        // This should always happen, however GC is
        // undeterministic so it might not happen.
        /* istanbul ignore else */ if (obj !== undefined) {
            fn(obj, event);
        }
    }
    refs[event] = [];
}
function clear(ref) {
    for (const event of [
        'exit',
        'beforeExit'
    ]){
        const index = refs[event].indexOf(ref);
        refs[event].splice(index, index + 1);
        uninstall(event);
    }
}
function _register(event, obj, fn) {
    if (obj === undefined) {
        throw new Error('the object can\'t be undefined');
    }
    install(event);
    const ref = new WeakRef(obj);
    ref.fn = fn;
    ensureRegistry();
    registry.register(obj, ref);
    refs[event].push(ref);
}
function register(obj, fn) {
    _register('exit', obj, fn);
}
function registerBeforeExit(obj, fn) {
    _register('beforeExit', obj, fn);
}
function unregister(obj) {
    if (registry === undefined) {
        return;
    }
    registry.unregister(obj);
    for (const event of [
        'exit',
        'beforeExit'
    ]){
        refs[event] = refs[event].filter((ref)=>{
            const _obj = ref.deref();
            return _obj && _obj !== obj;
        });
        uninstall(event);
    }
}
module.exports = {
    register,
    registerBeforeExit,
    unregister
};
}),
"[project]/node_modules/thread-stream/package.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"name":"thread-stream","version":"3.1.0","description":"A streaming way to send data to a Node.js Worker Thread","main":"index.js","types":"index.d.ts","dependencies":{"real-require":"^0.2.0"},"devDependencies":{"@types/node":"^20.1.0","@types/tap":"^15.0.0","@yao-pkg/pkg":"^5.11.5","desm":"^1.3.0","fastbench":"^1.0.1","husky":"^9.0.6","pino-elasticsearch":"^8.0.0","sonic-boom":"^4.0.1","standard":"^17.0.0","tap":"^16.2.0","ts-node":"^10.8.0","typescript":"^5.3.2","why-is-node-running":"^2.2.2"},"scripts":{"build":"tsc --noEmit","test":"standard && npm run build && npm run transpile && tap \"test/**/*.test.*js\" && tap --ts test/*.test.*ts","test:ci":"standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts","test:ci:js":"tap --no-check-coverage --timeout=120 --coverage-report=lcovonly \"test/**/*.test.*js\"","test:ci:ts":"tap --ts --no-check-coverage --coverage-report=lcovonly \"test/**/*.test.*ts\"","test:yarn":"npm run transpile && tap \"test/**/*.test.js\" --no-check-coverage","transpile":"sh ./test/ts/transpile.sh","prepare":"husky install"},"standard":{"ignore":["test/ts/**/*","test/syntax-error.mjs"]},"repository":{"type":"git","url":"git+https://github.com/mcollina/thread-stream.git"},"keywords":["worker","thread","threads","stream"],"author":"Matteo Collina <hello@matteocollina.com>","license":"MIT","bugs":{"url":"https://github.com/mcollina/thread-stream/issues"},"homepage":"https://github.com/mcollina/thread-stream#readme"});}),
"[project]/node_modules/thread-stream/lib/wait.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const MAX_TIMEOUT = 1000;
function wait(state, index, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index);
    if (current === expected) {
        done(null, 'ok');
        return;
    }
    let prior = current;
    const check = (backoff)=>{
        if (Date.now() > max) {
            done(null, 'timed-out');
        } else {
            setTimeout(()=>{
                prior = current;
                current = Atomics.load(state, index);
                if (current === prior) {
                    check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
                } else {
                    if (current === expected) done(null, 'ok');
                    else done(null, 'not-equal');
                }
            }, backoff);
        }
    };
    check(1);
}
// let waitDiffCount = 0
function waitDiff(state, index, expected, timeout, done) {
    // const id = waitDiffCount++
    // process._rawDebug(`>>> waitDiff ${id}`)
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index);
    if (current !== expected) {
        done(null, 'ok');
        return;
    }
    const check = (backoff)=>{
        // process._rawDebug(`${id} ${index} current ${current} expected ${expected}`)
        // process._rawDebug('' + backoff)
        if (Date.now() > max) {
            done(null, 'timed-out');
        } else {
            setTimeout(()=>{
                current = Atomics.load(state, index);
                if (current !== expected) {
                    done(null, 'ok');
                } else {
                    check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
                }
            }, backoff);
        }
    };
    check(1);
}
module.exports = {
    wait,
    waitDiff
};
}),
"[project]/node_modules/thread-stream/lib/indexes.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const WRITE_INDEX = 4;
const READ_INDEX = 8;
module.exports = {
    WRITE_INDEX,
    READ_INDEX
};
}),
"[project]/node_modules/thread-stream/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { version } = __turbopack_context__.r("[project]/node_modules/thread-stream/package.json (json)");
const { EventEmitter } = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const { Worker } = __turbopack_context__.r("[externals]/worker_threads [external] (worker_threads, cjs)");
const { join } = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const { pathToFileURL } = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
const { wait } = __turbopack_context__.r("[project]/node_modules/thread-stream/lib/wait.js [app-route] (ecmascript)");
const { WRITE_INDEX, READ_INDEX } = __turbopack_context__.r("[project]/node_modules/thread-stream/lib/indexes.js [app-route] (ecmascript)");
const buffer = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)");
const assert = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
const kImpl = Symbol('kImpl');
// V8 limit for string size
const MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
class FakeWeakRef {
    constructor(value){
        this._value = value;
    }
    deref() {
        return this._value;
    }
}
class FakeFinalizationRegistry {
    register() {}
    unregister() {}
}
// Currently using FinalizationRegistry with code coverage breaks the world
// Ref: https://github.com/nodejs/node/issues/49344
const FinalizationRegistry = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : /*TURBOPACK member replacement*/ __turbopack_context__.g.FinalizationRegistry || FakeFinalizationRegistry;
const WeakRef = process.env.NODE_V8_COVERAGE ? FakeWeakRef : /*TURBOPACK member replacement*/ __turbopack_context__.g.WeakRef || FakeWeakRef;
const registry = new FinalizationRegistry((worker)=>{
    if (worker.exited) {
        return;
    }
    worker.terminate();
});
function createWorker(stream, opts) {
    const { filename, workerData } = opts;
    const bundlerOverrides = '__bundlerPathsOverrides' in globalThis ? globalThis.__bundlerPathsOverrides : {};
    const toExecute = bundlerOverrides['thread-stream-worker'] || join(("TURBOPACK compile-time value", "/ROOT/node_modules/thread-stream"), 'lib', 'worker.js');
    const worker = new Worker(toExecute, {
        ...opts.workerOpts,
        trackUnmanagedFds: false,
        workerData: {
            filename: filename.indexOf('file://') === 0 ? filename : pathToFileURL(filename).href,
            dataBuf: stream[kImpl].dataBuf,
            stateBuf: stream[kImpl].stateBuf,
            workerData: {
                $context: {
                    threadStreamVersion: version
                },
                ...workerData
            }
        }
    });
    // We keep a strong reference for now,
    // we need to start writing first
    worker.stream = new FakeWeakRef(stream);
    worker.on('message', onWorkerMessage);
    worker.on('exit', onWorkerExit);
    registry.register(stream, worker);
    return worker;
}
function drain(stream) {
    assert(!stream[kImpl].sync);
    if (stream[kImpl].needDrain) {
        stream[kImpl].needDrain = false;
        stream.emit('drain');
    }
}
function nextFlush(stream) {
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let leftover = stream[kImpl].data.length - writeIndex;
    if (leftover > 0) {
        if (stream[kImpl].buf.length === 0) {
            stream[kImpl].flushing = false;
            if (stream[kImpl].ending) {
                end(stream);
            } else if (stream[kImpl].needDrain) {
                process.nextTick(drain, stream);
            }
            return;
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            // process._rawDebug('writing ' + toWrite.length)
            write(stream, toWrite, nextFlush.bind(null, stream));
        } else {
            // multi-byte utf-8
            stream.flush(()=>{
                // err is already handled in flush()
                if (stream.destroyed) {
                    return;
                }
                Atomics.store(stream[kImpl].state, READ_INDEX, 0);
                Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
                // Find a toWrite length that fits the buffer
                // it must exists as the buffer is at least 4 bytes length
                // and the max utf-8 length for a char is 4 bytes.
                while(toWriteBytes > stream[kImpl].data.length){
                    leftover = leftover / 2;
                    toWrite = stream[kImpl].buf.slice(0, leftover);
                    toWriteBytes = Buffer.byteLength(toWrite);
                }
                stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
                write(stream, toWrite, nextFlush.bind(null, stream));
            });
        }
    } else if (leftover === 0) {
        if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
            // we had a flushSync in the meanwhile
            return;
        }
        stream.flush(()=>{
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            nextFlush(stream);
        });
    } else {
        // This should never happen
        destroy(stream, new Error('overwritten'));
    }
}
function onWorkerMessage(msg) {
    const stream = this.stream.deref();
    if (stream === undefined) {
        this.exited = true;
        // Terminate the worker.
        this.terminate();
        return;
    }
    switch(msg.code){
        case 'READY':
            // Replace the FakeWeakRef with a
            // proper one.
            this.stream = new WeakRef(stream);
            stream.flush(()=>{
                stream[kImpl].ready = true;
                stream.emit('ready');
            });
            break;
        case 'ERROR':
            destroy(stream, msg.err);
            break;
        case 'EVENT':
            if (Array.isArray(msg.args)) {
                stream.emit(msg.name, ...msg.args);
            } else {
                stream.emit(msg.name, msg.args);
            }
            break;
        case 'WARNING':
            process.emitWarning(msg.err);
            break;
        default:
            destroy(stream, new Error('this should not happen: ' + msg.code));
    }
}
function onWorkerExit(code) {
    const stream = this.stream.deref();
    if (stream === undefined) {
        // Nothing to do, the worker already exit
        return;
    }
    registry.unregister(stream);
    stream.worker.exited = true;
    stream.worker.off('exit', onWorkerExit);
    destroy(stream, code !== 0 ? new Error('the worker thread exited') : null);
}
class ThreadStream extends EventEmitter {
    constructor(opts = {}){
        super();
        if (opts.bufferSize < 4) {
            throw new Error('bufferSize must at least fit a 4-byte utf-8 char');
        }
        this[kImpl] = {};
        this[kImpl].stateBuf = new SharedArrayBuffer(128);
        this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
        this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
        this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
        this[kImpl].sync = opts.sync || false;
        this[kImpl].ending = false;
        this[kImpl].ended = false;
        this[kImpl].needDrain = false;
        this[kImpl].destroyed = false;
        this[kImpl].flushing = false;
        this[kImpl].ready = false;
        this[kImpl].finished = false;
        this[kImpl].errored = null;
        this[kImpl].closed = false;
        this[kImpl].buf = '';
        // TODO (fix): Make private?
        this.worker = createWorker(this, opts); // TODO (fix): make private
        this.on('message', (message, transferList)=>{
            this.worker.postMessage(message, transferList);
        });
    }
    write(data) {
        if (this[kImpl].destroyed) {
            error(this, new Error('the worker has exited'));
            return false;
        }
        if (this[kImpl].ending) {
            error(this, new Error('the worker is ending'));
            return false;
        }
        if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
            try {
                writeSync(this);
                this[kImpl].flushing = true;
            } catch (err) {
                destroy(this, err);
                return false;
            }
        }
        this[kImpl].buf += data;
        if (this[kImpl].sync) {
            try {
                writeSync(this);
                return true;
            } catch (err) {
                destroy(this, err);
                return false;
            }
        }
        if (!this[kImpl].flushing) {
            this[kImpl].flushing = true;
            setImmediate(nextFlush, this);
        }
        this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
        return !this[kImpl].needDrain;
    }
    end() {
        if (this[kImpl].destroyed) {
            return;
        }
        this[kImpl].ending = true;
        end(this);
    }
    flush(cb) {
        if (this[kImpl].destroyed) {
            if (typeof cb === 'function') {
                process.nextTick(cb, new Error('the worker has exited'));
            }
            return;
        }
        // TODO write all .buf
        const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
        // process._rawDebug(`(flush) readIndex (${Atomics.load(this.state, READ_INDEX)}) writeIndex (${Atomics.load(this.state, WRITE_INDEX)})`)
        wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res)=>{
            if (err) {
                destroy(this, err);
                process.nextTick(cb, err);
                return;
            }
            if (res === 'not-equal') {
                // TODO handle deadlock
                this.flush(cb);
                return;
            }
            process.nextTick(cb);
        });
    }
    flushSync() {
        if (this[kImpl].destroyed) {
            return;
        }
        writeSync(this);
        flushSync(this);
    }
    unref() {
        this.worker.unref();
    }
    ref() {
        this.worker.ref();
    }
    get ready() {
        return this[kImpl].ready;
    }
    get destroyed() {
        return this[kImpl].destroyed;
    }
    get closed() {
        return this[kImpl].closed;
    }
    get writable() {
        return !this[kImpl].destroyed && !this[kImpl].ending;
    }
    get writableEnded() {
        return this[kImpl].ending;
    }
    get writableFinished() {
        return this[kImpl].finished;
    }
    get writableNeedDrain() {
        return this[kImpl].needDrain;
    }
    get writableObjectMode() {
        return false;
    }
    get writableErrored() {
        return this[kImpl].errored;
    }
}
function error(stream, err) {
    setImmediate(()=>{
        stream.emit('error', err);
    });
}
function destroy(stream, err) {
    if (stream[kImpl].destroyed) {
        return;
    }
    stream[kImpl].destroyed = true;
    if (err) {
        stream[kImpl].errored = err;
        error(stream, err);
    }
    if (!stream.worker.exited) {
        stream.worker.terminate().catch(()=>{}).then(()=>{
            stream[kImpl].closed = true;
            stream.emit('close');
        });
    } else {
        setImmediate(()=>{
            stream[kImpl].closed = true;
            stream.emit('close');
        });
    }
}
function write(stream, data, cb) {
    // data is smaller than the shared buffer length
    const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    const length = Buffer.byteLength(data);
    stream[kImpl].data.write(data, current);
    Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
    Atomics.notify(stream[kImpl].state, WRITE_INDEX);
    cb();
    return true;
}
function end(stream) {
    if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
        return;
    }
    stream[kImpl].ended = true;
    try {
        stream.flushSync();
        let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        // process._rawDebug('writing index')
        Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
        // process._rawDebug(`(end) readIndex (${Atomics.load(stream.state, READ_INDEX)}) writeIndex (${Atomics.load(stream.state, WRITE_INDEX)})`)
        Atomics.notify(stream[kImpl].state, WRITE_INDEX);
        // Wait for the process to complete
        let spins = 0;
        while(readIndex !== -1){
            // process._rawDebug(`read = ${read}`)
            Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
            readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
            if (readIndex === -2) {
                destroy(stream, new Error('end() failed'));
                return;
            }
            if (++spins === 10) {
                destroy(stream, new Error('end() took too long (10s)'));
                return;
            }
        }
        process.nextTick(()=>{
            stream[kImpl].finished = true;
            stream.emit('finish');
        });
    } catch (err) {
        destroy(stream, err);
    }
// process._rawDebug('end finished...')
}
function writeSync(stream) {
    const cb = ()=>{
        if (stream[kImpl].ending) {
            end(stream);
        } else if (stream[kImpl].needDrain) {
            process.nextTick(drain, stream);
        }
    };
    stream[kImpl].flushing = false;
    while(stream[kImpl].buf.length !== 0){
        const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
        let leftover = stream[kImpl].data.length - writeIndex;
        if (leftover === 0) {
            flushSync(stream);
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            continue;
        } else if (leftover < 0) {
            // stream should never happen
            throw new Error('overwritten');
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            // process._rawDebug('writing ' + toWrite.length)
            write(stream, toWrite, cb);
        } else {
            // multi-byte utf-8
            flushSync(stream);
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            // Find a toWrite length that fits the buffer
            // it must exists as the buffer is at least 4 bytes length
            // and the max utf-8 length for a char is 4 bytes.
            while(toWriteBytes > stream[kImpl].buf.length){
                leftover = leftover / 2;
                toWrite = stream[kImpl].buf.slice(0, leftover);
                toWriteBytes = Buffer.byteLength(toWrite);
            }
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            write(stream, toWrite, cb);
        }
    }
}
function flushSync(stream) {
    if (stream[kImpl].flushing) {
        throw new Error('unable to flush while flushing');
    }
    // process._rawDebug('flushSync started')
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let spins = 0;
    // TODO handle deadlock
    while(true){
        const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
            throw Error('_flushSync failed');
        }
        // process._rawDebug(`(flushSync) readIndex (${readIndex}) writeIndex (${writeIndex})`)
        if (readIndex !== writeIndex) {
            // TODO stream timeouts for some reason.
            Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
        } else {
            break;
        }
        if (++spins === 10) {
            throw new Error('_flushSync took too long (10s)');
        }
    }
// process._rawDebug('flushSync finished')
}
module.exports = ThreadStream;
}),
"[project]/node_modules/pino-std-serializers/lib/err-helpers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// **************************************************************
// * Code initially copied/adapted from "pony-cause" npm module *
// * Please upstream improvements there                         *
// **************************************************************
const isErrorLike = (err)=>{
    return err && typeof err.message === 'string';
};
/**
 * @param {Error|{ cause?: unknown|(()=>err)}} err
 * @returns {Error|Object|undefined}
 */ const getErrorCause = (err)=>{
    if (!err) return;
    /** @type {unknown} */ // @ts-ignore
    const cause = err.cause;
    // VError / NError style causes
    if (typeof cause === 'function') {
        // @ts-ignore
        const causeResult = err.cause();
        return isErrorLike(causeResult) ? causeResult : undefined;
    } else {
        return isErrorLike(cause) ? cause : undefined;
    }
};
/**
 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
 *
 * @private
 * @param {Error} err
 * @param {Set<Error>} seen
 * @returns {string}
 */ const _stackWithCauses = (err, seen)=>{
    if (!isErrorLike(err)) return '';
    const stack = err.stack || '';
    // Ensure we don't go circular or crazily deep
    if (seen.has(err)) {
        return stack + '\ncauses have become circular...';
    }
    const cause = getErrorCause(err);
    if (cause) {
        seen.add(err);
        return stack + '\ncaused by: ' + _stackWithCauses(cause, seen);
    } else {
        return stack;
    }
};
/**
 * @param {Error} err
 * @returns {string}
 */ const stackWithCauses = (err)=>_stackWithCauses(err, new Set());
/**
 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
 *
 * @private
 * @param {Error} err
 * @param {Set<Error>} seen
 * @param {boolean} [skip]
 * @returns {string}
 */ const _messageWithCauses = (err, seen, skip)=>{
    if (!isErrorLike(err)) return '';
    const message = skip ? '' : err.message || '';
    // Ensure we don't go circular or crazily deep
    if (seen.has(err)) {
        return message + ': ...';
    }
    const cause = getErrorCause(err);
    if (cause) {
        seen.add(err);
        // @ts-ignore
        const skipIfVErrorStyleCause = typeof err.cause === 'function';
        return message + (skipIfVErrorStyleCause ? '' : ': ') + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
        return message;
    }
};
/**
 * @param {Error} err
 * @returns {string}
 */ const messageWithCauses = (err)=>_messageWithCauses(err, new Set());
module.exports = {
    isErrorLike,
    getErrorCause,
    stackWithCauses,
    messageWithCauses
};
}),
"[project]/node_modules/pino-std-serializers/lib/err-proto.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const seen = Symbol('circular-ref-tag');
const rawSymbol = Symbol('pino-raw-err-ref');
const pinoErrProto = Object.create({}, {
    type: {
        enumerable: true,
        writable: true,
        value: undefined
    },
    message: {
        enumerable: true,
        writable: true,
        value: undefined
    },
    stack: {
        enumerable: true,
        writable: true,
        value: undefined
    },
    aggregateErrors: {
        enumerable: true,
        writable: true,
        value: undefined
    },
    raw: {
        enumerable: false,
        get: function() {
            return this[rawSymbol];
        },
        set: function(val) {
            this[rawSymbol] = val;
        }
    }
});
Object.defineProperty(pinoErrProto, rawSymbol, {
    writable: true,
    value: {}
});
module.exports = {
    pinoErrProto,
    pinoErrorSymbols: {
        seen,
        rawSymbol
    }
};
}),
"[project]/node_modules/pino-std-serializers/lib/err.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = errSerializer;
const { messageWithCauses, stackWithCauses, isErrorLike } = __turbopack_context__.r("[project]/node_modules/pino-std-serializers/lib/err-helpers.js [app-route] (ecmascript)");
const { pinoErrProto, pinoErrorSymbols } = __turbopack_context__.r("[project]/node_modules/pino-std-serializers/lib/err-proto.js [app-route] (ecmascript)");
const { seen } = pinoErrorSymbols;
const { toString } = Object.prototype;
function errSerializer(err) {
    if (!isErrorLike(err)) {
        return err;
    }
    err[seen] = undefined; // tag to prevent re-looking at this
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === '[object Function]' ? err.constructor.name : err.name;
    _err.message = messageWithCauses(err);
    _err.stack = stackWithCauses(err);
    if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err)=>errSerializer(err));
    }
    for(const key in err){
        if (_err[key] === undefined) {
            const val = err[key];
            if (isErrorLike(val)) {
                // We append cause messages and stacks to _err, therefore skipping causes here
                if (key !== 'cause' && !Object.prototype.hasOwnProperty.call(val, seen)) {
                    _err[key] = errSerializer(val);
                }
            } else {
                _err[key] = val;
            }
        }
    }
    delete err[seen]; // clean up tag in case err is serialized again later
    _err.raw = err;
    return _err;
}
}),
"[project]/node_modules/pino-std-serializers/lib/err-with-cause.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = errWithCauseSerializer;
const { isErrorLike } = __turbopack_context__.r("[project]/node_modules/pino-std-serializers/lib/err-helpers.js [app-route] (ecmascript)");
const { pinoErrProto, pinoErrorSymbols } = __turbopack_context__.r("[project]/node_modules/pino-std-serializers/lib/err-proto.js [app-route] (ecmascript)");
const { seen } = pinoErrorSymbols;
const { toString } = Object.prototype;
function errWithCauseSerializer(err) {
    if (!isErrorLike(err)) {
        return err;
    }
    err[seen] = undefined; // tag to prevent re-looking at this
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === '[object Function]' ? err.constructor.name : err.name;
    _err.message = err.message;
    _err.stack = err.stack;
    if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err)=>errWithCauseSerializer(err));
    }
    if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
        _err.cause = errWithCauseSerializer(err.cause);
    }
    for(const key in err){
        if (_err[key] === undefined) {
            const val = err[key];
            if (isErrorLike(val)) {
                if (!Object.prototype.hasOwnProperty.call(val, seen)) {
                    _err[key] = errWithCauseSerializer(val);
                }
            } else {
                _err[key] = val;
            }
        }
    }
    delete err[seen]; // clean up tag in case err is serialized again later
    _err.raw = err;
    return _err;
}
}),
"[project]/node_modules/pino-std-serializers/lib/req.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    mapHttpRequest,
    reqSerializer
};
const rawSymbol = Symbol('pino-raw-req-ref');
const pinoReqProto = Object.create({}, {
    id: {
        enumerable: true,
        writable: true,
        value: ''
    },
    method: {
        enumerable: true,
        writable: true,
        value: ''
    },
    url: {
        enumerable: true,
        writable: true,
        value: ''
    },
    query: {
        enumerable: true,
        writable: true,
        value: ''
    },
    params: {
        enumerable: true,
        writable: true,
        value: ''
    },
    headers: {
        enumerable: true,
        writable: true,
        value: {}
    },
    remoteAddress: {
        enumerable: true,
        writable: true,
        value: ''
    },
    remotePort: {
        enumerable: true,
        writable: true,
        value: ''
    },
    raw: {
        enumerable: false,
        get: function() {
            return this[rawSymbol];
        },
        set: function(val) {
            this[rawSymbol] = val;
        }
    }
});
Object.defineProperty(pinoReqProto, rawSymbol, {
    writable: true,
    value: {}
});
function reqSerializer(req) {
    // req.info is for hapi compat.
    const connection = req.info || req.socket;
    const _req = Object.create(pinoReqProto);
    _req.id = typeof req.id === 'function' ? req.id() : req.id || (req.info ? req.info.id : undefined);
    _req.method = req.method;
    // req.originalUrl is for expressjs compat.
    if (req.originalUrl) {
        _req.url = req.originalUrl;
    } else {
        const path = req.path;
        // path for safe hapi compat.
        _req.url = typeof path === 'string' ? path : req.url ? req.url.path || req.url : undefined;
    }
    if (req.query) {
        _req.query = req.query;
    }
    if (req.params) {
        _req.params = req.params;
    }
    _req.headers = req.headers;
    _req.remoteAddress = connection && connection.remoteAddress;
    _req.remotePort = connection && connection.remotePort;
    // req.raw is  for hapi compat/equivalence
    _req.raw = req.raw || req;
    return _req;
}
function mapHttpRequest(req) {
    return {
        req: reqSerializer(req)
    };
}
}),
"[project]/node_modules/pino-std-serializers/lib/res.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    mapHttpResponse,
    resSerializer
};
const rawSymbol = Symbol('pino-raw-res-ref');
const pinoResProto = Object.create({}, {
    statusCode: {
        enumerable: true,
        writable: true,
        value: 0
    },
    headers: {
        enumerable: true,
        writable: true,
        value: ''
    },
    raw: {
        enumerable: false,
        get: function() {
            return this[rawSymbol];
        },
        set: function(val) {
            this[rawSymbol] = val;
        }
    }
});
Object.defineProperty(pinoResProto, rawSymbol, {
    writable: true,
    value: {}
});
function resSerializer(res) {
    const _res = Object.create(pinoResProto);
    _res.statusCode = res.headersSent ? res.statusCode : null;
    _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
    _res.raw = res;
    return _res;
}
function mapHttpResponse(res) {
    return {
        res: resSerializer(res)
    };
}
}),
"[project]/node_modules/pino-std-serializers/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const errSerializer = __turbopack_context__.r("[project]/node_modules/pino-std-serializers/lib/err.js [app-route] (ecmascript)");
const errWithCauseSerializer = __turbopack_context__.r("[project]/node_modules/pino-std-serializers/lib/err-with-cause.js [app-route] (ecmascript)");
const reqSerializers = __turbopack_context__.r("[project]/node_modules/pino-std-serializers/lib/req.js [app-route] (ecmascript)");
const resSerializers = __turbopack_context__.r("[project]/node_modules/pino-std-serializers/lib/res.js [app-route] (ecmascript)");
module.exports = {
    err: errSerializer,
    errWithCause: errWithCauseSerializer,
    mapHttpRequest: reqSerializers.mapHttpRequest,
    mapHttpResponse: resSerializers.mapHttpResponse,
    req: reqSerializers.reqSerializer,
    res: resSerializers.resSerializer,
    wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer) return customSerializer;
        return function wrapErrSerializer(err) {
            return customSerializer(errSerializer(err));
        };
    },
    wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
        return function wrappedReqSerializer(req) {
            return customSerializer(reqSerializers.reqSerializer(req));
        };
    },
    wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer) return customSerializer;
        return function wrappedResSerializer(res) {
            return customSerializer(resSerializers.resSerializer(res));
        };
    }
};
}),
"[project]/node_modules/@pinojs/redact/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    if (obj instanceof Date) {
        return new Date(obj.getTime());
    }
    if (obj instanceof Array) {
        const cloned = [];
        for(let i = 0; i < obj.length; i++){
            cloned[i] = deepClone(obj[i]);
        }
        return cloned;
    }
    if (typeof obj === 'object') {
        const cloned = Object.create(Object.getPrototypeOf(obj));
        for(const key in obj){
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                cloned[key] = deepClone(obj[key]);
            }
        }
        return cloned;
    }
    return obj;
}
function parsePath(path) {
    const parts = [];
    let current = '';
    let inBrackets = false;
    let inQuotes = false;
    let quoteChar = '';
    for(let i = 0; i < path.length; i++){
        const char = path[i];
        if (!inBrackets && char === '.') {
            if (current) {
                parts.push(current);
                current = '';
            }
        } else if (char === '[') {
            if (current) {
                parts.push(current);
                current = '';
            }
            inBrackets = true;
        } else if (char === ']' && inBrackets) {
            // Always push the current value when closing brackets, even if it's an empty string
            parts.push(current);
            current = '';
            inBrackets = false;
            inQuotes = false;
        } else if ((char === '"' || char === "'") && inBrackets) {
            if (!inQuotes) {
                inQuotes = true;
                quoteChar = char;
            } else if (char === quoteChar) {
                inQuotes = false;
                quoteChar = '';
            } else {
                current += char;
            }
        } else {
            current += char;
        }
    }
    if (current) {
        parts.push(current);
    }
    return parts;
}
function setValue(obj, parts, value) {
    let current = obj;
    for(let i = 0; i < parts.length - 1; i++){
        const key = parts[i];
        // Type safety: Check if current is an object before using 'in' operator
        if (typeof current !== 'object' || current === null || !(key in current)) {
            return false // Path doesn't exist, don't create it
            ;
        }
        if (typeof current[key] !== 'object' || current[key] === null) {
            return false // Path doesn't exist properly
            ;
        }
        current = current[key];
    }
    const lastKey = parts[parts.length - 1];
    if (lastKey === '*') {
        if (Array.isArray(current)) {
            for(let i = 0; i < current.length; i++){
                current[i] = value;
            }
        } else if (typeof current === 'object' && current !== null) {
            for(const key in current){
                if (Object.prototype.hasOwnProperty.call(current, key)) {
                    current[key] = value;
                }
            }
        }
    } else {
        // Type safety: Check if current is an object before using 'in' operator
        if (typeof current === 'object' && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
            current[lastKey] = value;
        }
    }
    return true;
}
function removeKey(obj, parts) {
    let current = obj;
    for(let i = 0; i < parts.length - 1; i++){
        const key = parts[i];
        // Type safety: Check if current is an object before using 'in' operator
        if (typeof current !== 'object' || current === null || !(key in current)) {
            return false // Path doesn't exist, don't create it
            ;
        }
        if (typeof current[key] !== 'object' || current[key] === null) {
            return false // Path doesn't exist properly
            ;
        }
        current = current[key];
    }
    const lastKey = parts[parts.length - 1];
    if (lastKey === '*') {
        if (Array.isArray(current)) {
            // For arrays, we can't really "remove" all items as that would change indices
            // Instead, we set them to undefined which will be omitted by JSON.stringify
            for(let i = 0; i < current.length; i++){
                current[i] = undefined;
            }
        } else if (typeof current === 'object' && current !== null) {
            for(const key in current){
                if (Object.prototype.hasOwnProperty.call(current, key)) {
                    delete current[key];
                }
            }
        }
    } else {
        // Type safety: Check if current is an object before using 'in' operator
        if (typeof current === 'object' && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
            delete current[lastKey];
        }
    }
    return true;
}
// Sentinel object to distinguish between undefined value and non-existent path
const PATH_NOT_FOUND = Symbol('PATH_NOT_FOUND');
function getValueIfExists(obj, parts) {
    let current = obj;
    for (const part of parts){
        if (current === null || current === undefined) {
            return PATH_NOT_FOUND;
        }
        // Type safety: Check if current is an object before property access
        if (typeof current !== 'object' || current === null) {
            return PATH_NOT_FOUND;
        }
        // Check if the property exists before accessing it
        if (!(part in current)) {
            return PATH_NOT_FOUND;
        }
        current = current[part];
    }
    return current;
}
function getValue(obj, parts) {
    let current = obj;
    for (const part of parts){
        if (current === null || current === undefined) {
            return undefined;
        }
        // Type safety: Check if current is an object before property access
        if (typeof current !== 'object' || current === null) {
            return undefined;
        }
        current = current[part];
    }
    return current;
}
function redactPaths(obj, paths, censor, remove = false) {
    for (const path of paths){
        const parts = parsePath(path);
        if (parts.includes('*')) {
            redactWildcardPath(obj, parts, censor, path, remove);
        } else {
            if (remove) {
                removeKey(obj, parts);
            } else {
                // Get value only if path exists - single traversal
                const value = getValueIfExists(obj, parts);
                if (value === PATH_NOT_FOUND) {
                    continue;
                }
                const actualCensor = typeof censor === 'function' ? censor(value, parts) : censor;
                setValue(obj, parts, actualCensor);
            }
        }
    }
}
function redactWildcardPath(obj, parts, censor, originalPath, remove = false) {
    const wildcardIndex = parts.indexOf('*');
    if (wildcardIndex === parts.length - 1) {
        const parentParts = parts.slice(0, -1);
        let current = obj;
        for (const part of parentParts){
            if (current === null || current === undefined) return;
            // Type safety: Check if current is an object before property access
            if (typeof current !== 'object' || current === null) return;
            current = current[part];
        }
        if (Array.isArray(current)) {
            if (remove) {
                // For arrays, set all items to undefined which will be omitted by JSON.stringify
                for(let i = 0; i < current.length; i++){
                    current[i] = undefined;
                }
            } else {
                for(let i = 0; i < current.length; i++){
                    const indexPath = [
                        ...parentParts,
                        i.toString()
                    ];
                    const actualCensor = typeof censor === 'function' ? censor(current[i], indexPath) : censor;
                    current[i] = actualCensor;
                }
            }
        } else if (typeof current === 'object' && current !== null) {
            if (remove) {
                // Collect keys to delete to avoid issues with deleting during iteration
                const keysToDelete = [];
                for(const key in current){
                    if (Object.prototype.hasOwnProperty.call(current, key)) {
                        keysToDelete.push(key);
                    }
                }
                for (const key of keysToDelete){
                    delete current[key];
                }
            } else {
                for(const key in current){
                    const keyPath = [
                        ...parentParts,
                        key
                    ];
                    const actualCensor = typeof censor === 'function' ? censor(current[key], keyPath) : censor;
                    current[key] = actualCensor;
                }
            }
        }
    } else {
        redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove);
    }
}
function redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove = false) {
    const beforeWildcard = parts.slice(0, wildcardIndex);
    const afterWildcard = parts.slice(wildcardIndex + 1);
    const pathArray = [] // Cached array to avoid allocations
    ;
    function traverse(current, pathLength) {
        if (pathLength === beforeWildcard.length) {
            if (Array.isArray(current)) {
                for(let i = 0; i < current.length; i++){
                    pathArray[pathLength] = i.toString();
                    traverse(current[i], pathLength + 1);
                }
            } else if (typeof current === 'object' && current !== null) {
                for(const key in current){
                    pathArray[pathLength] = key;
                    traverse(current[key], pathLength + 1);
                }
            }
        } else if (pathLength < beforeWildcard.length) {
            const nextKey = beforeWildcard[pathLength];
            // Type safety: Check if current is an object before using 'in' operator
            if (current && typeof current === 'object' && current !== null && nextKey in current) {
                pathArray[pathLength] = nextKey;
                traverse(current[nextKey], pathLength + 1);
            }
        } else {
            // Check if afterWildcard contains more wildcards
            if (afterWildcard.includes('*')) {
                // Recursively handle remaining wildcards
                // Wrap censor to prepend current path context
                const wrappedCensor = typeof censor === 'function' ? (value, path)=>{
                    const fullPath = [
                        ...pathArray.slice(0, pathLength),
                        ...path
                    ];
                    return censor(value, fullPath);
                } : censor;
                redactWildcardPath(current, afterWildcard, wrappedCensor, originalPath, remove);
            } else {
                // No more wildcards, apply the redaction directly
                if (remove) {
                    removeKey(current, afterWildcard);
                } else {
                    const actualCensor = typeof censor === 'function' ? censor(getValue(current, afterWildcard), [
                        ...pathArray.slice(0, pathLength),
                        ...afterWildcard
                    ]) : censor;
                    setValue(current, afterWildcard, actualCensor);
                }
            }
        }
    }
    if (beforeWildcard.length === 0) {
        traverse(obj, 0);
    } else {
        let current = obj;
        for(let i = 0; i < beforeWildcard.length; i++){
            const part = beforeWildcard[i];
            if (current === null || current === undefined) return;
            // Type safety: Check if current is an object before property access
            if (typeof current !== 'object' || current === null) return;
            current = current[part];
            pathArray[i] = part;
        }
        if (current !== null && current !== undefined) {
            traverse(current, beforeWildcard.length);
        }
    }
}
function buildPathStructure(pathsToClone) {
    if (pathsToClone.length === 0) {
        return null // No paths to redact
        ;
    }
    // Parse all paths and organize by depth
    const pathStructure = new Map();
    for (const path of pathsToClone){
        const parts = parsePath(path);
        let current = pathStructure;
        for(let i = 0; i < parts.length; i++){
            const part = parts[i];
            if (!current.has(part)) {
                current.set(part, new Map());
            }
            current = current.get(part);
        }
    }
    return pathStructure;
}
function selectiveClone(obj, pathStructure) {
    if (!pathStructure) {
        return obj // No paths to redact, return original
        ;
    }
    function cloneSelectively(source, pathMap, depth = 0) {
        if (!pathMap || pathMap.size === 0) {
            return source // No more paths to clone, return reference
            ;
        }
        if (source === null || typeof source !== 'object') {
            return source;
        }
        if (source instanceof Date) {
            return new Date(source.getTime());
        }
        if (Array.isArray(source)) {
            const cloned = [];
            for(let i = 0; i < source.length; i++){
                const indexStr = i.toString();
                if (pathMap.has(indexStr) || pathMap.has('*')) {
                    cloned[i] = cloneSelectively(source[i], pathMap.get(indexStr) || pathMap.get('*'));
                } else {
                    cloned[i] = source[i]; // Share reference for non-redacted items
                }
            }
            return cloned;
        }
        // Handle objects
        const cloned = Object.create(Object.getPrototypeOf(source));
        for(const key in source){
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                if (pathMap.has(key) || pathMap.has('*')) {
                    cloned[key] = cloneSelectively(source[key], pathMap.get(key) || pathMap.get('*'));
                } else {
                    cloned[key] = source[key]; // Share reference for non-redacted properties
                }
            }
        }
        return cloned;
    }
    return cloneSelectively(obj, pathStructure);
}
function validatePath(path) {
    if (typeof path !== 'string') {
        throw new Error('Paths must be (non-empty) strings');
    }
    if (path === '') {
        throw new Error('Invalid redaction path ()');
    }
    // Check for double dots
    if (path.includes('..')) {
        throw new Error(`Invalid redaction path (${path})`);
    }
    // Check for comma-separated paths (invalid syntax)
    if (path.includes(',')) {
        throw new Error(`Invalid redaction path (${path})`);
    }
    // Check for unmatched brackets
    let bracketCount = 0;
    let inQuotes = false;
    let quoteChar = '';
    for(let i = 0; i < path.length; i++){
        const char = path[i];
        if ((char === '"' || char === "'") && bracketCount > 0) {
            if (!inQuotes) {
                inQuotes = true;
                quoteChar = char;
            } else if (char === quoteChar) {
                inQuotes = false;
                quoteChar = '';
            }
        } else if (char === '[' && !inQuotes) {
            bracketCount++;
        } else if (char === ']' && !inQuotes) {
            bracketCount--;
            if (bracketCount < 0) {
                throw new Error(`Invalid redaction path (${path})`);
            }
        }
    }
    if (bracketCount !== 0) {
        throw new Error(`Invalid redaction path (${path})`);
    }
}
function validatePaths(paths) {
    if (!Array.isArray(paths)) {
        throw new TypeError('paths must be an array');
    }
    for (const path of paths){
        validatePath(path);
    }
}
function slowRedact(options = {}) {
    const { paths = [], censor = '[REDACTED]', serialize = JSON.stringify, strict = true, remove = false } = options;
    // Validate paths upfront to match fast-redact behavior
    validatePaths(paths);
    // Build path structure once during setup, not on every call
    const pathStructure = buildPathStructure(paths);
    return function redact(obj) {
        if (strict && (obj === null || typeof obj !== 'object')) {
            if (obj === null || obj === undefined) {
                return serialize ? serialize(obj) : obj;
            }
            if (typeof obj !== 'object') {
                return serialize ? serialize(obj) : obj;
            }
        }
        // Only clone paths that need redaction
        const cloned = selectiveClone(obj, pathStructure);
        const original = obj // Keep reference to original for restore
        ;
        let actualCensor = censor;
        if (typeof censor === 'function') {
            actualCensor = censor;
        }
        redactPaths(cloned, paths, actualCensor, remove);
        if (serialize === false) {
            cloned.restore = function() {
                return deepClone(original) // Full clone only when restore is called
                ;
            };
            return cloned;
        }
        if (typeof serialize === 'function') {
            return serialize(cloned);
        }
        return JSON.stringify(cloned);
    };
}
module.exports = slowRedact;
}),
"[project]/node_modules/quick-format-unescaped/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function tryStringify(o) {
    try {
        return JSON.stringify(o);
    } catch (e) {
        return '"[Circular]"';
    }
}
module.exports = format;
function format(f, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset = 1;
    if (typeof f === 'object' && f !== null) {
        var len = args.length + offset;
        if (len === 1) return f;
        var objects = new Array(len);
        objects[0] = ss(f);
        for(var index = 1; index < len; index++){
            objects[index] = ss(args[index]);
        }
        return objects.join(' ');
    }
    if (typeof f !== 'string') {
        return f;
    }
    var argLen = args.length;
    if (argLen === 0) return f;
    var str = '';
    var a = 1 - offset;
    var lastPos = -1;
    var flen = f && f.length || 0;
    for(var i = 0; i < flen;){
        if (f.charCodeAt(i) === 37 && i + 1 < flen) {
            lastPos = lastPos > -1 ? lastPos : 0;
            switch(f.charCodeAt(i + 1)){
                case 100:
                case 102:
                    if (a >= argLen) break;
                    if (args[a] == null) break;
                    if (lastPos < i) str += f.slice(lastPos, i);
                    str += Number(args[a]);
                    lastPos = i + 2;
                    i++;
                    break;
                case 105:
                    if (a >= argLen) break;
                    if (args[a] == null) break;
                    if (lastPos < i) str += f.slice(lastPos, i);
                    str += Math.floor(Number(args[a]));
                    lastPos = i + 2;
                    i++;
                    break;
                case 79:
                case 111:
                case 106:
                    if (a >= argLen) break;
                    if (args[a] === undefined) break;
                    if (lastPos < i) str += f.slice(lastPos, i);
                    var type = typeof args[a];
                    if (type === 'string') {
                        str += '\'' + args[a] + '\'';
                        lastPos = i + 2;
                        i++;
                        break;
                    }
                    if (type === 'function') {
                        str += args[a].name || '<anonymous>';
                        lastPos = i + 2;
                        i++;
                        break;
                    }
                    str += ss(args[a]);
                    lastPos = i + 2;
                    i++;
                    break;
                case 115:
                    if (a >= argLen) break;
                    if (lastPos < i) str += f.slice(lastPos, i);
                    str += String(args[a]);
                    lastPos = i + 2;
                    i++;
                    break;
                case 37:
                    if (lastPos < i) str += f.slice(lastPos, i);
                    str += '%';
                    lastPos = i + 2;
                    i++;
                    a--;
                    break;
            }
            ++a;
        }
        ++i;
    }
    if (lastPos === -1) return f;
    else if (lastPos < flen) {
        str += f.slice(lastPos);
    }
    return str;
}
}),
"[project]/node_modules/sonic-boom/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const EventEmitter = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const inherits = __turbopack_context__.r("[externals]/util [external] (util, cjs)").inherits;
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const sleep = __turbopack_context__.r("[project]/node_modules/atomic-sleep/index.js [app-route] (ecmascript)");
const assert = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
const BUSY_WRITE_TIMEOUT = 100;
const kEmptyBuffer = Buffer.allocUnsafe(0);
// 16 KB. Don't write more than docker buffer size.
// https://github.com/moby/moby/blob/513ec73831269947d38a644c278ce3cac36783b2/daemon/logger/copier.go#L13
const MAX_WRITE = 16 * 1024;
const kContentModeBuffer = 'buffer';
const kContentModeUtf8 = 'utf8';
const [major, minor] = (process.versions.node || '0.0').split('.').map(Number);
const kCopyBuffer = major >= 22 && minor >= 7;
function openFile(file, sonic) {
    sonic._opening = true;
    sonic._writing = true;
    sonic._asyncDrainScheduled = false;
    // NOTE: 'error' and 'ready' events emitted below only relevant when sonic.sync===false
    // for sync mode, there is no way to add a listener that will receive these
    function fileOpened(err, fd) {
        if (err) {
            sonic._reopening = false;
            sonic._writing = false;
            sonic._opening = false;
            if (sonic.sync) {
                process.nextTick(()=>{
                    if (sonic.listenerCount('error') > 0) {
                        sonic.emit('error', err);
                    }
                });
            } else {
                sonic.emit('error', err);
            }
            return;
        }
        const reopening = sonic._reopening;
        sonic.fd = fd;
        sonic.file = file;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
            process.nextTick(()=>sonic.emit('ready'));
        } else {
            sonic.emit('ready');
        }
        if (sonic.destroyed) {
            return;
        }
        // start
        if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
            sonic._actualWrite();
        } else if (reopening) {
            process.nextTick(()=>sonic.emit('drain'));
        }
    }
    const flags = sonic.append ? 'a' : 'w';
    const mode = sonic.mode;
    if (sonic.sync) {
        try {
            if (sonic.mkdir) fs.mkdirSync(path.dirname(file), {
                recursive: true
            });
            const fd = fs.openSync(file, flags, mode);
            fileOpened(null, fd);
        } catch (err) {
            fileOpened(err);
            throw err;
        }
    } else if (sonic.mkdir) {
        fs.mkdir(path.dirname(file), {
            recursive: true
        }, (err)=>{
            if (err) return fileOpened(err);
            fs.open(file, flags, mode, fileOpened);
        });
    } else {
        fs.open(file, flags, mode, fileOpened);
    }
}
function SonicBoom(opts) {
    if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
    }
    let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};
    fd = fd || dest;
    this._len = 0;
    this.fd = -1;
    this._bufs = [];
    this._lens = [];
    this._writing = false;
    this._ending = false;
    this._reopening = false;
    this._asyncDrainScheduled = false;
    this._flushPending = false;
    this._hwm = Math.max(minLength || 0, 16387);
    this.file = null;
    this.destroyed = false;
    this.minLength = minLength || 0;
    this.maxLength = maxLength || 0;
    this.maxWrite = maxWrite || MAX_WRITE;
    this._periodicFlush = periodicFlush || 0;
    this._periodicFlushTimer = undefined;
    this.sync = sync || false;
    this.writable = true;
    this._fsync = fsync || false;
    this.append = append || false;
    this.mode = mode;
    this.retryEAGAIN = retryEAGAIN || (()=>true);
    this.mkdir = mkdir || false;
    let fsWriteSync;
    let fsWrite;
    if (contentMode === kContentModeBuffer) {
        this._writingBuf = kEmptyBuffer;
        this.write = writeBuffer;
        this.flush = flushBuffer;
        this.flushSync = flushBufferSync;
        this._actualWrite = actualWriteBuffer;
        fsWriteSync = ()=>fs.writeSync(this.fd, this._writingBuf);
        fsWrite = ()=>fs.write(this.fd, this._writingBuf, this.release);
    } else if (contentMode === undefined || contentMode === kContentModeUtf8) {
        this._writingBuf = '';
        this.write = write;
        this.flush = flush;
        this.flushSync = flushSync;
        this._actualWrite = actualWrite;
        fsWriteSync = ()=>fs.writeSync(this.fd, this._writingBuf, 'utf8');
        fsWrite = ()=>fs.write(this.fd, this._writingBuf, 'utf8', this.release);
    } else {
        throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
    }
    if (typeof fd === 'number') {
        this.fd = fd;
        process.nextTick(()=>this.emit('ready'));
    } else if (typeof fd === 'string') {
        openFile(fd, this);
    } else {
        throw new Error('SonicBoom supports only file descriptors and files');
    }
    if (this.minLength >= this.maxWrite) {
        throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    }
    this.release = (err, n)=>{
        if (err) {
            if ((err.code === 'EAGAIN' || err.code === 'EBUSY') && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
                if (this.sync) {
                    // This error code should not happen in sync mode, because it is
                    // not using the underlining operating system asynchronous functions.
                    // However it happens, and so we handle it.
                    // Ref: https://github.com/pinojs/pino/issues/783
                    try {
                        sleep(BUSY_WRITE_TIMEOUT);
                        this.release(undefined, 0);
                    } catch (err) {
                        this.release(err);
                    }
                } else {
                    // Let's give the destination some time to process the chunk.
                    setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
                }
            } else {
                this._writing = false;
                this.emit('error', err);
            }
            return;
        }
        this.emit('write', n);
        const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
        this._len = releasedBufObj.len;
        this._writingBuf = releasedBufObj.writingBuf;
        if (this._writingBuf.length) {
            if (!this.sync) {
                fsWrite();
                return;
            }
            try {
                do {
                    const n = fsWriteSync();
                    const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
                    this._len = releasedBufObj.len;
                    this._writingBuf = releasedBufObj.writingBuf;
                }while (this._writingBuf.length)
            } catch (err) {
                this.release(err);
                return;
            }
        }
        if (this._fsync) {
            fs.fsyncSync(this.fd);
        }
        const len = this._len;
        if (this._reopening) {
            this._writing = false;
            this._reopening = false;
            this.reopen();
        } else if (len > this.minLength) {
            this._actualWrite();
        } else if (this._ending) {
            if (len > 0) {
                this._actualWrite();
            } else {
                this._writing = false;
                actualClose(this);
            }
        } else {
            this._writing = false;
            if (this.sync) {
                if (!this._asyncDrainScheduled) {
                    this._asyncDrainScheduled = true;
                    process.nextTick(emitDrain, this);
                }
            } else {
                this.emit('drain');
            }
        }
    };
    this.on('newListener', function(name) {
        if (name === 'drain') {
            this._asyncDrainScheduled = false;
        }
    });
    if (this._periodicFlush !== 0) {
        this._periodicFlushTimer = setInterval(()=>this.flush(null), this._periodicFlush);
        this._periodicFlushTimer.unref();
    }
}
/**
 * Release the writingBuf after fs.write n bytes data
 * @param {string | Buffer} writingBuf - currently writing buffer, usually be instance._writingBuf.
 * @param {number} len - currently buffer length, usually be instance._len.
 * @param {number} n - number of bytes fs already written
 * @returns {{writingBuf: string | Buffer, len: number}} released writingBuf and length
 */ function releaseWritingBuf(writingBuf, len, n) {
    // if Buffer.byteLength is equal to n, that means writingBuf contains no multi-byte character
    if (typeof writingBuf === 'string' && Buffer.byteLength(writingBuf) !== n) {
        // Since the fs.write callback parameter `n` means how many bytes the passed of string
        // We calculate the original string length for avoiding the multi-byte character issue
        n = Buffer.from(writingBuf).subarray(0, n).toString().length;
    }
    len = Math.max(len - n, 0);
    writingBuf = writingBuf.slice(n);
    return {
        writingBuf,
        len
    };
}
function emitDrain(sonic) {
    const hasListeners = sonic.listenerCount('drain') > 0;
    if (!hasListeners) return;
    sonic._asyncDrainScheduled = false;
    sonic.emit('drain');
}
inherits(SonicBoom, EventEmitter);
function mergeBuf(bufs, len) {
    if (bufs.length === 0) {
        return kEmptyBuffer;
    }
    if (bufs.length === 1) {
        return bufs[0];
    }
    return Buffer.concat(bufs, len);
}
function write(data) {
    if (this.destroyed) {
        throw new Error('SonicBoom destroyed');
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    if (this.maxLength && len > this.maxLength) {
        this.emit('drop', data);
        return this._len < this._hwm;
    }
    if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
        bufs.push('' + data);
    } else {
        bufs[bufs.length - 1] += data;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
    }
    return this._len < this._hwm;
}
function writeBuffer(data) {
    if (this.destroyed) {
        throw new Error('SonicBoom destroyed');
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    const lens = this._lens;
    if (this.maxLength && len > this.maxLength) {
        this.emit('drop', data);
        return this._len < this._hwm;
    }
    if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
        bufs.push([
            data
        ]);
        lens.push(data.length);
    } else {
        bufs[bufs.length - 1].push(data);
        lens[lens.length - 1] += data.length;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
    }
    return this._len < this._hwm;
}
function callFlushCallbackOnDrain(cb) {
    this._flushPending = true;
    const onDrain = ()=>{
        // only if _fsync is false to avoid double fsync
        if (!this._fsync) {
            try {
                fs.fsync(this.fd, (err)=>{
                    this._flushPending = false;
                    cb(err);
                });
            } catch (err) {
                cb(err);
            }
        } else {
            this._flushPending = false;
            cb();
        }
        this.off('error', onError);
    };
    const onError = (err)=>{
        this._flushPending = false;
        cb(err);
        this.off('drain', onDrain);
    };
    this.once('drain', onDrain);
    this.once('error', onError);
}
function flush(cb) {
    if (cb != null && typeof cb !== 'function') {
        throw new Error('flush cb must be a function');
    }
    if (this.destroyed) {
        const error = new Error('SonicBoom destroyed');
        if (cb) {
            cb(error);
            return;
        }
        throw error;
    }
    if (this.minLength <= 0) {
        cb?.();
        return;
    }
    if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
        return;
    }
    if (this._bufs.length === 0) {
        this._bufs.push('');
    }
    this._actualWrite();
}
function flushBuffer(cb) {
    if (cb != null && typeof cb !== 'function') {
        throw new Error('flush cb must be a function');
    }
    if (this.destroyed) {
        const error = new Error('SonicBoom destroyed');
        if (cb) {
            cb(error);
            return;
        }
        throw error;
    }
    if (this.minLength <= 0) {
        cb?.();
        return;
    }
    if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
        return;
    }
    if (this._bufs.length === 0) {
        this._bufs.push([]);
        this._lens.push(0);
    }
    this._actualWrite();
}
SonicBoom.prototype.reopen = function(file) {
    if (this.destroyed) {
        throw new Error('SonicBoom destroyed');
    }
    if (this._opening) {
        this.once('ready', ()=>{
            this.reopen(file);
        });
        return;
    }
    if (this._ending) {
        return;
    }
    if (!this.file) {
        throw new Error('Unable to reopen a file descriptor, you must pass a file to SonicBoom');
    }
    if (file) {
        this.file = file;
    }
    this._reopening = true;
    if (this._writing) {
        return;
    }
    const fd = this.fd;
    this.once('ready', ()=>{
        if (fd !== this.fd) {
            fs.close(fd, (err)=>{
                if (err) {
                    return this.emit('error', err);
                }
            });
        }
    });
    openFile(this.file, this);
};
SonicBoom.prototype.end = function() {
    if (this.destroyed) {
        throw new Error('SonicBoom destroyed');
    }
    if (this._opening) {
        this.once('ready', ()=>{
            this.end();
        });
        return;
    }
    if (this._ending) {
        return;
    }
    this._ending = true;
    if (this._writing) {
        return;
    }
    if (this._len > 0 && this.fd >= 0) {
        this._actualWrite();
    } else {
        actualClose(this);
    }
};
function flushSync() {
    if (this.destroyed) {
        throw new Error('SonicBoom destroyed');
    }
    if (this.fd < 0) {
        throw new Error('sonic boom is not ready yet');
    }
    if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift(this._writingBuf);
        this._writingBuf = '';
    }
    let buf = '';
    while(this._bufs.length || buf){
        if (buf.length <= 0) {
            buf = this._bufs[0];
        }
        try {
            const n = fs.writeSync(this.fd, buf, 'utf8');
            const releasedBufObj = releaseWritingBuf(buf, this._len, n);
            buf = releasedBufObj.writingBuf;
            this._len = releasedBufObj.len;
            if (buf.length <= 0) {
                this._bufs.shift();
            }
        } catch (err) {
            const shouldRetry = err.code === 'EAGAIN' || err.code === 'EBUSY';
            if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
                throw err;
            }
            sleep(BUSY_WRITE_TIMEOUT);
        }
    }
    try {
        fs.fsyncSync(this.fd);
    } catch  {
    // Skip the error. The fd might not support fsync.
    }
}
function flushBufferSync() {
    if (this.destroyed) {
        throw new Error('SonicBoom destroyed');
    }
    if (this.fd < 0) {
        throw new Error('sonic boom is not ready yet');
    }
    if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift([
            this._writingBuf
        ]);
        this._writingBuf = kEmptyBuffer;
    }
    let buf = kEmptyBuffer;
    while(this._bufs.length || buf.length){
        if (buf.length <= 0) {
            buf = mergeBuf(this._bufs[0], this._lens[0]);
        }
        try {
            const n = fs.writeSync(this.fd, buf);
            buf = buf.subarray(n);
            this._len = Math.max(this._len - n, 0);
            if (buf.length <= 0) {
                this._bufs.shift();
                this._lens.shift();
            }
        } catch (err) {
            const shouldRetry = err.code === 'EAGAIN' || err.code === 'EBUSY';
            if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
                throw err;
            }
            sleep(BUSY_WRITE_TIMEOUT);
        }
    }
}
SonicBoom.prototype.destroy = function() {
    if (this.destroyed) {
        return;
    }
    actualClose(this);
};
function actualWrite() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf || this._bufs.shift() || '';
    if (this.sync) {
        try {
            const written = fs.writeSync(this.fd, this._writingBuf, 'utf8');
            release(null, written);
        } catch (err) {
            release(err);
        }
    } else {
        fs.write(this.fd, this._writingBuf, 'utf8', release);
    }
}
function actualWriteBuffer() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
    if (this.sync) {
        try {
            const written = fs.writeSync(this.fd, this._writingBuf);
            release(null, written);
        } catch (err) {
            release(err);
        }
    } else {
        // fs.write will need to copy string to buffer anyway so
        // we do it here to avoid the overhead of calculating the buffer size
        // in releaseWritingBuf.
        if (kCopyBuffer) {
            this._writingBuf = Buffer.from(this._writingBuf);
        }
        fs.write(this.fd, this._writingBuf, release);
    }
}
function actualClose(sonic) {
    if (sonic.fd === -1) {
        sonic.once('ready', actualClose.bind(null, sonic));
        return;
    }
    if (sonic._periodicFlushTimer !== undefined) {
        clearInterval(sonic._periodicFlushTimer);
    }
    sonic.destroyed = true;
    sonic._bufs = [];
    sonic._lens = [];
    assert(typeof sonic.fd === 'number', `sonic.fd must be a number, got ${typeof sonic.fd}`);
    try {
        fs.fsync(sonic.fd, closeWrapped);
    } catch  {}
    function closeWrapped() {
        // We skip errors in fsync
        if (sonic.fd !== 1 && sonic.fd !== 2) {
            fs.close(sonic.fd, done);
        } else {
            done();
        }
    }
    function done(err) {
        if (err) {
            sonic.emit('error', err);
            return;
        }
        if (sonic._ending && !sonic._writing) {
            sonic.emit('finish');
        }
        sonic.emit('close');
    }
}
/**
 * These export configurations enable JS and TS developers
 * to consumer SonicBoom in whatever way best suits their needs.
 * Some examples of supported import syntax includes:
 * - `const SonicBoom = require('SonicBoom')`
 * - `const { SonicBoom } = require('SonicBoom')`
 * - `import * as SonicBoom from 'SonicBoom'`
 * - `import { SonicBoom } from 'SonicBoom'`
 * - `import SonicBoom from 'SonicBoom'`
 */ SonicBoom.SonicBoom = SonicBoom;
SonicBoom.default = SonicBoom;
module.exports = SonicBoom;
}),
"[project]/node_modules/safe-stable-stringify/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { hasOwnProperty } = Object.prototype;
const stringify = configure();
// @ts-expect-error
stringify.configure = configure;
// @ts-expect-error
stringify.stringify = stringify;
// @ts-expect-error
stringify.default = stringify;
// @ts-expect-error used for named export
exports.stringify = stringify;
// @ts-expect-error used for named export
exports.configure = configure;
module.exports = stringify;
// eslint-disable-next-line no-control-regex
const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
// Escape C0 control characters, double quotes, the backslash and every code
// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.
function strEscape(str) {
    // Some magic numbers that worked out fine while benchmarking with v8 8.0
    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
    }
    return JSON.stringify(str);
}
function sort(array, comparator) {
    // Insertion sort is very efficient for small input sizes, but it has a bad
    // worst case complexity. Thus, use native array sort for bigger values.
    if (array.length > 2e2 || comparator) {
        return array.sort(comparator);
    }
    for(let i = 1; i < array.length; i++){
        const currentValue = array[i];
        let position = i;
        while(position !== 0 && array[position - 1] > currentValue){
            array[position] = array[position - 1];
            position--;
        }
        array[position] = currentValue;
    }
    return array;
}
const typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())), Symbol.toStringTag).get;
function isTypedArrayWithEntries(value) {
    return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;
}
function stringifyTypedArray(array, separator, maximumBreadth) {
    if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
    }
    const whitespace = separator === ',' ? '' : ' ';
    let res = `"0":${whitespace}${array[0]}`;
    for(let i = 1; i < maximumBreadth; i++){
        res += `${separator}"${i}":${whitespace}${array[i]}`;
    }
    return res;
}
function getCircularValueOption(options) {
    if (hasOwnProperty.call(options, 'circularValue')) {
        const circularValue = options.circularValue;
        if (typeof circularValue === 'string') {
            return `"${circularValue}"`;
        }
        if (circularValue == null) {
            return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
            return {
                toString () {
                    throw new TypeError('Converting circular structure to JSON');
                }
            };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
}
function getDeterministicOption(options) {
    let value;
    if (hasOwnProperty.call(options, 'deterministic')) {
        value = options.deterministic;
        if (typeof value !== 'boolean' && typeof value !== 'function') {
            throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
    }
    return value === undefined ? true : value;
}
function getBooleanOption(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== 'boolean') {
            throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
    }
    return value === undefined ? true : value;
}
function getPositiveIntegerOption(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== 'number') {
            throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
            throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
            throw new RangeError(`The "${key}" argument must be >= 1`);
        }
    }
    return value === undefined ? Infinity : value;
}
function getItemCount(number) {
    if (number === 1) {
        return '1 item';
    }
    return `${number} items`;
}
function getUniqueReplacerSet(replacerArray) {
    const replacerSet = new Set();
    for (const value of replacerArray){
        if (typeof value === 'string' || typeof value === 'number') {
            replacerSet.add(String(value));
        }
    }
    return replacerSet;
}
function getStrictOption(options) {
    if (hasOwnProperty.call(options, 'strict')) {
        const value = options.strict;
        if (typeof value !== 'boolean') {
            throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
            return (value)=>{
                let message = `Object can not safely be stringified. Received type ${typeof value}`;
                if (typeof value !== 'function') message += ` (${value.toString()})`;
                throw new Error(message);
            };
        }
    }
}
function configure(options) {
    options = {
        ...options
    };
    const fail = getStrictOption(options);
    if (fail) {
        if (options.bigint === undefined) {
            options.bigint = false;
        }
        if (!('circularValue' in options)) {
            options.circularValue = Error;
        }
    }
    const circularValue = getCircularValueOption(options);
    const bigint = getBooleanOption(options, 'bigint');
    const deterministic = getDeterministicOption(options);
    const comparator = typeof deterministic === 'function' ? deterministic : undefined;
    const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth');
    const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth');
    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch(typeof value){
            case 'string':
                return strEscape(value);
            case 'object':
                {
                    if (value === null) {
                        return 'null';
                    }
                    if (stack.indexOf(value) !== -1) {
                        return circularValue;
                    }
                    let res = '';
                    let join = ',';
                    const originalIndentation = indentation;
                    if (Array.isArray(value)) {
                        if (value.length === 0) {
                            return '[]';
                        }
                        if (maximumDepth < stack.length + 1) {
                            return '"[Array]"';
                        }
                        stack.push(value);
                        if (spacer !== '') {
                            indentation += spacer;
                            res += `\n${indentation}`;
                            join = `,\n${indentation}`;
                        }
                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                        let i = 0;
                        for(; i < maximumValuesToStringify - 1; i++){
                            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                            res += tmp !== undefined ? tmp : 'null';
                            res += join;
                        }
                        const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                        res += tmp !== undefined ? tmp : 'null';
                        if (value.length - 1 > maximumBreadth) {
                            const removedKeys = value.length - maximumBreadth - 1;
                            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                        }
                        if (spacer !== '') {
                            res += `\n${originalIndentation}`;
                        }
                        stack.pop();
                        return `[${res}]`;
                    }
                    let keys = Object.keys(value);
                    const keyLength = keys.length;
                    if (keyLength === 0) {
                        return '{}';
                    }
                    if (maximumDepth < stack.length + 1) {
                        return '"[Object]"';
                    }
                    let whitespace = '';
                    let separator = '';
                    if (spacer !== '') {
                        indentation += spacer;
                        join = `,\n${indentation}`;
                        whitespace = ' ';
                    }
                    const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                    if (deterministic && !isTypedArrayWithEntries(value)) {
                        keys = sort(keys, comparator);
                    }
                    stack.push(value);
                    for(let i = 0; i < maximumPropertiesToStringify; i++){
                        const key = keys[i];
                        const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation);
                        if (tmp !== undefined) {
                            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;
                            separator = join;
                        }
                    }
                    if (keyLength > maximumBreadth) {
                        const removedKeys = keyLength - maximumBreadth;
                        res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
                        separator = join;
                    }
                    if (spacer !== '' && separator.length > 1) {
                        res = `\n${indentation}${res}\n${originalIndentation}`;
                    }
                    stack.pop();
                    return `{${res}}`;
                }
            case 'number':
                return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
            case 'boolean':
                return value === true ? 'true' : 'false';
            case 'undefined':
                return undefined;
            case 'bigint':
                if (bigint) {
                    return String(value);
                }
            // fallthrough
            default:
                return fail ? fail(value) : undefined;
        }
    }
    function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }
        switch(typeof value){
            case 'string':
                return strEscape(value);
            case 'object':
                {
                    if (value === null) {
                        return 'null';
                    }
                    if (stack.indexOf(value) !== -1) {
                        return circularValue;
                    }
                    const originalIndentation = indentation;
                    let res = '';
                    let join = ',';
                    if (Array.isArray(value)) {
                        if (value.length === 0) {
                            return '[]';
                        }
                        if (maximumDepth < stack.length + 1) {
                            return '"[Array]"';
                        }
                        stack.push(value);
                        if (spacer !== '') {
                            indentation += spacer;
                            res += `\n${indentation}`;
                            join = `,\n${indentation}`;
                        }
                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                        let i = 0;
                        for(; i < maximumValuesToStringify - 1; i++){
                            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                            res += tmp !== undefined ? tmp : 'null';
                            res += join;
                        }
                        const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                        res += tmp !== undefined ? tmp : 'null';
                        if (value.length - 1 > maximumBreadth) {
                            const removedKeys = value.length - maximumBreadth - 1;
                            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                        }
                        if (spacer !== '') {
                            res += `\n${originalIndentation}`;
                        }
                        stack.pop();
                        return `[${res}]`;
                    }
                    stack.push(value);
                    let whitespace = '';
                    if (spacer !== '') {
                        indentation += spacer;
                        join = `,\n${indentation}`;
                        whitespace = ' ';
                    }
                    let separator = '';
                    for (const key of replacer){
                        const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation);
                        if (tmp !== undefined) {
                            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;
                            separator = join;
                        }
                    }
                    if (spacer !== '' && separator.length > 1) {
                        res = `\n${indentation}${res}\n${originalIndentation}`;
                    }
                    stack.pop();
                    return `{${res}}`;
                }
            case 'number':
                return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
            case 'boolean':
                return value === true ? 'true' : 'false';
            case 'undefined':
                return undefined;
            case 'bigint':
                if (bigint) {
                    return String(value);
                }
            // fallthrough
            default:
                return fail ? fail(value) : undefined;
        }
    }
    function stringifyIndent(key, value, stack, spacer, indentation) {
        switch(typeof value){
            case 'string':
                return strEscape(value);
            case 'object':
                {
                    if (value === null) {
                        return 'null';
                    }
                    if (typeof value.toJSON === 'function') {
                        value = value.toJSON(key);
                        // Prevent calling `toJSON` again.
                        if (typeof value !== 'object') {
                            return stringifyIndent(key, value, stack, spacer, indentation);
                        }
                        if (value === null) {
                            return 'null';
                        }
                    }
                    if (stack.indexOf(value) !== -1) {
                        return circularValue;
                    }
                    const originalIndentation = indentation;
                    if (Array.isArray(value)) {
                        if (value.length === 0) {
                            return '[]';
                        }
                        if (maximumDepth < stack.length + 1) {
                            return '"[Array]"';
                        }
                        stack.push(value);
                        indentation += spacer;
                        let res = `\n${indentation}`;
                        const join = `,\n${indentation}`;
                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                        let i = 0;
                        for(; i < maximumValuesToStringify - 1; i++){
                            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                            res += tmp !== undefined ? tmp : 'null';
                            res += join;
                        }
                        const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                        res += tmp !== undefined ? tmp : 'null';
                        if (value.length - 1 > maximumBreadth) {
                            const removedKeys = value.length - maximumBreadth - 1;
                            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                        }
                        res += `\n${originalIndentation}`;
                        stack.pop();
                        return `[${res}]`;
                    }
                    let keys = Object.keys(value);
                    const keyLength = keys.length;
                    if (keyLength === 0) {
                        return '{}';
                    }
                    if (maximumDepth < stack.length + 1) {
                        return '"[Object]"';
                    }
                    indentation += spacer;
                    const join = `,\n${indentation}`;
                    let res = '';
                    let separator = '';
                    let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                    if (isTypedArrayWithEntries(value)) {
                        res += stringifyTypedArray(value, join, maximumBreadth);
                        keys = keys.slice(value.length);
                        maximumPropertiesToStringify -= value.length;
                        separator = join;
                    }
                    if (deterministic) {
                        keys = sort(keys, comparator);
                    }
                    stack.push(value);
                    for(let i = 0; i < maximumPropertiesToStringify; i++){
                        const key = keys[i];
                        const tmp = stringifyIndent(key, value[key], stack, spacer, indentation);
                        if (tmp !== undefined) {
                            res += `${separator}${strEscape(key)}: ${tmp}`;
                            separator = join;
                        }
                    }
                    if (keyLength > maximumBreadth) {
                        const removedKeys = keyLength - maximumBreadth;
                        res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
                        separator = join;
                    }
                    if (separator !== '') {
                        res = `\n${indentation}${res}\n${originalIndentation}`;
                    }
                    stack.pop();
                    return `{${res}}`;
                }
            case 'number':
                return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
            case 'boolean':
                return value === true ? 'true' : 'false';
            case 'undefined':
                return undefined;
            case 'bigint':
                if (bigint) {
                    return String(value);
                }
            // fallthrough
            default:
                return fail ? fail(value) : undefined;
        }
    }
    function stringifySimple(key, value, stack) {
        switch(typeof value){
            case 'string':
                return strEscape(value);
            case 'object':
                {
                    if (value === null) {
                        return 'null';
                    }
                    if (typeof value.toJSON === 'function') {
                        value = value.toJSON(key);
                        // Prevent calling `toJSON` again
                        if (typeof value !== 'object') {
                            return stringifySimple(key, value, stack);
                        }
                        if (value === null) {
                            return 'null';
                        }
                    }
                    if (stack.indexOf(value) !== -1) {
                        return circularValue;
                    }
                    let res = '';
                    const hasLength = value.length !== undefined;
                    if (hasLength && Array.isArray(value)) {
                        if (value.length === 0) {
                            return '[]';
                        }
                        if (maximumDepth < stack.length + 1) {
                            return '"[Array]"';
                        }
                        stack.push(value);
                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                        let i = 0;
                        for(; i < maximumValuesToStringify - 1; i++){
                            const tmp = stringifySimple(String(i), value[i], stack);
                            res += tmp !== undefined ? tmp : 'null';
                            res += ',';
                        }
                        const tmp = stringifySimple(String(i), value[i], stack);
                        res += tmp !== undefined ? tmp : 'null';
                        if (value.length - 1 > maximumBreadth) {
                            const removedKeys = value.length - maximumBreadth - 1;
                            res += `,"... ${getItemCount(removedKeys)} not stringified"`;
                        }
                        stack.pop();
                        return `[${res}]`;
                    }
                    let keys = Object.keys(value);
                    const keyLength = keys.length;
                    if (keyLength === 0) {
                        return '{}';
                    }
                    if (maximumDepth < stack.length + 1) {
                        return '"[Object]"';
                    }
                    let separator = '';
                    let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                    if (hasLength && isTypedArrayWithEntries(value)) {
                        res += stringifyTypedArray(value, ',', maximumBreadth);
                        keys = keys.slice(value.length);
                        maximumPropertiesToStringify -= value.length;
                        separator = ',';
                    }
                    if (deterministic) {
                        keys = sort(keys, comparator);
                    }
                    stack.push(value);
                    for(let i = 0; i < maximumPropertiesToStringify; i++){
                        const key = keys[i];
                        const tmp = stringifySimple(key, value[key], stack);
                        if (tmp !== undefined) {
                            res += `${separator}${strEscape(key)}:${tmp}`;
                            separator = ',';
                        }
                    }
                    if (keyLength > maximumBreadth) {
                        const removedKeys = keyLength - maximumBreadth;
                        res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
                    }
                    stack.pop();
                    return `{${res}}`;
                }
            case 'number':
                return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
            case 'boolean':
                return value === true ? 'true' : 'false';
            case 'undefined':
                return undefined;
            case 'bigint':
                if (bigint) {
                    return String(value);
                }
            // fallthrough
            default:
                return fail ? fail(value) : undefined;
        }
    }
    function stringify(value, replacer, space) {
        if (arguments.length > 1) {
            let spacer = '';
            if (typeof space === 'number') {
                spacer = ' '.repeat(Math.min(space, 10));
            } else if (typeof space === 'string') {
                spacer = space.slice(0, 10);
            }
            if (replacer != null) {
                if (typeof replacer === 'function') {
                    return stringifyFnReplacer('', {
                        '': value
                    }, [], replacer, spacer, '');
                }
                if (Array.isArray(replacer)) {
                    return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '');
                }
            }
            if (spacer.length !== 0) {
                return stringifyIndent('', value, [], spacer, '');
            }
        }
        return stringifySimple('', value, []);
    }
    return stringify;
}
}),
];

//# sourceMappingURL=node_modules_8f476a6b._.js.map