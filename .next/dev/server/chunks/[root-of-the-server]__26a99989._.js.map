{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/base-facilitator.ts"],"sourcesContent":["// =============================================================================\n// FACILITATOR ABSTRACTION LAYER\n// =============================================================================\n// Base interface and types for pluggable x402 facilitators\n// Enables multi-facilitator orchestration and routing\n\nimport { createLogger } from '@/lib/logger';\n\nconst logger = createLogger({ component: 'BaseFacilitator' });\n\n/**\n * CAIP-2 Network Identifier (e.g., \"eip155:8453\" for Base)\n * CAIP-19 Asset Identifier (e.g., \"eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\" for USDC on Base)\n */\nexport type CAIPNetworkId = string; // e.g., \"eip155:8453\", \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\", \"bip122:000000000019d6689c085ae165831e93\"\nexport type CAIPAssetId = string; // e.g., \"eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\"\n\n/**\n * Settlement mode for payments\n */\nexport type SettlementMode = 'immediate' | 'deferred' | 'batch';\n\n/**\n * Payment requirements for x402 payment verification\n * Extended to support CAIP identifiers and settlement modes\n */\nexport interface PaymentRequirements {\n  scheme: string; // 'exact', 'x402', etc.\n  network: string; // Legacy: 'base', 'ethereum', 'solana', etc.\n  networks?: CAIPNetworkId[]; // CAIP-2 network identifiers (multi-network support)\n  maxAmountRequired: string; // Amount in smallest units\n  resource: string; // Resource URL\n  description?: string;\n  mimeType?: string;\n  payTo: string; // Recipient address\n  maxTimeoutSeconds?: number;\n  asset: string; // Legacy: Token address\n  assets?: CAIPAssetId[]; // CAIP-19 asset identifiers (multi-asset support)\n  settlementMode?: SettlementMode; // 'immediate', 'deferred', or 'batch'\n}\n\n/**\n * Payment verification result\n */\nexport interface VerificationResult {\n  success: boolean;\n  valid: boolean;\n  transactionHash?: string;\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\n  error?: string;\n  errorDetails?: Record<string, any>;\n  facilitatorId: string; // Which facilitator verified this\n  verifiedAt: string; // ISO timestamp\n}\n\n/**\n * Facilitator health status\n */\nexport interface FacilitatorHealth {\n  healthy: boolean;\n  latency?: number; // ms\n  lastChecked: string; // ISO timestamp\n  error?: string;\n  capabilities: {\n    networks: string[];\n    assets: string[];\n    schemes: string[];\n  };\n}\n\n/**\n * Pricing information for a facilitator\n */\nexport interface PricingInfo {\n  network: string;\n  asset: string;\n  baseFee?: string; // Base fee in smallest units\n  percentageFee?: number; // Percentage fee (0-1)\n  estimatedGas?: string; // Estimated gas cost\n  currency: string; // Fee currency\n}\n\n/**\n * Facilitator configuration\n */\nexport interface FacilitatorConfig {\n  id: string;\n  name: string;\n  enabled: boolean;\n  priority: number; // Lower = higher priority\n  networks: string[]; // Legacy: Supported networks\n  networksCAIP?: CAIPNetworkId[]; // CAIP-2 network identifiers\n  assets: string[]; // Legacy: Supported assets\n  assetsCAIP?: CAIPAssetId[]; // CAIP-19 asset identifiers\n  schemes: string[]; // Supported schemes ('exact', 'x402', etc.)\n  settlementModes?: SettlementMode[]; // Supported settlement modes\n  healthCheckUrl?: string;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Base facilitator interface\n * All facilitators must implement this interface\n */\nexport interface IFacilitator {\n  /**\n   * Unique identifier for this facilitator\n   */\n  readonly id: string;\n\n  /**\n   * Human-readable name\n   */\n  readonly name: string;\n\n  /**\n   * Facilitator configuration\n   */\n  readonly config: FacilitatorConfig;\n\n  /**\n   * Verify an x402 payment\n   */\n  verify(\n    payment: string,\n    requirements: PaymentRequirements\n  ): Promise<VerificationResult>;\n\n  /**\n   * Check facilitator health\n   */\n  getHealth(): Promise<FacilitatorHealth>;\n\n  /**\n   * Get pricing information for a network/asset combination\n   */\n  getPricing(network: string, asset: string): Promise<PricingInfo | null>;\n\n  /**\n   * Check if facilitator supports a given network/asset/scheme\n   * Extended to support settlement modes\n   */\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean;\n}\n\n/**\n * Base facilitator class with common functionality\n */\nexport abstract class BaseFacilitator implements IFacilitator {\n  abstract readonly id: string;\n  abstract readonly name: string;\n  abstract readonly config: FacilitatorConfig;\n\n  protected getLogger() {\n    return logger.child({ facilitator: this.constructor.name });\n  }\n\n  /**\n   * Verify payment (must be implemented by subclasses)\n   */\n  abstract verify(\n    payment: string,\n    requirements: PaymentRequirements\n  ): Promise<VerificationResult>;\n\n  /**\n   * Get health status (must be implemented by subclasses)\n   */\n  abstract getHealth(): Promise<FacilitatorHealth>;\n\n  /**\n   * Get pricing (default implementation returns null)\n   */\n  async getPricing(network: string, asset: string): Promise<PricingInfo | null> {\n    // Default: no pricing info available\n    return null;\n  }\n\n  /**\n   * Check if facilitator supports network/asset/scheme\n   * Enhanced to support both legacy and CAIP identifiers\n   */\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n\n    // Check scheme support\n    if (!this.config.schemes.includes(scheme)) {\n      return false;\n    }\n\n    // Check settlement mode support\n    if (settlementMode && this.config.settlementModes && !this.config.settlementModes.includes(settlementMode)) {\n      return false;\n    }\n\n    // Check network support (legacy or CAIP)\n    const supportsNetwork = \n      this.config.networks.includes(network) ||\n      (this.config.networksCAIP && this.config.networksCAIP.includes(network as CAIPNetworkId));\n\n    if (!supportsNetwork) {\n      return false;\n    }\n\n    // Check asset support (legacy or CAIP)\n    const supportsAsset = \n      this.config.assets.includes(asset) ||\n      (this.config.assetsCAIP && this.config.assetsCAIP.includes(asset as CAIPAssetId));\n\n    return supportsAsset;\n  }\n\n  /**\n   * Check if facilitator supports a CAIP-2 network identifier\n   */\n  supportsCAIPNetwork(caip: CAIPNetworkId): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n    return this.config.networksCAIP?.includes(caip) || false;\n  }\n\n  /**\n   * Check if facilitator supports a CAIP-19 asset identifier\n   */\n  supportsCAIPAsset(caip: CAIPAssetId): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n    return this.config.assetsCAIP?.includes(caip) || false;\n  }\n\n  /**\n   * Validate payment requirements\n   * Enhanced to support CAIP identifiers\n   */\n  protected validateRequirements(\n    requirements: PaymentRequirements\n  ): { valid: boolean; error?: string } {\n    // Check network (legacy or CAIP)\n    const hasNetwork = \n      !!requirements.network || \n      (requirements.networks && requirements.networks.length > 0);\n    \n    if (!hasNetwork) {\n      return { valid: false, error: 'Network is required' };\n    }\n\n    // Check asset (legacy or CAIP)\n    const hasAsset = \n      !!requirements.asset || \n      (requirements.assets && requirements.assets.length > 0);\n    \n    if (!hasAsset) {\n      return { valid: false, error: 'Asset is required' };\n    }\n\n    if (!requirements.payTo) {\n      return { valid: false, error: 'Recipient address (payTo) is required' };\n    }\n    if (!requirements.maxAmountRequired) {\n      return { valid: false, error: 'Amount is required' };\n    }\n\n    // Check support (use legacy network/asset for supports() check, or check CAIP directly)\n    const networkToCheck = requirements.network || (requirements.networks?.[0] || '');\n    const assetToCheck = requirements.asset || (requirements.assets?.[0] || '');\n    \n    // Check CAIP support if CAIP identifiers are provided\n    if (requirements.networks && requirements.networks.length > 0) {\n      const supportsAnyNetwork = requirements.networks.some((n) => \n        this.supportsCAIPNetwork(n) || this.config.networks.includes(n)\n      );\n      if (!supportsAnyNetwork) {\n        return {\n          valid: false,\n          error: `Facilitator ${this.id} does not support any of the requested networks: ${requirements.networks.join(', ')}`,\n        };\n      }\n    }\n\n    if (requirements.assets && requirements.assets.length > 0) {\n      const supportsAnyAsset = requirements.assets.some((a) => \n        this.supportsCAIPAsset(a) || this.config.assets.includes(a)\n      );\n      if (!supportsAnyAsset) {\n        return {\n          valid: false,\n          error: `Facilitator ${this.id} does not support any of the requested assets: ${requirements.assets.join(', ')}`,\n        };\n      }\n    }\n\n    // Check legacy support\n    if (!this.supports(networkToCheck, assetToCheck, requirements.scheme, requirements.settlementMode)) {\n      return {\n        valid: false,\n        error: `Facilitator ${this.id} does not support ${networkToCheck}/${assetToCheck}/${requirements.scheme}`,\n      };\n    }\n    return { valid: true };\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 146, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/cdp-jwt.ts"],"sourcesContent":["import { generateJwt } from '@coinbase/cdp-sdk/auth';\r\n\r\nexport interface CDPJWTPayload {\r\n  sub: string;\r\n  iss: string;\r\n  aud: string[];\r\n  nbf: number;\r\n  exp: number;\r\n  uris?: string[];\r\n}\r\n\r\nexport class CDPJWTGenerator {\r\n  private apiKeyId: string;\r\n  private apiKeySecret: string;\r\n\r\n  constructor(apiKeyId: string, apiKeySecret: string) {\r\n    this.apiKeyId = apiKeyId;\r\n    this.apiKeySecret = apiKeySecret;\r\n  }\r\n\r\n  /**\r\n   * Generate JWT token for CDP API authentication.\r\n   *\r\n   * Uses CDP SDK's generateJwt helper, which signs with the correct\r\n   * algorithm (ES256/EdDSA) for your CDP API key.\r\n   * \r\n   * @param requestMethod - HTTP method (GET, POST, etc.) or null for generic auth\r\n   * @param requestHost - Request host or null\r\n   * @param requestPath - Request path or null\r\n   */\r\n  async generateToken(\r\n    requestMethod: string | null = null,\r\n    requestHost: string | null = null,\r\n    requestPath: string | null = null,\r\n  ): Promise<string> {\r\n    // For REST requests, CDP expects method/host/path\r\n    // For generic facilitator auth, nulls are allowed\r\n    const token = await generateJwt({\r\n      apiKeyId: this.apiKeyId,\r\n      apiKeySecret: this.apiKeySecret,\r\n      requestMethod: requestMethod || null,\r\n      requestHost: requestHost || null,\r\n      requestPath: requestPath || null,\r\n      expiresIn: 120,\r\n      // CDP SDK will handle the JWT payload and headers correctly.\r\n    });\r\n\r\n    return token;\r\n  }\r\n\r\n  isTokenValid(_token: string): boolean {\r\n    // Keep simple: rely on short expiry and CDP errors instead of local decode.\r\n    return true;\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet jwtGenerator: CDPJWTGenerator | null = null;\r\n\r\nexport function getCDPJWTGenerator(): CDPJWTGenerator {\r\n  if (!jwtGenerator) {\r\n    const apiKeyId = process.env.CDP_API_KEY_ID;\r\n    const apiKeySecret = process.env.CDP_API_KEY_SECRET;\r\n\r\n    if (!apiKeyId || !apiKeySecret) {\r\n      throw new Error('CDP_API_KEY_ID and CDP_API_KEY_SECRET must be set');\r\n    }\r\n\r\n    jwtGenerator = new CDPJWTGenerator(apiKeyId, apiKeySecret);\r\n  }\r\n  return jwtGenerator;\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAWO,MAAM;IACH,SAAiB;IACjB,aAAqB;IAE7B,YAAY,QAAgB,EAAE,YAAoB,CAAE;QAClD,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,YAAY,GAAG;IACtB;IAEA;;;;;;;;;GASC,GACD,MAAM,cACJ,gBAA+B,IAAI,EACnC,cAA6B,IAAI,EACjC,cAA6B,IAAI,EAChB;QACjB,kDAAkD;QAClD,kDAAkD;QAClD,MAAM,QAAQ,MAAM,IAAA,4LAAW,EAAC;YAC9B,UAAU,IAAI,CAAC,QAAQ;YACvB,cAAc,IAAI,CAAC,YAAY;YAC/B,eAAe,iBAAiB;YAChC,aAAa,eAAe;YAC5B,aAAa,eAAe;YAC5B,WAAW;QAEb;QAEA,OAAO;IACT;IAEA,aAAa,MAAc,EAAW;QACpC,4EAA4E;QAC5E,OAAO;IACT;AACF;AAEA,qBAAqB;AACrB,IAAI,eAAuC;AAEpC,SAAS;IACd,IAAI,CAAC,cAAc;QACjB,MAAM,WAAW,QAAQ,GAAG,CAAC,cAAc;QAC3C,MAAM,eAAe,QAAQ,GAAG,CAAC,kBAAkB;QAEnD,IAAI,CAAC,YAAY,CAAC,cAAc;YAC9B,MAAM,IAAI,MAAM;QAClB;QAEA,eAAe,IAAI,gBAAgB,UAAU;IAC/C;IACA,OAAO;AACT"}},
    {"offset": {"line": 205, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/signature-verifier.ts"],"sourcesContent":["import { verifyTypedData, type Address } from 'viem';\r\nimport { base } from 'viem/chains';\r\n\r\nexport interface EIP712Domain {\r\n  name: string;\r\n  version: string;\r\n  chainId: number;\r\n  verifyingContract: Address;\r\n}\r\n\r\nexport interface PaymentAuthorization {\r\n  from: Address;\r\n  to: Address;\r\n  value: string;\r\n  validAfter: string;\r\n  validBefore: string;\r\n  nonce: string;\r\n}\r\n\r\n/**\r\n * Verify EIP-712 signature for x402 payment authorization\r\n * This provides an additional security layer before CDP verification\r\n */\r\nexport async function verifyPaymentSignature(\r\n  signature: string,\r\n  authorization: PaymentAuthorization,\r\n  signerAddress: Address,\r\n  chainId: number = 8453 // Base mainnet\r\n): Promise<boolean> {\r\n  try {\r\n    // EIP-712 domain for x402 payments\r\n    const domain: EIP712Domain = {\r\n      name: 'x402',\r\n      version: '1',\r\n      chainId,\r\n      verifyingContract: '0x0000000000000000000000000000000000000000' as Address, // x402 doesn't use a contract\r\n    };\r\n\r\n    // EIP-712 types for the payment authorization\r\n    const types = {\r\n      PaymentAuthorization: [\r\n        { name: 'from', type: 'address' },\r\n        { name: 'to', type: 'address' },\r\n        { name: 'value', type: 'uint256' },\r\n        { name: 'validAfter', type: 'uint256' },\r\n        { name: 'validBefore', type: 'uint256' },\r\n        { name: 'nonce', type: 'bytes32' },\r\n      ],\r\n    };\r\n\r\n    // Verify the signature\r\n    const isValid = await verifyTypedData({\r\n      address: signerAddress,\r\n      domain,\r\n      types,\r\n      primaryType: 'PaymentAuthorization',\r\n      message: authorization as Record<string, unknown>,\r\n      signature: signature as `0x${string}`,\r\n    });\r\n\r\n    return isValid;\r\n  } catch (error) {\r\n    console.error('[SignatureVerifier] Verification error:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Validate payment authorization fields\r\n */\r\nexport function validatePaymentAuthorization(\r\n  authorization: PaymentAuthorization\r\n): { valid: boolean; error?: string } {\r\n  const now = Math.floor(Date.now() / 1000);\r\n  const validAfter = parseInt(authorization.validAfter);\r\n  const validBefore = parseInt(authorization.validBefore);\r\n\r\n  if (now < validAfter) {\r\n    return { valid: false, error: 'Payment not yet valid' };\r\n  }\r\n\r\n  if (now >= validBefore) {\r\n    return { valid: false, error: 'Payment has expired' };\r\n  }\r\n\r\n  if (!authorization.from || !authorization.to) {\r\n    return { valid: false, error: 'Missing from or to address' };\r\n  }\r\n\r\n  if (!authorization.value || BigInt(authorization.value) <= BigInt(0)) {\r\n    return { valid: false, error: 'Invalid payment amount' };\r\n  }\r\n\r\n  if (!authorization.nonce) {\r\n    return { valid: false, error: 'Missing nonce' };\r\n  }\r\n\r\n  return { valid: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAuBO,eAAe,uBACpB,SAAiB,EACjB,aAAmC,EACnC,aAAsB,EACtB,UAAkB,KAAK,eAAe;AAAhB;IAEtB,IAAI;QACF,mCAAmC;QACnC,MAAM,SAAuB;YAC3B,MAAM;YACN,SAAS;YACT;YACA,mBAAmB;QACrB;QAEA,8CAA8C;QAC9C,MAAM,QAAQ;YACZ,sBAAsB;gBACpB;oBAAE,MAAM;oBAAQ,MAAM;gBAAU;gBAChC;oBAAE,MAAM;oBAAM,MAAM;gBAAU;gBAC9B;oBAAE,MAAM;oBAAS,MAAM;gBAAU;gBACjC;oBAAE,MAAM;oBAAc,MAAM;gBAAU;gBACtC;oBAAE,MAAM;oBAAe,MAAM;gBAAU;gBACvC;oBAAE,MAAM;oBAAS,MAAM;gBAAU;aAClC;QACH;QAEA,uBAAuB;QACvB,MAAM,UAAU,MAAM,IAAA,6LAAe,EAAC;YACpC,SAAS;YACT;YACA;YACA,aAAa;YACb,SAAS;YACT,WAAW;QACb;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2CAA2C;QACzD,OAAO;IACT;AACF;AAKO,SAAS,6BACd,aAAmC;IAEnC,MAAM,MAAM,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;IACpC,MAAM,aAAa,SAAS,cAAc,UAAU;IACpD,MAAM,cAAc,SAAS,cAAc,WAAW;IAEtD,IAAI,MAAM,YAAY;QACpB,OAAO;YAAE,OAAO;YAAO,OAAO;QAAwB;IACxD;IAEA,IAAI,OAAO,aAAa;QACtB,OAAO;YAAE,OAAO;YAAO,OAAO;QAAsB;IACtD;IAEA,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,EAAE,EAAE;QAC5C,OAAO;YAAE,OAAO;YAAO,OAAO;QAA6B;IAC7D;IAEA,IAAI,CAAC,cAAc,KAAK,IAAI,OAAO,cAAc,KAAK,KAAK,OAAO,IAAI;QACpE,OAAO;YAAE,OAAO;YAAO,OAAO;QAAyB;IACzD;IAEA,IAAI,CAAC,cAAc,KAAK,EAAE;QACxB,OAAO;YAAE,OAAO;YAAO,OAAO;QAAgB;IAChD;IAEA,OAAO;QAAE,OAAO;IAAK;AACvB"}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/amount-utils.ts"],"sourcesContent":["// =============================================================================\r\n// AMOUNT UTILITIES\r\n// =============================================================================\r\n// Helper functions for converting between human-readable amounts and atomic units\r\n\r\n/**\r\n * Convert human-readable amount to atomic units\r\n * \r\n * For USDC on Base: 1 USDC = 1,000,000 atomic units (6 decimals)\r\n * \r\n * @param humanAmount - Human-readable amount (e.g., \"1\" for 1 USDC)\r\n * @param decimals - Number of decimals (default: 6 for USDC)\r\n * @returns Atomic units as string (e.g., \"1000000\" for 1 USDC)\r\n * \r\n * @example\r\n * toAtomicUnits(\"1\", 6) // \"1000000\"\r\n * toAtomicUnits(\"0.5\", 6) // \"500000\"\r\n * toAtomicUnits(\"1.5\", 6) // \"1500000\"\r\n */\r\nexport function toAtomicUnits(humanAmount: string, decimals: number = 6): string {\r\n  // Remove any whitespace\r\n  const cleanAmount = humanAmount.trim();\r\n  \r\n  // Parse as decimal number\r\n  const amount = parseFloat(cleanAmount);\r\n  \r\n  if (isNaN(amount) || amount < 0) {\r\n    throw new Error(`Invalid amount: ${humanAmount}`);\r\n  }\r\n  \r\n  // Convert to atomic units: multiply by 10^decimals\r\n  const atomicUnits = BigInt(Math.floor(amount * Math.pow(10, decimals)));\r\n  \r\n  // Return as string\r\n  return atomicUnits.toString();\r\n}\r\n\r\n/**\r\n * Convert atomic units to human-readable amount\r\n * \r\n * @param atomicUnits - Atomic units as string (e.g., \"1000000\")\r\n * @param decimals - Number of decimals (default: 6 for USDC)\r\n * @returns Human-readable amount as string (e.g., \"1\")\r\n * \r\n * @example\r\n * fromAtomicUnits(\"1000000\", 6) // \"1\"\r\n * fromAtomicUnits(\"500000\", 6) // \"0.5\"\r\n */\r\nexport function fromAtomicUnits(atomicUnits: string, decimals: number = 6): string {\r\n  const atomic = BigInt(atomicUnits);\r\n  const divisor = BigInt(Math.pow(10, decimals));\r\n  const whole = atomic / divisor;\r\n  const remainder = atomic % divisor;\r\n  \r\n  if (remainder === BigInt(0)) {\r\n    return whole.toString();\r\n  }\r\n  \r\n  // Format with proper decimal places\r\n  const remainderStr = remainder.toString().padStart(decimals, '0');\r\n  const trimmed = remainderStr.replace(/0+$/, '');\r\n  return `${whole}.${trimmed}`;\r\n}\r\n\r\n/**\r\n * Normalize network identifier to CAIP-2 format\r\n * \r\n * @param network - Network identifier (e.g., \"base\", \"eip155:8453\")\r\n * @returns CAIP-2 format network identifier\r\n * \r\n * @example\r\n * normalizeNetwork(\"base\") // \"eip155:8453\"\r\n * normalizeNetwork(\"eip155:8453\") // \"eip155:8453\"\r\n */\r\nexport function normalizeNetwork(network: string): string {\r\n  // If already in CAIP format, return as-is\r\n  if (network.includes(':')) {\r\n    return network;\r\n  }\r\n  \r\n  // Map common network names to CAIP-2 format\r\n  const networkMap: Record<string, string> = {\r\n    'base': 'eip155:8453',\r\n    'ethereum': 'eip155:1',\r\n    'polygon': 'eip155:137',\r\n    'arbitrum': 'eip155:42161',\r\n    'optimism': 'eip155:10',\r\n    'avalanche': 'eip155:43114',\r\n    'bnb': 'eip155:56',\r\n  };\r\n  \r\n  const normalized = networkMap[network.toLowerCase()];\r\n  if (normalized) {\r\n    return normalized;\r\n  }\r\n  \r\n  // If not found, assume it's already in the correct format or return as-is\r\n  return network;\r\n}\r\n\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,mBAAmB;AACnB,gFAAgF;AAChF,kFAAkF;AAElF;;;;;;;;;;;;;CAaC;;;;;;;;AACM,SAAS,cAAc,WAAmB,EAAE,WAAmB,CAAC;IACrE,wBAAwB;IACxB,MAAM,cAAc,YAAY,IAAI;IAEpC,0BAA0B;IAC1B,MAAM,SAAS,WAAW;IAE1B,IAAI,MAAM,WAAW,SAAS,GAAG;QAC/B,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,aAAa;IAClD;IAEA,mDAAmD;IACnD,MAAM,cAAc,OAAO,KAAK,KAAK,CAAC,SAAS,KAAK,GAAG,CAAC,IAAI;IAE5D,mBAAmB;IACnB,OAAO,YAAY,QAAQ;AAC7B;AAaO,SAAS,gBAAgB,WAAmB,EAAE,WAAmB,CAAC;IACvE,MAAM,SAAS,OAAO;IACtB,MAAM,UAAU,OAAO,KAAK,GAAG,CAAC,IAAI;IACpC,MAAM,QAAQ,SAAS;IACvB,MAAM,YAAY,SAAS;IAE3B,IAAI,cAAc,OAAO,IAAI;QAC3B,OAAO,MAAM,QAAQ;IACvB;IAEA,oCAAoC;IACpC,MAAM,eAAe,UAAU,QAAQ,GAAG,QAAQ,CAAC,UAAU;IAC7D,MAAM,UAAU,aAAa,OAAO,CAAC,OAAO;IAC5C,OAAO,GAAG,MAAM,CAAC,EAAE,SAAS;AAC9B;AAYO,SAAS,iBAAiB,OAAe;IAC9C,0CAA0C;IAC1C,IAAI,QAAQ,QAAQ,CAAC,MAAM;QACzB,OAAO;IACT;IAEA,4CAA4C;IAC5C,MAAM,aAAqC;QACzC,QAAQ;QACR,YAAY;QACZ,WAAW;QACX,YAAY;QACZ,YAAY;QACZ,aAAa;QACb,OAAO;IACT;IAEA,MAAM,aAAa,UAAU,CAAC,QAAQ,WAAW,GAAG;IACpD,IAAI,YAAY;QACd,OAAO;IACT;IAEA,0EAA0E;IAC1E,OAAO;AACT"}},
    {"offset": {"line": 386, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/cdp-client.ts"],"sourcesContent":["// =============================================================================\r\n// CDP/x402 Client Wrapper\r\n// =============================================================================\r\n// Wraps all calls to Coinbase/CDP/x402 with normalized error handling\r\n// and structured logging\r\n\r\nimport { createLogger, type LogContext } from './logger';\r\n\r\nconst logger = createLogger({ component: 'CDPClient' });\r\n\r\n/**\r\n * Normalized CDP error codes\r\n */\r\nexport enum CDPErrorCode {\r\n  CDP_TIMEOUT = 'CDP_TIMEOUT',\r\n  CDP_4XX = 'CDP_4XX',\r\n  CDP_5XX = 'CDP_5XX',\r\n  CDP_INVALID_RESPONSE = 'CDP_INVALID_RESPONSE',\r\n  CDP_NETWORK_ERROR = 'CDP_NETWORK_ERROR',\r\n  CDP_AUTH_ERROR = 'CDP_AUTH_ERROR',\r\n  CDP_RATE_LIMIT = 'CDP_RATE_LIMIT',\r\n  CDP_UNKNOWN_ERROR = 'CDP_UNKNOWN_ERROR',\r\n}\r\n\r\n/**\r\n * Normalized CDP error\r\n */\r\nexport class CDPError extends Error {\r\n  constructor(\r\n    public code: CDPErrorCode,\r\n    message: string,\r\n    public statusCode?: number,\r\n    public cdpErrorId?: string,\r\n    public responseBody?: any\r\n  ) {\r\n    super(message);\r\n    this.name = 'CDPError';\r\n    // Ensure stack trace is captured\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, CDPError);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Normalize HTTP status code to CDP error code\r\n */\r\nfunction normalizeErrorCode(statusCode: number | undefined): CDPErrorCode {\r\n  if (!statusCode) {\r\n    return CDPErrorCode.CDP_UNKNOWN_ERROR;\r\n  }\r\n  \r\n  if (statusCode >= 500) {\r\n    return CDPErrorCode.CDP_5XX;\r\n  }\r\n  \r\n  if (statusCode === 401 || statusCode === 403) {\r\n    return CDPErrorCode.CDP_AUTH_ERROR;\r\n  }\r\n  \r\n  if (statusCode === 429) {\r\n    return CDPErrorCode.CDP_RATE_LIMIT;\r\n  }\r\n  \r\n  if (statusCode >= 400) {\r\n    return CDPErrorCode.CDP_4XX;\r\n  }\r\n  \r\n  return CDPErrorCode.CDP_UNKNOWN_ERROR;\r\n}\r\n\r\n/**\r\n * Extract safe excerpt from response body for logging\r\n * Removes sensitive data and truncates long responses\r\n */\r\nfunction extractSafeResponseExcerpt(body: any, maxLength: number = 500): string {\r\n  if (!body) return '';\r\n  \r\n  try {\r\n    const str = typeof body === 'string' ? body : JSON.stringify(body);\r\n    if (str.length <= maxLength) {\r\n      return str;\r\n    }\r\n    return str.substring(0, maxLength) + '... [truncated]';\r\n  } catch {\r\n    return '[unable to serialize response]';\r\n  }\r\n}\r\n\r\n/**\r\n * Wrapper for CDP API calls with error handling and logging\r\n */\r\nexport async function callCDP<T>(\r\n  operation: string,\r\n  requestFn: () => Promise<Response>,\r\n  context: {\r\n    requestId?: string;\r\n    apiKeyId?: string;\r\n    endpointId?: string;\r\n    targetUrl?: string;\r\n  }\r\n): Promise<T> {\r\n  const startTime = Date.now();\r\n  const logContext: LogContext = {\r\n    requestId: context.requestId,\r\n    apiKeyId: context.apiKeyId,\r\n    endpoint: context.endpointId,\r\n    cdpStatus: 'pending',\r\n  };\r\n  \r\n  try {\r\n    logger.debug({ ...logContext, operation, targetUrl: context.targetUrl }, `CDP call: ${operation}`);\r\n    \r\n    const response = await requestFn();\r\n    const duration = Date.now() - startTime;\r\n    \r\n    // Extract response body safely\r\n    let responseBody: any = null;\r\n    let responseText = '';\r\n    try {\r\n      responseText = await response.text();\r\n      if (responseText) {\r\n        responseBody = JSON.parse(responseText);\r\n      }\r\n    } catch {\r\n      // Response might not be JSON, that's okay\r\n      responseBody = responseText;\r\n    }\r\n    \r\n    // Check if response is successful\r\n    if (!response.ok) {\r\n      const errorCode = normalizeErrorCode(response.status);\r\n      const cdpErrorId = responseBody?.error?.id || responseBody?.errorId || response.headers.get('x-request-id');\r\n      const errorMessage = responseBody?.error?.message || responseBody?.message || `CDP API error: ${response.statusText}`;\r\n      \r\n      const error = new CDPError(\r\n        errorCode,\r\n        errorMessage,\r\n        response.status,\r\n        cdpErrorId,\r\n        responseBody\r\n      );\r\n      \r\n      // Log structured error\r\n      logger.error({\r\n        ...logContext,\r\n        operation,\r\n        targetUrl: context.targetUrl,\r\n        errorCode: error.code,\r\n        cdpErrorId: error.cdpErrorId,\r\n        statusCode: response.status,\r\n        durationMs: duration,\r\n        responseExcerpt: extractSafeResponseExcerpt(responseBody),\r\n      }, `CDP call failed: ${operation}`);\r\n      \r\n      throw error;\r\n    }\r\n    \r\n    // Log successful call\r\n    logger.info({\r\n      ...logContext,\r\n      operation,\r\n      targetUrl: context.targetUrl,\r\n      cdpStatus: 'success',\r\n      statusCode: response.status,\r\n      durationMs: duration,\r\n    }, `CDP call succeeded: ${operation}`);\r\n    \r\n    return responseBody as T;\r\n  } catch (error) {\r\n    const duration = Date.now() - startTime;\r\n    \r\n    // Handle network errors\r\n    if (error instanceof TypeError && error.message.includes('fetch')) {\r\n      const cdpError = new CDPError(\r\n        CDPErrorCode.CDP_NETWORK_ERROR,\r\n        `Network error calling CDP: ${error.message}`,\r\n        undefined,\r\n        undefined,\r\n        undefined\r\n      );\r\n      \r\n      logger.error({\r\n        ...logContext,\r\n        operation,\r\n        targetUrl: context.targetUrl,\r\n        errorCode: cdpError.code,\r\n        durationMs: duration,\r\n        error: error,\r\n      }, `CDP network error: ${operation}`);\r\n      \r\n      throw cdpError;\r\n    }\r\n    \r\n    // Handle timeout errors\r\n    if (error instanceof Error && (error.message.includes('timeout') || error.message.includes('aborted'))) {\r\n      const cdpError = new CDPError(\r\n        CDPErrorCode.CDP_TIMEOUT,\r\n        `CDP call timed out: ${operation}`,\r\n        undefined,\r\n        undefined,\r\n        undefined\r\n      );\r\n      \r\n      logger.error({\r\n        ...logContext,\r\n        operation,\r\n        targetUrl: context.targetUrl,\r\n        errorCode: cdpError.code,\r\n        durationMs: duration,\r\n        error: error,\r\n      }, `CDP timeout: ${operation}`);\r\n      \r\n      throw cdpError;\r\n    }\r\n    \r\n    // Re-throw CDPError as-is\r\n    if (error instanceof CDPError) {\r\n      throw error;\r\n    }\r\n    \r\n    // Wrap unknown errors\r\n    const cdpError = new CDPError(\r\n      CDPErrorCode.CDP_UNKNOWN_ERROR,\r\n      `Unknown error calling CDP: ${error instanceof Error ? error.message : String(error)}`,\r\n      undefined,\r\n      undefined,\r\n      undefined\r\n    );\r\n    \r\n    logger.error({\r\n      ...logContext,\r\n      operation,\r\n      targetUrl: context.targetUrl,\r\n      errorCode: cdpError.code,\r\n      durationMs: duration,\r\n      error: error,\r\n    }, `CDP unknown error: ${operation}`);\r\n    \r\n    throw cdpError;\r\n  }\r\n}\r\n\r\n/**\r\n * Helper to add request ID to CDP API calls\r\n */\r\nexport function addRequestIdToCDPHeaders(\r\n  headers: HeadersInit,\r\n  requestId?: string\r\n): HeadersInit {\r\n  const headersObj = headers instanceof Headers ? Object.fromEntries(headers.entries()) : \r\n                     Array.isArray(headers) ? Object.fromEntries(headers) : \r\n                     headers;\r\n  \r\n  if (requestId) {\r\n    return {\r\n      ...headersObj,\r\n      'x-request-id': requestId,\r\n    };\r\n  }\r\n  \r\n  return headersObj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 582, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/cdp-facilitator.ts"],"sourcesContent":["import { getCDPJWTGenerator } from './cdp-jwt';\r\nimport { verifyPaymentSignature, validatePaymentAuthorization, type PaymentAuthorization } from './signature-verifier';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { toAtomicUnits, normalizeNetwork } from './amount-utils';\r\nimport { callCDP, addRequestIdToCDPHeaders, CDPError, CDPErrorCode } from '@/lib/cdp-client';\r\n\r\nconst logger = createLogger({ component: 'CDPFacilitator' });\r\n\r\n/**\r\n * CDP (Coinbase Developer Platform) Facilitator\r\n * \r\n * Primary facilitator for x402 payment verification on Base network.\r\n * Handles JWT authentication, payment verification, and compliance checks.\r\n */\r\n\r\nexport interface CDPPaymentPayload {\r\n  x402Version: number;\r\n  scheme: 'x402';\r\n  network: string;\r\n  payload: {\r\n    signature: string;\r\n    authorization: PaymentAuthorization;\r\n  };\r\n}\r\n\r\nexport interface X402PaymentRequirements {\r\n  scheme: string;\r\n  network: string;\r\n  to?: string; // Internal field name\r\n  payTo?: string; // CDP field name\r\n  value?: string; // Internal field name\r\n  maxAmountRequired?: string; // CDP field name\r\n  resource: string;\r\n  validAfter?: string; // Validity window start\r\n  validBefore?: string; // Validity window end\r\n  asset: string;\r\n  // Optional fields\r\n  description?: string;\r\n  mimeType?: string;\r\n  maxTimeoutSeconds?: number;\r\n  outputSchema?: any; // Optional JSON schema\r\n  extra?: any; // Optional scheme-specific data\r\n  payer?: string; // Optional: payer address (internal only)\r\n}\r\n\r\n// CDP Verify Request Body - matches CDP x402 v2 API schema exactly\r\n// Per: https://docs.cdp.coinbase.com/api-reference/v2/rest-api/x402-facilitator/verify-a-payment\r\n// This type matches the v2 VerifyRequest schema exactly - no v1 fields or schemas\r\nexport interface CDPVerifyRequestBody {\r\n  x402Version: 2; // CDP x402 v2 - top level (must be 2, not 1)\r\n  paymentPayload: {\r\n    x402Version: 2; // CDP x402 v2 - inside paymentPayload (must match top level, must be 2)\r\n    scheme: string; // 'exact' for EVM\r\n    network: string; // 'base', 'ethereum', etc.\r\n    payload: {\r\n      signature: string; // EIP-712 signature\r\n      authorization: {\r\n        from: string; // EVM address\r\n        to: string; // EVM address\r\n        value: string; // Amount in atomic units\r\n        validAfter: string; // Unix timestamp\r\n        validBefore: string; // Unix timestamp\r\n        nonce: string; // Hex-encoded nonce\r\n      };\r\n    };\r\n  };\r\n  paymentRequirements: {\r\n    scheme: string; // 'exact' for EVM\r\n    network: string; // 'base', 'ethereum', etc.\r\n    payTo: string; // CDP v2 field name (destination address)\r\n    // CDP x402 v2: maxAmountRequired must be a string of atomic units (integer, not decimal)\r\n    // Example: \"1000000\" for 1 USDC (6 decimals), not \"1.0\" or 1000000\r\n    // Must match authorization.value exactly\r\n    maxAmountRequired: string; // Amount in atomic units as string (e.g., \"1000000\" for 1 USDC)\r\n    resource: string; // URI of the resource\r\n    description: string; // Description of the resource\r\n    mimeType: string; // MIME type of the resource response\r\n    maxTimeoutSeconds: number; // Maximum time for server to respond\r\n    asset: string; // Asset contract address (e.g., USDC)\r\n    validAfter?: string; // Optional: validity window start\r\n    validBefore?: string; // Optional: validity window end\r\n    outputSchema?: any; // Optional: JSON schema describing resource output\r\n    extra?: any; // Optional: scheme-specific payment information\r\n  };\r\n}\r\n\r\nexport interface CDPVerifyRequest {\r\n  payment: string; // Payment header or transaction hash\r\n  paymentPayload: CDPPaymentPayload;\r\n  paymentRequirements?: X402PaymentRequirements; // Optional - will be constructed if not provided\r\n}\r\n\r\nexport interface CDPVerifyResponse {\r\n  success: boolean;\r\n  valid: boolean;\r\n  transactionHash?: string;\r\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\r\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\r\n  error?: string;\r\n  errorDetails?: {\r\n    error: string;\r\n    cdpResponse?: any;\r\n    httpStatus?: number;\r\n  };\r\n}\r\n\r\nexport class CDPFacilitator {\r\n  private apiKeyId: string;\r\n  private facilitatorUrl: string;\r\n  private jwtGenerator: ReturnType<typeof getCDPJWTGenerator>;\r\n  private cachedToken: string | null = null;\r\n  private tokenExpiry: number = 0;\r\n\r\n  constructor(\r\n    apiKeyId: string,\r\n    facilitatorUrl: string = 'https://api.cdp.coinbase.com/platform/v2/x402'\r\n  ) {\r\n    this.apiKeyId = apiKeyId;\r\n    this.facilitatorUrl = facilitatorUrl;\r\n    this.jwtGenerator = getCDPJWTGenerator();\r\n  }\r\n\r\n  /**\r\n   * Generate JWT token for CDP API authentication\r\n   * Uses cached token if still valid, otherwise generates new one\r\n   * \r\n   * @param requestMethod - HTTP method for REST calls (optional)\r\n   * @param requestPath - Request path for REST calls (optional)\r\n   */\r\n  private async generateJWT(\r\n    requestMethod: string | null = null,\r\n    requestPath: string | null = null\r\n  ): Promise<string> {\r\n    const now = Date.now();\r\n    \r\n    // For REST calls with specific method/path, don't cache (must be request-specific)\r\n    if (requestMethod && requestPath) {\r\n      const url = new URL(this.facilitatorUrl);\r\n      return await this.jwtGenerator.generateToken(\r\n        requestMethod,\r\n        url.host,\r\n        requestPath\r\n      );\r\n    }\r\n    \r\n    // Return cached token if still valid (with 10 second buffer) - for generic auth\r\n    if (this.cachedToken && this.tokenExpiry > now + 10000) {\r\n      return this.cachedToken;\r\n    }\r\n\r\n    // Generate new token for generic facilitator auth\r\n    const token = await this.jwtGenerator.generateToken(null, null, null);\r\n    this.cachedToken = token;\r\n    this.tokenExpiry = now + 120000; // 2 minutes expiry\r\n\r\n    return token;\r\n  }\r\n\r\n  /**\r\n   * Verify payment with CDP facilitator API\r\n   * \r\n   * This method:\r\n   * 1. Validates payment authorization fields locally\r\n   * 2. Optionally verifies EIP-712 signature locally\r\n   * 3. Calls CDP API for on-chain verification\r\n   * 4. Returns verification result with KYT/OFAC status\r\n   */\r\n  async verifyPayment(request: CDPVerifyRequest): Promise<CDPVerifyResponse> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // Step 1: Validate payment authorization fields locally\r\n      const authValidation = validatePaymentAuthorization(request.paymentPayload.payload.authorization);\r\n      if (!authValidation.valid) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: authValidation.error || 'Invalid payment authorization',\r\n        };\r\n      }\r\n\r\n      // Step 2: Extract authorization for use throughout\r\n      const auth = request.paymentPayload.payload.authorization;\r\n      const signature = request.paymentPayload.payload.signature;\r\n\r\n      // Step 3: Optionally verify signature locally (additional security layer)\r\n      // Note: CDP will also verify, but local check catches issues early\r\n      try {\r\n        const signatureValid = await verifyPaymentSignature(\r\n          signature,\r\n          auth,\r\n          auth.from as `0x${string}`\r\n        );\r\n        if (!signatureValid) {\r\n          logger.warn('Local signature verification failed, but continuing to CDP');\r\n          // Don't fail here - let CDP make the final decision\r\n        }\r\n      } catch (sigError) {\r\n        logger.warn({ error: sigError }, 'Signature verification error, continuing to CDP');\r\n        // Continue to CDP verification\r\n      }\r\n\r\n      // Step 4: Use paymentRequirements from request (must be provided by caller)\r\n      // CDP requires paymentRequirements that match the challenge\r\n      if (!request.paymentRequirements || (!request.paymentRequirements.to && !(request.paymentRequirements as any).payTo)) {\r\n        logger.error({\r\n          hasPaymentRequirements: !!request.paymentRequirements,\r\n          paymentRequirements: request.paymentRequirements,\r\n        }, 'Missing paymentRequirements');\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: 'paymentRequirements must be provided for CDP verification',\r\n        };\r\n      }\r\n      // Normalize paymentRequirements to CDP's expected format\r\n      // CDP expects: scheme, network, to, value, resource, validAfter, validBefore, asset\r\n      // Remove any fields that CDP doesn't expect (payer, maxTimeoutSeconds, description, mimeType might be optional)\r\n      const paymentRequirements: any = {\r\n        scheme: request.paymentRequirements?.scheme || 'exact',\r\n        network: request.paymentRequirements?.network || request.paymentPayload.network,\r\n        // Convert legacy field names to CDP format\r\n        to: request.paymentRequirements?.to || (request.paymentRequirements as any)?.payTo || auth.to,\r\n        value: request.paymentRequirements?.value || (request.paymentRequirements as any)?.maxAmountRequired || auth.value,\r\n        // Ensure validity window is included\r\n        validAfter: request.paymentRequirements?.validAfter || auth.validAfter,\r\n        validBefore: request.paymentRequirements?.validBefore || auth.validBefore,\r\n        // Required fields - ensure they exist\r\n        resource: request.paymentRequirements?.resource,\r\n        asset: request.paymentRequirements?.asset,\r\n        // Optional fields (only include if present)\r\n        ...(request.paymentRequirements?.description && { description: request.paymentRequirements.description }),\r\n        ...(request.paymentRequirements?.mimeType && { mimeType: request.paymentRequirements.mimeType }),\r\n      };\r\n      \r\n      // Validate that required fields are present\r\n      if (!paymentRequirements.resource || !paymentRequirements.asset) {\r\n        logger.error({\r\n          hasResource: !!paymentRequirements.resource,\r\n          hasAsset: !!paymentRequirements.asset,\r\n          paymentRequirements: request.paymentRequirements,\r\n        }, 'Missing required paymentRequirements fields (resource or asset)');\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: 'paymentRequirements must include resource and asset',\r\n        };\r\n      }\r\n\r\n      // Step 5: Parse payment header to check for transaction hash\r\n      // CDP may require transaction hash for on-chain verification\r\n      let txHash: string | undefined;\r\n      try {\r\n        const { parseX402Header } = await import('./payment-header-parser');\r\n        const parsed = parseX402Header(request.payment);\r\n        if (parsed.valid && parsed.parsed?.txHash) {\r\n          txHash = parsed.parsed.txHash;\r\n          logger.debug({ txHash }, 'Found transaction hash in payment header');\r\n        }\r\n      } catch (error) {\r\n        logger.warn({ error }, 'Failed to parse payment header for txHash');\r\n      }\r\n\r\n      // Step 6: Construct request body matching CDP x402 v2 schema exactly\r\n      // CDP v2 schema per docs: https://docs.cdp.coinbase.com/api-reference/v2/rest-api/x402-facilitator/verify-a-payment\r\n      // \r\n      // CDP Requirements for USDC on Base:\r\n      // - 1 USDC = 1,000,000 atomic units (6 decimals)\r\n      // - network must be \"eip155:8453\" (not \"base\")\r\n      // - value and maxAmountRequired must be strings of atomic units\r\n      \r\n      // Normalize network to CAIP-2 format (e.g., \"base\" -> \"eip155:8453\")\r\n      const normalizedNetwork = normalizeNetwork(request.paymentPayload.network || paymentRequirements.network || 'base');\r\n      \r\n      // Convert authorization.value to atomic units if needed\r\n      // auth.value might already be in atomic units (string), or might be human-readable\r\n      // For now, assume it's already in atomic units if it's a large number string\r\n      // If it looks like a human amount (small number), convert it\r\n      let authorizationValue: string;\r\n      const authValueStr = String(auth.value);\r\n      const authValueNum = parseFloat(authValueStr);\r\n      \r\n      // If the value is less than 1000, assume it's human-readable (e.g., \"1\" = 1 USDC)\r\n      // Otherwise, assume it's already in atomic units\r\n      if (authValueNum < 1000 && authValueNum > 0) {\r\n        // Convert human amount to atomic units\r\n        authorizationValue = toAtomicUnits(authValueStr, 6);\r\n        logger.debug({ \r\n          original: authValueStr, \r\n          converted: authorizationValue \r\n        }, 'Converted human amount to atomic units');\r\n      } else {\r\n        // Already in atomic units, ensure it's a string\r\n        authorizationValue = authValueStr;\r\n      }\r\n      \r\n      // Convert maxAmountRequired to atomic units if needed\r\n      const maxAmountRaw = paymentRequirements.value || (paymentRequirements as any).maxAmountRequired || authorizationValue;\r\n      const maxAmountStr = String(maxAmountRaw);\r\n      const maxAmountNum = parseFloat(maxAmountStr);\r\n      \r\n      let maxAmountRequired: string;\r\n      if (maxAmountNum < 1000 && maxAmountNum > 0) {\r\n        // Convert human amount to atomic units\r\n        maxAmountRequired = toAtomicUnits(maxAmountStr, 6);\r\n        logger.debug({ \r\n          original: maxAmountStr, \r\n          converted: maxAmountRequired \r\n        }, 'Converted maxAmountRequired to atomic units');\r\n      } else {\r\n        // Already in atomic units, ensure it's a string\r\n        maxAmountRequired = maxAmountStr;\r\n      }\r\n      \r\n      // Ensure both are strings and digit-only (atomic units)\r\n      if (!/^[0-9]+$/.test(authorizationValue) || !/^[0-9]+$/.test(maxAmountRequired)) {\r\n        const error = new Error('Amount fields must be digit-only strings in atomic units');\r\n        logger.error({\r\n          authorizationValue,\r\n          maxAmountRequired,\r\n          authorizationValueType: typeof authorizationValue,\r\n          maxAmountRequiredType: typeof maxAmountRequired,\r\n        }, 'Amount validation failed');\r\n        throw error;\r\n      }\r\n      \r\n      // Log the final values being sent\r\n      logger.debug({\r\n        network: normalizedNetwork,\r\n        authorizationValue,\r\n        maxAmountRequired,\r\n        payTo: paymentRequirements.to || (paymentRequirements as any).payTo,\r\n      }, 'CDP verify request payload (amounts in atomic units)');\r\n      \r\n      const verifyBody: CDPVerifyRequestBody = {\r\n        x402Version: 2, // CDP x402 v2 - top level\r\n        paymentPayload: {\r\n          x402Version: 2, // CDP x402 v2 - inside paymentPayload (must match top level)\r\n          scheme: request.paymentPayload.scheme || 'exact',\r\n          network: normalizedNetwork, // Use CAIP-2 format: \"eip155:8453\"\r\n          payload: {\r\n            signature: request.paymentPayload.payload.signature,\r\n            authorization: {\r\n              from: auth.from,\r\n              to: auth.to,\r\n              // CDP x402 v2: value must be a string of atomic units (e.g., \"1000000\" for 1 USDC)\r\n              value: authorizationValue,\r\n              validAfter: auth.validAfter,\r\n              validBefore: auth.validBefore,\r\n              nonce: auth.nonce,\r\n            },\r\n          },\r\n        },\r\n        // paymentRequirements at root level (NOT nested inside paymentPayload)\r\n        // CDP v2 field names: payTo, maxAmountRequired (not to, value)\r\n        paymentRequirements: {\r\n          scheme: paymentRequirements.scheme || 'exact',\r\n          network: normalizedNetwork, // Use CAIP-2 format: \"eip155:8453\"\r\n          payTo: paymentRequirements.to || (paymentRequirements as any).payTo,\r\n          // CDP x402 v2: maxAmountRequired must be a string of atomic units (e.g., \"1000000\" for 1 USDC)\r\n          // Must match authorization.value exactly\r\n          maxAmountRequired: maxAmountRequired,\r\n          resource: paymentRequirements.resource,\r\n          asset: paymentRequirements.asset,\r\n          description: paymentRequirements.description || 'x402 Payment Verification',\r\n          mimeType: paymentRequirements.mimeType || 'application/json',\r\n          maxTimeoutSeconds: (paymentRequirements as any).maxTimeoutSeconds || 300,\r\n          // Optional fields per v2 spec\r\n          ...(paymentRequirements.validAfter && { validAfter: paymentRequirements.validAfter }),\r\n          ...(paymentRequirements.validBefore && { validBefore: paymentRequirements.validBefore }),\r\n          ...((paymentRequirements as any).outputSchema && { outputSchema: (paymentRequirements as any).outputSchema }),\r\n          ...((paymentRequirements as any).extra && { extra: (paymentRequirements as any).extra }),\r\n        },\r\n      };\r\n\r\n      // Note: Transaction hash is included in the paymentHeader string itself\r\n      // CDP will extract it from the payment header, so we don't need to add it separately\r\n      if (txHash) {\r\n        logger.debug({ txHash }, 'Transaction hash is included in paymentHeader');\r\n      }\r\n\r\n      // Step 5: Generate JWT token for CDP API\r\n      const url = new URL('https://api.cdp.coinbase.com/platform/v2/x402/verify');\r\n      const token = await this.generateJWT('POST', url.pathname);\r\n\r\n      // Log request details (without sensitive data)\r\n      logger.debug({\r\n        url: url.toString(),\r\n        x402Version: verifyBody.x402Version,\r\n        paymentPayload: {\r\n          scheme: verifyBody.paymentPayload.scheme,\r\n          network: verifyBody.paymentPayload.network,\r\n          signaturePreview: verifyBody.paymentPayload.payload.signature?.substring(0, 20) + '...',\r\n          authorization: {\r\n            from: verifyBody.paymentPayload.payload.authorization.from,\r\n            to: verifyBody.paymentPayload.payload.authorization.to,\r\n            value: verifyBody.paymentPayload.payload.authorization.value,\r\n          },\r\n        },\r\n        paymentRequirements: {\r\n          scheme: paymentRequirements.scheme,\r\n          network: paymentRequirements.network,\r\n          to: paymentRequirements.to,\r\n          value: paymentRequirements.value,\r\n          validAfter: paymentRequirements.validAfter,\r\n          validBefore: paymentRequirements.validBefore,\r\n          payer: (paymentRequirements as any).payer, // Include payer if present\r\n          asset: paymentRequirements.asset,\r\n          resource: paymentRequirements.resource,\r\n          description: paymentRequirements.description,\r\n          mimeType: paymentRequirements.mimeType,\r\n          maxTimeoutSeconds: paymentRequirements.maxTimeoutSeconds,\r\n        },\r\n        fullRequestBody: JSON.stringify(verifyBody, null, 2), // Full request for debugging\r\n        // Log the actual paymentRequirements object being sent\r\n        paymentRequirementsKeys: Object.keys(paymentRequirements),\r\n        paymentRequirementsHasPayer: 'payer' in paymentRequirements,\r\n        paymentRequirementsPayerValue: (paymentRequirements as any).payer,\r\n      }, 'Sending verification request to CDP');\r\n\r\n      // Step 6: Call CDP API using fetch with request ID\r\n      // Extract request ID from context if available (passed via verifyPaymentWithRetry)\r\n      const requestId = (request as any).requestId;\r\n      const headers: HeadersInit = {\r\n        'Content-Type': 'application/json',\r\n        'Authorization': `Bearer ${token}`,\r\n        'X-CDP-API-Key': this.apiKeyId,\r\n      };\r\n      \r\n      // Add request ID to CDP call for correlation\r\n      if (requestId) {\r\n        Object.assign(headers, addRequestIdToCDPHeaders(headers, requestId));\r\n      }\r\n      \r\n      try {\r\n        const response = await fetch(url.toString(), {\r\n          method: 'POST',\r\n          headers,\r\n          body: JSON.stringify(verifyBody),\r\n          signal: AbortSignal.timeout(10000),\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data = text ? JSON.parse(text) : {};\r\n\r\n        const latencyMs = Date.now() - start;\r\n\r\n        // Log CDP response\r\n        logger.debug({\r\n          status: response.status,\r\n          isValid: data.isValid,\r\n          latencyMs,\r\n        }, 'CDP verification response');\r\n\r\n        // CDP response uses `isValid` (not `valid`) and `invalidReason` (not `reason`)\r\n        if (response.ok && data.isValid) {\r\n          logger.info({ latencyMs }, 'Payment verified successfully');\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            transactionHash: undefined, // CDP verify doesn't return transaction hash\r\n            kytStatus: 'passed', // CDP verify doesn't return KYT/OFAC status\r\n            ofacStatus: 'passed',\r\n          };\r\n        } else {\r\n          // Log detailed error information including request body for debugging\r\n          logger.error({\r\n            status: response.status,\r\n            invalidReason: data.invalidReason,\r\n            errorMessage: data.errorMessage,\r\n            error: data.error,\r\n            code: data.code,\r\n            details: data.details,\r\n            cdpResponse: data,\r\n            requestBody: {\r\n              x402Version: verifyBody.x402Version,\r\n              hasPaymentPayload: !!verifyBody.paymentPayload,\r\n              hasPaymentRequirements: !!verifyBody.paymentRequirements,\r\n            },\r\n          }, 'Payment verification failed');\r\n          \r\n          // Extract error code from CDP response - prefer invalidReason, then errorMessage, then error, then code\r\n          const errorCode = data.invalidReason || data.errorMessage || data.error || data.code || 'CDP_VERIFY_FAILED';\r\n          \r\n          // Extract authorization details from the parsed payment header for logging\r\n          let authorizationFrom = 'UNKNOWN';\r\n          let authorizationTo = 'UNKNOWN';\r\n          let transactionHash = 'NOT PROVIDED';\r\n          try {\r\n            const { parseX402Header } = await import('./payment-header-parser');\r\n            const parsed = parseX402Header(request.payment);\r\n            if (parsed.valid && parsed.parsed) {\r\n              authorizationFrom = parsed.parsed.authorization.from;\r\n              authorizationTo = parsed.parsed.authorization.to;\r\n              transactionHash = parsed.parsed.txHash || 'NOT PROVIDED';\r\n            }\r\n          } catch (parseError) {\r\n            logger.warn({ error: parseError }, 'Failed to parse payment header for error logging');\r\n          }\r\n          \r\n          const errorDetails = {\r\n            error: errorMessage,\r\n            cdpResponse: data,\r\n            httpStatus: response.status,\r\n            invalidReason: data.invalidReason,\r\n            errorMessage: data.errorMessage,\r\n            code: data.code,\r\n            details: data.details,\r\n            // Include request details for debugging (using paymentRequirements from verifyBody)\r\n            requestDetails: {\r\n              scheme: verifyBody.paymentRequirements?.scheme || 'MISSING',\r\n              network: verifyBody.paymentRequirements?.network || 'MISSING',\r\n              to: verifyBody.paymentRequirements?.to || 'MISSING',\r\n              value: verifyBody.paymentRequirements?.value || 'MISSING',\r\n              payer: (verifyBody.paymentRequirements as any)?.payer || 'NOT PROVIDED IN PAYMENT REQUIREMENTS',\r\n              validAfter: verifyBody.paymentRequirements?.validAfter || 'MISSING',\r\n              validBefore: verifyBody.paymentRequirements?.validBefore || 'MISSING',\r\n              resource: verifyBody.paymentRequirements?.resource || 'MISSING',\r\n              asset: verifyBody.paymentRequirements?.asset || 'MISSING',\r\n              // Include full paymentRequirements to see what's actually being sent\r\n              fullPaymentRequirements: verifyBody.paymentRequirements,\r\n              // Include authorization from parsed header\r\n              authorizationFrom,\r\n              authorizationTo,\r\n              transactionHash,\r\n            },\r\n          };\r\n\r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            error: errorCode,\r\n            errorDetails: errorDetails,\r\n            kytStatus: undefined,\r\n            ofacStatus: undefined,\r\n          };\r\n        }\r\n      } catch (error: any) {\r\n        // Handle network errors with enhanced logging\r\n        const errorMessage = error?.message || 'CDP_VERIFY_FAILED';\r\n        const isTimeout = error?.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout');\r\n        const isNetworkError = errorMessage.toLowerCase().includes('network') || \r\n                              errorMessage.toLowerCase().includes('fetch') ||\r\n                              errorMessage.toLowerCase().includes('econnrefused');\r\n        \r\n        logger.error({ \r\n          error,\r\n          errorMessage,\r\n          isTimeout,\r\n          isNetworkError,\r\n          component: 'cdp-facilitator',\r\n          operation: 'verifyPayment',\r\n          requestId: (request as any).requestId,\r\n        }, 'CDP API request error');\r\n        \r\n        const errorDetails = {\r\n          error: errorMessage,\r\n          cdpResponse: undefined,\r\n          httpStatus: 500,\r\n          errorType: isTimeout ? 'timeout' : isNetworkError ? 'network' : 'unknown',\r\n        };\r\n\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: errorMessage,\r\n          errorDetails: errorDetails,\r\n        };\r\n      }\r\n    } catch (error) {\r\n      const latencyMs = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : String(error);\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      logger.error({ \r\n        error,\r\n        latencyMs,\r\n        errorMessage,\r\n        isTimeout,\r\n        component: 'cdp-facilitator',\r\n        operation: 'verifyPayment',\r\n        requestId: (request as any).requestId,\r\n      }, 'Verification error');\r\n\r\n      // Handle timeout errors\r\n      if (isTimeout) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: 'CDP_REQUEST_TIMEOUT',\r\n        };\r\n      }\r\n\r\n      // Handle network errors\r\n      if (error instanceof Error && (error.message.includes('fetch') || error.message.includes('network'))) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: 'CDP_NETWORK_ERROR',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: error instanceof Error ? error.message : 'CDP_VERIFICATION_ERROR',\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify payment with retry logic and exponential backoff\r\n   * \r\n   * Retries on network errors and timeouts, but not on validation failures\r\n   */\r\n  async verifyPaymentWithRetry(\r\n    request: CDPVerifyRequest,\r\n    maxRetries: number = 3\r\n  ): Promise<CDPVerifyResponse> {\r\n    let lastError: Error | null = null;\r\n\r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const result = await this.verifyPayment(request);\r\n        \r\n        // If verification succeeded, return immediately\r\n        if (result.success && result.valid) {\r\n          return result;\r\n        }\r\n\r\n        // If verification failed due to validation (not network), don't retry\r\n        if (result.error && \r\n            !result.error.includes('timeout') && \r\n            !result.error.includes('network') &&\r\n            !result.error.includes('Unable to reach')) {\r\n          return result;\r\n        }\r\n\r\n        // If blocked by KYT/OFAC, don't retry\r\n        if (result.kytStatus === 'blocked' || result.ofacStatus === 'blocked') {\r\n          return result;\r\n        }\r\n\r\n        lastError = new Error(result.error || 'Verification failed');\r\n      } catch (error) {\r\n        lastError = error instanceof Error ? error : new Error(String(error));\r\n      }\r\n\r\n      // Exponential backoff: 100ms, 200ms, 400ms\r\n      if (attempt < maxRetries - 1) {\r\n        const delay = 100 * Math.pow(2, attempt);\r\n        logger.info({ attempt: attempt + 1, maxRetries, delay }, 'Retrying CDP verification');\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n      }\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      error: lastError?.message || 'Max retries exceeded',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Health check - verify CDP facilitator is accessible\r\n   * \r\n   * Note: CDP may not have a /health endpoint. This is a best-effort check.\r\n   * If it fails, it doesn't necessarily mean CDP is unavailable.\r\n   * \r\n   * IMPORTANT: If the facilitator URL domain doesn't resolve (DNS error),\r\n   * this will return unhealthy, but actual payment verification might\r\n   * still work if it uses a different endpoint.\r\n   */\r\n  async healthCheck(): Promise<{ healthy: boolean; error?: string }> {\r\n    try {\r\n      // For REST API calls, CDP requires request-specific JWT\r\n      // Generate JWT with the actual request details\r\n      const url = new URL(`${this.facilitatorUrl}/health`);\r\n      const token = await this.generateJWT('GET', url.pathname);\r\n      \r\n      const response = await fetch(url.toString(), {\r\n        method: 'GET',\r\n        headers: {\r\n          'Authorization': `Bearer ${token}`,\r\n          'X-CDP-API-Key': this.apiKeyId,\r\n        },\r\n        signal: AbortSignal.timeout(5000), // 5 second timeout\r\n      });\r\n\r\n      if (response.ok) {\r\n        return { healthy: true };\r\n      } else {\r\n        // 401/403 might mean auth is working but endpoint doesn't exist or keys are wrong\r\n        // 404 means endpoint doesn't exist (but auth might be working)\r\n        // For now, we'll consider it healthy if we get any response (not a network error)\r\n        if (response.status === 404) {\r\n          return { \r\n            healthy: true, \r\n            error: 'Health endpoint not found, but CDP is reachable' \r\n          };\r\n        }\r\n        \r\n        // Get error details from response if available\r\n        let errorMsg = `Health check failed: ${response.status} ${response.statusText}`;\r\n        try {\r\n          const errorBody = await response.text();\r\n          if (errorBody) {\r\n            errorMsg += ` - ${errorBody.substring(0, 200)}`;\r\n          }\r\n        } catch {\r\n          // Ignore parsing errors\r\n        }\r\n        \r\n        return { \r\n          healthy: false, \r\n          error: errorMsg\r\n        };\r\n      }\r\n    } catch (error) {\r\n      // Network errors or timeouts indicate CDP is not reachable\r\n      // This includes DNS resolution failures (domain doesn't exist)\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      \r\n      // If it's a DNS/network error, note that payment verification might still work\r\n      if (errorMessage.includes('fetch failed') || \r\n          errorMessage.includes('ENOTFOUND') || \r\n          errorMessage.includes('getaddrinfo')) {\r\n        return {\r\n          healthy: false,\r\n          error: `Facilitator URL not reachable (${errorMessage}). Payment verification may use a different endpoint.`,\r\n        };\r\n      }\r\n      \r\n      return {\r\n        healthy: false,\r\n        error: errorMessage,\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet cdpFacilitator: CDPFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton CDP facilitator instance\r\n */\r\nexport function getCDPFacilitator(): CDPFacilitator {\r\n  if (!cdpFacilitator) {\r\n    const apiKeyId = process.env.CDP_API_KEY_ID;\r\n    const facilitatorUrl = process.env.CDP_FACILITATOR_URL || 'https://api.cdp.coinbase.com/platform/v2/x402';\r\n\r\n    if (!apiKeyId) {\r\n      throw new Error('CDP_API_KEY_ID must be set in environment variables');\r\n    }\r\n\r\n    cdpFacilitator = new CDPFacilitator(apiKeyId, facilitatorUrl);\r\n  }\r\n  return cdpFacilitator;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1196, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/cdp-facilitator-adapter.ts"],"sourcesContent":["// =============================================================================\r\n// CDP FACILITATOR ADAPTER\r\n// =============================================================================\r\n// Adapter to make CDP facilitator conform to IFacilitator interface\r\n\r\nimport { BaseFacilitator, type IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorHealth, type FacilitatorConfig, type CAIPNetworkId, type CAIPAssetId } from './base-facilitator';\r\nimport { getCDPFacilitator, type CDPVerifyRequest, type CDPVerifyResponse } from '../cdp-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\n// Logger will be created per instance\r\n\r\n/**\r\n * CDP Facilitator Adapter\r\n * Wraps the existing CDP facilitator to implement IFacilitator interface\r\n */\r\nexport class CDPFacilitatorAdapter extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'cdp';\r\n  readonly name = 'Coinbase Developer Platform';\r\n  \r\n  readonly config: FacilitatorConfig = {\r\n    id: 'cdp',\r\n    name: 'Coinbase Developer Platform',\r\n    enabled: true,\r\n    priority: 1, // High priority (primary facilitator)\r\n    networks: ['base'], // Legacy: Currently Base only\r\n    networksCAIP: ['eip155:8453'], // CAIP-2: Base mainnet\r\n    assets: ['0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // Legacy: USDC on Base\r\n    assetsCAIP: ['eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // CAIP-19: USDC on Base\r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'], // CDP supports immediate settlement\r\n    healthCheckUrl: process.env.CDP_FACILITATOR_URL || 'https://api.cdp.coinbase.com/platform/v2/x402',\r\n    metadata: {\r\n      provider: 'Coinbase',\r\n      kytEnabled: true,\r\n      ofacEnabled: true,\r\n      complianceLevel: 'enterprise',\r\n    },\r\n  };\r\n\r\n  private cdpFacilitator = getCDPFacilitator();\r\n\r\n  /**\r\n   * Verify payment using CDP facilitator\r\n   * \r\n   * Note: This adapter expects the payment header to be passed as-is.\r\n   * The CDP facilitator will parse it internally. For a more complete\r\n   * adapter, we could parse the header here and extract the authorization,\r\n   * but for now we rely on CDP's internal parsing.\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Import payment header parser to extract authorization\r\n      const { parseAndVerifyPaymentHeader } = await import('../payment-header-parser');\r\n      const parsed = await parseAndVerifyPaymentHeader(payment);\r\n\r\n      if (!parsed.valid || !parsed.payment) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parsed.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Build CDP request with parsed payment data\r\n      const cdpRequest: CDPVerifyRequest = {\r\n        payment,\r\n        paymentPayload: {\r\n          x402Version: 1,\r\n          scheme: 'x402' as const,\r\n          network: parsed.payment.network || requirements.network,\r\n          payload: {\r\n            signature: parsed.payment.signature,\r\n            authorization: parsed.payment.authorization,\r\n          },\r\n        },\r\n        paymentRequirements: {\r\n          scheme: requirements.scheme,\r\n          network: requirements.network,\r\n          maxAmountRequired: requirements.maxAmountRequired,\r\n          resource: requirements.resource,\r\n          description: requirements.description || '',\r\n          mimeType: requirements.mimeType || 'application/json',\r\n          payTo: requirements.payTo,\r\n          maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n          asset: requirements.asset,\r\n        },\r\n      };\r\n\r\n      // Verify with CDP\r\n      const result = await this.cdpFacilitator.verifyPaymentWithRetry(cdpRequest);\r\n\r\n      return {\r\n        success: result.success,\r\n        valid: result.valid,\r\n        transactionHash: result.transactionHash,\r\n        kytStatus: result.kytStatus,\r\n        ofacStatus: result.ofacStatus,\r\n        error: result.error,\r\n        errorDetails: result.errorDetails,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      this.getLogger().error({ error, requirements }, 'CDP verification error');\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: error instanceof Error ? error.message : 'Verification failed',\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get CDP facilitator health\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    try {\r\n      const start = Date.now();\r\n      const health = await this.cdpFacilitator.healthCheck();\r\n      const latency = Date.now() - start;\r\n\r\n      return {\r\n        healthy: health.healthy,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        healthy: false,\r\n        lastChecked: new Date().toISOString(),\r\n        error: error instanceof Error ? error.message : 'Health check failed',\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing (CDP doesn't charge fees, but we track gas costs)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    if (network === 'base' && asset === '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913') {\r\n      return {\r\n        network: 'base',\r\n        asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n        baseFee: '0', // CDP doesn't charge fees\r\n        percentageFee: 0,\r\n        estimatedGas: '21000', // Typical gas for USDC transfer\r\n        currency: 'USDC',\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get CDP facilitator adapter instance\r\n */\r\nlet cdpAdapter: CDPFacilitatorAdapter | null = null;\r\n\r\nexport function getCDPFacilitatorAdapter(): CDPFacilitatorAdapter {\r\n  if (!cdpAdapter) {\r\n    cdpAdapter = new CDPFacilitatorAdapter();\r\n  }\r\n  return cdpAdapter;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1390, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/health-aggregator.ts"],"sourcesContent":["// =============================================================================\r\n// HEALTH AGGREGATOR\r\n// =============================================================================\r\n// Aggregates health metrics from route attempts for scoring and monitoring\r\n\r\nimport { getRouteAttemptsForHealth, upsertHealthSnapshot, getLatestHealthSnapshot, type RouteAttempt, type FacilitatorHealthSnapshot } from '@/db/smf';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'HealthAggregator' });\r\n\r\n/**\r\n * Calculate percentile from sorted array\r\n */\r\nfunction percentile(sortedValues: number[], p: number): number {\r\n  if (sortedValues.length === 0) return 0;\r\n  const index = Math.ceil((p / 100) * sortedValues.length) - 1;\r\n  return sortedValues[Math.max(0, index)];\r\n}\r\n\r\n/**\r\n * Aggregate health metrics from route attempts\r\n */\r\nexport async function aggregateHealthMetrics(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowStart: Date,\r\n  windowEnd: Date\r\n): Promise<FacilitatorHealthSnapshot | null> {\r\n  try {\r\n    const attempts = await getRouteAttemptsForHealth(\r\n      facilitatorId,\r\n      network,\r\n      token,\r\n      windowStart.toISOString(),\r\n      windowEnd.toISOString()\r\n    );\r\n\r\n    if (attempts.length === 0) {\r\n      logger.debug({ facilitatorId, network, token }, 'No attempts found for health aggregation');\r\n      return null;\r\n    }\r\n\r\n    // Calculate success rate\r\n    const successful = attempts.filter((a) => a.result === 'success').length;\r\n    const successRate = successful / attempts.length;\r\n\r\n    // Calculate latency percentiles\r\n    const latencies = attempts\r\n      .map((a) => a.latency_ms)\r\n      .filter((l) => l > 0)\r\n      .sort((a, b) => a - b);\r\n\r\n    const p50 = latencies.length > 0 ? percentile(latencies, 50) : null;\r\n    const p95 = latencies.length > 0 ? percentile(latencies, 95) : null;\r\n    const p99 = latencies.length > 0 ? percentile(latencies, 99) : null;\r\n\r\n    // Calculate error rate\r\n    const errors = attempts.filter((a) => a.result !== 'success').length;\r\n    const errorRate = errors / attempts.length;\r\n\r\n    // Get last error type\r\n    const failedAttempts = attempts.filter((a) => a.result !== 'success');\r\n    const lastErrorType = failedAttempts.length > 0 ? failedAttempts[failedAttempts.length - 1].result : null;\r\n\r\n    // Determine status\r\n    let status: 'healthy' | 'degraded' | 'down' = 'healthy';\r\n    if (successRate < 0.5) {\r\n      status = 'down';\r\n    } else if (successRate < 0.9 || (p95 && p95 > 5000)) {\r\n      status = 'degraded';\r\n    }\r\n\r\n    const snapshot: Omit<FacilitatorHealthSnapshot, 'id' | 'created_at'> = {\r\n      facilitator_id: facilitatorId,\r\n      network,\r\n      token,\r\n      window_start: windowStart.toISOString(),\r\n      window_end: windowEnd.toISOString(),\r\n      success_rate: successRate,\r\n      p50_latency_ms: p50,\r\n      p95_latency_ms: p95,\r\n      p99_latency_ms: p99,\r\n      error_rate: errorRate,\r\n      last_error_type: lastErrorType,\r\n      status,\r\n    };\r\n\r\n    const saved = await upsertHealthSnapshot(snapshot);\r\n    logger.info(\r\n      {\r\n        facilitatorId,\r\n        network,\r\n        token,\r\n        successRate,\r\n        p95Latency: p95,\r\n        status,\r\n        attempts: attempts.length,\r\n      },\r\n      'Health snapshot created'\r\n    );\r\n\r\n    return saved;\r\n  } catch (error) {\r\n    logger.error({ error, facilitatorId, network, token }, 'Failed to aggregate health metrics');\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get current health for a facilitator/network/token\r\n * Returns latest snapshot or calculates from recent attempts\r\n */\r\nexport async function getCurrentHealth(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowMinutes: number = 15\r\n): Promise<{\r\n  successRate: number;\r\n  p50LatencyMs: number | null;\r\n  p95LatencyMs: number | null;\r\n  p99LatencyMs: number | null;\r\n  errorRate: number;\r\n  lastErrorType: string | null;\r\n  status: 'healthy' | 'degraded' | 'down';\r\n}> {\r\n  // Try to get latest snapshot first\r\n  const snapshot = await getLatestHealthSnapshot(facilitatorId, network, token);\r\n\r\n  if (snapshot) {\r\n    const snapshotAge = Date.now() - new Date(snapshot.window_end).getTime();\r\n    const maxAge = windowMinutes * 60 * 1000;\r\n\r\n    // If snapshot is recent enough, use it\r\n    if (snapshotAge < maxAge) {\r\n      return {\r\n        successRate: Number(snapshot.success_rate),\r\n        p50LatencyMs: snapshot.p50_latency_ms,\r\n        p95LatencyMs: snapshot.p95_latency_ms,\r\n        p99LatencyMs: snapshot.p99_latency_ms,\r\n        errorRate: Number(snapshot.error_rate),\r\n        lastErrorType: snapshot.last_error_type,\r\n        status: snapshot.status,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Otherwise, calculate from recent attempts\r\n  const windowEnd = new Date();\r\n  const windowStart = new Date(windowEnd.getTime() - windowMinutes * 60 * 1000);\r\n\r\n  const aggregated = await aggregateHealthMetrics(facilitatorId, network, token, windowStart, windowEnd);\r\n\r\n  if (aggregated) {\r\n    return {\r\n      successRate: Number(aggregated.success_rate),\r\n      p50LatencyMs: aggregated.p50_latency_ms,\r\n      p95LatencyMs: aggregated.p95_latency_ms,\r\n      p99LatencyMs: aggregated.p99_latency_ms,\r\n      errorRate: Number(aggregated.error_rate),\r\n      lastErrorType: aggregated.last_error_type,\r\n      status: aggregated.status,\r\n    };\r\n  }\r\n\r\n  // Default values if no data\r\n  return {\r\n    successRate: 1.0,\r\n    p50LatencyMs: null,\r\n    p95LatencyMs: null,\r\n    p99LatencyMs: null,\r\n    errorRate: 0.0,\r\n    lastErrorType: null,\r\n    status: 'healthy',\r\n  };\r\n}\r\n\r\n/**\r\n * Periodic job to update health snapshots\r\n * Should be called every 5-15 minutes\r\n */\r\nexport async function updateHealthSnapshots(windowMinutes: number = 15): Promise<void> {\r\n  logger.info({ windowMinutes }, 'Starting health snapshot update');\r\n\r\n  // Get all unique facilitator/network/token combinations from recent routes\r\n  // For now, we'll focus on CDP/Base/USDC - can be expanded later\r\n  const combinations = [\r\n    { facilitatorId: 'cdp', network: 'base', token: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' },\r\n  ];\r\n\r\n  const windowEnd = new Date();\r\n  const windowStart = new Date(windowEnd.getTime() - windowMinutes * 60 * 1000);\r\n\r\n  await Promise.all(\r\n    combinations.map(async (combo) => {\r\n      try {\r\n        await aggregateHealthMetrics(combo.facilitatorId, combo.network, combo.token, windowStart, windowEnd);\r\n      } catch (error) {\r\n        logger.error({ error, ...combo }, 'Failed to update health snapshot');\r\n      }\r\n    })\r\n  );\r\n\r\n  logger.info('Health snapshot update complete');\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1564, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/dummy-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// DUMMY FACILITATOR (FOR TESTING)\r\n// =============================================================================\r\n// Test facilitator that wraps CDP or provides mock behavior\r\n// Used to test routing logic, priority ties, failover, etc.\r\n\r\nimport { BaseFacilitator, type IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorHealth, type FacilitatorConfig } from './base-facilitator';\r\nimport { getCDPFacilitatorAdapter } from './cdp-facilitator-adapter';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'DummyFacilitator' });\r\n\r\n/**\r\n * Dummy Facilitator\r\n * \r\n * Can be configured to:\r\n * - Wrap CDP (for testing routing with same backend)\r\n * - Provide mock behavior (for testing without real payments)\r\n * - Simulate failures (for testing failover)\r\n */\r\nexport class DummyFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id: string;\r\n  readonly name: string;\r\n  readonly config: FacilitatorConfig;\r\n  \r\n  private wrapCDP: boolean;\r\n  private mockBehavior?: 'success' | 'failure' | 'timeout';\r\n  private cdpAdapter?: ReturnType<typeof getCDPFacilitatorAdapter>;\r\n\r\n  constructor(\r\n    id: string = 'dummy',\r\n    name: string = 'Dummy Facilitator',\r\n    config: Partial<FacilitatorConfig> = {},\r\n    options: {\r\n      wrapCDP?: boolean; // If true, wraps CDP adapter\r\n      mockBehavior?: 'success' | 'failure' | 'timeout'; // Mock behavior if not wrapping CDP\r\n    } = {}\r\n  ) {\r\n    super();\r\n    this.id = id;\r\n    this.name = name;\r\n    this.wrapCDP = options.wrapCDP ?? false;\r\n    this.mockBehavior = options.mockBehavior;\r\n\r\n    // Default config (can be overridden)\r\n    this.config = {\r\n      id: this.id,\r\n      name: this.name,\r\n      enabled: true,\r\n      priority: 2, // Lower priority than CDP (for testing priority-based routing)\r\n      networks: ['base'],\r\n      networksCAIP: ['eip155:8453'], // CAIP-2: Base mainnet\r\n      assets: ['0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // USDC on Base\r\n      assetsCAIP: ['eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // CAIP-19: USDC on Base\r\n      schemes: ['exact', 'x402'],\r\n      settlementModes: ['immediate'], // Default to immediate settlement\r\n      ...config,\r\n    };\r\n\r\n    if (this.wrapCDP) {\r\n      this.cdpAdapter = getCDPFacilitatorAdapter();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify payment\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    // If wrapping CDP, delegate to CDP\r\n    if (this.wrapCDP && this.cdpAdapter) {\r\n      logger.info({ payment: payment.substring(0, 20) + '...' }, 'Dummy facilitator delegating to CDP');\r\n      return await this.cdpAdapter.verify(payment, requirements);\r\n    }\r\n\r\n    // Mock behavior for testing\r\n    if (this.mockBehavior === 'failure') {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: 'Mock failure for testing',\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    if (this.mockBehavior === 'timeout') {\r\n      await new Promise((resolve) => setTimeout(resolve, 10000)); // 10 second delay\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: 'Mock timeout for testing',\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    // Mock success\r\n    return {\r\n      success: true,\r\n      valid: true,\r\n      transactionHash: `0x${Math.random().toString(16).substring(2, 66)}`,\r\n      kytStatus: 'passed',\r\n      ofacStatus: 'passed',\r\n      facilitatorId: this.id,\r\n      verifiedAt: new Date().toISOString(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get health status\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    // If wrapping CDP, delegate to CDP\r\n    if (this.wrapCDP && this.cdpAdapter) {\r\n      return await this.cdpAdapter.getHealth();\r\n    }\r\n\r\n    // Mock health (always healthy for testing)\r\n    return {\r\n      healthy: true,\r\n      latency: 50, // Mock low latency\r\n      lastChecked: new Date().toISOString(),\r\n      capabilities: {\r\n        networks: this.config.networks,\r\n        assets: this.config.assets,\r\n        schemes: this.config.schemes,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: string): boolean {\r\n    return super.supports(network, asset, scheme, settlementMode as any);\r\n  }\r\n\r\n  /**\r\n   * Get pricing (mock)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    if (this.wrapCDP && this.cdpAdapter) {\r\n      return await this.cdpAdapter.getPricing(network, asset);\r\n    }\r\n\r\n    // Mock pricing (slightly higher than CDP to test cost optimization)\r\n    if (network === 'base' && asset === '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913') {\r\n      return {\r\n        network: 'base',\r\n        asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n        baseFee: '1000', // Slightly higher than CDP\r\n        percentageFee: 0.001, // 0.1%\r\n        estimatedGas: '21000',\r\n        currency: 'USDC',\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Create a dummy facilitator for testing\r\n */\r\nexport function createDummyFacilitator(\r\n  id: string = 'dummy',\r\n  options?: {\r\n    wrapCDP?: boolean;\r\n    mockBehavior?: 'success' | 'failure' | 'timeout';\r\n    priority?: number;\r\n  }\r\n): DummyFacilitator {\r\n  return new DummyFacilitator(\r\n    id,\r\n    `Dummy Facilitator (${id})`,\r\n    {\r\n      priority: options?.priority ?? 2,\r\n    },\r\n    {\r\n      wrapCDP: options?.wrapCDP ?? false,\r\n      mockBehavior: options?.mockBehavior,\r\n    }\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1738, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/facilitator-router.ts"],"sourcesContent":["// =============================================================================\r\n// FACILITATOR ROUTER\r\n// =============================================================================\r\n// Smart routing logic for selecting the best facilitator based on policy\r\n// Implements \"meta-facilitator\" pattern: SDK expresses preferences, SMF owns policy\r\n\r\nimport { IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorConfig, type CAIPNetworkId, type CAIPAssetId, type SettlementMode } from './base-facilitator';\r\nimport { getCDPFacilitatorAdapter } from './cdp-facilitator-adapter';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { getCurrentHealth } from './health-aggregator';\r\nimport { getFacilitatorCapabilities } from '@/db/smf';\r\n\r\nconst logger = createLogger({ component: 'FacilitatorRouter' });\r\n\r\n/**\r\n * Routing preferences (from SDK/agent)\r\n * SDK expresses preferences, SMF owns policy\r\n */\r\nexport interface RoutingPreferences {\r\n  preferredNetworks?: string[]; // Legacy: e.g., ['solana', 'base']\r\n  preferredNetworksCAIP?: CAIPNetworkId[]; // CAIP-2 network identifiers\r\n  preferredAssets?: string[]; // Legacy: e.g., ['USDC']\r\n  preferredAssetsCAIP?: CAIPAssetId[]; // CAIP-19 asset identifiers\r\n  avoidNetworks?: string[]; // Legacy: e.g., ['ethereum'] (mainnet too expensive)\r\n  avoidNetworksCAIP?: CAIPNetworkId[]; // CAIP-2 networks to avoid\r\n  maxCost?: number; // Maximum cost in USD\r\n  requireCompliance?: boolean; // Require KYT/OFAC\r\n  priority?: 'cost' | 'speed' | 'reliability' | 'compliance';\r\n  jurisdiction?: string; // ISO country code (e.g., 'US', 'GB')\r\n  settlementMode?: SettlementMode; // Preferred settlement mode\r\n}\r\n\r\n/**\r\n * Routing policy (SMF business logic)\r\n * SMF owns higher-level policy above raw settlement\r\n */\r\nexport interface RoutingPolicy {\r\n  // Risk rules\r\n  riskThreshold?: number; // Max risk score (0-100)\r\n  requireKYC?: boolean; // Require KYC for certain amounts\r\n  \r\n  // Cost optimization\r\n  preferCheapest?: boolean; // Prefer cheapest facilitator\r\n  maxCostMultiplier?: number; // Max cost vs cheapest (1.5 = 50% premium)\r\n  \r\n  // Compliance rules\r\n  jurisdictionRules?: JurisdictionRule[];\r\n  \r\n  // Reliability\r\n  requireHealthCheck?: boolean; // Only route to healthy facilitators\r\n  minUptime?: number; // Minimum uptime percentage (0-1)\r\n  \r\n  // Custom rules\r\n  customRules?: (facilitator: IFacilitator, requirements: PaymentRequirements) => boolean;\r\n}\r\n\r\n/**\r\n * Jurisdiction-based routing rules\r\n */\r\nexport interface JurisdictionRule {\r\n  country?: string; // ISO country code\r\n  region?: string; // Region name\r\n  allowedNetworks?: string[];\r\n  requiredKYC?: boolean;\r\n  maxAmount?: string; // Max amount in smallest units\r\n  blockedFacilitators?: string[]; // Facilitator IDs to avoid\r\n}\r\n\r\n/**\r\n * Facilitator router\r\n * Implements smart routing based on preferences and policy\r\n */\r\nexport class FacilitatorRouter {\r\n  private facilitators: Map<string, IFacilitator> = new Map();\r\n  private facilitatorHealth: Map<string, { healthy: boolean; lastChecked: number }> = new Map();\r\n  private healthCheckInterval: NodeJS.Timeout | null = null;\r\n\r\n  constructor() {\r\n    // Register default facilitators\r\n    this.registerFacilitator(getCDPFacilitatorAdapter());\r\n    \r\n    // Register dummy facilitator for testing (wraps CDP, different priority)\r\n    // This allows testing routing logic, priority ties, failover, etc.\r\n    if (process.env.ENABLE_DUMMY_FACILITATOR === 'true') {\r\n      const { createDummyFacilitator } = require('./dummy-facilitator');\r\n      const dummy = createDummyFacilitator('dummy', {\r\n        wrapCDP: true, // Wrap CDP for realistic testing\r\n        priority: 2, // Lower priority than CDP\r\n      });\r\n      this.registerFacilitator(dummy);\r\n    }\r\n    \r\n    // Start health check interval (every 5 minutes)\r\n    this.startHealthChecks();\r\n  }\r\n\r\n  /**\r\n   * Register a facilitator\r\n   */\r\n  registerFacilitator(facilitator: IFacilitator): void {\r\n    this.facilitators.set(facilitator.id, facilitator);\r\n    logger.info({ facilitatorId: facilitator.id, name: facilitator.name }, 'Facilitator registered');\r\n  }\r\n\r\n  /**\r\n   * Unregister a facilitator\r\n   */\r\n  unregisterFacilitator(facilitatorId: string): void {\r\n    this.facilitators.delete(facilitatorId);\r\n    this.facilitatorHealth.delete(facilitatorId);\r\n    logger.info({ facilitatorId }, 'Facilitator unregistered');\r\n  }\r\n\r\n  /**\r\n   * Get all registered facilitators\r\n   */\r\n  getFacilitators(): IFacilitator[] {\r\n    return Array.from(this.facilitators.values());\r\n  }\r\n\r\n  /**\r\n   * Route payment to best facilitator\r\n   * \r\n   * @param requirements - Payment requirements\r\n   * @param preferences - SDK/agent preferences\r\n   * @param policy - SMF business logic policy\r\n   */\r\n  async routePayment(\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): Promise<IFacilitator> {\r\n    // Get eligible facilitators\r\n    const eligible = this.getEligibleFacilitators(requirements, preferences, policy);\r\n\r\n    if (eligible.length === 0) {\r\n      throw new Error(\r\n        `No eligible facilitator found for ${requirements.network}/${requirements.asset}/${requirements.scheme}`\r\n      );\r\n    }\r\n\r\n    // Score and rank facilitators\r\n    const scored = await this.scoreFacilitators(eligible, requirements, preferences, policy);\r\n\r\n    // Select best facilitator\r\n    const best = scored[0].facilitator;\r\n    \r\n    // Log decision trace (compact format for explainer/debugger UI)\r\n    logger.info({\r\n      facilitatorId: best.id,\r\n      score: scored[0].score,\r\n      alternatives: scored.length - 1,\r\n      reasons: scored[0].reasons,\r\n      constraints: {\r\n        preferences: preferences ? {\r\n          priority: preferences.priority,\r\n          preferredNetworks: preferences.preferredNetworks,\r\n          preferredAssets: preferences.preferredAssets,\r\n        } : undefined,\r\n        settlementMode: requirements.settlementMode,\r\n      },\r\n      candidates: scored.map((s) => ({\r\n        id: s.facilitator.id,\r\n        score: s.score,\r\n        reasons: s.reasons,\r\n      })),\r\n    }, 'Facilitator selected');\r\n\r\n    return best;\r\n  }\r\n\r\n  /**\r\n   * Get eligible facilitators based on requirements, preferences, and policy\r\n   * Extended to support CAIP identifiers and settlement modes\r\n   */\r\n  private getEligibleFacilitators(\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): IFacilitator[] {\r\n    const facilitators = Array.from(this.facilitators.values());\r\n\r\n    return facilitators.filter((facilitator) => {\r\n      // 1. Check basic support (legacy or CAIP)\r\n      let supportsNetwork = false;\r\n      let supportsAsset = false;\r\n\r\n      // Check network support\r\n      if (requirements.networks && requirements.networks.length > 0) {\r\n        // CAIP networks\r\n        supportsNetwork = requirements.networks.some((n) =>\r\n          facilitator.supportsCAIPNetwork(n)\r\n        );\r\n      } else {\r\n        // Legacy network\r\n        supportsNetwork = facilitator.config.networks.includes(requirements.network);\r\n      }\r\n\r\n      // Check asset support\r\n      if (requirements.assets && requirements.assets.length > 0) {\r\n        // CAIP assets\r\n        supportsAsset = requirements.assets.some((a) =>\r\n          facilitator.supportsCAIPAsset(a)\r\n        );\r\n      } else {\r\n        // Legacy asset\r\n        supportsAsset = facilitator.config.assets.includes(requirements.asset);\r\n      }\r\n\r\n      if (\r\n        !supportsNetwork ||\r\n        !supportsAsset ||\r\n        !facilitator.supports(\r\n          requirements.network,\r\n          requirements.asset,\r\n          requirements.scheme,\r\n          requirements.settlementMode\r\n        )\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      // 2. Check if enabled\r\n      if (!facilitator.config.enabled) {\r\n        return false;\r\n      }\r\n\r\n      // 3. Check preferences (SDK preferences) - support both legacy and CAIP\r\n      const preferredNetworks = [\r\n        ...(preferences?.preferredNetworks || []),\r\n        ...(preferences?.preferredNetworksCAIP || []),\r\n      ];\r\n      if (preferredNetworks.length > 0) {\r\n        const facilitatorNetworks = [\r\n          ...facilitator.config.networks,\r\n          ...(facilitator.config.networksCAIP || []),\r\n        ];\r\n        if (!preferredNetworks.some((p) => facilitatorNetworks.some((n) => n.includes(p) || p.includes(n)))) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      const avoidedNetworks = [\r\n        ...(preferences?.avoidNetworks || []),\r\n        ...(preferences?.avoidNetworksCAIP || []),\r\n      ];\r\n      if (avoidedNetworks.length > 0) {\r\n        const facilitatorNetworks = [\r\n          ...facilitator.config.networks,\r\n          ...(facilitator.config.networksCAIP || []),\r\n        ];\r\n        if (avoidedNetworks.some((a) => facilitatorNetworks.some((n) => n.includes(a) || a.includes(n)))) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      const preferredAssets = [\r\n        ...(preferences?.preferredAssets || []),\r\n        ...(preferences?.preferredAssetsCAIP || []),\r\n      ];\r\n      if (preferredAssets.length > 0) {\r\n        const facilitatorAssets = [\r\n          ...facilitator.config.assets,\r\n          ...(facilitator.config.assetsCAIP || []),\r\n        ];\r\n        if (!preferredAssets.some((p) => facilitatorAssets.some((a) => a.includes(p) || p.includes(a)))) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // 3b. Check jurisdiction (if specified)\r\n      if (preferences?.jurisdiction) {\r\n        // This would integrate with jurisdiction rules\r\n        // For now, pass through (can be enhanced later)\r\n      }\r\n\r\n      // 3c. Check settlement mode preference\r\n      if (preferences?.settlementMode) {\r\n        if (facilitator.config.settlementModes && !facilitator.config.settlementModes.includes(preferences.settlementMode)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // 4. Check policy (SMF business logic)\r\n      if (policy?.requireHealthCheck) {\r\n        const health = this.facilitatorHealth.get(facilitator.id);\r\n        if (!health || !health.healthy) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Note: Database health snapshot check is done in scoreFacilitators (async)\r\n      // to avoid blocking the synchronous filter operation\r\n\r\n      if (policy?.customRules) {\r\n        if (!policy.customRules(facilitator, requirements)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // 5. Check compliance requirements\r\n      if (preferences?.requireCompliance || policy?.requireKYC) {\r\n        // Check if facilitator supports compliance\r\n        const metadata = facilitator.config.metadata;\r\n        if (!metadata?.kytEnabled && !metadata?.ofacEnabled) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Score facilitators based on preferences and policy\r\n   * Uses real health metrics from database for accurate scoring\r\n   * Handles priority ties with randomization\r\n   * Exposed for decision trace building\r\n   */\r\n  public async scoreFacilitators(\r\n    facilitators: IFacilitator[],\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): Promise<Array<{ facilitator: IFacilitator; score: number; reasons: string[] }>> {\r\n    const scored = await Promise.all(\r\n      facilitators.map(async (facilitator) => {\r\n        let score = 100; // Start with base score\r\n        const reasons: string[] = [];\r\n\r\n        // 1. Base priority (lower priority number = higher priority)\r\n        const basePriority = facilitator.config.priority;\r\n        score += basePriority * 10;\r\n        reasons.push(`priority:${basePriority}`);\r\n\r\n        // 2. Get real health metrics from database\r\n        const network = requirements.network;\r\n        const token = requirements.asset;\r\n        let healthMetrics;\r\n        try {\r\n          healthMetrics = await getCurrentHealth(facilitator.id, network, token, 15);\r\n        } catch (error) {\r\n          logger.warn({ error, facilitatorId: facilitator.id, network, token }, 'Failed to get health metrics, using defaults');\r\n          healthMetrics = {\r\n            successRate: 1.0,\r\n            p95LatencyMs: null,\r\n            errorRate: 0.0,\r\n            status: 'healthy' as const,\r\n          };\r\n        }\r\n\r\n        // 3. Success rate scoring (w1 * successRate)\r\n        const w1 = 50; // Weight for success rate\r\n        const successRateScore = healthMetrics.successRate * w1;\r\n        score += successRateScore;\r\n        reasons.push(`success-rate:${(healthMetrics.successRate * 100).toFixed(1)}%`);\r\n\r\n        // 4. Latency scoring (w2 * p95LatencyMs) - lower is better\r\n        const w2 = 0.1; // Weight for latency penalty\r\n        if (healthMetrics.p95LatencyMs !== null) {\r\n          const latencyPenalty = healthMetrics.p95LatencyMs * w2;\r\n          score -= latencyPenalty;\r\n          reasons.push(`p95-latency:${healthMetrics.p95LatencyMs}ms`);\r\n        }\r\n\r\n        // 5. Fee scoring (w3 * feeBps) - get from capabilities\r\n        const w3 = 0.5; // Weight for fee penalty\r\n        try {\r\n          const capabilities = await getFacilitatorCapabilities(facilitator.id, network, token);\r\n          const capability = capabilities[0];\r\n          if (capability) {\r\n            const feePenalty = capability.fee_bps * w3;\r\n            score -= feePenalty;\r\n            reasons.push(`fee:${capability.fee_bps}bps`);\r\n          }\r\n        } catch (error) {\r\n          logger.debug({ error, facilitatorId: facilitator.id }, 'Failed to get capabilities for fee scoring');\r\n        }\r\n\r\n        // 6. Risk penalty (w4 * riskPenalty) - based on error rate and status\r\n        const w4 = 30; // Weight for risk penalty\r\n        const riskPenalty = healthMetrics.errorRate * w4;\r\n        score -= riskPenalty;\r\n        if (healthMetrics.status === 'down') {\r\n          // Refuse routing to down facilitators (set score to very low value)\r\n          score = -1000; // Effectively prevents routing\r\n          reasons.push('status:down');\r\n          logger.warn(\r\n            { facilitatorId: facilitator.id, network: requirements.network, token: requirements.asset },\r\n            'Refusing to route - facilitator is down'\r\n          );\r\n        } else if (healthMetrics.status === 'degraded') {\r\n          score -= 25; // Moderate penalty for degraded\r\n          reasons.push('status:degraded');\r\n          logger.warn(\r\n            { facilitatorId: facilitator.id, network: requirements.network, token: requirements.asset },\r\n            'Facilitator is degraded - routing with caution'\r\n          );\r\n        }\r\n\r\n        // 7. Health status check (cached)\r\n        const health = this.facilitatorHealth.get(facilitator.id);\r\n        if (health && !health.healthy) {\r\n          score -= 30; // Additional penalty for unhealthy in cache\r\n          reasons.push('cache-unhealthy');\r\n        }\r\n\r\n        // 8. Cost optimization (if policy requires)\r\n        if (policy?.preferCheapest || preferences?.priority === 'cost') {\r\n          const pricing = await facilitator.getPricing(requirements.network, requirements.asset);\r\n          if (pricing) {\r\n            // Lower cost = higher score (normalize)\r\n            score += 20; // Bonus for having pricing info\r\n            reasons.push('has-pricing');\r\n          }\r\n        }\r\n\r\n        // 9. Speed optimization (if preference)\r\n        if (preferences?.priority === 'speed') {\r\n          if (healthMetrics.p95LatencyMs !== null) {\r\n            // Lower latency = higher score\r\n            const latencyBonus = Math.max(0, 30 - healthMetrics.p95LatencyMs / 10);\r\n            score += latencyBonus;\r\n            reasons.push(`speed-optimized:${healthMetrics.p95LatencyMs}ms`);\r\n          }\r\n        }\r\n\r\n        // 10. Compliance optimization\r\n        if (preferences?.priority === 'compliance' || policy?.requireKYC) {\r\n          const metadata = facilitator.config.metadata;\r\n          if (metadata?.kytEnabled && metadata?.ofacEnabled) {\r\n            score += 30; // Bonus for compliance\r\n            reasons.push('compliance-enabled');\r\n          }\r\n        }\r\n\r\n        // 11. Reliability optimization\r\n        if (preferences?.priority === 'reliability') {\r\n          if (healthMetrics.status === 'healthy' && healthMetrics.successRate > 0.95) {\r\n            score += 25;\r\n            reasons.push('high-reliability');\r\n          }\r\n        }\r\n\r\n        // 12. Settlement mode optimization\r\n        if (requirements.settlementMode) {\r\n          if (facilitator.config.settlementModes?.includes(requirements.settlementMode)) {\r\n            score += 15; // Bonus for supporting requested settlement mode\r\n            reasons.push(`settlement:${requirements.settlementMode}`);\r\n          }\r\n        }\r\n\r\n        return { facilitator, score, reasons };\r\n      })\r\n    );\r\n\r\n    // Sort by score (highest first)\r\n    const sorted = scored.sort((a, b) => b.score - a.score);\r\n\r\n    // Handle priority ties with randomization\r\n    // If top scores are within 5 points, randomize order\r\n    if (sorted.length > 1) {\r\n      const topScore = sorted[0].score;\r\n      const tied = sorted.filter((s) => Math.abs(s.score - topScore) <= 5);\r\n      \r\n      if (tied.length > 1) {\r\n        // Shuffle tied facilitators\r\n        for (let i = tied.length - 1; i > 0; i--) {\r\n          const j = Math.floor(Math.random() * (i + 1));\r\n          [tied[i], tied[j]] = [tied[j], tied[i]];\r\n        }\r\n        // Rebuild sorted array with shuffled ties\r\n        const rest = sorted.filter((s) => Math.abs(s.score - topScore) > 5);\r\n        return [...tied, ...rest];\r\n      }\r\n    }\r\n\r\n    return sorted;\r\n  }\r\n\r\n  /**\r\n   * Start periodic health checks\r\n   */\r\n  private startHealthChecks(): void {\r\n    this.healthCheckInterval = setInterval(async () => {\r\n      await this.checkAllFacilitators();\r\n    }, 5 * 60 * 1000); // Every 5 minutes\r\n\r\n    // Initial health check\r\n    this.checkAllFacilitators();\r\n  }\r\n\r\n  /**\r\n   * Check health of all facilitators\r\n   */\r\n  private async checkAllFacilitators(): Promise<void> {\r\n    const facilitators = Array.from(this.facilitators.values());\r\n    \r\n    await Promise.all(\r\n      facilitators.map(async (facilitator) => {\r\n        try {\r\n          const health = await facilitator.getHealth();\r\n          this.facilitatorHealth.set(facilitator.id, {\r\n            healthy: health.healthy,\r\n            lastChecked: Date.now(),\r\n          });\r\n        } catch (error) {\r\n          logger.error({ facilitatorId: facilitator.id, error }, 'Health check failed');\r\n          this.facilitatorHealth.set(facilitator.id, {\r\n            healthy: false,\r\n            lastChecked: Date.now(),\r\n          });\r\n        }\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get facilitator by ID\r\n   */\r\n  getFacilitator(id: string): IFacilitator | undefined {\r\n    return this.facilitators.get(id);\r\n  }\r\n\r\n  /**\r\n   * Get facilitator health status\r\n   */\r\n  getFacilitatorHealth(id: string): { healthy: boolean; lastChecked: number } | undefined {\r\n    return this.facilitatorHealth.get(id);\r\n  }\r\n\r\n  /**\r\n   * Cleanup\r\n   */\r\n  destroy(): void {\r\n    if (this.healthCheckInterval) {\r\n      clearInterval(this.healthCheckInterval);\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet router: FacilitatorRouter | null = null;\r\n\r\n/**\r\n * Get facilitator router instance\r\n */\r\nexport function getFacilitatorRouter(): FacilitatorRouter {\r\n  if (!router) {\r\n    router = new FacilitatorRouter();\r\n  }\r\n  return router;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}}]
}