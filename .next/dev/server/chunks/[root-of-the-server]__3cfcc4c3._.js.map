{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/sentry.ts"],"sourcesContent":["// src/lib/sentry.ts\r\n\r\n// Temporary no-op Sentry shim to avoid module errors during dev\r\nconst Sentry = null as any;\r\n\r\nexport const sentry = {\r\n  captureException: (..._args: any[]) => {},\r\n  captureMessage: (..._args: any[]) => {},\r\n  withScope: (fn: (scope: any) => void) => fn({}),\r\n};\r\n\r\n// No-op functions for compatibility\r\nexport function initSentry() {}\r\nexport function setSentryUser(_userId?: string, _apiKeyId?: string) {}\r\nexport function setSentryContext(_context: any) {}\r\nexport function captureException(_error: Error, _context?: any) {}\r\nexport function captureMessage(_message: string, _level: any = 'info', _context?: any) {}\r\n"],"names":[],"mappings":"AAAA,oBAAoB;AAEpB,gEAAgE;;;;;;;;;;;;;;;AAChE,MAAM,SAAS;AAER,MAAM,SAAS;IACpB,kBAAkB,CAAC,GAAG,SAAkB;IACxC,gBAAgB,CAAC,GAAG,SAAkB;IACtC,WAAW,CAAC,KAA6B,GAAG,CAAC;AAC/C;AAGO,SAAS,cAAc;AACvB,SAAS,cAAc,OAAgB,EAAE,SAAkB,GAAG;AAC9D,SAAS,iBAAiB,QAAa,GAAG;AAC1C,SAAS,iBAAiB,MAAa,EAAE,QAAc,GAAG;AAC1D,SAAS,eAAe,QAAgB,EAAE,SAAc,MAAM,EAAE,QAAc,GAAG"}},
    {"offset": {"line": 155, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/logger.ts"],"sourcesContent":["// =============================================================================\r\n// Structured Logging\r\n// =============================================================================\r\n// Uses Pino for fast, structured logging\r\n// Supports request ID tracking and different log levels\r\n// All logs include standard fields: timestamp, level, message, requestId, etc.\r\n\r\nimport pino from 'pino';\r\n\r\n// Determine log level from environment\r\nconst logLevel = process.env.LOG_LEVEL || (process.env.NODE_ENV === 'production' ? 'info' : 'debug');\r\n\r\n// Create logger instance with structured output\r\n// In Next.js dev mode, disable pino-pretty transport to avoid worker thread issues\r\n// Use simple JSON output instead (can be prettified by other tools)\r\nconst isNextDev = process.env.NODE_ENV === 'development' && process.env.NEXT_RUNTIME;\r\nconst usePrettyTransport = process.env.NODE_ENV !== 'production' && !isNextDev;\r\n\r\nconst logger = pino({\r\n  level: logLevel,\r\n  transport: usePrettyTransport ? {\r\n    target: 'pino-pretty',\r\n    options: {\r\n      colorize: true,\r\n      translateTime: 'SYS:standard',\r\n      ignore: 'pid,hostname',\r\n    },\r\n  } : undefined,\r\n  formatters: {\r\n    level: (label) => {\r\n      return { level: label.toUpperCase() };\r\n    },\r\n  },\r\n  base: {\r\n    env: process.env.NODE_ENV || 'development',\r\n    service: 'nexflow-api',\r\n  },\r\n  // Ensure timestamps are included\r\n  timestamp: pino.stdTimeFunctions.isoTime,\r\n});\r\n\r\nexport type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';\r\n\r\n/**\r\n * Standard log context fields\r\n */\r\nexport interface LogContext {\r\n  // Request tracking\r\n  requestId?: string;\r\n  apiKeyId?: string;\r\n  endpoint?: string;\r\n  method?: string;\r\n  statusCode?: number;\r\n  durationMs?: number;\r\n  ip?: string;\r\n  \r\n  // Error context\r\n  errorCode?: string;\r\n  error?: Error | any;\r\n  stack?: string;\r\n  \r\n  // CDP/x402 context\r\n  cdpStatus?: string;\r\n  cdpErrorId?: string;\r\n  paymentIntentId?: string;\r\n  x402HeaderId?: string;\r\n  \r\n  // Rate limiting\r\n  rateLimitKey?: string;\r\n  rateLimitRemaining?: number;\r\n  \r\n  // Additional context\r\n  [key: string]: any;\r\n}\r\n\r\n/**\r\n * Create a child logger with additional context\r\n * Useful for request-scoped logging with request IDs\r\n */\r\nexport function createLogger(context?: LogContext | Record<string, any>) {\r\n  return context ? logger.child(context) : logger;\r\n}\r\n\r\n/**\r\n * Get the default logger instance\r\n */\r\nexport function getLogger() {\r\n  return logger;\r\n}\r\n\r\n/**\r\n * Sanitize sensitive data from log context\r\n * Removes API keys, tokens, payment headers, and PII\r\n */\r\nfunction sanitizeContext(context: LogContext): LogContext {\r\n  const sanitized = { ...context };\r\n  \r\n  // Remove sensitive fields\r\n  const sensitiveKeys = [\r\n    'apiKey', 'token', 'authorization', 'x-payment', 'paymentHeader',\r\n    'cardNumber', 'cvv', 'ssn', 'password', 'secret',\r\n  ];\r\n  \r\n  sensitiveKeys.forEach(key => {\r\n    if (key in sanitized) {\r\n      delete sanitized[key];\r\n    }\r\n  });\r\n  \r\n  // Truncate long strings that might contain sensitive data\r\n  Object.keys(sanitized).forEach(key => {\r\n    const value = sanitized[key];\r\n    if (typeof value === 'string' && value.length > 200) {\r\n      sanitized[key] = value.substring(0, 200) + '... [truncated]';\r\n    }\r\n  });\r\n  \r\n  return sanitized;\r\n}\r\n\r\n/**\r\n * Log levels with structured context\r\n */\r\nexport const log = {\r\n  trace: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.trace(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  debug: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.debug(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  info: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.info(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  warn: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.warn(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  error: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.error(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry if error object exists\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'UNKNOWN_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n  fatal: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.fatal(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry for fatal errors\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'FATAL_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n            severity: 'fatal',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport default logger;\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 347, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/base-facilitator.ts"],"sourcesContent":["// =============================================================================\n// FACILITATOR ABSTRACTION LAYER\n// =============================================================================\n// Base interface and types for pluggable x402 facilitators\n// Enables multi-facilitator orchestration and routing\n\nimport { createLogger } from '@/lib/logger';\n\nconst logger = createLogger({ component: 'BaseFacilitator' });\n\n/**\n * CAIP-2 Network Identifier (e.g., \"eip155:8453\" for Base)\n * CAIP-19 Asset Identifier (e.g., \"eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\" for USDC on Base)\n */\nexport type CAIPNetworkId = string; // e.g., \"eip155:8453\", \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\", \"bip122:000000000019d6689c085ae165831e93\"\nexport type CAIPAssetId = string; // e.g., \"eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\"\n\n/**\n * Settlement mode for payments\n */\nexport type SettlementMode = 'immediate' | 'deferred' | 'batch';\n\n/**\n * Payment requirements for x402 payment verification\n * Extended to support CAIP identifiers and settlement modes\n */\nexport interface PaymentRequirements {\n  scheme: string; // 'exact', 'x402', etc.\n  network: string; // Legacy: 'base', 'ethereum', 'solana', etc.\n  networks?: CAIPNetworkId[]; // CAIP-2 network identifiers (multi-network support)\n  maxAmountRequired: string; // Amount in smallest units\n  resource: string; // Resource URL\n  description?: string;\n  mimeType?: string;\n  payTo: string; // Recipient address\n  maxTimeoutSeconds?: number;\n  asset: string; // Legacy: Token address\n  assets?: CAIPAssetId[]; // CAIP-19 asset identifiers (multi-asset support)\n  settlementMode?: SettlementMode; // 'immediate', 'deferred', or 'batch'\n}\n\n/**\n * Payment verification result\n */\nexport interface VerificationResult {\n  success: boolean;\n  valid: boolean;\n  transactionHash?: string;\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\n  error?: string;\n  errorDetails?: Record<string, any>;\n  facilitatorId: string; // Which facilitator verified this\n  verifiedAt: string; // ISO timestamp\n}\n\n/**\n * Facilitator health status\n */\nexport interface FacilitatorHealth {\n  healthy: boolean;\n  latency?: number; // ms\n  lastChecked: string; // ISO timestamp\n  error?: string;\n  capabilities: {\n    networks: string[];\n    assets: string[];\n    schemes: string[];\n  };\n}\n\n/**\n * Pricing information for a facilitator\n */\nexport interface PricingInfo {\n  network: string;\n  asset: string;\n  baseFee?: string; // Base fee in smallest units\n  percentageFee?: number; // Percentage fee (0-1)\n  estimatedGas?: string; // Estimated gas cost\n  currency: string; // Fee currency\n}\n\n/**\n * Facilitator configuration\n */\nexport interface FacilitatorConfig {\n  id: string;\n  name: string;\n  enabled: boolean;\n  priority: number; // Lower = higher priority\n  networks: string[]; // Legacy: Supported networks\n  networksCAIP?: CAIPNetworkId[]; // CAIP-2 network identifiers\n  assets: string[]; // Legacy: Supported assets\n  assetsCAIP?: CAIPAssetId[]; // CAIP-19 asset identifiers\n  schemes: string[]; // Supported schemes ('exact', 'x402', etc.)\n  settlementModes?: SettlementMode[]; // Supported settlement modes\n  healthCheckUrl?: string;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Base facilitator interface\n * All facilitators must implement this interface\n */\nexport interface IFacilitator {\n  /**\n   * Unique identifier for this facilitator\n   */\n  readonly id: string;\n\n  /**\n   * Human-readable name\n   */\n  readonly name: string;\n\n  /**\n   * Facilitator configuration\n   */\n  readonly config: FacilitatorConfig;\n\n  /**\n   * Verify an x402 payment\n   */\n  verify(\n    payment: string,\n    requirements: PaymentRequirements\n  ): Promise<VerificationResult>;\n\n  /**\n   * Check facilitator health\n   */\n  getHealth(): Promise<FacilitatorHealth>;\n\n  /**\n   * Get pricing information for a network/asset combination\n   */\n  getPricing(network: string, asset: string): Promise<PricingInfo | null>;\n\n  /**\n   * Check if facilitator supports a given network/asset/scheme\n   * Extended to support settlement modes\n   */\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean;\n}\n\n/**\n * Base facilitator class with common functionality\n */\nexport abstract class BaseFacilitator implements IFacilitator {\n  abstract readonly id: string;\n  abstract readonly name: string;\n  abstract readonly config: FacilitatorConfig;\n\n  protected getLogger() {\n    return logger.child({ facilitator: this.constructor.name });\n  }\n\n  /**\n   * Verify payment (must be implemented by subclasses)\n   */\n  abstract verify(\n    payment: string,\n    requirements: PaymentRequirements\n  ): Promise<VerificationResult>;\n\n  /**\n   * Get health status (must be implemented by subclasses)\n   */\n  abstract getHealth(): Promise<FacilitatorHealth>;\n\n  /**\n   * Get pricing (default implementation returns null)\n   */\n  async getPricing(network: string, asset: string): Promise<PricingInfo | null> {\n    // Default: no pricing info available\n    return null;\n  }\n\n  /**\n   * Check if facilitator supports network/asset/scheme\n   * Enhanced to support both legacy and CAIP identifiers\n   */\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n\n    // Check scheme support\n    if (!this.config.schemes.includes(scheme)) {\n      return false;\n    }\n\n    // Check settlement mode support\n    if (settlementMode && this.config.settlementModes && !this.config.settlementModes.includes(settlementMode)) {\n      return false;\n    }\n\n    // Check network support (legacy or CAIP)\n    const supportsNetwork = \n      this.config.networks.includes(network) ||\n      (this.config.networksCAIP && this.config.networksCAIP.includes(network as CAIPNetworkId));\n\n    if (!supportsNetwork) {\n      return false;\n    }\n\n    // Check asset support (legacy or CAIP)\n    const supportsAsset = \n      this.config.assets.includes(asset) ||\n      (this.config.assetsCAIP && this.config.assetsCAIP.includes(asset as CAIPAssetId));\n\n    return supportsAsset;\n  }\n\n  /**\n   * Check if facilitator supports a CAIP-2 network identifier\n   */\n  supportsCAIPNetwork(caip: CAIPNetworkId): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n    return this.config.networksCAIP?.includes(caip) || false;\n  }\n\n  /**\n   * Check if facilitator supports a CAIP-19 asset identifier\n   */\n  supportsCAIPAsset(caip: CAIPAssetId): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n    return this.config.assetsCAIP?.includes(caip) || false;\n  }\n\n  /**\n   * Validate payment requirements\n   * Enhanced to support CAIP identifiers\n   */\n  protected validateRequirements(\n    requirements: PaymentRequirements\n  ): { valid: boolean; error?: string } {\n    // Check network (legacy or CAIP)\n    const hasNetwork = \n      !!requirements.network || \n      (requirements.networks && requirements.networks.length > 0);\n    \n    if (!hasNetwork) {\n      return { valid: false, error: 'Network is required' };\n    }\n\n    // Check asset (legacy or CAIP)\n    const hasAsset = \n      !!requirements.asset || \n      (requirements.assets && requirements.assets.length > 0);\n    \n    if (!hasAsset) {\n      return { valid: false, error: 'Asset is required' };\n    }\n\n    if (!requirements.payTo) {\n      return { valid: false, error: 'Recipient address (payTo) is required' };\n    }\n    if (!requirements.maxAmountRequired) {\n      return { valid: false, error: 'Amount is required' };\n    }\n\n    // Check support (use legacy network/asset for supports() check, or check CAIP directly)\n    const networkToCheck = requirements.network || (requirements.networks?.[0] || '');\n    const assetToCheck = requirements.asset || (requirements.assets?.[0] || '');\n    \n    // Check CAIP support if CAIP identifiers are provided\n    if (requirements.networks && requirements.networks.length > 0) {\n      const supportsAnyNetwork = requirements.networks.some((n) => \n        this.supportsCAIPNetwork(n) || this.config.networks.includes(n)\n      );\n      if (!supportsAnyNetwork) {\n        return {\n          valid: false,\n          error: `Facilitator ${this.id} does not support any of the requested networks: ${requirements.networks.join(', ')}`,\n        };\n      }\n    }\n\n    if (requirements.assets && requirements.assets.length > 0) {\n      const supportsAnyAsset = requirements.assets.some((a) => \n        this.supportsCAIPAsset(a) || this.config.assets.includes(a)\n      );\n      if (!supportsAnyAsset) {\n        return {\n          valid: false,\n          error: `Facilitator ${this.id} does not support any of the requested assets: ${requirements.assets.join(', ')}`,\n        };\n      }\n    }\n\n    // Check legacy support\n    if (!this.supports(networkToCheck, assetToCheck, requirements.scheme, requirements.settlementMode)) {\n      return {\n        valid: false,\n        error: `Facilitator ${this.id} does not support ${networkToCheck}/${assetToCheck}/${requirements.scheme}`,\n      };\n    }\n    return { valid: true };\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 483, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/cdp-jwt.ts"],"sourcesContent":["import { generateJwt } from '@coinbase/cdp-sdk/auth';\r\n\r\nexport interface CDPJWTPayload {\r\n  sub: string;\r\n  iss: string;\r\n  aud: string[];\r\n  nbf: number;\r\n  exp: number;\r\n  uris?: string[];\r\n}\r\n\r\nexport class CDPJWTGenerator {\r\n  private apiKeyId: string;\r\n  private apiKeySecret: string;\r\n\r\n  constructor(apiKeyId: string, apiKeySecret: string) {\r\n    this.apiKeyId = apiKeyId;\r\n    this.apiKeySecret = apiKeySecret;\r\n  }\r\n\r\n  /**\r\n   * Generate JWT token for CDP API authentication.\r\n   *\r\n   * Uses CDP SDK's generateJwt helper, which signs with the correct\r\n   * algorithm (ES256/EdDSA) for your CDP API key.\r\n   * \r\n   * @param requestMethod - HTTP method (GET, POST, etc.) or null for generic auth\r\n   * @param requestHost - Request host or null\r\n   * @param requestPath - Request path or null\r\n   */\r\n  async generateToken(\r\n    requestMethod: string | null = null,\r\n    requestHost: string | null = null,\r\n    requestPath: string | null = null,\r\n  ): Promise<string> {\r\n    // For REST requests, CDP expects method/host/path\r\n    // For generic facilitator auth, nulls are allowed\r\n    const token = await generateJwt({\r\n      apiKeyId: this.apiKeyId,\r\n      apiKeySecret: this.apiKeySecret,\r\n      requestMethod: requestMethod || null,\r\n      requestHost: requestHost || null,\r\n      requestPath: requestPath || null,\r\n      expiresIn: 120,\r\n      // CDP SDK will handle the JWT payload and headers correctly.\r\n    });\r\n\r\n    return token;\r\n  }\r\n\r\n  isTokenValid(_token: string): boolean {\r\n    // Keep simple: rely on short expiry and CDP errors instead of local decode.\r\n    return true;\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet jwtGenerator: CDPJWTGenerator | null = null;\r\n\r\nexport function getCDPJWTGenerator(): CDPJWTGenerator {\r\n  if (!jwtGenerator) {\r\n    const apiKeyId = process.env.CDP_API_KEY_ID;\r\n    const apiKeySecret = process.env.CDP_API_KEY_SECRET;\r\n\r\n    if (!apiKeyId || !apiKeySecret) {\r\n      throw new Error('CDP_API_KEY_ID and CDP_API_KEY_SECRET must be set');\r\n    }\r\n\r\n    jwtGenerator = new CDPJWTGenerator(apiKeyId, apiKeySecret);\r\n  }\r\n  return jwtGenerator;\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAWO,MAAM;IACH,SAAiB;IACjB,aAAqB;IAE7B,YAAY,QAAgB,EAAE,YAAoB,CAAE;QAClD,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,YAAY,GAAG;IACtB;IAEA;;;;;;;;;GASC,GACD,MAAM,cACJ,gBAA+B,IAAI,EACnC,cAA6B,IAAI,EACjC,cAA6B,IAAI,EAChB;QACjB,kDAAkD;QAClD,kDAAkD;QAClD,MAAM,QAAQ,MAAM,YAAY;YAC9B,UAAU,IAAI,CAAC,QAAQ;YACvB,cAAc,IAAI,CAAC,YAAY;YAC/B,eAAe,iBAAiB;YAChC,aAAa,eAAe;YAC5B,aAAa,eAAe;YAC5B,WAAW;QAEb;QAEA,OAAO;IACT;IAEA,aAAa,MAAc,EAAW;QACpC,4EAA4E;QAC5E,OAAO;IACT;AACF;AAEA,qBAAqB;AACrB,IAAI,eAAuC;AAEpC,SAAS;IACd,IAAI,CAAC,cAAc;QACjB,MAAM,WAAW,QAAQ,GAAG,CAAC,cAAc;QAC3C,MAAM,eAAe,QAAQ,GAAG,CAAC,kBAAkB;QAEnD,IAAI,CAAC,YAAY,CAAC,cAAc;YAC9B,MAAM,IAAI,MAAM;QAClB;QAEA,eAAe,IAAI,gBAAgB,UAAU;IAC/C;IACA,OAAO;AACT"}},
    {"offset": {"line": 546, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/signature-verifier.ts"],"sourcesContent":["import { verifyTypedData, type Address } from 'viem';\r\nimport { base } from 'viem/chains';\r\n\r\nexport interface EIP712Domain {\r\n  name: string;\r\n  version: string;\r\n  chainId: number;\r\n  verifyingContract: Address;\r\n}\r\n\r\nexport interface PaymentAuthorization {\r\n  from: Address;\r\n  to: Address;\r\n  value: string;\r\n  validAfter: string;\r\n  validBefore: string;\r\n  nonce: string;\r\n}\r\n\r\n/**\r\n * Verify EIP-712 signature for x402 payment authorization\r\n * This provides an additional security layer before CDP verification\r\n */\r\nexport async function verifyPaymentSignature(\r\n  signature: string,\r\n  authorization: PaymentAuthorization,\r\n  signerAddress: Address,\r\n  chainId: number = 8453 // Base mainnet\r\n): Promise<boolean> {\r\n  try {\r\n    // EIP-712 domain for x402 payments\r\n    const domain: EIP712Domain = {\r\n      name: 'x402',\r\n      version: '1',\r\n      chainId,\r\n      verifyingContract: '0x0000000000000000000000000000000000000000' as Address, // x402 doesn't use a contract\r\n    };\r\n\r\n    // EIP-712 types for the payment authorization\r\n    const types = {\r\n      PaymentAuthorization: [\r\n        { name: 'from', type: 'address' },\r\n        { name: 'to', type: 'address' },\r\n        { name: 'value', type: 'uint256' },\r\n        { name: 'validAfter', type: 'uint256' },\r\n        { name: 'validBefore', type: 'uint256' },\r\n        { name: 'nonce', type: 'bytes32' },\r\n      ],\r\n    };\r\n\r\n    // Verify the signature\r\n    const isValid = await verifyTypedData({\r\n      address: signerAddress,\r\n      domain,\r\n      types,\r\n      primaryType: 'PaymentAuthorization',\r\n      message: authorization as Record<string, unknown>,\r\n      signature: signature as `0x${string}`,\r\n    });\r\n\r\n    return isValid;\r\n  } catch (error) {\r\n    console.error('[SignatureVerifier] Verification error:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Validate payment authorization fields\r\n */\r\nexport function validatePaymentAuthorization(\r\n  authorization: PaymentAuthorization\r\n): { valid: boolean; error?: string } {\r\n  const now = Math.floor(Date.now() / 1000);\r\n  const validAfter = parseInt(authorization.validAfter);\r\n  const validBefore = parseInt(authorization.validBefore);\r\n\r\n  if (now < validAfter) {\r\n    return { valid: false, error: 'Payment not yet valid' };\r\n  }\r\n\r\n  if (now >= validBefore) {\r\n    return { valid: false, error: 'Payment has expired' };\r\n  }\r\n\r\n  if (!authorization.from || !authorization.to) {\r\n    return { valid: false, error: 'Missing from or to address' };\r\n  }\r\n\r\n  if (!authorization.value || BigInt(authorization.value) <= BigInt(0)) {\r\n    return { valid: false, error: 'Invalid payment amount' };\r\n  }\r\n\r\n  if (!authorization.nonce) {\r\n    return { valid: false, error: 'Missing nonce' };\r\n  }\r\n\r\n  return { valid: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAuBO,eAAe,uBACpB,SAAiB,EACjB,aAAmC,EACnC,aAAsB,EACtB,UAAkB,KAAK,eAAe;AAAhB;IAEtB,IAAI;QACF,mCAAmC;QACnC,MAAM,SAAuB;YAC3B,MAAM;YACN,SAAS;YACT;YACA,mBAAmB;QACrB;QAEA,8CAA8C;QAC9C,MAAM,QAAQ;YACZ,sBAAsB;gBACpB;oBAAE,MAAM;oBAAQ,MAAM;gBAAU;gBAChC;oBAAE,MAAM;oBAAM,MAAM;gBAAU;gBAC9B;oBAAE,MAAM;oBAAS,MAAM;gBAAU;gBACjC;oBAAE,MAAM;oBAAc,MAAM;gBAAU;gBACtC;oBAAE,MAAM;oBAAe,MAAM;gBAAU;gBACvC;oBAAE,MAAM;oBAAS,MAAM;gBAAU;aAClC;QACH;QAEA,uBAAuB;QACvB,MAAM,UAAU,MAAM,gBAAgB;YACpC,SAAS;YACT;YACA;YACA,aAAa;YACb,SAAS;YACT,WAAW;QACb;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2CAA2C;QACzD,OAAO;IACT;AACF;AAKO,SAAS,6BACd,aAAmC;IAEnC,MAAM,MAAM,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;IACpC,MAAM,aAAa,SAAS,cAAc,UAAU;IACpD,MAAM,cAAc,SAAS,cAAc,WAAW;IAEtD,IAAI,MAAM,YAAY;QACpB,OAAO;YAAE,OAAO;YAAO,OAAO;QAAwB;IACxD;IAEA,IAAI,OAAO,aAAa;QACtB,OAAO;YAAE,OAAO;YAAO,OAAO;QAAsB;IACtD;IAEA,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,EAAE,EAAE;QAC5C,OAAO;YAAE,OAAO;YAAO,OAAO;QAA6B;IAC7D;IAEA,IAAI,CAAC,cAAc,KAAK,IAAI,OAAO,cAAc,KAAK,KAAK,OAAO,IAAI;QACpE,OAAO;YAAE,OAAO;YAAO,OAAO;QAAyB;IACzD;IAEA,IAAI,CAAC,cAAc,KAAK,EAAE;QACxB,OAAO;YAAE,OAAO;YAAO,OAAO;QAAgB;IAChD;IAEA,OAAO;QAAE,OAAO;IAAK;AACvB"}},
    {"offset": {"line": 654, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/amount-utils.ts"],"sourcesContent":["// =============================================================================\r\n// AMOUNT UTILITIES\r\n// =============================================================================\r\n// Helper functions for converting between human-readable amounts and atomic units\r\n\r\n/**\r\n * Convert human-readable amount to atomic units\r\n * \r\n * For USDC on Base: 1 USDC = 1,000,000 atomic units (6 decimals)\r\n * \r\n * @param humanAmount - Human-readable amount (e.g., \"1\" for 1 USDC)\r\n * @param decimals - Number of decimals (default: 6 for USDC)\r\n * @returns Atomic units as string (e.g., \"1000000\" for 1 USDC)\r\n * \r\n * @example\r\n * toAtomicUnits(\"1\", 6) // \"1000000\"\r\n * toAtomicUnits(\"0.5\", 6) // \"500000\"\r\n * toAtomicUnits(\"1.5\", 6) // \"1500000\"\r\n */\r\nexport function toAtomicUnits(humanAmount: string, decimals: number = 6): string {\r\n  // Remove any whitespace\r\n  const cleanAmount = humanAmount.trim();\r\n  \r\n  // Parse as decimal number\r\n  const amount = parseFloat(cleanAmount);\r\n  \r\n  if (isNaN(amount) || amount < 0) {\r\n    throw new Error(`Invalid amount: ${humanAmount}`);\r\n  }\r\n  \r\n  // Convert to atomic units: multiply by 10^decimals\r\n  const atomicUnits = BigInt(Math.floor(amount * Math.pow(10, decimals)));\r\n  \r\n  // Return as string\r\n  return atomicUnits.toString();\r\n}\r\n\r\n/**\r\n * Convert atomic units to human-readable amount\r\n * \r\n * @param atomicUnits - Atomic units as string (e.g., \"1000000\")\r\n * @param decimals - Number of decimals (default: 6 for USDC)\r\n * @returns Human-readable amount as string (e.g., \"1\")\r\n * \r\n * @example\r\n * fromAtomicUnits(\"1000000\", 6) // \"1\"\r\n * fromAtomicUnits(\"500000\", 6) // \"0.5\"\r\n */\r\nexport function fromAtomicUnits(atomicUnits: string, decimals: number = 6): string {\r\n  const atomic = BigInt(atomicUnits);\r\n  const divisor = BigInt(Math.pow(10, decimals));\r\n  const whole = atomic / divisor;\r\n  const remainder = atomic % divisor;\r\n  \r\n  if (remainder === BigInt(0)) {\r\n    return whole.toString();\r\n  }\r\n  \r\n  // Format with proper decimal places\r\n  const remainderStr = remainder.toString().padStart(decimals, '0');\r\n  const trimmed = remainderStr.replace(/0+$/, '');\r\n  return `${whole}.${trimmed}`;\r\n}\r\n\r\n/**\r\n * Normalize network identifier to CAIP-2 format\r\n * \r\n * @param network - Network identifier (e.g., \"base\", \"eip155:8453\")\r\n * @returns CAIP-2 format network identifier\r\n * \r\n * @example\r\n * normalizeNetwork(\"base\") // \"eip155:8453\"\r\n * normalizeNetwork(\"eip155:8453\") // \"eip155:8453\"\r\n */\r\nexport function normalizeNetwork(network: string): string {\r\n  // If already in CAIP format, return as-is\r\n  if (network.includes(':')) {\r\n    return network;\r\n  }\r\n  \r\n  // Map common network names to CAIP-2 format\r\n  const networkMap: Record<string, string> = {\r\n    'base': 'eip155:8453',\r\n    'ethereum': 'eip155:1',\r\n    'polygon': 'eip155:137',\r\n    'arbitrum': 'eip155:42161',\r\n    'optimism': 'eip155:10',\r\n    'avalanche': 'eip155:43114',\r\n    'bnb': 'eip155:56',\r\n  };\r\n  \r\n  const normalized = networkMap[network.toLowerCase()];\r\n  if (normalized) {\r\n    return normalized;\r\n  }\r\n  \r\n  // If not found, assume it's already in the correct format or return as-is\r\n  return network;\r\n}\r\n\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,mBAAmB;AACnB,gFAAgF;AAChF,kFAAkF;AAElF;;;;;;;;;;;;;CAaC;;;;;;;;AACM,SAAS,cAAc,WAAmB,EAAE,WAAmB,CAAC;IACrE,wBAAwB;IACxB,MAAM,cAAc,YAAY,IAAI;IAEpC,0BAA0B;IAC1B,MAAM,SAAS,WAAW;IAE1B,IAAI,MAAM,WAAW,SAAS,GAAG;QAC/B,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,aAAa;IAClD;IAEA,mDAAmD;IACnD,MAAM,cAAc,OAAO,KAAK,KAAK,CAAC,SAAS,KAAK,GAAG,CAAC,IAAI;IAE5D,mBAAmB;IACnB,OAAO,YAAY,QAAQ;AAC7B;AAaO,SAAS,gBAAgB,WAAmB,EAAE,WAAmB,CAAC;IACvE,MAAM,SAAS,OAAO;IACtB,MAAM,UAAU,OAAO,KAAK,GAAG,CAAC,IAAI;IACpC,MAAM,QAAQ,SAAS;IACvB,MAAM,YAAY,SAAS;IAE3B,IAAI,cAAc,OAAO,IAAI;QAC3B,OAAO,MAAM,QAAQ;IACvB;IAEA,oCAAoC;IACpC,MAAM,eAAe,UAAU,QAAQ,GAAG,QAAQ,CAAC,UAAU;IAC7D,MAAM,UAAU,aAAa,OAAO,CAAC,OAAO;IAC5C,OAAO,GAAG,MAAM,CAAC,EAAE,SAAS;AAC9B;AAYO,SAAS,iBAAiB,OAAe;IAC9C,0CAA0C;IAC1C,IAAI,QAAQ,QAAQ,CAAC,MAAM;QACzB,OAAO;IACT;IAEA,4CAA4C;IAC5C,MAAM,aAAqC;QACzC,QAAQ;QACR,YAAY;QACZ,WAAW;QACX,YAAY;QACZ,YAAY;QACZ,aAAa;QACb,OAAO;IACT;IAEA,MAAM,aAAa,UAAU,CAAC,QAAQ,WAAW,GAAG;IACpD,IAAI,YAAY;QACd,OAAO;IACT;IAEA,0EAA0E;IAC1E,OAAO;AACT"}},
    {"offset": {"line": 731, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/cdp-client.ts"],"sourcesContent":["// =============================================================================\r\n// CDP/x402 Client Wrapper\r\n// =============================================================================\r\n// Wraps all calls to Coinbase/CDP/x402 with normalized error handling\r\n// and structured logging\r\n\r\nimport { createLogger, type LogContext } from './logger';\r\n\r\nconst logger = createLogger({ component: 'CDPClient' });\r\n\r\n/**\r\n * Normalized CDP error codes\r\n */\r\nexport enum CDPErrorCode {\r\n  CDP_TIMEOUT = 'CDP_TIMEOUT',\r\n  CDP_4XX = 'CDP_4XX',\r\n  CDP_5XX = 'CDP_5XX',\r\n  CDP_INVALID_RESPONSE = 'CDP_INVALID_RESPONSE',\r\n  CDP_NETWORK_ERROR = 'CDP_NETWORK_ERROR',\r\n  CDP_AUTH_ERROR = 'CDP_AUTH_ERROR',\r\n  CDP_RATE_LIMIT = 'CDP_RATE_LIMIT',\r\n  CDP_UNKNOWN_ERROR = 'CDP_UNKNOWN_ERROR',\r\n}\r\n\r\n/**\r\n * Normalized CDP error\r\n */\r\nexport class CDPError extends Error {\r\n  constructor(\r\n    public code: CDPErrorCode,\r\n    message: string,\r\n    public statusCode?: number,\r\n    public cdpErrorId?: string,\r\n    public responseBody?: any\r\n  ) {\r\n    super(message);\r\n    this.name = 'CDPError';\r\n    // Ensure stack trace is captured\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, CDPError);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Normalize HTTP status code to CDP error code\r\n */\r\nfunction normalizeErrorCode(statusCode: number | undefined): CDPErrorCode {\r\n  if (!statusCode) {\r\n    return CDPErrorCode.CDP_UNKNOWN_ERROR;\r\n  }\r\n  \r\n  if (statusCode >= 500) {\r\n    return CDPErrorCode.CDP_5XX;\r\n  }\r\n  \r\n  if (statusCode === 401 || statusCode === 403) {\r\n    return CDPErrorCode.CDP_AUTH_ERROR;\r\n  }\r\n  \r\n  if (statusCode === 429) {\r\n    return CDPErrorCode.CDP_RATE_LIMIT;\r\n  }\r\n  \r\n  if (statusCode >= 400) {\r\n    return CDPErrorCode.CDP_4XX;\r\n  }\r\n  \r\n  return CDPErrorCode.CDP_UNKNOWN_ERROR;\r\n}\r\n\r\n/**\r\n * Extract safe excerpt from response body for logging\r\n * Removes sensitive data and truncates long responses\r\n */\r\nfunction extractSafeResponseExcerpt(body: any, maxLength: number = 500): string {\r\n  if (!body) return '';\r\n  \r\n  try {\r\n    const str = typeof body === 'string' ? body : JSON.stringify(body);\r\n    if (str.length <= maxLength) {\r\n      return str;\r\n    }\r\n    return str.substring(0, maxLength) + '... [truncated]';\r\n  } catch {\r\n    return '[unable to serialize response]';\r\n  }\r\n}\r\n\r\n/**\r\n * Wrapper for CDP API calls with error handling and logging\r\n */\r\nexport async function callCDP<T>(\r\n  operation: string,\r\n  requestFn: () => Promise<Response>,\r\n  context: {\r\n    requestId?: string;\r\n    apiKeyId?: string;\r\n    endpointId?: string;\r\n    targetUrl?: string;\r\n  }\r\n): Promise<T> {\r\n  const startTime = Date.now();\r\n  const logContext: LogContext = {\r\n    requestId: context.requestId,\r\n    apiKeyId: context.apiKeyId,\r\n    endpoint: context.endpointId,\r\n    cdpStatus: 'pending',\r\n  };\r\n  \r\n  try {\r\n    logger.debug({ ...logContext, operation, targetUrl: context.targetUrl }, `CDP call: ${operation}`);\r\n    \r\n    const response = await requestFn();\r\n    const duration = Date.now() - startTime;\r\n    \r\n    // Extract response body safely\r\n    let responseBody: any = null;\r\n    let responseText = '';\r\n    try {\r\n      responseText = await response.text();\r\n      if (responseText) {\r\n        responseBody = JSON.parse(responseText);\r\n      }\r\n    } catch {\r\n      // Response might not be JSON, that's okay\r\n      responseBody = responseText;\r\n    }\r\n    \r\n    // Check if response is successful\r\n    if (!response.ok) {\r\n      const errorCode = normalizeErrorCode(response.status);\r\n      const cdpErrorId = responseBody?.error?.id || responseBody?.errorId || response.headers.get('x-request-id');\r\n      const errorMessage = responseBody?.error?.message || responseBody?.message || `CDP API error: ${response.statusText}`;\r\n      \r\n      const error = new CDPError(\r\n        errorCode,\r\n        errorMessage,\r\n        response.status,\r\n        cdpErrorId,\r\n        responseBody\r\n      );\r\n      \r\n      // Log structured error\r\n      logger.error({\r\n        ...logContext,\r\n        operation,\r\n        targetUrl: context.targetUrl,\r\n        errorCode: error.code,\r\n        cdpErrorId: error.cdpErrorId,\r\n        statusCode: response.status,\r\n        durationMs: duration,\r\n        responseExcerpt: extractSafeResponseExcerpt(responseBody),\r\n      }, `CDP call failed: ${operation}`);\r\n      \r\n      throw error;\r\n    }\r\n    \r\n    // Log successful call\r\n    logger.info({\r\n      ...logContext,\r\n      operation,\r\n      targetUrl: context.targetUrl,\r\n      cdpStatus: 'success',\r\n      statusCode: response.status,\r\n      durationMs: duration,\r\n    }, `CDP call succeeded: ${operation}`);\r\n    \r\n    return responseBody as T;\r\n  } catch (error) {\r\n    const duration = Date.now() - startTime;\r\n    \r\n    // Handle network errors\r\n    if (error instanceof TypeError && error.message.includes('fetch')) {\r\n      const cdpError = new CDPError(\r\n        CDPErrorCode.CDP_NETWORK_ERROR,\r\n        `Network error calling CDP: ${error.message}`,\r\n        undefined,\r\n        undefined,\r\n        undefined\r\n      );\r\n      \r\n      logger.error({\r\n        ...logContext,\r\n        operation,\r\n        targetUrl: context.targetUrl,\r\n        errorCode: cdpError.code,\r\n        durationMs: duration,\r\n        error: error,\r\n      }, `CDP network error: ${operation}`);\r\n      \r\n      throw cdpError;\r\n    }\r\n    \r\n    // Handle timeout errors\r\n    if (error instanceof Error && (error.message.includes('timeout') || error.message.includes('aborted'))) {\r\n      const cdpError = new CDPError(\r\n        CDPErrorCode.CDP_TIMEOUT,\r\n        `CDP call timed out: ${operation}`,\r\n        undefined,\r\n        undefined,\r\n        undefined\r\n      );\r\n      \r\n      logger.error({\r\n        ...logContext,\r\n        operation,\r\n        targetUrl: context.targetUrl,\r\n        errorCode: cdpError.code,\r\n        durationMs: duration,\r\n        error: error,\r\n      }, `CDP timeout: ${operation}`);\r\n      \r\n      throw cdpError;\r\n    }\r\n    \r\n    // Re-throw CDPError as-is\r\n    if (error instanceof CDPError) {\r\n      throw error;\r\n    }\r\n    \r\n    // Wrap unknown errors\r\n    const cdpError = new CDPError(\r\n      CDPErrorCode.CDP_UNKNOWN_ERROR,\r\n      `Unknown error calling CDP: ${error instanceof Error ? error.message : String(error)}`,\r\n      undefined,\r\n      undefined,\r\n      undefined\r\n    );\r\n    \r\n    logger.error({\r\n      ...logContext,\r\n      operation,\r\n      targetUrl: context.targetUrl,\r\n      errorCode: cdpError.code,\r\n      durationMs: duration,\r\n      error: error,\r\n    }, `CDP unknown error: ${operation}`);\r\n    \r\n    throw cdpError;\r\n  }\r\n}\r\n\r\n/**\r\n * Helper to add request ID to CDP API calls\r\n */\r\nexport function addRequestIdToCDPHeaders(\r\n  headers: HeadersInit,\r\n  requestId?: string\r\n): HeadersInit {\r\n  const headersObj = headers instanceof Headers ? Object.fromEntries(headers.entries()) : \r\n                     Array.isArray(headers) ? Object.fromEntries(headers) : \r\n                     headers;\r\n  \r\n  if (requestId) {\r\n    return {\r\n      ...headersObj,\r\n      'x-request-id': requestId,\r\n    };\r\n  }\r\n  \r\n  return headersObj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 927, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/cdp-facilitator.ts"],"sourcesContent":["import { getCDPJWTGenerator } from './cdp-jwt';\r\nimport { verifyPaymentSignature, validatePaymentAuthorization, type PaymentAuthorization } from './signature-verifier';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { toAtomicUnits, normalizeNetwork } from './amount-utils';\r\nimport { callCDP, addRequestIdToCDPHeaders, CDPError, CDPErrorCode } from '@/lib/cdp-client';\r\n\r\nconst logger = createLogger({ component: 'CDPFacilitator' });\r\n\r\n/**\r\n * CDP (Coinbase Developer Platform) Facilitator\r\n * \r\n * Primary facilitator for x402 payment verification on Base network.\r\n * Handles JWT authentication, payment verification, and compliance checks.\r\n */\r\n\r\nexport interface CDPPaymentPayload {\r\n  x402Version: number;\r\n  scheme: 'x402';\r\n  network: string;\r\n  payload: {\r\n    signature: string;\r\n    authorization: PaymentAuthorization;\r\n  };\r\n}\r\n\r\nexport interface X402PaymentRequirements {\r\n  scheme: string;\r\n  network: string;\r\n  to?: string; // Internal field name\r\n  payTo?: string; // CDP field name\r\n  value?: string; // Internal field name\r\n  maxAmountRequired?: string; // CDP field name\r\n  resource: string;\r\n  validAfter?: string; // Validity window start\r\n  validBefore?: string; // Validity window end\r\n  asset: string;\r\n  // Optional fields\r\n  description?: string;\r\n  mimeType?: string;\r\n  maxTimeoutSeconds?: number;\r\n  outputSchema?: any; // Optional JSON schema\r\n  extra?: any; // Optional scheme-specific data\r\n  payer?: string; // Optional: payer address (internal only)\r\n}\r\n\r\n// CDP Verify Request Body - matches CDP x402 v2 API schema exactly\r\n// Per: https://docs.cdp.coinbase.com/api-reference/v2/rest-api/x402-facilitator/verify-a-payment\r\n// This type matches the v2 VerifyRequest schema exactly - no v1 fields or schemas\r\nexport interface CDPVerifyRequestBody {\r\n  x402Version: 2; // CDP x402 v2 - top level (must be 2, not 1)\r\n  paymentPayload: {\r\n    x402Version: 2; // CDP x402 v2 - inside paymentPayload (must match top level, must be 2)\r\n    scheme: string; // 'exact' for EVM\r\n    network: string; // 'base', 'ethereum', etc.\r\n    payload: {\r\n      signature: string; // EIP-712 signature\r\n      authorization: {\r\n        from: string; // EVM address\r\n        to: string; // EVM address\r\n        value: string; // Amount in atomic units\r\n        validAfter: string; // Unix timestamp\r\n        validBefore: string; // Unix timestamp\r\n        nonce: string; // Hex-encoded nonce\r\n      };\r\n    };\r\n  };\r\n  paymentRequirements: {\r\n    scheme: string; // 'exact' for EVM\r\n    network: string; // 'base', 'ethereum', etc.\r\n    payTo: string; // CDP v2 field name (destination address)\r\n    // CDP x402 v2: maxAmountRequired must be a string of atomic units (integer, not decimal)\r\n    // Example: \"1000000\" for 1 USDC (6 decimals), not \"1.0\" or 1000000\r\n    // Must match authorization.value exactly\r\n    maxAmountRequired: string; // Amount in atomic units as string (e.g., \"1000000\" for 1 USDC)\r\n    resource: string; // URI of the resource\r\n    description: string; // Description of the resource\r\n    mimeType: string; // MIME type of the resource response\r\n    maxTimeoutSeconds: number; // Maximum time for server to respond\r\n    asset: string; // Asset contract address (e.g., USDC)\r\n    validAfter?: string; // Optional: validity window start\r\n    validBefore?: string; // Optional: validity window end\r\n    outputSchema?: any; // Optional: JSON schema describing resource output\r\n    extra?: any; // Optional: scheme-specific payment information\r\n  };\r\n}\r\n\r\nexport interface CDPVerifyRequest {\r\n  payment: string; // Payment header or transaction hash\r\n  paymentPayload: CDPPaymentPayload;\r\n  paymentRequirements?: X402PaymentRequirements; // Optional - will be constructed if not provided\r\n}\r\n\r\nexport interface CDPVerifyResponse {\r\n  success: boolean;\r\n  valid: boolean;\r\n  transactionHash?: string;\r\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\r\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\r\n  error?: string;\r\n  errorDetails?: {\r\n    error: string;\r\n    cdpResponse?: any;\r\n    httpStatus?: number;\r\n  };\r\n}\r\n\r\nexport class CDPFacilitator {\r\n  private apiKeyId: string;\r\n  private facilitatorUrl: string;\r\n  private jwtGenerator: ReturnType<typeof getCDPJWTGenerator>;\r\n  private cachedToken: string | null = null;\r\n  private tokenExpiry: number = 0;\r\n\r\n  constructor(\r\n    apiKeyId: string,\r\n    facilitatorUrl: string = 'https://api.cdp.coinbase.com/platform/v2/x402'\r\n  ) {\r\n    this.apiKeyId = apiKeyId;\r\n    this.facilitatorUrl = facilitatorUrl;\r\n    this.jwtGenerator = getCDPJWTGenerator();\r\n  }\r\n\r\n  /**\r\n   * Generate JWT token for CDP API authentication\r\n   * Uses cached token if still valid, otherwise generates new one\r\n   * \r\n   * @param requestMethod - HTTP method for REST calls (optional)\r\n   * @param requestPath - Request path for REST calls (optional)\r\n   */\r\n  private async generateJWT(\r\n    requestMethod: string | null = null,\r\n    requestPath: string | null = null\r\n  ): Promise<string> {\r\n    const now = Date.now();\r\n    \r\n    // For REST calls with specific method/path, don't cache (must be request-specific)\r\n    if (requestMethod && requestPath) {\r\n      const url = new URL(this.facilitatorUrl);\r\n      return await this.jwtGenerator.generateToken(\r\n        requestMethod,\r\n        url.host,\r\n        requestPath\r\n      );\r\n    }\r\n    \r\n    // Return cached token if still valid (with 10 second buffer) - for generic auth\r\n    if (this.cachedToken && this.tokenExpiry > now + 10000) {\r\n      return this.cachedToken;\r\n    }\r\n\r\n    // Generate new token for generic facilitator auth\r\n    const token = await this.jwtGenerator.generateToken(null, null, null);\r\n    this.cachedToken = token;\r\n    this.tokenExpiry = now + 120000; // 2 minutes expiry\r\n\r\n    return token;\r\n  }\r\n\r\n  /**\r\n   * Verify payment with CDP facilitator API\r\n   * \r\n   * This method:\r\n   * 1. Validates payment authorization fields locally\r\n   * 2. Optionally verifies EIP-712 signature locally\r\n   * 3. Calls CDP API for on-chain verification\r\n   * 4. Returns verification result with KYT/OFAC status\r\n   */\r\n  async verifyPayment(request: CDPVerifyRequest): Promise<CDPVerifyResponse> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // Step 1: Validate payment authorization fields locally\r\n      const authValidation = validatePaymentAuthorization(request.paymentPayload.payload.authorization);\r\n      if (!authValidation.valid) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: authValidation.error || 'Invalid payment authorization',\r\n        };\r\n      }\r\n\r\n      // Step 2: Extract authorization for use throughout\r\n      const auth = request.paymentPayload.payload.authorization;\r\n      const signature = request.paymentPayload.payload.signature;\r\n\r\n      // Step 3: Optionally verify signature locally (additional security layer)\r\n      // Note: CDP will also verify, but local check catches issues early\r\n      try {\r\n        const signatureValid = await verifyPaymentSignature(\r\n          signature,\r\n          auth,\r\n          auth.from as `0x${string}`\r\n        );\r\n        if (!signatureValid) {\r\n          logger.warn('Local signature verification failed, but continuing to CDP');\r\n          // Don't fail here - let CDP make the final decision\r\n        }\r\n      } catch (sigError) {\r\n        logger.warn({ error: sigError }, 'Signature verification error, continuing to CDP');\r\n        // Continue to CDP verification\r\n      }\r\n\r\n      // Step 4: Use paymentRequirements from request (must be provided by caller)\r\n      // CDP requires paymentRequirements that match the challenge\r\n      if (!request.paymentRequirements || (!request.paymentRequirements.to && !(request.paymentRequirements as any).payTo)) {\r\n        logger.error({\r\n          hasPaymentRequirements: !!request.paymentRequirements,\r\n          paymentRequirements: request.paymentRequirements,\r\n        }, 'Missing paymentRequirements');\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: 'paymentRequirements must be provided for CDP verification',\r\n        };\r\n      }\r\n      // Normalize paymentRequirements to CDP's expected format\r\n      // CDP expects: scheme, network, to, value, resource, validAfter, validBefore, asset\r\n      // Remove any fields that CDP doesn't expect (payer, maxTimeoutSeconds, description, mimeType might be optional)\r\n      const paymentRequirements: any = {\r\n        scheme: request.paymentRequirements?.scheme || 'exact',\r\n        network: request.paymentRequirements?.network || request.paymentPayload.network,\r\n        // Convert legacy field names to CDP format\r\n        to: request.paymentRequirements?.to || (request.paymentRequirements as any)?.payTo || auth.to,\r\n        value: request.paymentRequirements?.value || (request.paymentRequirements as any)?.maxAmountRequired || auth.value,\r\n        // Ensure validity window is included\r\n        validAfter: request.paymentRequirements?.validAfter || auth.validAfter,\r\n        validBefore: request.paymentRequirements?.validBefore || auth.validBefore,\r\n        // Required fields - ensure they exist\r\n        resource: request.paymentRequirements?.resource,\r\n        asset: request.paymentRequirements?.asset,\r\n        // Optional fields (only include if present)\r\n        ...(request.paymentRequirements?.description && { description: request.paymentRequirements.description }),\r\n        ...(request.paymentRequirements?.mimeType && { mimeType: request.paymentRequirements.mimeType }),\r\n      };\r\n      \r\n      // Validate that required fields are present\r\n      if (!paymentRequirements.resource || !paymentRequirements.asset) {\r\n        logger.error({\r\n          hasResource: !!paymentRequirements.resource,\r\n          hasAsset: !!paymentRequirements.asset,\r\n          paymentRequirements: request.paymentRequirements,\r\n        }, 'Missing required paymentRequirements fields (resource or asset)');\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: 'paymentRequirements must include resource and asset',\r\n        };\r\n      }\r\n\r\n      // Step 5: Parse payment header to check for transaction hash\r\n      // CDP may require transaction hash for on-chain verification\r\n      let txHash: string | undefined;\r\n      try {\r\n        const { parseX402Header } = await import('./payment-header-parser');\r\n        const parsed = parseX402Header(request.payment);\r\n        if (parsed.valid && parsed.parsed?.txHash) {\r\n          txHash = parsed.parsed.txHash;\r\n          logger.debug({ txHash }, 'Found transaction hash in payment header');\r\n        }\r\n      } catch (error) {\r\n        logger.warn({ error }, 'Failed to parse payment header for txHash');\r\n      }\r\n\r\n      // Step 6: Construct request body matching CDP x402 v2 schema exactly\r\n      // CDP v2 schema per docs: https://docs.cdp.coinbase.com/api-reference/v2/rest-api/x402-facilitator/verify-a-payment\r\n      // \r\n      // CDP Requirements for USDC on Base:\r\n      // - 1 USDC = 1,000,000 atomic units (6 decimals)\r\n      // - network must be \"eip155:8453\" (not \"base\")\r\n      // - value and maxAmountRequired must be strings of atomic units\r\n      \r\n      // Normalize network to CAIP-2 format (e.g., \"base\" -> \"eip155:8453\")\r\n      const normalizedNetwork = normalizeNetwork(request.paymentPayload.network || paymentRequirements.network || 'base');\r\n      \r\n      // Convert authorization.value to atomic units if needed\r\n      // auth.value might already be in atomic units (string), or might be human-readable\r\n      // For now, assume it's already in atomic units if it's a large number string\r\n      // If it looks like a human amount (small number), convert it\r\n      let authorizationValue: string;\r\n      const authValueStr = String(auth.value);\r\n      const authValueNum = parseFloat(authValueStr);\r\n      \r\n      // If the value is less than 1000, assume it's human-readable (e.g., \"1\" = 1 USDC)\r\n      // Otherwise, assume it's already in atomic units\r\n      if (authValueNum < 1000 && authValueNum > 0) {\r\n        // Convert human amount to atomic units\r\n        authorizationValue = toAtomicUnits(authValueStr, 6);\r\n        logger.debug({ \r\n          original: authValueStr, \r\n          converted: authorizationValue \r\n        }, 'Converted human amount to atomic units');\r\n      } else {\r\n        // Already in atomic units, ensure it's a string\r\n        authorizationValue = authValueStr;\r\n      }\r\n      \r\n      // Convert maxAmountRequired to atomic units if needed\r\n      const maxAmountRaw = paymentRequirements.value || (paymentRequirements as any).maxAmountRequired || authorizationValue;\r\n      const maxAmountStr = String(maxAmountRaw);\r\n      const maxAmountNum = parseFloat(maxAmountStr);\r\n      \r\n      let maxAmountRequired: string;\r\n      if (maxAmountNum < 1000 && maxAmountNum > 0) {\r\n        // Convert human amount to atomic units\r\n        maxAmountRequired = toAtomicUnits(maxAmountStr, 6);\r\n        logger.debug({ \r\n          original: maxAmountStr, \r\n          converted: maxAmountRequired \r\n        }, 'Converted maxAmountRequired to atomic units');\r\n      } else {\r\n        // Already in atomic units, ensure it's a string\r\n        maxAmountRequired = maxAmountStr;\r\n      }\r\n      \r\n      // Ensure both are strings and digit-only (atomic units)\r\n      if (!/^[0-9]+$/.test(authorizationValue) || !/^[0-9]+$/.test(maxAmountRequired)) {\r\n        const error = new Error('Amount fields must be digit-only strings in atomic units');\r\n        logger.error({\r\n          authorizationValue,\r\n          maxAmountRequired,\r\n          authorizationValueType: typeof authorizationValue,\r\n          maxAmountRequiredType: typeof maxAmountRequired,\r\n        }, 'Amount validation failed');\r\n        throw error;\r\n      }\r\n      \r\n      // Log the final values being sent\r\n      logger.debug({\r\n        network: normalizedNetwork,\r\n        authorizationValue,\r\n        maxAmountRequired,\r\n        payTo: paymentRequirements.to || (paymentRequirements as any).payTo,\r\n      }, 'CDP verify request payload (amounts in atomic units)');\r\n      \r\n      const verifyBody: CDPVerifyRequestBody = {\r\n        x402Version: 2, // CDP x402 v2 - top level\r\n        paymentPayload: {\r\n          x402Version: 2, // CDP x402 v2 - inside paymentPayload (must match top level)\r\n          scheme: request.paymentPayload.scheme || 'exact',\r\n          network: normalizedNetwork, // Use CAIP-2 format: \"eip155:8453\"\r\n          payload: {\r\n            signature: request.paymentPayload.payload.signature,\r\n            authorization: {\r\n              from: auth.from,\r\n              to: auth.to,\r\n              // CDP x402 v2: value must be a string of atomic units (e.g., \"1000000\" for 1 USDC)\r\n              value: authorizationValue,\r\n              validAfter: auth.validAfter,\r\n              validBefore: auth.validBefore,\r\n              nonce: auth.nonce,\r\n            },\r\n          },\r\n        },\r\n        // paymentRequirements at root level (NOT nested inside paymentPayload)\r\n        // CDP v2 field names: payTo, maxAmountRequired (not to, value)\r\n        paymentRequirements: {\r\n          scheme: paymentRequirements.scheme || 'exact',\r\n          network: normalizedNetwork, // Use CAIP-2 format: \"eip155:8453\"\r\n          payTo: paymentRequirements.to || (paymentRequirements as any).payTo,\r\n          // CDP x402 v2: maxAmountRequired must be a string of atomic units (e.g., \"1000000\" for 1 USDC)\r\n          // Must match authorization.value exactly\r\n          maxAmountRequired: maxAmountRequired,\r\n          resource: paymentRequirements.resource,\r\n          asset: paymentRequirements.asset,\r\n          description: paymentRequirements.description || 'x402 Payment Verification',\r\n          mimeType: paymentRequirements.mimeType || 'application/json',\r\n          maxTimeoutSeconds: (paymentRequirements as any).maxTimeoutSeconds || 300,\r\n          // Optional fields per v2 spec\r\n          ...(paymentRequirements.validAfter && { validAfter: paymentRequirements.validAfter }),\r\n          ...(paymentRequirements.validBefore && { validBefore: paymentRequirements.validBefore }),\r\n          ...((paymentRequirements as any).outputSchema && { outputSchema: (paymentRequirements as any).outputSchema }),\r\n          ...((paymentRequirements as any).extra && { extra: (paymentRequirements as any).extra }),\r\n        },\r\n      };\r\n\r\n      // Note: Transaction hash is included in the paymentHeader string itself\r\n      // CDP will extract it from the payment header, so we don't need to add it separately\r\n      if (txHash) {\r\n        logger.debug({ txHash }, 'Transaction hash is included in paymentHeader');\r\n      }\r\n\r\n      // Step 5: Generate JWT token for CDP API\r\n      const url = new URL('https://api.cdp.coinbase.com/platform/v2/x402/verify');\r\n      const token = await this.generateJWT('POST', url.pathname);\r\n\r\n      // Log request details (without sensitive data)\r\n      logger.debug({\r\n        url: url.toString(),\r\n        x402Version: verifyBody.x402Version,\r\n        paymentPayload: {\r\n          scheme: verifyBody.paymentPayload.scheme,\r\n          network: verifyBody.paymentPayload.network,\r\n          signaturePreview: verifyBody.paymentPayload.payload.signature?.substring(0, 20) + '...',\r\n          authorization: {\r\n            from: verifyBody.paymentPayload.payload.authorization.from,\r\n            to: verifyBody.paymentPayload.payload.authorization.to,\r\n            value: verifyBody.paymentPayload.payload.authorization.value,\r\n          },\r\n        },\r\n        paymentRequirements: {\r\n          scheme: paymentRequirements.scheme,\r\n          network: paymentRequirements.network,\r\n          to: paymentRequirements.to,\r\n          value: paymentRequirements.value,\r\n          validAfter: paymentRequirements.validAfter,\r\n          validBefore: paymentRequirements.validBefore,\r\n          payer: (paymentRequirements as any).payer, // Include payer if present\r\n          asset: paymentRequirements.asset,\r\n          resource: paymentRequirements.resource,\r\n          description: paymentRequirements.description,\r\n          mimeType: paymentRequirements.mimeType,\r\n          maxTimeoutSeconds: paymentRequirements.maxTimeoutSeconds,\r\n        },\r\n        fullRequestBody: JSON.stringify(verifyBody, null, 2), // Full request for debugging\r\n        // Log the actual paymentRequirements object being sent\r\n        paymentRequirementsKeys: Object.keys(paymentRequirements),\r\n        paymentRequirementsHasPayer: 'payer' in paymentRequirements,\r\n        paymentRequirementsPayerValue: (paymentRequirements as any).payer,\r\n      }, 'Sending verification request to CDP');\r\n\r\n      // Step 6: Call CDP API using fetch with request ID\r\n      // Extract request ID from context if available (passed via verifyPaymentWithRetry)\r\n      const requestId = (request as any).requestId;\r\n      const headers: HeadersInit = {\r\n        'Content-Type': 'application/json',\r\n        'Authorization': `Bearer ${token}`,\r\n        'X-CDP-API-Key': this.apiKeyId,\r\n      };\r\n      \r\n      // Add request ID to CDP call for correlation\r\n      if (requestId) {\r\n        Object.assign(headers, addRequestIdToCDPHeaders(headers, requestId));\r\n      }\r\n      \r\n      try {\r\n        const response = await fetch(url.toString(), {\r\n          method: 'POST',\r\n          headers,\r\n          body: JSON.stringify(verifyBody),\r\n          signal: AbortSignal.timeout(10000),\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data = text ? JSON.parse(text) : {};\r\n\r\n        const latencyMs = Date.now() - start;\r\n\r\n        // Log CDP response\r\n        logger.debug({\r\n          status: response.status,\r\n          isValid: data.isValid,\r\n          latencyMs,\r\n        }, 'CDP verification response');\r\n\r\n        // CDP response uses `isValid` (not `valid`) and `invalidReason` (not `reason`)\r\n        if (response.ok && data.isValid) {\r\n          logger.info({ latencyMs }, 'Payment verified successfully');\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            transactionHash: undefined, // CDP verify doesn't return transaction hash\r\n            kytStatus: 'passed', // CDP verify doesn't return KYT/OFAC status\r\n            ofacStatus: 'passed',\r\n          };\r\n        } else {\r\n          // Log detailed error information including request body for debugging\r\n          logger.error({\r\n            status: response.status,\r\n            invalidReason: data.invalidReason,\r\n            errorMessage: data.errorMessage,\r\n            error: data.error,\r\n            code: data.code,\r\n            details: data.details,\r\n            cdpResponse: data,\r\n            requestBody: {\r\n              x402Version: verifyBody.x402Version,\r\n              hasPaymentPayload: !!verifyBody.paymentPayload,\r\n              hasPaymentRequirements: !!verifyBody.paymentRequirements,\r\n            },\r\n          }, 'Payment verification failed');\r\n          \r\n          // Extract error code from CDP response - prefer invalidReason, then errorMessage, then error, then code\r\n          const errorCode = data.invalidReason || data.errorMessage || data.error || data.code || 'CDP_VERIFY_FAILED';\r\n          \r\n          // Extract authorization details from the parsed payment header for logging\r\n          let authorizationFrom = 'UNKNOWN';\r\n          let authorizationTo = 'UNKNOWN';\r\n          let transactionHash = 'NOT PROVIDED';\r\n          try {\r\n            const { parseX402Header } = await import('./payment-header-parser');\r\n            const parsed = parseX402Header(request.payment);\r\n            if (parsed.valid && parsed.parsed) {\r\n              authorizationFrom = parsed.parsed.authorization.from;\r\n              authorizationTo = parsed.parsed.authorization.to;\r\n              transactionHash = parsed.parsed.txHash || 'NOT PROVIDED';\r\n            }\r\n          } catch (parseError) {\r\n            logger.warn({ error: parseError }, 'Failed to parse payment header for error logging');\r\n          }\r\n          \r\n          const errorDetails = {\r\n            error: errorMessage,\r\n            cdpResponse: data,\r\n            httpStatus: response.status,\r\n            invalidReason: data.invalidReason,\r\n            errorMessage: data.errorMessage,\r\n            code: data.code,\r\n            details: data.details,\r\n            // Include request details for debugging (using paymentRequirements from verifyBody)\r\n            requestDetails: {\r\n              scheme: verifyBody.paymentRequirements?.scheme || 'MISSING',\r\n              network: verifyBody.paymentRequirements?.network || 'MISSING',\r\n              to: verifyBody.paymentRequirements?.to || 'MISSING',\r\n              value: verifyBody.paymentRequirements?.value || 'MISSING',\r\n              payer: (verifyBody.paymentRequirements as any)?.payer || 'NOT PROVIDED IN PAYMENT REQUIREMENTS',\r\n              validAfter: verifyBody.paymentRequirements?.validAfter || 'MISSING',\r\n              validBefore: verifyBody.paymentRequirements?.validBefore || 'MISSING',\r\n              resource: verifyBody.paymentRequirements?.resource || 'MISSING',\r\n              asset: verifyBody.paymentRequirements?.asset || 'MISSING',\r\n              // Include full paymentRequirements to see what's actually being sent\r\n              fullPaymentRequirements: verifyBody.paymentRequirements,\r\n              // Include authorization from parsed header\r\n              authorizationFrom,\r\n              authorizationTo,\r\n              transactionHash,\r\n            },\r\n          };\r\n\r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            error: errorCode,\r\n            errorDetails: errorDetails,\r\n            kytStatus: undefined,\r\n            ofacStatus: undefined,\r\n          };\r\n        }\r\n      } catch (error: any) {\r\n        // Handle network errors with enhanced logging\r\n        const errorMessage = error?.message || 'CDP_VERIFY_FAILED';\r\n        const isTimeout = error?.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout');\r\n        const isNetworkError = errorMessage.toLowerCase().includes('network') || \r\n                              errorMessage.toLowerCase().includes('fetch') ||\r\n                              errorMessage.toLowerCase().includes('econnrefused');\r\n        \r\n        logger.error({ \r\n          error,\r\n          errorMessage,\r\n          isTimeout,\r\n          isNetworkError,\r\n          component: 'cdp-facilitator',\r\n          operation: 'verifyPayment',\r\n          requestId: (request as any).requestId,\r\n        }, 'CDP API request error');\r\n        \r\n        const errorDetails = {\r\n          error: errorMessage,\r\n          cdpResponse: undefined,\r\n          httpStatus: 500,\r\n          errorType: isTimeout ? 'timeout' : isNetworkError ? 'network' : 'unknown',\r\n        };\r\n\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: errorMessage,\r\n          errorDetails: errorDetails,\r\n        };\r\n      }\r\n    } catch (error) {\r\n      const latencyMs = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : String(error);\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      logger.error({ \r\n        error,\r\n        latencyMs,\r\n        errorMessage,\r\n        isTimeout,\r\n        component: 'cdp-facilitator',\r\n        operation: 'verifyPayment',\r\n        requestId: (request as any).requestId,\r\n      }, 'Verification error');\r\n\r\n      // Handle timeout errors\r\n      if (isTimeout) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: 'CDP_REQUEST_TIMEOUT',\r\n        };\r\n      }\r\n\r\n      // Handle network errors\r\n      if (error instanceof Error && (error.message.includes('fetch') || error.message.includes('network'))) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: 'CDP_NETWORK_ERROR',\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: error instanceof Error ? error.message : 'CDP_VERIFICATION_ERROR',\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify payment with retry logic and exponential backoff\r\n   * \r\n   * Retries on network errors and timeouts, but not on validation failures\r\n   */\r\n  async verifyPaymentWithRetry(\r\n    request: CDPVerifyRequest,\r\n    maxRetries: number = 3\r\n  ): Promise<CDPVerifyResponse> {\r\n    let lastError: Error | null = null;\r\n\r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const result = await this.verifyPayment(request);\r\n        \r\n        // If verification succeeded, return immediately\r\n        if (result.success && result.valid) {\r\n          return result;\r\n        }\r\n\r\n        // If verification failed due to validation (not network), don't retry\r\n        if (result.error && \r\n            !result.error.includes('timeout') && \r\n            !result.error.includes('network') &&\r\n            !result.error.includes('Unable to reach')) {\r\n          return result;\r\n        }\r\n\r\n        // If blocked by KYT/OFAC, don't retry\r\n        if (result.kytStatus === 'blocked' || result.ofacStatus === 'blocked') {\r\n          return result;\r\n        }\r\n\r\n        lastError = new Error(result.error || 'Verification failed');\r\n      } catch (error) {\r\n        lastError = error instanceof Error ? error : new Error(String(error));\r\n      }\r\n\r\n      // Exponential backoff: 100ms, 200ms, 400ms\r\n      if (attempt < maxRetries - 1) {\r\n        const delay = 100 * Math.pow(2, attempt);\r\n        logger.info({ attempt: attempt + 1, maxRetries, delay }, 'Retrying CDP verification');\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n      }\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      error: lastError?.message || 'Max retries exceeded',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Health check - verify CDP facilitator is accessible\r\n   * \r\n   * Note: CDP may not have a /health endpoint. This is a best-effort check.\r\n   * If it fails, it doesn't necessarily mean CDP is unavailable.\r\n   * \r\n   * IMPORTANT: If the facilitator URL domain doesn't resolve (DNS error),\r\n   * this will return unhealthy, but actual payment verification might\r\n   * still work if it uses a different endpoint.\r\n   */\r\n  async healthCheck(): Promise<{ healthy: boolean; error?: string }> {\r\n    try {\r\n      // For REST API calls, CDP requires request-specific JWT\r\n      // Generate JWT with the actual request details\r\n      const url = new URL(`${this.facilitatorUrl}/health`);\r\n      const token = await this.generateJWT('GET', url.pathname);\r\n      \r\n      const response = await fetch(url.toString(), {\r\n        method: 'GET',\r\n        headers: {\r\n          'Authorization': `Bearer ${token}`,\r\n          'X-CDP-API-Key': this.apiKeyId,\r\n        },\r\n        signal: AbortSignal.timeout(5000), // 5 second timeout\r\n      });\r\n\r\n      if (response.ok) {\r\n        return { healthy: true };\r\n      } else {\r\n        // 401/403 might mean auth is working but endpoint doesn't exist or keys are wrong\r\n        // 404 means endpoint doesn't exist (but auth might be working)\r\n        // For now, we'll consider it healthy if we get any response (not a network error)\r\n        if (response.status === 404) {\r\n          return { \r\n            healthy: true, \r\n            error: 'Health endpoint not found, but CDP is reachable' \r\n          };\r\n        }\r\n        \r\n        // Get error details from response if available\r\n        let errorMsg = `Health check failed: ${response.status} ${response.statusText}`;\r\n        try {\r\n          const errorBody = await response.text();\r\n          if (errorBody) {\r\n            errorMsg += ` - ${errorBody.substring(0, 200)}`;\r\n          }\r\n        } catch {\r\n          // Ignore parsing errors\r\n        }\r\n        \r\n        return { \r\n          healthy: false, \r\n          error: errorMsg\r\n        };\r\n      }\r\n    } catch (error) {\r\n      // Network errors or timeouts indicate CDP is not reachable\r\n      // This includes DNS resolution failures (domain doesn't exist)\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      \r\n      // If it's a DNS/network error, note that payment verification might still work\r\n      if (errorMessage.includes('fetch failed') || \r\n          errorMessage.includes('ENOTFOUND') || \r\n          errorMessage.includes('getaddrinfo')) {\r\n        return {\r\n          healthy: false,\r\n          error: `Facilitator URL not reachable (${errorMessage}). Payment verification may use a different endpoint.`,\r\n        };\r\n      }\r\n      \r\n      return {\r\n        healthy: false,\r\n        error: errorMessage,\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet cdpFacilitator: CDPFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton CDP facilitator instance\r\n */\r\nexport function getCDPFacilitator(): CDPFacilitator {\r\n  if (!cdpFacilitator) {\r\n    const apiKeyId = process.env.CDP_API_KEY_ID;\r\n    const facilitatorUrl = process.env.CDP_FACILITATOR_URL || 'https://api.cdp.coinbase.com/platform/v2/x402';\r\n\r\n    if (!apiKeyId) {\r\n      throw new Error('CDP_API_KEY_ID must be set in environment variables');\r\n    }\r\n\r\n    cdpFacilitator = new CDPFacilitator(apiKeyId, facilitatorUrl);\r\n  }\r\n  return cdpFacilitator;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1541, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/cdp-facilitator-adapter.ts"],"sourcesContent":["// =============================================================================\r\n// CDP FACILITATOR ADAPTER\r\n// =============================================================================\r\n// Adapter to make CDP facilitator conform to IFacilitator interface\r\n\r\nimport { BaseFacilitator, type IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorHealth, type FacilitatorConfig, type CAIPNetworkId, type CAIPAssetId } from './base-facilitator';\r\nimport { getCDPFacilitator, type CDPVerifyRequest, type CDPVerifyResponse } from '../cdp-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\n// Logger will be created per instance\r\n\r\n/**\r\n * CDP Facilitator Adapter\r\n * Wraps the existing CDP facilitator to implement IFacilitator interface\r\n */\r\nexport class CDPFacilitatorAdapter extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'cdp';\r\n  readonly name = 'Coinbase Developer Platform';\r\n  \r\n  readonly config: FacilitatorConfig = {\r\n    id: 'cdp',\r\n    name: 'Coinbase Developer Platform',\r\n    enabled: true,\r\n    priority: 1, // High priority (primary facilitator)\r\n    networks: ['base'], // Legacy: Currently Base only\r\n    networksCAIP: ['eip155:8453'], // CAIP-2: Base mainnet\r\n    assets: ['0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // Legacy: USDC on Base\r\n    assetsCAIP: ['eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // CAIP-19: USDC on Base\r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'], // CDP supports immediate settlement\r\n    healthCheckUrl: process.env.CDP_FACILITATOR_URL || 'https://api.cdp.coinbase.com/platform/v2/x402',\r\n    metadata: {\r\n      provider: 'Coinbase',\r\n      kytEnabled: true,\r\n      ofacEnabled: true,\r\n      complianceLevel: 'enterprise',\r\n    },\r\n  };\r\n\r\n  private cdpFacilitator = getCDPFacilitator();\r\n\r\n  /**\r\n   * Verify payment using CDP facilitator\r\n   * \r\n   * Note: This adapter expects the payment header to be passed as-is.\r\n   * The CDP facilitator will parse it internally. For a more complete\r\n   * adapter, we could parse the header here and extract the authorization,\r\n   * but for now we rely on CDP's internal parsing.\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Import payment header parser to extract authorization\r\n      const { parseAndVerifyPaymentHeader } = await import('../payment-header-parser');\r\n      const parsed = await parseAndVerifyPaymentHeader(payment);\r\n\r\n      if (!parsed.valid || !parsed.payment) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parsed.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Build CDP request with parsed payment data\r\n      const cdpRequest: CDPVerifyRequest = {\r\n        payment,\r\n        paymentPayload: {\r\n          x402Version: 1,\r\n          scheme: 'x402' as const,\r\n          network: parsed.payment.network || requirements.network,\r\n          payload: {\r\n            signature: parsed.payment.signature,\r\n            authorization: parsed.payment.authorization,\r\n          },\r\n        },\r\n        paymentRequirements: {\r\n          scheme: requirements.scheme,\r\n          network: requirements.network,\r\n          maxAmountRequired: requirements.maxAmountRequired,\r\n          resource: requirements.resource,\r\n          description: requirements.description || '',\r\n          mimeType: requirements.mimeType || 'application/json',\r\n          payTo: requirements.payTo,\r\n          maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n          asset: requirements.asset,\r\n        },\r\n      };\r\n\r\n      // Verify with CDP\r\n      const result = await this.cdpFacilitator.verifyPaymentWithRetry(cdpRequest);\r\n\r\n      return {\r\n        success: result.success,\r\n        valid: result.valid,\r\n        transactionHash: result.transactionHash,\r\n        kytStatus: result.kytStatus,\r\n        ofacStatus: result.ofacStatus,\r\n        error: result.error,\r\n        errorDetails: result.errorDetails,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      this.getLogger().error({ error, requirements }, 'CDP verification error');\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: error instanceof Error ? error.message : 'Verification failed',\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get CDP facilitator health\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    try {\r\n      const start = Date.now();\r\n      const health = await this.cdpFacilitator.healthCheck();\r\n      const latency = Date.now() - start;\r\n\r\n      return {\r\n        healthy: health.healthy,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        healthy: false,\r\n        lastChecked: new Date().toISOString(),\r\n        error: error instanceof Error ? error.message : 'Health check failed',\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing (CDP doesn't charge fees, but we track gas costs)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    if (network === 'base' && asset === '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913') {\r\n      return {\r\n        network: 'base',\r\n        asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n        baseFee: '0', // CDP doesn't charge fees\r\n        percentageFee: 0,\r\n        estimatedGas: '21000', // Typical gas for USDC transfer\r\n        currency: 'USDC',\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get CDP facilitator adapter instance\r\n */\r\nlet cdpAdapter: CDPFacilitatorAdapter | null = null;\r\n\r\nexport function getCDPFacilitatorAdapter(): CDPFacilitatorAdapter {\r\n  if (!cdpAdapter) {\r\n    cdpAdapter = new CDPFacilitatorAdapter();\r\n  }\r\n  return cdpAdapter;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1739, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/adapters/sqlite-adapter.ts"],"sourcesContent":["// =============================================================================\r\n// SQLITE ADAPTER\r\n// =============================================================================\r\n// SQLite implementation of DatabaseAdapter\r\n// Wraps existing better-sqlite3 code for adapter pattern\r\n\r\nimport Database from 'better-sqlite3';\r\nimport path from 'path';\r\nimport fs from 'fs';\r\nimport type { DatabaseAdapter } from './base-adapter';\r\nimport type { MeteredEndpoint, Payment, UsageLog } from '../metered-endpoints';\r\n\r\n// Re-export the schema initialization from metered-endpoints\r\nfunction initializeSchema(db: Database.Database) {\r\n  // Endpoints table\r\n  db.exec(`\r\n    CREATE TABLE IF NOT EXISTS endpoints (\r\n      id TEXT PRIMARY KEY,\r\n      name TEXT NOT NULL,\r\n      description TEXT,\r\n      upstream_url TEXT NOT NULL,\r\n      price TEXT NOT NULL,\r\n      network TEXT NOT NULL DEFAULT 'base',\r\n      token_address TEXT NOT NULL,\r\n      token_symbol TEXT NOT NULL DEFAULT 'USDC',\r\n      chain_id INTEGER NOT NULL DEFAULT 8453,\r\n      recipient_address TEXT,\r\n      status TEXT NOT NULL DEFAULT 'active',\r\n      created_at TEXT NOT NULL,\r\n      updated_at TEXT NOT NULL,\r\n      created_by TEXT\r\n    )\r\n  `);\r\n\r\n  // Migration: Add recipient_address column if it doesn't exist\r\n  try {\r\n    const tableInfo = db.prepare(\"PRAGMA table_info(endpoints)\").all() as Array<{ name: string }>;\r\n    const hasRecipientAddress = tableInfo.some(col => col.name === 'recipient_address');\r\n    \r\n    if (!hasRecipientAddress) {\r\n      db.exec(`ALTER TABLE endpoints ADD COLUMN recipient_address TEXT`);\r\n      console.log('[db] Added recipient_address column');\r\n    }\r\n  } catch (error: any) {\r\n    if (!error.message?.includes('duplicate column name') && !error.message?.includes('no such column')) {\r\n      console.warn('[db] Migration warning:', error.message);\r\n    }\r\n  }\r\n\r\n  // Payments table\r\n  db.exec(`\r\n    CREATE TABLE IF NOT EXISTS payments (\r\n      id TEXT PRIMARY KEY,\r\n      endpoint_id TEXT NOT NULL,\r\n      tx_hash TEXT NOT NULL UNIQUE,\r\n      from_address TEXT NOT NULL,\r\n      to_address TEXT NOT NULL,\r\n      amount TEXT NOT NULL,\r\n      token_address TEXT NOT NULL,\r\n      network TEXT NOT NULL,\r\n      verified_at TEXT NOT NULL,\r\n      kyt_status TEXT,\r\n      ofac_status TEXT,\r\n      facilitator TEXT NOT NULL DEFAULT 'cdp',\r\n      FOREIGN KEY (endpoint_id) REFERENCES endpoints(id)\r\n    )\r\n  `);\r\n\r\n  // Usage logs table\r\n  db.exec(`\r\n    CREATE TABLE IF NOT EXISTS usage_logs (\r\n      id TEXT PRIMARY KEY,\r\n      endpoint_id TEXT NOT NULL,\r\n      payment_id TEXT,\r\n      timestamp TEXT NOT NULL,\r\n      method TEXT NOT NULL,\r\n      path TEXT NOT NULL,\r\n      status_code INTEGER NOT NULL,\r\n      response_time INTEGER NOT NULL,\r\n      units INTEGER NOT NULL DEFAULT 1,\r\n      ip_address TEXT,\r\n      user_agent TEXT,\r\n      FOREIGN KEY (endpoint_id) REFERENCES endpoints(id),\r\n      FOREIGN KEY (payment_id) REFERENCES payments(id)\r\n    )\r\n  `);\r\n\r\n  // API keys table\r\n  db.exec(`\r\n    CREATE TABLE IF NOT EXISTS api_keys (\r\n      id TEXT PRIMARY KEY,\r\n      key_hash TEXT UNIQUE NOT NULL,\r\n      name TEXT NOT NULL,\r\n      role TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('admin', 'user', 'read-only')),\r\n      user_id TEXT,\r\n      rate_limit INTEGER DEFAULT 1000,\r\n      last_used_at TEXT,\r\n      last_used_ip TEXT,\r\n      expires_at TEXT,\r\n      x402_demo_calls_used INTEGER DEFAULT 0,\r\n      x402_demo_calls_limit INTEGER DEFAULT 200,\r\n      x402_demo_amount_used TEXT DEFAULT '0',\r\n      x402_demo_amount_limit TEXT DEFAULT '1000000',\r\n      created_at TEXT NOT NULL,\r\n      updated_at TEXT NOT NULL,\r\n      revoked_at TEXT\r\n    )\r\n  `);\r\n\r\n  // Indexes\r\n  db.exec(`\r\n    CREATE INDEX IF NOT EXISTS idx_payments_endpoint_id ON payments(endpoint_id);\r\n    CREATE INDEX IF NOT EXISTS idx_payments_tx_hash ON payments(tx_hash);\r\n    CREATE INDEX IF NOT EXISTS idx_payments_verified_at ON payments(verified_at);\r\n    CREATE INDEX IF NOT EXISTS idx_usage_logs_endpoint_id ON usage_logs(endpoint_id);\r\n    CREATE INDEX IF NOT EXISTS idx_usage_logs_timestamp ON usage_logs(timestamp);\r\n    CREATE INDEX IF NOT EXISTS idx_usage_logs_payment_id ON usage_logs(payment_id);\r\n    CREATE INDEX IF NOT EXISTS idx_endpoints_status ON endpoints(status);\r\n    CREATE UNIQUE INDEX IF NOT EXISTS idx_api_keys_key_hash ON api_keys(key_hash);\r\n    CREATE INDEX IF NOT EXISTS idx_api_keys_user_id ON api_keys(user_id);\r\n    CREATE INDEX IF NOT EXISTS idx_api_keys_role ON api_keys(role);\r\n    CREATE INDEX IF NOT EXISTS idx_api_keys_revoked_at ON api_keys(revoked_at);\r\n  `);\r\n}\r\n\r\nexport class SqliteAdapter implements DatabaseAdapter {\r\n  private db: Database.Database;\r\n\r\n  constructor(dbPath?: string) {\r\n    const DB_PATH = dbPath || path.join(process.cwd(), 'data', 'metered-endpoints.db');\r\n    \r\n    // Ensure data directory exists\r\n    if (!fs.existsSync(path.dirname(DB_PATH))) {\r\n      fs.mkdirSync(path.dirname(DB_PATH), { recursive: true });\r\n    }\r\n    \r\n    this.db = new Database(DB_PATH);\r\n    this.db.pragma('journal_mode = WAL');\r\n    \r\n    // Initialize schema\r\n    initializeSchema(this.db);\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    try {\r\n      this.db.prepare('SELECT 1').get();\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // =============================================================================\r\n  // ENDPOINTS\r\n  // =============================================================================\r\n\r\n  async createEndpoint(endpoint: Omit<MeteredEndpoint, 'id' | 'createdAt' | 'updatedAt'> & { id?: string }): Promise<MeteredEndpoint> {\r\n    const id = endpoint.id || `ep_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const now = new Date().toISOString();\r\n\r\n    this.db.prepare(`\r\n      INSERT INTO endpoints (\r\n        id, name, description, upstream_url, price, network, token_address,\r\n        token_symbol, chain_id, recipient_address, status, created_at, updated_at, created_by\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `).run(\r\n      id,\r\n      endpoint.name,\r\n      endpoint.description || null,\r\n      endpoint.upstreamUrl,\r\n      endpoint.price,\r\n      endpoint.network,\r\n      endpoint.tokenAddress,\r\n      endpoint.tokenSymbol,\r\n      endpoint.chainId,\r\n      endpoint.recipientAddress,\r\n      endpoint.status,\r\n      now,\r\n      now,\r\n      endpoint.createdBy || null\r\n    );\r\n\r\n    return Promise.resolve({\r\n      ...endpoint,\r\n      id,\r\n      createdAt: now,\r\n      updatedAt: now,\r\n    });\r\n  }\r\n\r\n  async getEndpoint(endpointId: string): Promise<MeteredEndpoint | null> {\r\n    const row = this.db.prepare('SELECT * FROM endpoints WHERE id = ? AND status != ?').get(endpointId, 'deleted') as any;\r\n    if (!row) return Promise.resolve(null);\r\n    return Promise.resolve(this.mapRowToEndpoint(row));\r\n  }\r\n\r\n  async listEndpoints(filters?: { status?: string; createdBy?: string }): Promise<MeteredEndpoint[]> {\r\n    let query = 'SELECT * FROM endpoints WHERE status != ?';\r\n    const params: any[] = ['deleted'];\r\n\r\n    if (filters?.status) {\r\n      query += ' AND status = ?';\r\n      params.push(filters.status);\r\n    }\r\n\r\n    if (filters?.createdBy) {\r\n      query += ' AND created_by = ?';\r\n      params.push(filters.createdBy);\r\n    }\r\n\r\n    query += ' ORDER BY created_at DESC';\r\n\r\n    const rows = this.db.prepare(query).all(...params) as any[];\r\n    return Promise.resolve(rows.map(row => this.mapRowToEndpoint(row)));\r\n  }\r\n\r\n  async updateEndpoint(endpointId: string, updates: Partial<MeteredEndpoint>): Promise<MeteredEndpoint | null> {\r\n    const allowedFields = [\r\n      'name', 'description', 'upstreamUrl', 'price', 'network',\r\n      'tokenAddress', 'tokenSymbol', 'chainId', 'recipientAddress', 'status'\r\n    ];\r\n\r\n    const setClauses: string[] = [];\r\n    const values: any[] = [];\r\n\r\n    for (const [key, value] of Object.entries(updates)) {\r\n      if (allowedFields.includes(key) && value !== undefined) {\r\n        const dbKey = key === 'upstreamUrl' ? 'upstream_url' :\r\n                     key === 'tokenAddress' ? 'token_address' :\r\n                     key === 'tokenSymbol' ? 'token_symbol' :\r\n                     key === 'chainId' ? 'chain_id' :\r\n                     key === 'recipientAddress' ? 'recipient_address' :\r\n                     key === 'createdAt' ? 'created_at' :\r\n                     key === 'updatedAt' ? 'updated_at' :\r\n                     key === 'createdBy' ? 'created_by' : key;\r\n        setClauses.push(`${dbKey} = ?`);\r\n        values.push(value);\r\n      }\r\n    }\r\n\r\n    if (setClauses.length === 0) {\r\n      return this.getEndpoint(endpointId);\r\n    }\r\n\r\n    setClauses.push('updated_at = ?');\r\n    values.push(new Date().toISOString());\r\n    values.push(endpointId);\r\n\r\n    this.db.prepare(`UPDATE endpoints SET ${setClauses.join(', ')} WHERE id = ?`).run(...values);\r\n    return this.getEndpoint(endpointId);\r\n  }\r\n\r\n  async deleteEndpoint(endpointId: string): Promise<boolean> {\r\n    const result = this.db.prepare('UPDATE endpoints SET status = ?, updated_at = ? WHERE id = ?').run(\r\n      'deleted',\r\n      new Date().toISOString(),\r\n      endpointId\r\n    );\r\n    return Promise.resolve(result.changes > 0);\r\n  }\r\n\r\n  // =============================================================================\r\n  // PAYMENTS\r\n  // =============================================================================\r\n\r\n  async createPayment(payment: Omit<Payment, 'id' | 'verifiedAt'>): Promise<Payment> {\r\n    const id = `pay_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const verifiedAt = new Date().toISOString();\r\n\r\n    this.db.prepare(`\r\n      INSERT INTO payments (\r\n        id, endpoint_id, tx_hash, from_address, to_address, amount,\r\n        token_address, network, verified_at, kyt_status, ofac_status, facilitator\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `).run(\r\n      id,\r\n      payment.endpointId,\r\n      payment.txHash,\r\n      payment.fromAddress,\r\n      payment.toAddress,\r\n      payment.amount,\r\n      payment.tokenAddress,\r\n      payment.network,\r\n      verifiedAt,\r\n      payment.kytStatus || null,\r\n      payment.ofacStatus || null,\r\n      payment.facilitator\r\n    );\r\n\r\n    return Promise.resolve({\r\n      ...payment,\r\n      id,\r\n      verifiedAt,\r\n    });\r\n  }\r\n\r\n  async getPayment(paymentId: string): Promise<Payment | null> {\r\n    const row = this.db.prepare('SELECT * FROM payments WHERE id = ?').get(paymentId) as any;\r\n    if (!row) return Promise.resolve(null);\r\n    return Promise.resolve(this.mapRowToPayment(row));\r\n  }\r\n\r\n  async getPaymentByTxHash(txHash: string): Promise<Payment | null> {\r\n    const row = this.db.prepare('SELECT * FROM payments WHERE tx_hash = ?').get(txHash) as any;\r\n    if (!row) return Promise.resolve(null);\r\n    return Promise.resolve(this.mapRowToPayment(row));\r\n  }\r\n\r\n  async listPayments(filters?: { endpointId?: string; fromAddress?: string }): Promise<Payment[]> {\r\n    let query = 'SELECT * FROM payments WHERE 1=1';\r\n    const params: any[] = [];\r\n\r\n    if (filters?.endpointId) {\r\n      query += ' AND endpoint_id = ?';\r\n      params.push(filters.endpointId);\r\n    }\r\n\r\n    if (filters?.fromAddress) {\r\n      query += ' AND from_address = ?';\r\n      params.push(filters.fromAddress);\r\n    }\r\n\r\n    query += ' ORDER BY verified_at DESC';\r\n\r\n    const rows = this.db.prepare(query).all(...params) as any[];\r\n    return Promise.resolve(rows.map(row => this.mapRowToPayment(row)));\r\n  }\r\n\r\n  async getPaymentsForEndpoint(endpointId: string, limit: number = 100): Promise<Payment[]> {\r\n    const rows = this.db.prepare(\r\n      'SELECT * FROM payments WHERE endpoint_id = ? ORDER BY verified_at DESC LIMIT ?'\r\n    ).all(endpointId, limit) as any[];\r\n    return Promise.resolve(rows.map(row => this.mapRowToPayment(row)));\r\n  }\r\n\r\n  // =============================================================================\r\n  // USAGE LOGS\r\n  // =============================================================================\r\n\r\n  async createUsageLog(log: Omit<UsageLog, 'id' | 'timestamp'>): Promise<UsageLog> {\r\n    const id = `log_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const timestamp = new Date().toISOString();\r\n\r\n    // Add tracing columns if they don't exist (migration support)\r\n    try {\r\n      this.db.exec(`\r\n        ALTER TABLE usage_logs ADD COLUMN conversation_id TEXT;\r\n        ALTER TABLE usage_logs ADD COLUMN agent_id TEXT;\r\n        ALTER TABLE usage_logs ADD COLUMN x402_tx_hash TEXT;\r\n        ALTER TABLE usage_logs ADD COLUMN failure_code TEXT;\r\n      `);\r\n    } catch (e: any) {\r\n      // Columns may already exist, ignore error\r\n      if (!e.message?.includes('duplicate column')) {\r\n        console.warn('[SQLite] Migration warning:', e.message);\r\n      }\r\n    }\r\n\r\n    try {\r\n      this.db.prepare(`\r\n        INSERT INTO usage_logs (\r\n          id, endpoint_id, payment_id, timestamp, method, path,\r\n          status_code, response_time, units, ip_address, user_agent,\r\n          conversation_id, agent_id, x402_tx_hash, failure_code\r\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n      `).run(\r\n        id,\r\n        log.endpointId,\r\n        log.paymentId || null,\r\n        timestamp,\r\n        log.method,\r\n        log.path,\r\n        log.statusCode,\r\n        log.responseTime,\r\n        log.units,\r\n        log.ipAddress || null,\r\n        log.userAgent || null,\r\n        log.conversationId || null,\r\n        log.agentId || null,\r\n        log.x402TxHash || null,\r\n        log.failureCode || null\r\n      );\r\n    } catch (dbError: any) {\r\n      // Log full error details for debugging\r\n      const errorInfo = {\r\n        message: dbError.message || String(dbError),\r\n        code: dbError.code || 'unknown',\r\n        errno: dbError.errno,\r\n        sql: dbError.sql,\r\n        endpointId: log.endpointId,\r\n        table: 'usage_logs',\r\n      };\r\n      \r\n      console.error('[SQLite] Insert error details:', JSON.stringify(errorInfo, null, 2));\r\n      \r\n      // Re-throw with more context\r\n      throw new Error(\r\n        `SQLite insert failed: ${dbError.message || String(dbError)}. ` +\r\n        `Table: usage_logs, EndpointId: ${log.endpointId}, ` +\r\n        `Error code: ${dbError.code || 'unknown'}, ` +\r\n        `SQL: ${dbError.sql || 'N/A'}`\r\n      );\r\n    }\r\n\r\n    return Promise.resolve({\r\n      ...log,\r\n      id,\r\n      timestamp,\r\n    });\r\n  }\r\n\r\n  async listUsageLogs(filters?: { endpointId?: string; paymentId?: string }): Promise<UsageLog[]> {\r\n    let query = 'SELECT * FROM usage_logs WHERE 1=1';\r\n    const params: any[] = [];\r\n\r\n    if (filters?.endpointId) {\r\n      query += ' AND endpoint_id = ?';\r\n      params.push(filters.endpointId);\r\n    }\r\n\r\n    if (filters?.paymentId) {\r\n      query += ' AND payment_id = ?';\r\n      params.push(filters.paymentId);\r\n    }\r\n\r\n    query += ' ORDER BY timestamp DESC LIMIT 1000';\r\n\r\n    const rows = this.db.prepare(query).all(...params) as any[];\r\n    return Promise.resolve(rows.map(row => this.mapRowToUsageLog(row)));\r\n  }\r\n\r\n  async getUsageStats(endpointId: string, startDate?: string, endDate?: string): Promise<{\r\n    totalRequests: number;\r\n    totalPayments: number;\r\n    totalRevenue: string;\r\n    averageResponseTime: number;\r\n  }> {\r\n    let query = `\r\n      SELECT\r\n        COUNT(*) as total_requests,\r\n        COUNT(DISTINCT payment_id) as total_payments,\r\n        COALESCE(SUM(CAST(p.amount AS INTEGER)), 0) as total_revenue,\r\n        COALESCE(AVG(response_time), 0) as avg_response_time\r\n      FROM usage_logs ul\r\n      LEFT JOIN payments p ON ul.payment_id = p.id\r\n      WHERE ul.endpoint_id = ?\r\n    `;\r\n    const params: any[] = [endpointId];\r\n\r\n    if (startDate) {\r\n      query += ' AND ul.timestamp >= ?';\r\n      params.push(startDate);\r\n    }\r\n\r\n    if (endDate) {\r\n      query += ' AND ul.timestamp <= ?';\r\n      params.push(endDate);\r\n    }\r\n\r\n    const row = this.db.prepare(query).get(...params) as any;\r\n\r\n    return Promise.resolve({\r\n      totalRequests: row.total_requests || 0,\r\n      totalPayments: row.total_payments || 0,\r\n      totalRevenue: row.total_revenue?.toString() || '0',\r\n      averageResponseTime: row.avg_response_time || 0,\r\n    });\r\n  }\r\n\r\n  // =============================================================================\r\n  // HELPERS\r\n  // =============================================================================\r\n\r\n  private mapRowToEndpoint(row: any): MeteredEndpoint {\r\n    return {\r\n      id: row.id,\r\n      name: row.name,\r\n      description: row.description,\r\n      upstreamUrl: row.upstream_url,\r\n      price: row.price,\r\n      network: row.network,\r\n      tokenAddress: row.token_address,\r\n      tokenSymbol: row.token_symbol,\r\n      chainId: row.chain_id,\r\n      recipientAddress: row.recipient_address,\r\n      status: row.status,\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      createdBy: row.created_by,\r\n    };\r\n  }\r\n\r\n  private mapRowToPayment(row: any): Payment {\r\n    return {\r\n      id: row.id,\r\n      endpointId: row.endpoint_id,\r\n      txHash: row.tx_hash,\r\n      fromAddress: row.from_address,\r\n      toAddress: row.to_address,\r\n      amount: row.amount,\r\n      tokenAddress: row.token_address,\r\n      network: row.network,\r\n      verifiedAt: row.verified_at,\r\n      kytStatus: row.kyt_status,\r\n      ofacStatus: row.ofac_status,\r\n      facilitator: row.facilitator,\r\n    };\r\n  }\r\n\r\n  private mapRowToUsageLog(row: any): UsageLog {\r\n    return {\r\n      id: row.id,\r\n      endpointId: row.endpoint_id,\r\n      paymentId: row.payment_id,\r\n      timestamp: row.timestamp,\r\n      method: row.method,\r\n      path: row.path,\r\n      statusCode: row.status_code,\r\n      responseTime: row.response_time,\r\n      units: row.units,\r\n      ipAddress: row.ip_address,\r\n      userAgent: row.user_agent,\r\n      conversationId: row.conversation_id,\r\n      agentId: row.agent_id,\r\n      x402TxHash: row.x402_tx_hash,\r\n      failureCode: row.failure_code,\r\n    };\r\n  }\r\n\r\n  // =============================================================================\r\n  // API KEYS\r\n  // =============================================================================\r\n\r\n  async createApiKey(apiKey: { id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; expiresAt?: string; createdAt: string; updatedAt: string }): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }> {\r\n    this.db.prepare(\r\n      `INSERT INTO api_keys (id, key_hash, name, role, user_id, rate_limit, expires_at, x402_demo_calls_used, x402_demo_calls_limit, x402_demo_amount_used, x402_demo_amount_limit, created_at, updated_at)\r\n       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\r\n    ).run(\r\n      apiKey.id, apiKey.keyHash, apiKey.name, apiKey.role, apiKey.userId || null,\r\n      apiKey.rateLimit, apiKey.expiresAt || null,\r\n      apiKey.x402DemoCallsUsed || 0, apiKey.x402DemoCallsLimit || 200,\r\n      apiKey.x402DemoAmountUsed || '0', apiKey.x402DemoAmountLimit || '1000000',\r\n      apiKey.createdAt, apiKey.updatedAt\r\n    );\r\n    return this.findApiKeyByHash(apiKey.keyHash) as Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }>;\r\n  }\r\n\r\n  async findApiKeyByHash(keyHash: string): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string } | null> {\r\n    const row = this.db.prepare(\r\n      `SELECT * FROM api_keys WHERE key_hash = ? AND revoked_at IS NULL`\r\n    ).get(keyHash) as any;\r\n    if (!row) return null;\r\n    return {\r\n      id: row.id,\r\n      keyHash: row.key_hash,\r\n      name: row.name,\r\n      role: row.role,\r\n      userId: row.user_id,\r\n      rateLimit: row.rate_limit,\r\n      lastUsedAt: row.last_used_at,\r\n      lastUsedIp: row.last_used_ip,\r\n      expiresAt: row.expires_at,\r\n      x402DemoCallsUsed: row.x402_demo_calls_used || 0,\r\n      x402DemoCallsLimit: row.x402_demo_calls_limit || 200,\r\n      x402DemoAmountUsed: row.x402_demo_amount_used || '0',\r\n      x402DemoAmountLimit: row.x402_demo_amount_limit || '1000000',\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      revokedAt: row.revoked_at,\r\n    };\r\n  }\r\n\r\n  async updateApiKeyLastUsed(keyId: string, ipAddress?: string): Promise<void> {\r\n    const now = new Date().toISOString();\r\n    this.db.prepare(\r\n      `UPDATE api_keys SET last_used_at = ?, last_used_ip = ?, updated_at = ? WHERE id = ?`\r\n    ).run(now, ipAddress || null, now, keyId);\r\n  }\r\n\r\n  async updateApiKeyX402DemoAllowance(keyId: string, callsUsed: number, amountUsed: string): Promise<void> {\r\n    const now = new Date().toISOString();\r\n    this.db.prepare(\r\n      `UPDATE api_keys SET x402_demo_calls_used = ?, x402_demo_amount_used = ?, updated_at = ? WHERE id = ?`\r\n    ).run(callsUsed, amountUsed, now, keyId);\r\n  }\r\n\r\n  async updateApiKeyX402DemoLimits(keyId: string, callsLimit?: number, amountLimit?: string): Promise<void> {\r\n    const now = new Date().toISOString();\r\n    if (callsLimit !== undefined && amountLimit !== undefined) {\r\n      this.db.prepare(\r\n        `UPDATE api_keys SET x402_demo_calls_limit = ?, x402_demo_amount_limit = ?, updated_at = ? WHERE id = ?`\r\n      ).run(callsLimit, amountLimit, now, keyId);\r\n    } else if (callsLimit !== undefined) {\r\n      this.db.prepare(\r\n        `UPDATE api_keys SET x402_demo_calls_limit = ?, updated_at = ? WHERE id = ?`\r\n      ).run(callsLimit, now, keyId);\r\n    } else if (amountLimit !== undefined) {\r\n      this.db.prepare(\r\n        `UPDATE api_keys SET x402_demo_amount_limit = ?, updated_at = ? WHERE id = ?`\r\n      ).run(amountLimit, now, keyId);\r\n    }\r\n  }\r\n\r\n  async revokeApiKey(keyId: string): Promise<boolean> {\r\n    const now = new Date().toISOString();\r\n    const result = this.db.prepare(\r\n      `UPDATE api_keys SET revoked_at = ?, updated_at = ? WHERE id = ? AND revoked_at IS NULL`\r\n    ).run(now, now, keyId);\r\n    return result.changes > 0;\r\n  }\r\n\r\n  async listApiKeys(userId?: string): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }[]> {\r\n    let query = `SELECT * FROM api_keys WHERE revoked_at IS NULL`;\r\n    const params: any[] = [];\r\n    if (userId) {\r\n      query += ` AND user_id = ?`;\r\n      params.push(userId);\r\n    }\r\n    query += ` ORDER BY created_at DESC`;\r\n    const rows = this.db.prepare(query).all(...params) as any[];\r\n    return Promise.resolve(rows.map((row) => ({\r\n      id: row.id,\r\n      keyHash: row.key_hash,\r\n      name: row.name,\r\n      role: row.role,\r\n      userId: row.user_id,\r\n      rateLimit: row.rate_limit,\r\n      lastUsedAt: row.last_used_at,\r\n      lastUsedIp: row.last_used_ip,\r\n      expiresAt: row.expires_at,\r\n      x402DemoCallsUsed: row.x402_demo_calls_used || 0,\r\n      x402DemoCallsLimit: row.x402_demo_calls_limit || 200,\r\n      x402DemoAmountUsed: row.x402_demo_amount_used || '0',\r\n      x402DemoAmountLimit: row.x402_demo_amount_limit || '1000000',\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      revokedAt: row.revoked_at,\r\n    })));\r\n  }\r\n\r\n  close(): void {\r\n    this.db.close();\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,iBAAiB;AACjB,gFAAgF;AAChF,2CAA2C;AAC3C,yDAAyD;;;;;AAEzD;AACA;AACA;;;;AAIA,6DAA6D;AAC7D,SAAS,iBAAiB,EAAqB;IAC7C,kBAAkB;IAClB,GAAG,IAAI,CAAC,CAAC;;;;;;;;;;;;;;;;;EAiBT,CAAC;IAED,8DAA8D;IAC9D,IAAI;QACF,MAAM,YAAY,GAAG,OAAO,CAAC,gCAAgC,GAAG;QAChE,MAAM,sBAAsB,UAAU,IAAI,CAAC,CAAA,MAAO,IAAI,IAAI,KAAK;QAE/D,IAAI,CAAC,qBAAqB;YACxB,GAAG,IAAI,CAAC,CAAC,uDAAuD,CAAC;YACjE,QAAQ,GAAG,CAAC;QACd;IACF,EAAE,OAAO,OAAY;QACnB,IAAI,CAAC,MAAM,OAAO,EAAE,SAAS,4BAA4B,CAAC,MAAM,OAAO,EAAE,SAAS,mBAAmB;YACnG,QAAQ,IAAI,CAAC,2BAA2B,MAAM,OAAO;QACvD;IACF;IAEA,iBAAiB;IACjB,GAAG,IAAI,CAAC,CAAC;;;;;;;;;;;;;;;;EAgBT,CAAC;IAED,mBAAmB;IACnB,GAAG,IAAI,CAAC,CAAC;;;;;;;;;;;;;;;;EAgBT,CAAC;IAED,iBAAiB;IACjB,GAAG,IAAI,CAAC,CAAC;;;;;;;;;;;;;;;;;;;EAmBT,CAAC;IAED,UAAU;IACV,GAAG,IAAI,CAAC,CAAC;;;;;;;;;;;;EAYT,CAAC;AACH;AAEO,MAAM;IACH,GAAsB;IAE9B,YAAY,MAAe,CAAE;QAC3B,MAAM,UAAU,UAAU,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ;QAE3D,+BAA+B;QAC/B,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,4GAAI,CAAC,OAAO,CAAC,WAAW;YACzC,wGAAE,CAAC,SAAS,CAAC,4GAAI,CAAC,OAAO,CAAC,UAAU;gBAAE,WAAW;YAAK;QACxD;QAEA,IAAI,CAAC,EAAE,GAAG,IAAI,sIAAQ,CAAC;QACvB,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC;QAEf,oBAAoB;QACpB,iBAAiB,IAAI,CAAC,EAAE;IAC1B;IAEA,MAAM,cAAgC;QACpC,IAAI;YACF,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,YAAY,GAAG;YAC/B,OAAO;QACT,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,gFAAgF;IAChF,YAAY;IACZ,gFAAgF;IAEhF,MAAM,eAAe,QAAmF,EAA4B;QAClI,MAAM,KAAK,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,IAAI;QAC1F,MAAM,MAAM,IAAI,OAAO,WAAW;QAElC,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;;;;;IAKjB,CAAC,EAAE,GAAG,CACJ,IACA,SAAS,IAAI,EACb,SAAS,WAAW,IAAI,MACxB,SAAS,WAAW,EACpB,SAAS,KAAK,EACd,SAAS,OAAO,EAChB,SAAS,YAAY,EACrB,SAAS,WAAW,EACpB,SAAS,OAAO,EAChB,SAAS,gBAAgB,EACzB,SAAS,MAAM,EACf,KACA,KACA,SAAS,SAAS,IAAI;QAGxB,OAAO,QAAQ,OAAO,CAAC;YACrB,GAAG,QAAQ;YACX;YACA,WAAW;YACX,WAAW;QACb;IACF;IAEA,MAAM,YAAY,UAAkB,EAAmC;QACrE,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,wDAAwD,GAAG,CAAC,YAAY;QACpG,IAAI,CAAC,KAAK,OAAO,QAAQ,OAAO,CAAC;QACjC,OAAO,QAAQ,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC;IAC/C;IAEA,MAAM,cAAc,OAAiD,EAA8B;QACjG,IAAI,QAAQ;QACZ,MAAM,SAAgB;YAAC;SAAU;QAEjC,IAAI,SAAS,QAAQ;YACnB,SAAS;YACT,OAAO,IAAI,CAAC,QAAQ,MAAM;QAC5B;QAEA,IAAI,SAAS,WAAW;YACtB,SAAS;YACT,OAAO,IAAI,CAAC,QAAQ,SAAS;QAC/B;QAEA,SAAS;QAET,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI;QAC3C,OAAO,QAAQ,OAAO,CAAC,KAAK,GAAG,CAAC,CAAA,MAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/D;IAEA,MAAM,eAAe,UAAkB,EAAE,OAAiC,EAAmC;QAC3G,MAAM,gBAAgB;YACpB;YAAQ;YAAe;YAAe;YAAS;YAC/C;YAAgB;YAAe;YAAW;YAAoB;SAC/D;QAED,MAAM,aAAuB,EAAE;QAC/B,MAAM,SAAgB,EAAE;QAExB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,SAAU;YAClD,IAAI,cAAc,QAAQ,CAAC,QAAQ,UAAU,WAAW;gBACtD,MAAM,QAAQ,QAAQ,gBAAgB,iBACzB,QAAQ,iBAAiB,kBACzB,QAAQ,gBAAgB,iBACxB,QAAQ,YAAY,aACpB,QAAQ,qBAAqB,sBAC7B,QAAQ,cAAc,eACtB,QAAQ,cAAc,eACtB,QAAQ,cAAc,eAAe;gBAClD,WAAW,IAAI,CAAC,GAAG,MAAM,IAAI,CAAC;gBAC9B,OAAO,IAAI,CAAC;YACd;QACF;QAEA,IAAI,WAAW,MAAM,KAAK,GAAG;YAC3B,OAAO,IAAI,CAAC,WAAW,CAAC;QAC1B;QAEA,WAAW,IAAI,CAAC;QAChB,OAAO,IAAI,CAAC,IAAI,OAAO,WAAW;QAClC,OAAO,IAAI,CAAC;QAEZ,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,qBAAqB,EAAE,WAAW,IAAI,CAAC,MAAM,aAAa,CAAC,EAAE,GAAG,IAAI;QACrF,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B;IAEA,MAAM,eAAe,UAAkB,EAAoB;QACzD,MAAM,SAAS,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,gEAAgE,GAAG,CAChG,WACA,IAAI,OAAO,WAAW,IACtB;QAEF,OAAO,QAAQ,OAAO,CAAC,OAAO,OAAO,GAAG;IAC1C;IAEA,gFAAgF;IAChF,WAAW;IACX,gFAAgF;IAEhF,MAAM,cAAc,OAA2C,EAAoB;QACjF,MAAM,KAAK,CAAC,IAAI,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,IAAI;QAC5E,MAAM,aAAa,IAAI,OAAO,WAAW;QAEzC,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;;;;;IAKjB,CAAC,EAAE,GAAG,CACJ,IACA,QAAQ,UAAU,EAClB,QAAQ,MAAM,EACd,QAAQ,WAAW,EACnB,QAAQ,SAAS,EACjB,QAAQ,MAAM,EACd,QAAQ,YAAY,EACpB,QAAQ,OAAO,EACf,YACA,QAAQ,SAAS,IAAI,MACrB,QAAQ,UAAU,IAAI,MACtB,QAAQ,WAAW;QAGrB,OAAO,QAAQ,OAAO,CAAC;YACrB,GAAG,OAAO;YACV;YACA;QACF;IACF;IAEA,MAAM,WAAW,SAAiB,EAA2B;QAC3D,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,uCAAuC,GAAG,CAAC;QACvE,IAAI,CAAC,KAAK,OAAO,QAAQ,OAAO,CAAC;QACjC,OAAO,QAAQ,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC;IAC9C;IAEA,MAAM,mBAAmB,MAAc,EAA2B;QAChE,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,4CAA4C,GAAG,CAAC;QAC5E,IAAI,CAAC,KAAK,OAAO,QAAQ,OAAO,CAAC;QACjC,OAAO,QAAQ,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC;IAC9C;IAEA,MAAM,aAAa,OAAuD,EAAsB;QAC9F,IAAI,QAAQ;QACZ,MAAM,SAAgB,EAAE;QAExB,IAAI,SAAS,YAAY;YACvB,SAAS;YACT,OAAO,IAAI,CAAC,QAAQ,UAAU;QAChC;QAEA,IAAI,SAAS,aAAa;YACxB,SAAS;YACT,OAAO,IAAI,CAAC,QAAQ,WAAW;QACjC;QAEA,SAAS;QAET,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI;QAC3C,OAAO,QAAQ,OAAO,CAAC,KAAK,GAAG,CAAC,CAAA,MAAO,IAAI,CAAC,eAAe,CAAC;IAC9D;IAEA,MAAM,uBAAuB,UAAkB,EAAE,QAAgB,GAAG,EAAsB;QACxF,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,OAAO,CAC1B,kFACA,GAAG,CAAC,YAAY;QAClB,OAAO,QAAQ,OAAO,CAAC,KAAK,GAAG,CAAC,CAAA,MAAO,IAAI,CAAC,eAAe,CAAC;IAC9D;IAEA,gFAAgF;IAChF,aAAa;IACb,gFAAgF;IAEhF,MAAM,eAAe,GAAuC,EAAqB;QAC/E,MAAM,KAAK,CAAC,IAAI,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,IAAI;QAC5E,MAAM,YAAY,IAAI,OAAO,WAAW;QAExC,8DAA8D;QAC9D,IAAI;YACF,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;;;;;MAKd,CAAC;QACH,EAAE,OAAO,GAAQ;YACf,0CAA0C;YAC1C,IAAI,CAAC,EAAE,OAAO,EAAE,SAAS,qBAAqB;gBAC5C,QAAQ,IAAI,CAAC,+BAA+B,EAAE,OAAO;YACvD;QACF;QAEA,IAAI;YACF,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;;;;;;MAMjB,CAAC,EAAE,GAAG,CACJ,IACA,IAAI,UAAU,EACd,IAAI,SAAS,IAAI,MACjB,WACA,IAAI,MAAM,EACV,IAAI,IAAI,EACR,IAAI,UAAU,EACd,IAAI,YAAY,EAChB,IAAI,KAAK,EACT,IAAI,SAAS,IAAI,MACjB,IAAI,SAAS,IAAI,MACjB,IAAI,cAAc,IAAI,MACtB,IAAI,OAAO,IAAI,MACf,IAAI,UAAU,IAAI,MAClB,IAAI,WAAW,IAAI;QAEvB,EAAE,OAAO,SAAc;YACrB,uCAAuC;YACvC,MAAM,YAAY;gBAChB,SAAS,QAAQ,OAAO,IAAI,OAAO;gBACnC,MAAM,QAAQ,IAAI,IAAI;gBACtB,OAAO,QAAQ,KAAK;gBACpB,KAAK,QAAQ,GAAG;gBAChB,YAAY,IAAI,UAAU;gBAC1B,OAAO;YACT;YAEA,QAAQ,KAAK,CAAC,kCAAkC,KAAK,SAAS,CAAC,WAAW,MAAM;YAEhF,6BAA6B;YAC7B,MAAM,IAAI,MACR,CAAC,sBAAsB,EAAE,QAAQ,OAAO,IAAI,OAAO,SAAS,EAAE,CAAC,GAC/D,CAAC,+BAA+B,EAAE,IAAI,UAAU,CAAC,EAAE,CAAC,GACpD,CAAC,YAAY,EAAE,QAAQ,IAAI,IAAI,UAAU,EAAE,CAAC,GAC5C,CAAC,KAAK,EAAE,QAAQ,GAAG,IAAI,OAAO;QAElC;QAEA,OAAO,QAAQ,OAAO,CAAC;YACrB,GAAG,GAAG;YACN;YACA;QACF;IACF;IAEA,MAAM,cAAc,OAAqD,EAAuB;QAC9F,IAAI,QAAQ;QACZ,MAAM,SAAgB,EAAE;QAExB,IAAI,SAAS,YAAY;YACvB,SAAS;YACT,OAAO,IAAI,CAAC,QAAQ,UAAU;QAChC;QAEA,IAAI,SAAS,WAAW;YACtB,SAAS;YACT,OAAO,IAAI,CAAC,QAAQ,SAAS;QAC/B;QAEA,SAAS;QAET,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI;QAC3C,OAAO,QAAQ,OAAO,CAAC,KAAK,GAAG,CAAC,CAAA,MAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/D;IAEA,MAAM,cAAc,UAAkB,EAAE,SAAkB,EAAE,OAAgB,EAKzE;QACD,IAAI,QAAQ,CAAC;;;;;;;;;IASb,CAAC;QACD,MAAM,SAAgB;YAAC;SAAW;QAElC,IAAI,WAAW;YACb,SAAS;YACT,OAAO,IAAI,CAAC;QACd;QAEA,IAAI,SAAS;YACX,SAAS;YACT,OAAO,IAAI,CAAC;QACd;QAEA,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI;QAE1C,OAAO,QAAQ,OAAO,CAAC;YACrB,eAAe,IAAI,cAAc,IAAI;YACrC,eAAe,IAAI,cAAc,IAAI;YACrC,cAAc,IAAI,aAAa,EAAE,cAAc;YAC/C,qBAAqB,IAAI,iBAAiB,IAAI;QAChD;IACF;IAEA,gFAAgF;IAChF,UAAU;IACV,gFAAgF;IAExE,iBAAiB,GAAQ,EAAmB;QAClD,OAAO;YACL,IAAI,IAAI,EAAE;YACV,MAAM,IAAI,IAAI;YACd,aAAa,IAAI,WAAW;YAC5B,aAAa,IAAI,YAAY;YAC7B,OAAO,IAAI,KAAK;YAChB,SAAS,IAAI,OAAO;YACpB,cAAc,IAAI,aAAa;YAC/B,aAAa,IAAI,YAAY;YAC7B,SAAS,IAAI,QAAQ;YACrB,kBAAkB,IAAI,iBAAiB;YACvC,QAAQ,IAAI,MAAM;YAClB,WAAW,IAAI,UAAU;YACzB,WAAW,IAAI,UAAU;YACzB,WAAW,IAAI,UAAU;QAC3B;IACF;IAEQ,gBAAgB,GAAQ,EAAW;QACzC,OAAO;YACL,IAAI,IAAI,EAAE;YACV,YAAY,IAAI,WAAW;YAC3B,QAAQ,IAAI,OAAO;YACnB,aAAa,IAAI,YAAY;YAC7B,WAAW,IAAI,UAAU;YACzB,QAAQ,IAAI,MAAM;YAClB,cAAc,IAAI,aAAa;YAC/B,SAAS,IAAI,OAAO;YACpB,YAAY,IAAI,WAAW;YAC3B,WAAW,IAAI,UAAU;YACzB,YAAY,IAAI,WAAW;YAC3B,aAAa,IAAI,WAAW;QAC9B;IACF;IAEQ,iBAAiB,GAAQ,EAAY;QAC3C,OAAO;YACL,IAAI,IAAI,EAAE;YACV,YAAY,IAAI,WAAW;YAC3B,WAAW,IAAI,UAAU;YACzB,WAAW,IAAI,SAAS;YACxB,QAAQ,IAAI,MAAM;YAClB,MAAM,IAAI,IAAI;YACd,YAAY,IAAI,WAAW;YAC3B,cAAc,IAAI,aAAa;YAC/B,OAAO,IAAI,KAAK;YAChB,WAAW,IAAI,UAAU;YACzB,WAAW,IAAI,UAAU;YACzB,gBAAgB,IAAI,eAAe;YACnC,SAAS,IAAI,QAAQ;YACrB,YAAY,IAAI,YAAY;YAC5B,aAAa,IAAI,YAAY;QAC/B;IACF;IAEA,gFAAgF;IAChF,WAAW;IACX,gFAAgF;IAEhF,MAAM,aAAa,MAAiK,EAA+M;QACjY,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,CAAC;qDAC8C,CAAC,EAChD,GAAG,CACH,OAAO,EAAE,EAAE,OAAO,OAAO,EAAE,OAAO,IAAI,EAAE,OAAO,IAAI,EAAE,OAAO,MAAM,IAAI,MACtE,OAAO,SAAS,EAAE,OAAO,SAAS,IAAI,MACtC,OAAO,iBAAiB,IAAI,GAAG,OAAO,kBAAkB,IAAI,KAC5D,OAAO,kBAAkB,IAAI,KAAK,OAAO,mBAAmB,IAAI,WAChE,OAAO,SAAS,EAAE,OAAO,SAAS;QAEpC,OAAO,IAAI,CAAC,gBAAgB,CAAC,OAAO,OAAO;IAC7C;IAEA,MAAM,iBAAiB,OAAe,EAAsN;QAC1P,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,OAAO,CACzB,CAAC,gEAAgE,CAAC,EAClE,GAAG,CAAC;QACN,IAAI,CAAC,KAAK,OAAO;QACjB,OAAO;YACL,IAAI,IAAI,EAAE;YACV,SAAS,IAAI,QAAQ;YACrB,MAAM,IAAI,IAAI;YACd,MAAM,IAAI,IAAI;YACd,QAAQ,IAAI,OAAO;YACnB,WAAW,IAAI,UAAU;YACzB,YAAY,IAAI,YAAY;YAC5B,YAAY,IAAI,YAAY;YAC5B,WAAW,IAAI,UAAU;YACzB,mBAAmB,IAAI,oBAAoB,IAAI;YAC/C,oBAAoB,IAAI,qBAAqB,IAAI;YACjD,oBAAoB,IAAI,qBAAqB,IAAI;YACjD,qBAAqB,IAAI,sBAAsB,IAAI;YACnD,WAAW,IAAI,UAAU;YACzB,WAAW,IAAI,UAAU;YACzB,WAAW,IAAI,UAAU;QAC3B;IACF;IAEA,MAAM,qBAAqB,KAAa,EAAE,SAAkB,EAAiB;QAC3E,MAAM,MAAM,IAAI,OAAO,WAAW;QAClC,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,CAAC,mFAAmF,CAAC,EACrF,GAAG,CAAC,KAAK,aAAa,MAAM,KAAK;IACrC;IAEA,MAAM,8BAA8B,KAAa,EAAE,SAAiB,EAAE,UAAkB,EAAiB;QACvG,MAAM,MAAM,IAAI,OAAO,WAAW;QAClC,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,CAAC,oGAAoG,CAAC,EACtG,GAAG,CAAC,WAAW,YAAY,KAAK;IACpC;IAEA,MAAM,2BAA2B,KAAa,EAAE,UAAmB,EAAE,WAAoB,EAAiB;QACxG,MAAM,MAAM,IAAI,OAAO,WAAW;QAClC,IAAI,eAAe,aAAa,gBAAgB,WAAW;YACzD,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,CAAC,sGAAsG,CAAC,EACxG,GAAG,CAAC,YAAY,aAAa,KAAK;QACtC,OAAO,IAAI,eAAe,WAAW;YACnC,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,CAAC,0EAA0E,CAAC,EAC5E,GAAG,CAAC,YAAY,KAAK;QACzB,OAAO,IAAI,gBAAgB,WAAW;YACpC,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,CAAC,2EAA2E,CAAC,EAC7E,GAAG,CAAC,aAAa,KAAK;QAC1B;IACF;IAEA,MAAM,aAAa,KAAa,EAAoB;QAClD,MAAM,MAAM,IAAI,OAAO,WAAW;QAClC,MAAM,SAAS,IAAI,CAAC,EAAE,CAAC,OAAO,CAC5B,CAAC,sFAAsF,CAAC,EACxF,GAAG,CAAC,KAAK,KAAK;QAChB,OAAO,OAAO,OAAO,GAAG;IAC1B;IAEA,MAAM,YAAY,MAAe,EAAiN;QAChP,IAAI,QAAQ,CAAC,+CAA+C,CAAC;QAC7D,MAAM,SAAgB,EAAE;QACxB,IAAI,QAAQ;YACV,SAAS,CAAC,gBAAgB,CAAC;YAC3B,OAAO,IAAI,CAAC;QACd;QACA,SAAS,CAAC,yBAAyB,CAAC;QACpC,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI;QAC3C,OAAO,QAAQ,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC,MAAQ,CAAC;gBACxC,IAAI,IAAI,EAAE;gBACV,SAAS,IAAI,QAAQ;gBACrB,MAAM,IAAI,IAAI;gBACd,MAAM,IAAI,IAAI;gBACd,QAAQ,IAAI,OAAO;gBACnB,WAAW,IAAI,UAAU;gBACzB,YAAY,IAAI,YAAY;gBAC5B,YAAY,IAAI,YAAY;gBAC5B,WAAW,IAAI,UAAU;gBACzB,mBAAmB,IAAI,oBAAoB,IAAI;gBAC/C,oBAAoB,IAAI,qBAAqB,IAAI;gBACjD,oBAAoB,IAAI,qBAAqB,IAAI;gBACjD,qBAAqB,IAAI,sBAAsB,IAAI;gBACnD,WAAW,IAAI,UAAU;gBACzB,WAAW,IAAI,UAAU;gBACzB,WAAW,IAAI,UAAU;YAC3B,CAAC;IACH;IAEA,QAAc;QACZ,IAAI,CAAC,EAAE,CAAC,KAAK;IACf;AACF"}},
    {"offset": {"line": 2256, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/adapters/postgres-adapter.ts"],"sourcesContent":["// =============================================================================\r\n// POSTGRESQL ADAPTER\r\n// =============================================================================\r\n// PostgreSQL implementation of DatabaseAdapter\r\n// Uses pg (node-postgres) with connection pooling\r\n\r\nimport { Pool, QueryResult } from 'pg';\r\nimport type { DatabaseAdapter } from './base-adapter';\r\nimport type { MeteredEndpoint, Payment, UsageLog } from '../metered-endpoints';\r\n\r\nexport class PostgresAdapter implements DatabaseAdapter {\r\n  private pool: Pool;\r\n\r\n  constructor(connectionString: string) {\r\n    this.pool = new Pool({\r\n      connectionString,\r\n      max: 20, // Maximum pool size\r\n      idleTimeoutMillis: 30000,\r\n      connectionTimeoutMillis: 2000,\r\n    });\r\n\r\n    // Handle pool errors\r\n    this.pool.on('error', (err) => {\r\n      console.error('[PostgresAdapter] Unexpected pool error:', err);\r\n    });\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    try {\r\n      const result = await this.pool.query('SELECT 1');\r\n      return result.rows.length > 0;\r\n    } catch (error) {\r\n      console.error('[PostgresAdapter] Health check failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // =============================================================================\r\n  // ENDPOINTS\r\n  // =============================================================================\r\n\r\n  async createEndpoint(endpoint: Omit<MeteredEndpoint, 'id' | 'createdAt' | 'updatedAt'> & { id?: string }): Promise<MeteredEndpoint> {\r\n    const id = endpoint.id || `ep_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const now = new Date().toISOString();\r\n\r\n    const result = await this.pool.query(\r\n      `INSERT INTO endpoints (\r\n        id, name, description, upstream_url, price, network, token_address,\r\n        token_symbol, chain_id, recipient_address, status, created_at, updated_at, created_by\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        endpoint.name,\r\n        endpoint.description || null,\r\n        endpoint.upstreamUrl,\r\n        endpoint.price,\r\n        endpoint.network,\r\n        endpoint.tokenAddress,\r\n        endpoint.tokenSymbol,\r\n        endpoint.chainId,\r\n        endpoint.recipientAddress,\r\n        endpoint.status,\r\n        now,\r\n        now,\r\n        endpoint.createdBy || null,\r\n      ]\r\n    );\r\n\r\n    return this.mapRowToEndpoint(result.rows[0]);\r\n  }\r\n\r\n  async getEndpoint(endpointId: string): Promise<MeteredEndpoint | null> {\r\n    const result = await this.pool.query(\r\n      'SELECT * FROM endpoints WHERE id = $1 AND status != $2',\r\n      [endpointId, 'deleted']\r\n    );\r\n\r\n    if (result.rows.length === 0) return null;\r\n    return this.mapRowToEndpoint(result.rows[0]);\r\n  }\r\n\r\n  async listEndpoints(filters?: { status?: string; createdBy?: string }): Promise<MeteredEndpoint[]> {\r\n    let query = 'SELECT * FROM endpoints WHERE status != $1';\r\n    const params: any[] = ['deleted'];\r\n    let paramIndex = 2;\r\n\r\n    if (filters?.status) {\r\n      query += ` AND status = $${paramIndex}`;\r\n      params.push(filters.status);\r\n      paramIndex++;\r\n    }\r\n\r\n    if (filters?.createdBy) {\r\n      query += ` AND created_by = $${paramIndex}`;\r\n      params.push(filters.createdBy);\r\n      paramIndex++;\r\n    }\r\n\r\n    query += ' ORDER BY created_at DESC';\r\n\r\n    try {\r\n      const result = await this.pool.query(query, params);\r\n      return result.rows.map(row => this.mapRowToEndpoint(row));\r\n    } catch (error) {\r\n      console.error('[PostgresAdapter] listEndpoints error:', error);\r\n      console.error('[PostgresAdapter] Query:', query);\r\n      console.error('[PostgresAdapter] Params:', params);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async updateEndpoint(endpointId: string, updates: Partial<MeteredEndpoint>): Promise<MeteredEndpoint | null> {\r\n    const allowedFields = [\r\n      'name', 'description', 'upstreamUrl', 'price', 'network',\r\n      'tokenAddress', 'tokenSymbol', 'chainId', 'recipientAddress', 'status'\r\n    ];\r\n\r\n    const setClauses: string[] = [];\r\n    const values: any[] = [];\r\n    let paramIndex = 1;\r\n\r\n    for (const [key, value] of Object.entries(updates)) {\r\n      if (allowedFields.includes(key) && value !== undefined) {\r\n        const dbKey = key === 'upstreamUrl' ? 'upstream_url' :\r\n                     key === 'tokenAddress' ? 'token_address' :\r\n                     key === 'tokenSymbol' ? 'token_symbol' :\r\n                     key === 'chainId' ? 'chain_id' :\r\n                     key === 'recipientAddress' ? 'recipient_address' :\r\n                     key === 'createdAt' ? 'created_at' :\r\n                     key === 'updatedAt' ? 'updated_at' :\r\n                     key === 'createdBy' ? 'created_by' : key;\r\n        setClauses.push(`${dbKey} = $${paramIndex}`);\r\n        values.push(value);\r\n        paramIndex++;\r\n      }\r\n    }\r\n\r\n    if (setClauses.length === 0) {\r\n      return this.getEndpoint(endpointId);\r\n    }\r\n\r\n    setClauses.push(`updated_at = $${paramIndex}`);\r\n    values.push(new Date().toISOString());\r\n    paramIndex++;\r\n\r\n    values.push(endpointId);\r\n\r\n    const result = await this.pool.query(\r\n      `UPDATE endpoints SET ${setClauses.join(', ')} WHERE id = $${paramIndex} RETURNING *`,\r\n      values\r\n    );\r\n\r\n    if (result.rows.length === 0) return null;\r\n    return this.mapRowToEndpoint(result.rows[0]);\r\n  }\r\n\r\n  async deleteEndpoint(endpointId: string): Promise<boolean> {\r\n    const result = await this.pool.query(\r\n      'UPDATE endpoints SET status = $1, updated_at = $2 WHERE id = $3',\r\n      ['deleted', new Date().toISOString(), endpointId]\r\n    );\r\n    return result.rowCount !== null && result.rowCount > 0;\r\n  }\r\n\r\n  // =============================================================================\r\n  // PAYMENTS\r\n  // =============================================================================\r\n\r\n  async createPayment(payment: Omit<Payment, 'id' | 'verifiedAt'>): Promise<Payment> {\r\n    const id = `pay_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const now = new Date().toISOString();\r\n    const verifiedAt = now;\r\n    // Generate invoice_id if not provided (required by schema)\r\n    const invoiceId = `inv_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Determine currency and token symbol from token address or default to USDC\r\n    // For USDC on Base: 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\r\n    const currency = payment.tokenAddress === '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' ? 'USDC' : 'USDC';\r\n    const token = payment.tokenAddress; // token column stores the token address\r\n\r\n    // Set default status for verified payments\r\n    const status = 'verified'; // Payment is verified and completed\r\n\r\n    const result = await this.pool.query(\r\n      `INSERT INTO payments (\r\n        id, endpoint_id, invoice_id, tx_hash, from_address, to_address, amount,\r\n        currency, token, token_address, network, status, created_at, verified_at, kyt_status, ofac_status, facilitator\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        payment.endpointId,\r\n        invoiceId,\r\n        payment.txHash,\r\n        payment.fromAddress,\r\n        payment.toAddress,\r\n        payment.amount,\r\n        currency,\r\n        token,\r\n        payment.tokenAddress,\r\n        payment.network,\r\n        status,\r\n        now, // created_at\r\n        verifiedAt,\r\n        payment.kytStatus || null,\r\n        payment.ofacStatus || null,\r\n        payment.facilitator,\r\n      ]\r\n    );\r\n\r\n    return this.mapRowToPayment(result.rows[0]);\r\n  }\r\n\r\n  async getPayment(paymentId: string): Promise<Payment | null> {\r\n    const result = await this.pool.query('SELECT * FROM payments WHERE id = $1', [paymentId]);\r\n    if (result.rows.length === 0) return null;\r\n    return this.mapRowToPayment(result.rows[0]);\r\n  }\r\n\r\n  async getPaymentByTxHash(txHash: string): Promise<Payment | null> {\r\n    const result = await this.pool.query('SELECT * FROM payments WHERE tx_hash = $1', [txHash]);\r\n    if (result.rows.length === 0) return null;\r\n    return this.mapRowToPayment(result.rows[0]);\r\n  }\r\n\r\n  async listPayments(filters?: { endpointId?: string; fromAddress?: string }): Promise<Payment[]> {\r\n    let query = 'SELECT * FROM payments WHERE 1=1';\r\n    const params: any[] = [];\r\n    let paramIndex = 1;\r\n\r\n    if (filters?.endpointId) {\r\n      query += ` AND endpoint_id = $${paramIndex}`;\r\n      params.push(filters.endpointId);\r\n      paramIndex++;\r\n    }\r\n\r\n    if (filters?.fromAddress) {\r\n      query += ` AND from_address = $${paramIndex}`;\r\n      params.push(filters.fromAddress);\r\n      paramIndex++;\r\n    }\r\n\r\n    query += ' ORDER BY verified_at DESC';\r\n\r\n    const result = await this.pool.query(query, params);\r\n    return result.rows.map(row => this.mapRowToPayment(row));\r\n  }\r\n\r\n  async getPaymentsForEndpoint(endpointId: string, limit: number = 100): Promise<Payment[]> {\r\n    const result = await this.pool.query(\r\n      'SELECT * FROM payments WHERE endpoint_id = $1 ORDER BY verified_at DESC LIMIT $2',\r\n      [endpointId, limit]\r\n    );\r\n    return result.rows.map(row => this.mapRowToPayment(row));\r\n  }\r\n\r\n  // =============================================================================\r\n  // USAGE LOGS\r\n  // =============================================================================\r\n\r\n  async createUsageLog(log: Omit<UsageLog, 'id' | 'timestamp'>): Promise<UsageLog> {\r\n    const id = `log_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const timestamp = new Date().toISOString();\r\n\r\n    const result = await this.pool.query(\r\n      `INSERT INTO usage_logs (\r\n        id, endpoint_id, payment_id, timestamp, method, path,\r\n        status_code, response_time, units, ip_address, user_agent,\r\n        conversation_id, agent_id, x402_tx_hash, failure_code\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        log.endpointId,\r\n        log.paymentId || null,\r\n        timestamp,\r\n        log.method,\r\n        log.path,\r\n        log.statusCode,\r\n        log.responseTime,\r\n        log.units,\r\n        log.ipAddress || null,\r\n        log.userAgent || null,\r\n        log.conversationId || null,\r\n        log.agentId || null,\r\n        log.x402TxHash || null,\r\n        log.failureCode || null,\r\n      ]\r\n    );\r\n\r\n    return this.mapRowToUsageLog(result.rows[0]);\r\n  }\r\n\r\n  async listUsageLogs(filters?: { endpointId?: string; paymentId?: string }): Promise<UsageLog[]> {\r\n    let query = 'SELECT * FROM usage_logs WHERE 1=1';\r\n    const params: any[] = [];\r\n    let paramIndex = 1;\r\n\r\n    if (filters?.endpointId) {\r\n      query += ` AND endpoint_id = $${paramIndex}`;\r\n      params.push(filters.endpointId);\r\n      paramIndex++;\r\n    }\r\n\r\n    if (filters?.paymentId) {\r\n      query += ` AND payment_id = $${paramIndex}`;\r\n      params.push(filters.paymentId);\r\n      paramIndex++;\r\n    }\r\n\r\n    query += ' ORDER BY timestamp DESC LIMIT 1000';\r\n\r\n    const result = await this.pool.query(query, params);\r\n    return result.rows.map(row => this.mapRowToUsageLog(row));\r\n  }\r\n\r\n  async getUsageStats(endpointId: string, startDate?: string, endDate?: string): Promise<{\r\n    totalRequests: number;\r\n    totalPayments: number;\r\n    totalRevenue: string;\r\n    averageResponseTime: number;\r\n  }> {\r\n    let query = `\r\n      SELECT\r\n        COUNT(*) as total_requests,\r\n        COUNT(DISTINCT payment_id) as total_payments,\r\n        COALESCE(SUM(p.amount), '0') as total_revenue,\r\n        COALESCE(AVG(response_time), 0) as avg_response_time\r\n      FROM usage_logs ul\r\n      LEFT JOIN payments p ON ul.payment_id = p.id\r\n      WHERE ul.endpoint_id = $1\r\n    `;\r\n    const params: any[] = [endpointId];\r\n    let paramIndex = 2;\r\n\r\n    if (startDate) {\r\n      query += ` AND ul.timestamp >= $${paramIndex}`;\r\n      params.push(startDate);\r\n      paramIndex++;\r\n    }\r\n\r\n    if (endDate) {\r\n      query += ` AND ul.timestamp <= $${paramIndex}`;\r\n      params.push(endDate);\r\n      paramIndex++;\r\n    }\r\n\r\n    const result = await this.pool.query(query, params);\r\n    const row = result.rows[0];\r\n\r\n    return {\r\n      totalRequests: parseInt(row.total_requests) || 0,\r\n      totalPayments: parseInt(row.total_payments) || 0,\r\n      totalRevenue: row.total_revenue || '0',\r\n      averageResponseTime: parseFloat(row.avg_response_time) || 0,\r\n    };\r\n  }\r\n\r\n  // =============================================================================\r\n  // HELPERS\r\n  // =============================================================================\r\n\r\n  private mapRowToEndpoint(row: any): MeteredEndpoint {\r\n    return {\r\n      id: row.id,\r\n      name: row.name,\r\n      description: row.description,\r\n      upstreamUrl: row.upstream_url,\r\n      price: row.price,\r\n      network: row.network,\r\n      tokenAddress: row.token_address,\r\n      tokenSymbol: row.token_symbol,\r\n      chainId: row.chain_id,\r\n      recipientAddress: row.recipient_address,\r\n      status: row.status,\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      createdBy: row.created_by,\r\n    };\r\n  }\r\n\r\n  private mapRowToPayment(row: any): Payment {\r\n    return {\r\n      id: row.id,\r\n      endpointId: row.endpoint_id,\r\n      txHash: row.tx_hash,\r\n      fromAddress: row.from_address,\r\n      toAddress: row.to_address,\r\n      amount: row.amount,\r\n      tokenAddress: row.token_address,\r\n      network: row.network,\r\n      verifiedAt: row.verified_at,\r\n      kytStatus: row.kyt_status,\r\n      ofacStatus: row.ofac_status,\r\n      facilitator: row.facilitator,\r\n    };\r\n  }\r\n\r\n  private mapRowToUsageLog(row: any): UsageLog {\r\n    return {\r\n      id: row.id,\r\n      endpointId: row.endpoint_id,\r\n      paymentId: row.payment_id,\r\n      timestamp: row.timestamp,\r\n      method: row.method,\r\n      path: row.path,\r\n      statusCode: row.status_code,\r\n      responseTime: row.response_time,\r\n      units: row.units,\r\n      ipAddress: row.ip_address,\r\n      userAgent: row.user_agent,\r\n      conversationId: row.conversation_id,\r\n      agentId: row.agent_id,\r\n      x402TxHash: row.x402_tx_hash,\r\n      failureCode: row.failure_code,\r\n    };\r\n  }\r\n\r\n  // =============================================================================\r\n  // API KEYS\r\n  // =============================================================================\r\n\r\n  async createApiKey(apiKey: { id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; expiresAt?: string; createdAt: string; updatedAt: string }): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }> {\r\n    await this.pool.query(\r\n      `INSERT INTO api_keys (id, key_hash, name, role, user_id, rate_limit, expires_at, created_at, updated_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,\r\n      [\r\n        apiKey.id, apiKey.keyHash, apiKey.name, apiKey.role, apiKey.userId || null,\r\n        apiKey.rateLimit, apiKey.expiresAt || null, apiKey.createdAt, apiKey.updatedAt,\r\n      ]\r\n    );\r\n    return this.findApiKeyByHash(apiKey.keyHash) as Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }>;\r\n  }\r\n\r\n  async findApiKeyByHash(keyHash: string): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string } | null> {\r\n    const result = await this.pool.query(\r\n      `SELECT * FROM api_keys WHERE key_hash = $1 AND revoked_at IS NULL`,\r\n      [keyHash]\r\n    );\r\n    if (result.rows.length === 0) return null;\r\n    const row = result.rows[0];\r\n    return {\r\n      id: row.id,\r\n      keyHash: row.key_hash,\r\n      name: row.name,\r\n      role: row.role,\r\n      userId: row.user_id,\r\n      rateLimit: row.rate_limit,\r\n      lastUsedAt: row.last_used_at,\r\n      lastUsedIp: row.last_used_ip,\r\n      expiresAt: row.expires_at,\r\n      x402DemoCallsUsed: row.x402_demo_calls_used || 0,\r\n      x402DemoCallsLimit: row.x402_demo_calls_limit || 200,\r\n      x402DemoAmountUsed: row.x402_demo_amount_used || '0',\r\n      x402DemoAmountLimit: row.x402_demo_amount_limit || '1000000',\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      revokedAt: row.revoked_at,\r\n    };\r\n  }\r\n\r\n  async updateApiKeyLastUsed(keyId: string, ipAddress?: string): Promise<void> {\r\n    await this.pool.query(\r\n      `UPDATE api_keys SET last_used_at = NOW(), last_used_ip = $2, updated_at = NOW() WHERE id = $1`,\r\n      [keyId, ipAddress || null]\r\n    );\r\n  }\r\n\r\n  async updateApiKeyX402DemoAllowance(keyId: string, callsUsed: number, amountUsed: string): Promise<void> {\r\n    await this.pool.query(\r\n      `UPDATE api_keys SET x402_demo_calls_used = $2, x402_demo_amount_used = $3, updated_at = NOW() WHERE id = $1`,\r\n      [keyId, callsUsed, amountUsed]\r\n    );\r\n  }\r\n\r\n  async updateApiKeyX402DemoLimits(keyId: string, callsLimit?: number, amountLimit?: string): Promise<void> {\r\n    if (callsLimit !== undefined && amountLimit !== undefined) {\r\n      await this.pool.query(\r\n        `UPDATE api_keys SET x402_demo_calls_limit = $2, x402_demo_amount_limit = $3, updated_at = NOW() WHERE id = $1`,\r\n        [keyId, callsLimit, amountLimit]\r\n      );\r\n    } else if (callsLimit !== undefined) {\r\n      await this.pool.query(\r\n        `UPDATE api_keys SET x402_demo_calls_limit = $2, updated_at = NOW() WHERE id = $1`,\r\n        [keyId, callsLimit]\r\n      );\r\n    } else if (amountLimit !== undefined) {\r\n      await this.pool.query(\r\n        `UPDATE api_keys SET x402_demo_amount_limit = $2, updated_at = NOW() WHERE id = $1`,\r\n        [keyId, amountLimit]\r\n      );\r\n    }\r\n  }\r\n\r\n  async revokeApiKey(keyId: string): Promise<boolean> {\r\n    const result = await this.pool.query(\r\n      `UPDATE api_keys SET revoked_at = NOW(), updated_at = NOW() WHERE id = $1 AND revoked_at IS NULL`,\r\n      [keyId]\r\n    );\r\n    return result.rowCount > 0;\r\n  }\r\n\r\n  async listApiKeys(userId?: string): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }[]> {\r\n    let query = `SELECT * FROM api_keys WHERE revoked_at IS NULL`;\r\n    const params: any[] = [];\r\n    if (userId) {\r\n      query += ` AND user_id = $1`;\r\n      params.push(userId);\r\n    }\r\n    query += ` ORDER BY created_at DESC`;\r\n    const result = await this.pool.query(query, params);\r\n    return result.rows.map((row) => ({\r\n      id: row.id,\r\n      keyHash: row.key_hash,\r\n      name: row.name,\r\n      role: row.role,\r\n      userId: row.user_id,\r\n      rateLimit: row.rate_limit,\r\n      lastUsedAt: row.last_used_at,\r\n      lastUsedIp: row.last_used_ip,\r\n      expiresAt: row.expires_at,\r\n      x402DemoCallsUsed: row.x402_demo_calls_used || 0,\r\n      x402DemoCallsLimit: row.x402_demo_calls_limit || 200,\r\n      x402DemoAmountUsed: row.x402_demo_amount_used || '0',\r\n      x402DemoAmountLimit: row.x402_demo_amount_limit || '1000000',\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      revokedAt: row.revoked_at,\r\n    }));\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    await this.pool.end();\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2737, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/client.ts"],"sourcesContent":["// =============================================================================\r\n// DATABASE CLIENT FACTORY\r\n// =============================================================================\r\n// Automatically selects SQLite (dev) or PostgreSQL (prod) based on environment\r\n\r\nimport type { DatabaseAdapter } from './adapters/base-adapter';\r\nimport { SqliteAdapter } from './adapters/sqlite-adapter';\r\nimport { PostgresAdapter } from './adapters/postgres-adapter';\r\n\r\nlet dbAdapter: DatabaseAdapter | null = null;\r\n\r\n/**\r\n * Get the database adapter instance\r\n * Uses PostgreSQL if DATABASE_URL is set, otherwise falls back to SQLite\r\n */\r\nexport function getDb(): DatabaseAdapter {\r\n  if (dbAdapter) {\r\n    return dbAdapter;\r\n  }\r\n\r\n  const databaseUrl = process.env.DATABASE_URL;\r\n\r\n  if (databaseUrl && databaseUrl.startsWith('postgresql://')) {\r\n    // Production: Use PostgreSQL\r\n    console.log('[db] Using PostgreSQL adapter');\r\n    dbAdapter = new PostgresAdapter(databaseUrl);\r\n  } else {\r\n    // Development: Use SQLite\r\n    console.log('[db] Using SQLite adapter (development mode)');\r\n    dbAdapter = new SqliteAdapter();\r\n  }\r\n\r\n  return dbAdapter;\r\n}\r\n\r\n/**\r\n * Close database connections (useful for cleanup in tests)\r\n */\r\nexport async function closeDb(): Promise<void> {\r\n  if (dbAdapter) {\r\n    if ('close' in dbAdapter && typeof dbAdapter.close === 'function') {\r\n      await dbAdapter.close();\r\n    }\r\n    dbAdapter = null;\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;AAC1B,gFAAgF;AAChF,+EAA+E;;;;;;;AAG/E;AACA;;;;;;;AAEA,IAAI,YAAoC;AAMjC,SAAS;IACd,IAAI,WAAW;QACb,OAAO;IACT;IAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY;IAE5C,IAAI,eAAe,YAAY,UAAU,CAAC,kBAAkB;QAC1D,6BAA6B;QAC7B,QAAQ,GAAG,CAAC;QACZ,YAAY,IAAI,iKAAe,CAAC;IAClC,OAAO;QACL,0BAA0B;QAC1B,QAAQ,GAAG,CAAC;QACZ,YAAY,IAAI,6JAAa;IAC/B;IAEA,OAAO;AACT;AAKO,eAAe;IACpB,IAAI,WAAW;QACb,IAAI,WAAW,aAAa,OAAO,UAAU,KAAK,KAAK,YAAY;YACjE,MAAM,UAAU,KAAK;QACvB;QACA,YAAY;IACd;AACF"}},
    {"offset": {"line": 2787, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/smf.ts"],"sourcesContent":["// =============================================================================\r\n// SMF DATABASE OPERATIONS\r\n// =============================================================================\r\n// Database operations for Smart Meta-Facilitator routing, attempts, and health\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'SMFDatabase' });\r\n\r\nexport interface Facilitator {\r\n  id: string;\r\n  name: string;\r\n  status: 'active' | 'disabled' | 'testing';\r\n  base_url: string;\r\n  priority: number;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface FacilitatorCapability {\r\n  id: string;\r\n  facilitator_id: string;\r\n  network: string;\r\n  token: string;\r\n  min_amount: string;\r\n  max_amount: string | null;\r\n  fee_bps: number;\r\n  regions: string[] | null;\r\n  supports_deferred: boolean;\r\n  supports_subscriptions: boolean;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface Route {\r\n  id: string;\r\n  request_id: string | null;\r\n  correlation_id: string | null;\r\n  client_id: string | null;\r\n  agent_id: string | null;\r\n  network: string;\r\n  token: string;\r\n  amount: string;\r\n  selected_facilitator_id: string;\r\n  status: 'planned' | 'verifying' | 'settling' | 'settled' | 'failed';\r\n  created_at: string;\r\n  updated_at: string;\r\n  completed_at: string | null;\r\n}\r\n\r\nexport interface RouteAttempt {\r\n  id: string;\r\n  route_id: string;\r\n  facilitator_id: string;\r\n  phase: 'verify' | 'settle';\r\n  result: 'success' | 'failure' | 'timeout' | 'rate_limited' | 'insufficient_liquidity' | 'invalid_request' | 'network_error';\r\n  latency_ms: number;\r\n  error_code: string | null;\r\n  raw_status: number | null;\r\n  created_at: string;\r\n}\r\n\r\nexport interface FacilitatorHealthSnapshot {\r\n  id: string;\r\n  facilitator_id: string;\r\n  network: string;\r\n  token: string;\r\n  window_start: string;\r\n  window_end: string;\r\n  success_rate: number;\r\n  p50_latency_ms: number | null;\r\n  p95_latency_ms: number | null;\r\n  p99_latency_ms: number | null;\r\n  error_rate: number;\r\n  last_error_type: string | null;\r\n  status: 'healthy' | 'degraded' | 'down';\r\n  created_at: string;\r\n}\r\n\r\n/**\r\n * Create a route record\r\n */\r\nexport async function createRoute(route: Omit<Route, 'id' | 'created_at' | 'updated_at' | 'completed_at'>): Promise<Route> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO routes (\r\n        id, request_id, correlation_id, client_id, agent_id, network, token, amount,\r\n        selected_facilitator_id, status, created_at, updated_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        route.request_id,\r\n        route.correlation_id,\r\n        route.client_id,\r\n        route.agent_id,\r\n        route.network,\r\n        route.token,\r\n        route.amount,\r\n        route.selected_facilitator_id,\r\n        route.status,\r\n        now,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO routes (\r\n        id, request_id, correlation_id, client_id, agent_id, network, token, amount,\r\n        selected_facilitator_id, status, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      route.request_id,\r\n      route.correlation_id,\r\n      route.client_id,\r\n      route.agent_id,\r\n      route.network,\r\n      route.token,\r\n      route.amount,\r\n      route.selected_facilitator_id,\r\n      route.status,\r\n      now,\r\n      now\r\n    );\r\n    return {\r\n      id,\r\n      ...route,\r\n      created_at: now,\r\n      updated_at: now,\r\n      completed_at: null,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update route status\r\n */\r\nexport async function updateRouteStatus(\r\n  routeId: string,\r\n  status: Route['status'],\r\n  completedAt?: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE routes SET status = $1, updated_at = $2, completed_at = $3 WHERE id = $4`,\r\n      [status, now, completedAt || null, routeId]\r\n    );\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(\r\n      `UPDATE routes SET status = ?, updated_at = ?, completed_at = ? WHERE id = ?`\r\n    );\r\n    stmt.run(status, now, completedAt || null, routeId);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a route attempt record\r\n */\r\nexport async function createRouteAttempt(\r\n  attempt: Omit<RouteAttempt, 'id' | 'created_at'>\r\n): Promise<RouteAttempt> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO route_attempts (\r\n        id, route_id, facilitator_id, phase, result, latency_ms, error_code, raw_status, created_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        attempt.route_id,\r\n        attempt.facilitator_id,\r\n        attempt.phase,\r\n        attempt.result,\r\n        attempt.latency_ms,\r\n        attempt.error_code,\r\n        attempt.raw_status,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO route_attempts (\r\n        id, route_id, facilitator_id, phase, result, latency_ms, error_code, raw_status, created_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      attempt.route_id,\r\n      attempt.facilitator_id,\r\n      attempt.phase,\r\n      attempt.result,\r\n      attempt.latency_ms,\r\n      attempt.error_code,\r\n      attempt.raw_status,\r\n      now\r\n    );\r\n    return {\r\n      id,\r\n      ...attempt,\r\n      created_at: now,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get facilitator capabilities\r\n */\r\nexport async function getFacilitatorCapabilities(\r\n  facilitatorId?: string,\r\n  network?: string,\r\n  token?: string\r\n): Promise<FacilitatorCapability[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let query = 'SELECT * FROM facilitator_capabilities WHERE 1=1';\r\n  const params: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (facilitatorId) {\r\n    if (isPostgres) {\r\n      query += ` AND facilitator_id = $${paramIndex++}`;\r\n      params.push(facilitatorId);\r\n    } else {\r\n      query += ` AND facilitator_id = ?`;\r\n      params.push(facilitatorId);\r\n    }\r\n  }\r\n\r\n  if (network) {\r\n    if (isPostgres) {\r\n      query += ` AND network = $${paramIndex++}`;\r\n      params.push(network);\r\n    } else {\r\n      query += ` AND network = ?`;\r\n      params.push(network);\r\n    }\r\n  }\r\n\r\n  if (token) {\r\n    if (isPostgres) {\r\n      query += ` AND token = $${paramIndex++}`;\r\n      params.push(token);\r\n    } else {\r\n      query += ` AND token = ?`;\r\n      params.push(token);\r\n    }\r\n  }\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, params);\r\n    return result.rows;\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(query);\r\n    const rows = stmt.all(...params);\r\n    return rows;\r\n  }\r\n}\r\n\r\n/**\r\n * Get latest health snapshot for a facilitator/network/token\r\n */\r\nexport async function getLatestHealthSnapshot(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string\r\n): Promise<FacilitatorHealthSnapshot | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_health_snapshots\r\n       WHERE facilitator_id = $1 AND network = $2 AND token = $3\r\n       ORDER BY window_end DESC\r\n       LIMIT 1`,\r\n      [facilitatorId, network, token]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(\r\n      `SELECT * FROM facilitator_health_snapshots\r\n       WHERE facilitator_id = ? AND network = ? AND token = ?\r\n       ORDER BY window_end DESC\r\n       LIMIT 1`\r\n    );\r\n    const row = stmt.get(facilitatorId, network, token);\r\n    return row || null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get route attempts for health aggregation\r\n */\r\nexport async function getRouteAttemptsForHealth(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowStart: string,\r\n  windowEnd: string\r\n): Promise<RouteAttempt[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT ra.* FROM route_attempts ra\r\n       INNER JOIN routes r ON ra.route_id = r.id\r\n       WHERE ra.facilitator_id = $1\r\n         AND r.network = $2\r\n         AND r.token = $3\r\n         AND ra.created_at >= $4\r\n         AND ra.created_at < $5\r\n       ORDER BY ra.created_at`,\r\n      [facilitatorId, network, token, windowStart, windowEnd]\r\n    );\r\n    return result.rows;\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(\r\n      `SELECT ra.* FROM route_attempts ra\r\n       INNER JOIN routes r ON ra.route_id = r.id\r\n       WHERE ra.facilitator_id = ?\r\n         AND r.network = ?\r\n         AND r.token = ?\r\n         AND ra.created_at >= ?\r\n         AND ra.created_at < ?\r\n       ORDER BY ra.created_at`\r\n    );\r\n    const rows = stmt.all(facilitatorId, network, token, windowStart, windowEnd);\r\n    return rows;\r\n  }\r\n}\r\n\r\n/**\r\n * Create or update health snapshot\r\n */\r\nexport async function upsertHealthSnapshot(\r\n  snapshot: Omit<FacilitatorHealthSnapshot, 'id' | 'created_at'>\r\n): Promise<FacilitatorHealthSnapshot> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    // Use ON CONFLICT for upsert\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO facilitator_health_snapshots (\r\n        id, facilitator_id, network, token, window_start, window_end,\r\n        success_rate, p50_latency_ms, p95_latency_ms, p99_latency_ms,\r\n        error_rate, last_error_type, status, created_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\r\n      ON CONFLICT (facilitator_id, network, token, window_end)\r\n      DO UPDATE SET\r\n        success_rate = EXCLUDED.success_rate,\r\n        p50_latency_ms = EXCLUDED.p50_latency_ms,\r\n        p95_latency_ms = EXCLUDED.p95_latency_ms,\r\n        p99_latency_ms = EXCLUDED.p99_latency_ms,\r\n        error_rate = EXCLUDED.error_rate,\r\n        last_error_type = EXCLUDED.last_error_type,\r\n        status = EXCLUDED.status\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        snapshot.facilitator_id,\r\n        snapshot.network,\r\n        snapshot.token,\r\n        snapshot.window_start,\r\n        snapshot.window_end,\r\n        snapshot.success_rate,\r\n        snapshot.p50_latency_ms,\r\n        snapshot.p95_latency_ms,\r\n        snapshot.p99_latency_ms,\r\n        snapshot.error_rate,\r\n        snapshot.last_error_type,\r\n        snapshot.status,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite - simple insert (no upsert for now)\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO facilitator_health_snapshots (\r\n        id, facilitator_id, network, token, window_start, window_end,\r\n        success_rate, p50_latency_ms, p95_latency_ms, p99_latency_ms,\r\n        error_rate, last_error_type, status, created_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      snapshot.facilitator_id,\r\n      snapshot.network,\r\n      snapshot.token,\r\n      snapshot.window_start,\r\n      snapshot.window_end,\r\n      snapshot.success_rate,\r\n      snapshot.p50_latency_ms,\r\n      snapshot.p95_latency_ms,\r\n      snapshot.p99_latency_ms,\r\n      snapshot.error_rate,\r\n      snapshot.last_error_type,\r\n      snapshot.status,\r\n      now\r\n    );\r\n    return {\r\n      id,\r\n      ...snapshot,\r\n      created_at: now,\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3075, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/health-aggregator.ts"],"sourcesContent":["// =============================================================================\r\n// HEALTH AGGREGATOR\r\n// =============================================================================\r\n// Aggregates health metrics from route attempts for scoring and monitoring\r\n\r\nimport { getRouteAttemptsForHealth, upsertHealthSnapshot, getLatestHealthSnapshot, type RouteAttempt, type FacilitatorHealthSnapshot } from '@/db/smf';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'HealthAggregator' });\r\n\r\n/**\r\n * Calculate percentile from sorted array\r\n */\r\nfunction percentile(sortedValues: number[], p: number): number {\r\n  if (sortedValues.length === 0) return 0;\r\n  const index = Math.ceil((p / 100) * sortedValues.length) - 1;\r\n  return sortedValues[Math.max(0, index)];\r\n}\r\n\r\n/**\r\n * Aggregate health metrics from route attempts\r\n */\r\nexport async function aggregateHealthMetrics(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowStart: Date,\r\n  windowEnd: Date\r\n): Promise<FacilitatorHealthSnapshot | null> {\r\n  try {\r\n    const attempts = await getRouteAttemptsForHealth(\r\n      facilitatorId,\r\n      network,\r\n      token,\r\n      windowStart.toISOString(),\r\n      windowEnd.toISOString()\r\n    );\r\n\r\n    if (attempts.length === 0) {\r\n      logger.debug({ facilitatorId, network, token }, 'No attempts found for health aggregation');\r\n      return null;\r\n    }\r\n\r\n    // Calculate success rate\r\n    const successful = attempts.filter((a) => a.result === 'success').length;\r\n    const successRate = successful / attempts.length;\r\n\r\n    // Calculate latency percentiles\r\n    const latencies = attempts\r\n      .map((a) => a.latency_ms)\r\n      .filter((l) => l > 0)\r\n      .sort((a, b) => a - b);\r\n\r\n    const p50 = latencies.length > 0 ? percentile(latencies, 50) : null;\r\n    const p95 = latencies.length > 0 ? percentile(latencies, 95) : null;\r\n    const p99 = latencies.length > 0 ? percentile(latencies, 99) : null;\r\n\r\n    // Calculate error rate\r\n    const errors = attempts.filter((a) => a.result !== 'success').length;\r\n    const errorRate = errors / attempts.length;\r\n\r\n    // Get last error type\r\n    const failedAttempts = attempts.filter((a) => a.result !== 'success');\r\n    const lastErrorType = failedAttempts.length > 0 ? failedAttempts[failedAttempts.length - 1].result : null;\r\n\r\n    // Determine status\r\n    let status: 'healthy' | 'degraded' | 'down' = 'healthy';\r\n    if (successRate < 0.5) {\r\n      status = 'down';\r\n    } else if (successRate < 0.9 || (p95 && p95 > 5000)) {\r\n      status = 'degraded';\r\n    }\r\n\r\n    const snapshot: Omit<FacilitatorHealthSnapshot, 'id' | 'created_at'> = {\r\n      facilitator_id: facilitatorId,\r\n      network,\r\n      token,\r\n      window_start: windowStart.toISOString(),\r\n      window_end: windowEnd.toISOString(),\r\n      success_rate: successRate,\r\n      p50_latency_ms: p50,\r\n      p95_latency_ms: p95,\r\n      p99_latency_ms: p99,\r\n      error_rate: errorRate,\r\n      last_error_type: lastErrorType,\r\n      status,\r\n    };\r\n\r\n    const saved = await upsertHealthSnapshot(snapshot);\r\n    logger.info(\r\n      {\r\n        facilitatorId,\r\n        network,\r\n        token,\r\n        successRate,\r\n        p95Latency: p95,\r\n        status,\r\n        attempts: attempts.length,\r\n      },\r\n      'Health snapshot created'\r\n    );\r\n\r\n    return saved;\r\n  } catch (error) {\r\n    logger.error({ error, facilitatorId, network, token }, 'Failed to aggregate health metrics');\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get current health for a facilitator/network/token\r\n * Returns latest snapshot or calculates from recent attempts\r\n */\r\nexport async function getCurrentHealth(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowMinutes: number = 15\r\n): Promise<{\r\n  successRate: number;\r\n  p50LatencyMs: number | null;\r\n  p95LatencyMs: number | null;\r\n  p99LatencyMs: number | null;\r\n  errorRate: number;\r\n  lastErrorType: string | null;\r\n  status: 'healthy' | 'degraded' | 'down';\r\n}> {\r\n  // Try to get latest snapshot first\r\n  const snapshot = await getLatestHealthSnapshot(facilitatorId, network, token);\r\n\r\n  if (snapshot) {\r\n    const snapshotAge = Date.now() - new Date(snapshot.window_end).getTime();\r\n    const maxAge = windowMinutes * 60 * 1000;\r\n\r\n    // If snapshot is recent enough, use it\r\n    if (snapshotAge < maxAge) {\r\n      return {\r\n        successRate: Number(snapshot.success_rate),\r\n        p50LatencyMs: snapshot.p50_latency_ms,\r\n        p95LatencyMs: snapshot.p95_latency_ms,\r\n        p99LatencyMs: snapshot.p99_latency_ms,\r\n        errorRate: Number(snapshot.error_rate),\r\n        lastErrorType: snapshot.last_error_type,\r\n        status: snapshot.status,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Otherwise, calculate from recent attempts\r\n  const windowEnd = new Date();\r\n  const windowStart = new Date(windowEnd.getTime() - windowMinutes * 60 * 1000);\r\n\r\n  const aggregated = await aggregateHealthMetrics(facilitatorId, network, token, windowStart, windowEnd);\r\n\r\n  if (aggregated) {\r\n    return {\r\n      successRate: Number(aggregated.success_rate),\r\n      p50LatencyMs: aggregated.p50_latency_ms,\r\n      p95LatencyMs: aggregated.p95_latency_ms,\r\n      p99LatencyMs: aggregated.p99_latency_ms,\r\n      errorRate: Number(aggregated.error_rate),\r\n      lastErrorType: aggregated.last_error_type,\r\n      status: aggregated.status,\r\n    };\r\n  }\r\n\r\n  // Default values if no data\r\n  return {\r\n    successRate: 1.0,\r\n    p50LatencyMs: null,\r\n    p95LatencyMs: null,\r\n    p99LatencyMs: null,\r\n    errorRate: 0.0,\r\n    lastErrorType: null,\r\n    status: 'healthy',\r\n  };\r\n}\r\n\r\n/**\r\n * Periodic job to update health snapshots\r\n * Should be called every 5-15 minutes\r\n */\r\nexport async function updateHealthSnapshots(windowMinutes: number = 15): Promise<void> {\r\n  logger.info({ windowMinutes }, 'Starting health snapshot update');\r\n\r\n  // Get all unique facilitator/network/token combinations from recent routes\r\n  // For now, we'll focus on CDP/Base/USDC - can be expanded later\r\n  const combinations = [\r\n    { facilitatorId: 'cdp', network: 'base', token: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' },\r\n  ];\r\n\r\n  const windowEnd = new Date();\r\n  const windowStart = new Date(windowEnd.getTime() - windowMinutes * 60 * 1000);\r\n\r\n  await Promise.all(\r\n    combinations.map(async (combo) => {\r\n      try {\r\n        await aggregateHealthMetrics(combo.facilitatorId, combo.network, combo.token, windowStart, windowEnd);\r\n      } catch (error) {\r\n        logger.error({ error, ...combo }, 'Failed to update health snapshot');\r\n      }\r\n    })\r\n  );\r\n\r\n  logger.info('Health snapshot update complete');\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3249, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/dummy-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// DUMMY FACILITATOR (FOR TESTING)\r\n// =============================================================================\r\n// Test facilitator that wraps CDP or provides mock behavior\r\n// Used to test routing logic, priority ties, failover, etc.\r\n\r\nimport { BaseFacilitator, type IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorHealth, type FacilitatorConfig } from './base-facilitator';\r\nimport { getCDPFacilitatorAdapter } from './cdp-facilitator-adapter';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'DummyFacilitator' });\r\n\r\n/**\r\n * Dummy Facilitator\r\n * \r\n * Can be configured to:\r\n * - Wrap CDP (for testing routing with same backend)\r\n * - Provide mock behavior (for testing without real payments)\r\n * - Simulate failures (for testing failover)\r\n */\r\nexport class DummyFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id: string;\r\n  readonly name: string;\r\n  readonly config: FacilitatorConfig;\r\n  \r\n  private wrapCDP: boolean;\r\n  private mockBehavior?: 'success' | 'failure' | 'timeout';\r\n  private cdpAdapter?: ReturnType<typeof getCDPFacilitatorAdapter>;\r\n\r\n  constructor(\r\n    id: string = 'dummy',\r\n    name: string = 'Dummy Facilitator',\r\n    config: Partial<FacilitatorConfig> = {},\r\n    options: {\r\n      wrapCDP?: boolean; // If true, wraps CDP adapter\r\n      mockBehavior?: 'success' | 'failure' | 'timeout'; // Mock behavior if not wrapping CDP\r\n    } = {}\r\n  ) {\r\n    super();\r\n    this.id = id;\r\n    this.name = name;\r\n    this.wrapCDP = options.wrapCDP ?? false;\r\n    this.mockBehavior = options.mockBehavior;\r\n\r\n    // Default config (can be overridden)\r\n    this.config = {\r\n      id: this.id,\r\n      name: this.name,\r\n      enabled: true,\r\n      priority: 2, // Lower priority than CDP (for testing priority-based routing)\r\n      networks: ['base'],\r\n      networksCAIP: ['eip155:8453'], // CAIP-2: Base mainnet\r\n      assets: ['0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // USDC on Base\r\n      assetsCAIP: ['eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // CAIP-19: USDC on Base\r\n      schemes: ['exact', 'x402'],\r\n      settlementModes: ['immediate'], // Default to immediate settlement\r\n      ...config,\r\n    };\r\n\r\n    if (this.wrapCDP) {\r\n      this.cdpAdapter = getCDPFacilitatorAdapter();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify payment\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    // If wrapping CDP, delegate to CDP\r\n    if (this.wrapCDP && this.cdpAdapter) {\r\n      logger.info({ payment: payment.substring(0, 20) + '...' }, 'Dummy facilitator delegating to CDP');\r\n      return await this.cdpAdapter.verify(payment, requirements);\r\n    }\r\n\r\n    // Mock behavior for testing\r\n    if (this.mockBehavior === 'failure') {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: 'Mock failure for testing',\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    if (this.mockBehavior === 'timeout') {\r\n      await new Promise((resolve) => setTimeout(resolve, 10000)); // 10 second delay\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: 'Mock timeout for testing',\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    // Mock success\r\n    return {\r\n      success: true,\r\n      valid: true,\r\n      transactionHash: `0x${Math.random().toString(16).substring(2, 66)}`,\r\n      kytStatus: 'passed',\r\n      ofacStatus: 'passed',\r\n      facilitatorId: this.id,\r\n      verifiedAt: new Date().toISOString(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get health status\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    // If wrapping CDP, delegate to CDP\r\n    if (this.wrapCDP && this.cdpAdapter) {\r\n      return await this.cdpAdapter.getHealth();\r\n    }\r\n\r\n    // Mock health (always healthy for testing)\r\n    return {\r\n      healthy: true,\r\n      latency: 50, // Mock low latency\r\n      lastChecked: new Date().toISOString(),\r\n      capabilities: {\r\n        networks: this.config.networks,\r\n        assets: this.config.assets,\r\n        schemes: this.config.schemes,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: string): boolean {\r\n    return super.supports(network, asset, scheme, settlementMode as any);\r\n  }\r\n\r\n  /**\r\n   * Get pricing (mock)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    if (this.wrapCDP && this.cdpAdapter) {\r\n      return await this.cdpAdapter.getPricing(network, asset);\r\n    }\r\n\r\n    // Mock pricing (slightly higher than CDP to test cost optimization)\r\n    if (network === 'base' && asset === '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913') {\r\n      return {\r\n        network: 'base',\r\n        asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n        baseFee: '1000', // Slightly higher than CDP\r\n        percentageFee: 0.001, // 0.1%\r\n        estimatedGas: '21000',\r\n        currency: 'USDC',\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Create a dummy facilitator for testing\r\n */\r\nexport function createDummyFacilitator(\r\n  id: string = 'dummy',\r\n  options?: {\r\n    wrapCDP?: boolean;\r\n    mockBehavior?: 'success' | 'failure' | 'timeout';\r\n    priority?: number;\r\n  }\r\n): DummyFacilitator {\r\n  return new DummyFacilitator(\r\n    id,\r\n    `Dummy Facilitator (${id})`,\r\n    {\r\n      priority: options?.priority ?? 2,\r\n    },\r\n    {\r\n      wrapCDP: options?.wrapCDP ?? false,\r\n      mockBehavior: options?.mockBehavior,\r\n    }\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3423, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/facilitator-router.ts"],"sourcesContent":["// =============================================================================\r\n// FACILITATOR ROUTER\r\n// =============================================================================\r\n// Smart routing logic for selecting the best facilitator based on policy\r\n// Implements \"meta-facilitator\" pattern: SDK expresses preferences, SMF owns policy\r\n\r\nimport { IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorConfig, type CAIPNetworkId, type CAIPAssetId, type SettlementMode } from './base-facilitator';\r\nimport { getCDPFacilitatorAdapter } from './cdp-facilitator-adapter';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { getCurrentHealth } from './health-aggregator';\r\nimport { getFacilitatorCapabilities } from '@/db/smf';\r\n\r\nconst logger = createLogger({ component: 'FacilitatorRouter' });\r\n\r\n/**\r\n * Routing preferences (from SDK/agent)\r\n * SDK expresses preferences, SMF owns policy\r\n */\r\nexport interface RoutingPreferences {\r\n  preferredNetworks?: string[]; // Legacy: e.g., ['solana', 'base']\r\n  preferredNetworksCAIP?: CAIPNetworkId[]; // CAIP-2 network identifiers\r\n  preferredAssets?: string[]; // Legacy: e.g., ['USDC']\r\n  preferredAssetsCAIP?: CAIPAssetId[]; // CAIP-19 asset identifiers\r\n  avoidNetworks?: string[]; // Legacy: e.g., ['ethereum'] (mainnet too expensive)\r\n  avoidNetworksCAIP?: CAIPNetworkId[]; // CAIP-2 networks to avoid\r\n  maxCost?: number; // Maximum cost in USD\r\n  requireCompliance?: boolean; // Require KYT/OFAC\r\n  priority?: 'cost' | 'speed' | 'reliability' | 'compliance';\r\n  jurisdiction?: string; // ISO country code (e.g., 'US', 'GB')\r\n  settlementMode?: SettlementMode; // Preferred settlement mode\r\n}\r\n\r\n/**\r\n * Routing policy (SMF business logic)\r\n * SMF owns higher-level policy above raw settlement\r\n */\r\nexport interface RoutingPolicy {\r\n  // Risk rules\r\n  riskThreshold?: number; // Max risk score (0-100)\r\n  requireKYC?: boolean; // Require KYC for certain amounts\r\n  \r\n  // Cost optimization\r\n  preferCheapest?: boolean; // Prefer cheapest facilitator\r\n  maxCostMultiplier?: number; // Max cost vs cheapest (1.5 = 50% premium)\r\n  \r\n  // Compliance rules\r\n  jurisdictionRules?: JurisdictionRule[];\r\n  \r\n  // Reliability\r\n  requireHealthCheck?: boolean; // Only route to healthy facilitators\r\n  minUptime?: number; // Minimum uptime percentage (0-1)\r\n  \r\n  // Custom rules\r\n  customRules?: (facilitator: IFacilitator, requirements: PaymentRequirements) => boolean;\r\n}\r\n\r\n/**\r\n * Jurisdiction-based routing rules\r\n */\r\nexport interface JurisdictionRule {\r\n  country?: string; // ISO country code\r\n  region?: string; // Region name\r\n  allowedNetworks?: string[];\r\n  requiredKYC?: boolean;\r\n  maxAmount?: string; // Max amount in smallest units\r\n  blockedFacilitators?: string[]; // Facilitator IDs to avoid\r\n}\r\n\r\n/**\r\n * Facilitator router\r\n * Implements smart routing based on preferences and policy\r\n */\r\nexport class FacilitatorRouter {\r\n  private facilitators: Map<string, IFacilitator> = new Map();\r\n  private facilitatorHealth: Map<string, { healthy: boolean; lastChecked: number }> = new Map();\r\n  private healthCheckInterval: NodeJS.Timeout | null = null;\r\n\r\n  constructor() {\r\n    // Register default facilitators\r\n    this.registerFacilitator(getCDPFacilitatorAdapter());\r\n    \r\n    // Register dummy facilitator for testing (wraps CDP, different priority)\r\n    // This allows testing routing logic, priority ties, failover, etc.\r\n    if (process.env.ENABLE_DUMMY_FACILITATOR === 'true') {\r\n      const { createDummyFacilitator } = require('./dummy-facilitator');\r\n      const dummy = createDummyFacilitator('dummy', {\r\n        wrapCDP: true, // Wrap CDP for realistic testing\r\n        priority: 2, // Lower priority than CDP\r\n      });\r\n      this.registerFacilitator(dummy);\r\n    }\r\n    \r\n    // Start health check interval (every 5 minutes)\r\n    this.startHealthChecks();\r\n  }\r\n\r\n  /**\r\n   * Register a facilitator\r\n   */\r\n  registerFacilitator(facilitator: IFacilitator): void {\r\n    this.facilitators.set(facilitator.id, facilitator);\r\n    logger.info({ facilitatorId: facilitator.id, name: facilitator.name }, 'Facilitator registered');\r\n  }\r\n\r\n  /**\r\n   * Unregister a facilitator\r\n   */\r\n  unregisterFacilitator(facilitatorId: string): void {\r\n    this.facilitators.delete(facilitatorId);\r\n    this.facilitatorHealth.delete(facilitatorId);\r\n    logger.info({ facilitatorId }, 'Facilitator unregistered');\r\n  }\r\n\r\n  /**\r\n   * Get all registered facilitators\r\n   */\r\n  getFacilitators(): IFacilitator[] {\r\n    return Array.from(this.facilitators.values());\r\n  }\r\n\r\n  /**\r\n   * Route payment to best facilitator\r\n   * \r\n   * @param requirements - Payment requirements\r\n   * @param preferences - SDK/agent preferences\r\n   * @param policy - SMF business logic policy\r\n   */\r\n  async routePayment(\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): Promise<IFacilitator> {\r\n    // Get eligible facilitators\r\n    const eligible = this.getEligibleFacilitators(requirements, preferences, policy);\r\n\r\n    if (eligible.length === 0) {\r\n      throw new Error(\r\n        `No eligible facilitator found for ${requirements.network}/${requirements.asset}/${requirements.scheme}`\r\n      );\r\n    }\r\n\r\n    // Score and rank facilitators\r\n    const scored = await this.scoreFacilitators(eligible, requirements, preferences, policy);\r\n\r\n    // Select best facilitator\r\n    const best = scored[0].facilitator;\r\n    \r\n    // Log decision trace (compact format for explainer/debugger UI)\r\n    logger.info({\r\n      facilitatorId: best.id,\r\n      score: scored[0].score,\r\n      alternatives: scored.length - 1,\r\n      reasons: scored[0].reasons,\r\n      constraints: {\r\n        preferences: preferences ? {\r\n          priority: preferences.priority,\r\n          preferredNetworks: preferences.preferredNetworks,\r\n          preferredAssets: preferences.preferredAssets,\r\n        } : undefined,\r\n        settlementMode: requirements.settlementMode,\r\n      },\r\n      candidates: scored.map((s) => ({\r\n        id: s.facilitator.id,\r\n        score: s.score,\r\n        reasons: s.reasons,\r\n      })),\r\n    }, 'Facilitator selected');\r\n\r\n    return best;\r\n  }\r\n\r\n  /**\r\n   * Get eligible facilitators based on requirements, preferences, and policy\r\n   * Extended to support CAIP identifiers and settlement modes\r\n   */\r\n  private getEligibleFacilitators(\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): IFacilitator[] {\r\n    const facilitators = Array.from(this.facilitators.values());\r\n\r\n    return facilitators.filter((facilitator) => {\r\n      // 1. Check basic support (legacy or CAIP)\r\n      let supportsNetwork = false;\r\n      let supportsAsset = false;\r\n\r\n      // Check network support\r\n      if (requirements.networks && requirements.networks.length > 0) {\r\n        // CAIP networks\r\n        supportsNetwork = requirements.networks.some((n) =>\r\n          facilitator.supportsCAIPNetwork(n)\r\n        );\r\n      } else {\r\n        // Legacy network\r\n        supportsNetwork = facilitator.config.networks.includes(requirements.network);\r\n      }\r\n\r\n      // Check asset support\r\n      if (requirements.assets && requirements.assets.length > 0) {\r\n        // CAIP assets\r\n        supportsAsset = requirements.assets.some((a) =>\r\n          facilitator.supportsCAIPAsset(a)\r\n        );\r\n      } else {\r\n        // Legacy asset\r\n        supportsAsset = facilitator.config.assets.includes(requirements.asset);\r\n      }\r\n\r\n      if (\r\n        !supportsNetwork ||\r\n        !supportsAsset ||\r\n        !facilitator.supports(\r\n          requirements.network,\r\n          requirements.asset,\r\n          requirements.scheme,\r\n          requirements.settlementMode\r\n        )\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      // 2. Check if enabled\r\n      if (!facilitator.config.enabled) {\r\n        return false;\r\n      }\r\n\r\n      // 3. Check preferences (SDK preferences) - support both legacy and CAIP\r\n      const preferredNetworks = [\r\n        ...(preferences?.preferredNetworks || []),\r\n        ...(preferences?.preferredNetworksCAIP || []),\r\n      ];\r\n      if (preferredNetworks.length > 0) {\r\n        const facilitatorNetworks = [\r\n          ...facilitator.config.networks,\r\n          ...(facilitator.config.networksCAIP || []),\r\n        ];\r\n        if (!preferredNetworks.some((p) => facilitatorNetworks.some((n) => n.includes(p) || p.includes(n)))) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      const avoidedNetworks = [\r\n        ...(preferences?.avoidNetworks || []),\r\n        ...(preferences?.avoidNetworksCAIP || []),\r\n      ];\r\n      if (avoidedNetworks.length > 0) {\r\n        const facilitatorNetworks = [\r\n          ...facilitator.config.networks,\r\n          ...(facilitator.config.networksCAIP || []),\r\n        ];\r\n        if (avoidedNetworks.some((a) => facilitatorNetworks.some((n) => n.includes(a) || a.includes(n)))) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      const preferredAssets = [\r\n        ...(preferences?.preferredAssets || []),\r\n        ...(preferences?.preferredAssetsCAIP || []),\r\n      ];\r\n      if (preferredAssets.length > 0) {\r\n        const facilitatorAssets = [\r\n          ...facilitator.config.assets,\r\n          ...(facilitator.config.assetsCAIP || []),\r\n        ];\r\n        if (!preferredAssets.some((p) => facilitatorAssets.some((a) => a.includes(p) || p.includes(a)))) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // 3b. Check jurisdiction (if specified)\r\n      if (preferences?.jurisdiction) {\r\n        // This would integrate with jurisdiction rules\r\n        // For now, pass through (can be enhanced later)\r\n      }\r\n\r\n      // 3c. Check settlement mode preference\r\n      if (preferences?.settlementMode) {\r\n        if (facilitator.config.settlementModes && !facilitator.config.settlementModes.includes(preferences.settlementMode)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // 4. Check policy (SMF business logic)\r\n      if (policy?.requireHealthCheck) {\r\n        const health = this.facilitatorHealth.get(facilitator.id);\r\n        if (!health || !health.healthy) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (policy?.customRules) {\r\n        if (!policy.customRules(facilitator, requirements)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // 5. Check compliance requirements\r\n      if (preferences?.requireCompliance || policy?.requireKYC) {\r\n        // Check if facilitator supports compliance\r\n        const metadata = facilitator.config.metadata;\r\n        if (!metadata?.kytEnabled && !metadata?.ofacEnabled) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Score facilitators based on preferences and policy\r\n   * Uses real health metrics from database for accurate scoring\r\n   * Handles priority ties with randomization\r\n   * Exposed for decision trace building\r\n   */\r\n  public async scoreFacilitators(\r\n    facilitators: IFacilitator[],\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): Promise<Array<{ facilitator: IFacilitator; score: number; reasons: string[] }>> {\r\n    const scored = await Promise.all(\r\n      facilitators.map(async (facilitator) => {\r\n        let score = 100; // Start with base score\r\n        const reasons: string[] = [];\r\n\r\n        // 1. Base priority (lower priority number = higher priority)\r\n        const basePriority = facilitator.config.priority;\r\n        score += basePriority * 10;\r\n        reasons.push(`priority:${basePriority}`);\r\n\r\n        // 2. Get real health metrics from database\r\n        const network = requirements.network;\r\n        const token = requirements.asset;\r\n        let healthMetrics;\r\n        try {\r\n          healthMetrics = await getCurrentHealth(facilitator.id, network, token, 15);\r\n        } catch (error) {\r\n          logger.warn({ error, facilitatorId: facilitator.id, network, token }, 'Failed to get health metrics, using defaults');\r\n          healthMetrics = {\r\n            successRate: 1.0,\r\n            p95LatencyMs: null,\r\n            errorRate: 0.0,\r\n            status: 'healthy' as const,\r\n          };\r\n        }\r\n\r\n        // 3. Success rate scoring (w1 * successRate)\r\n        const w1 = 50; // Weight for success rate\r\n        const successRateScore = healthMetrics.successRate * w1;\r\n        score += successRateScore;\r\n        reasons.push(`success-rate:${(healthMetrics.successRate * 100).toFixed(1)}%`);\r\n\r\n        // 4. Latency scoring (w2 * p95LatencyMs) - lower is better\r\n        const w2 = 0.1; // Weight for latency penalty\r\n        if (healthMetrics.p95LatencyMs !== null) {\r\n          const latencyPenalty = healthMetrics.p95LatencyMs * w2;\r\n          score -= latencyPenalty;\r\n          reasons.push(`p95-latency:${healthMetrics.p95LatencyMs}ms`);\r\n        }\r\n\r\n        // 5. Fee scoring (w3 * feeBps) - get from capabilities\r\n        const w3 = 0.5; // Weight for fee penalty\r\n        try {\r\n          const capabilities = await getFacilitatorCapabilities(facilitator.id, network, token);\r\n          const capability = capabilities[0];\r\n          if (capability) {\r\n            const feePenalty = capability.fee_bps * w3;\r\n            score -= feePenalty;\r\n            reasons.push(`fee:${capability.fee_bps}bps`);\r\n          }\r\n        } catch (error) {\r\n          logger.debug({ error, facilitatorId: facilitator.id }, 'Failed to get capabilities for fee scoring');\r\n        }\r\n\r\n        // 6. Risk penalty (w4 * riskPenalty) - based on error rate and status\r\n        const w4 = 30; // Weight for risk penalty\r\n        const riskPenalty = healthMetrics.errorRate * w4;\r\n        score -= riskPenalty;\r\n        if (healthMetrics.status === 'down') {\r\n          score -= 50; // Heavy penalty for down status\r\n          reasons.push('status:down');\r\n        } else if (healthMetrics.status === 'degraded') {\r\n          score -= 25; // Moderate penalty for degraded\r\n          reasons.push('status:degraded');\r\n        }\r\n\r\n        // 7. Health status check (cached)\r\n        const health = this.facilitatorHealth.get(facilitator.id);\r\n        if (health && !health.healthy) {\r\n          score -= 30; // Additional penalty for unhealthy in cache\r\n          reasons.push('cache-unhealthy');\r\n        }\r\n\r\n        // 8. Cost optimization (if policy requires)\r\n        if (policy?.preferCheapest || preferences?.priority === 'cost') {\r\n          const pricing = await facilitator.getPricing(requirements.network, requirements.asset);\r\n          if (pricing) {\r\n            // Lower cost = higher score (normalize)\r\n            score += 20; // Bonus for having pricing info\r\n            reasons.push('has-pricing');\r\n          }\r\n        }\r\n\r\n        // 9. Speed optimization (if preference)\r\n        if (preferences?.priority === 'speed') {\r\n          if (healthMetrics.p95LatencyMs !== null) {\r\n            // Lower latency = higher score\r\n            const latencyBonus = Math.max(0, 30 - healthMetrics.p95LatencyMs / 10);\r\n            score += latencyBonus;\r\n            reasons.push(`speed-optimized:${healthMetrics.p95LatencyMs}ms`);\r\n          }\r\n        }\r\n\r\n        // 10. Compliance optimization\r\n        if (preferences?.priority === 'compliance' || policy?.requireKYC) {\r\n          const metadata = facilitator.config.metadata;\r\n          if (metadata?.kytEnabled && metadata?.ofacEnabled) {\r\n            score += 30; // Bonus for compliance\r\n            reasons.push('compliance-enabled');\r\n          }\r\n        }\r\n\r\n        // 11. Reliability optimization\r\n        if (preferences?.priority === 'reliability') {\r\n          if (healthMetrics.status === 'healthy' && healthMetrics.successRate > 0.95) {\r\n            score += 25;\r\n            reasons.push('high-reliability');\r\n          }\r\n        }\r\n\r\n        // 12. Settlement mode optimization\r\n        if (requirements.settlementMode) {\r\n          if (facilitator.config.settlementModes?.includes(requirements.settlementMode)) {\r\n            score += 15; // Bonus for supporting requested settlement mode\r\n            reasons.push(`settlement:${requirements.settlementMode}`);\r\n          }\r\n        }\r\n\r\n        return { facilitator, score, reasons };\r\n      })\r\n    );\r\n\r\n    // Sort by score (highest first)\r\n    const sorted = scored.sort((a, b) => b.score - a.score);\r\n\r\n    // Handle priority ties with randomization\r\n    // If top scores are within 5 points, randomize order\r\n    if (sorted.length > 1) {\r\n      const topScore = sorted[0].score;\r\n      const tied = sorted.filter((s) => Math.abs(s.score - topScore) <= 5);\r\n      \r\n      if (tied.length > 1) {\r\n        // Shuffle tied facilitators\r\n        for (let i = tied.length - 1; i > 0; i--) {\r\n          const j = Math.floor(Math.random() * (i + 1));\r\n          [tied[i], tied[j]] = [tied[j], tied[i]];\r\n        }\r\n        // Rebuild sorted array with shuffled ties\r\n        const rest = sorted.filter((s) => Math.abs(s.score - topScore) > 5);\r\n        return [...tied, ...rest];\r\n      }\r\n    }\r\n\r\n    return sorted;\r\n  }\r\n\r\n  /**\r\n   * Start periodic health checks\r\n   */\r\n  private startHealthChecks(): void {\r\n    this.healthCheckInterval = setInterval(async () => {\r\n      await this.checkAllFacilitators();\r\n    }, 5 * 60 * 1000); // Every 5 minutes\r\n\r\n    // Initial health check\r\n    this.checkAllFacilitators();\r\n  }\r\n\r\n  /**\r\n   * Check health of all facilitators\r\n   */\r\n  private async checkAllFacilitators(): Promise<void> {\r\n    const facilitators = Array.from(this.facilitators.values());\r\n    \r\n    await Promise.all(\r\n      facilitators.map(async (facilitator) => {\r\n        try {\r\n          const health = await facilitator.getHealth();\r\n          this.facilitatorHealth.set(facilitator.id, {\r\n            healthy: health.healthy,\r\n            lastChecked: Date.now(),\r\n          });\r\n        } catch (error) {\r\n          logger.error({ facilitatorId: facilitator.id, error }, 'Health check failed');\r\n          this.facilitatorHealth.set(facilitator.id, {\r\n            healthy: false,\r\n            lastChecked: Date.now(),\r\n          });\r\n        }\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get facilitator by ID\r\n   */\r\n  getFacilitator(id: string): IFacilitator | undefined {\r\n    return this.facilitators.get(id);\r\n  }\r\n\r\n  /**\r\n   * Get facilitator health status\r\n   */\r\n  getFacilitatorHealth(id: string): { healthy: boolean; lastChecked: number } | undefined {\r\n    return this.facilitatorHealth.get(id);\r\n  }\r\n\r\n  /**\r\n   * Cleanup\r\n   */\r\n  destroy(): void {\r\n    if (this.healthCheckInterval) {\r\n      clearInterval(this.healthCheckInterval);\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet router: FacilitatorRouter | null = null;\r\n\r\n/**\r\n * Get facilitator router instance\r\n */\r\nexport function getFacilitatorRouter(): FacilitatorRouter {\r\n  if (!router) {\r\n    router = new FacilitatorRouter();\r\n  }\r\n  return router;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3852, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/app/api/v1/smf/health/route.ts"],"sourcesContent":["// =============================================================================\r\n// SMF Health API\r\n// =============================================================================\r\n// GET /api/v1/smf/health\r\n// Returns summary health status for all facilitators\r\n\r\nimport { NextResponse } from 'next/server';\r\nimport { getFacilitatorRouter } from '@/integrations/x402/facilitators/facilitator-router';\r\nimport { getLatestHealthSnapshot, getFacilitatorCapabilities } from '@/db/smf';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'SMFHealthAPI' });\r\n\r\nexport async function GET() {\r\n  try {\r\n    const router = getFacilitatorRouter();\r\n    const facilitators = router.getFacilitators();\r\n\r\n    const healthStatus = await Promise.all(\r\n      facilitators.map(async (facilitator) => {\r\n        try {\r\n          // Get latest health snapshot\r\n          const snapshot = await getLatestHealthSnapshot(\r\n            facilitator.id,\r\n            'base', // Default network - can be made configurable\r\n            '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' // Default token - can be made configurable\r\n          );\r\n\r\n          // Get cached health\r\n          const cachedHealth = router.getFacilitatorHealth(facilitator.id);\r\n\r\n          // Determine overall status\r\n          let status: 'healthy' | 'degraded' | 'down' = 'healthy';\r\n          let reasons: string[] = [];\r\n\r\n          if (snapshot) {\r\n            status = snapshot.status;\r\n            if (snapshot.success_rate < 0.5) {\r\n              reasons.push('low-success-rate');\r\n            }\r\n            if (snapshot.p95_latency_ms && snapshot.p95_latency_ms > 5000) {\r\n              reasons.push('high-latency');\r\n            }\r\n            if (snapshot.error_rate > 0.1) {\r\n              reasons.push('high-error-rate');\r\n            }\r\n          }\r\n\r\n          if (cachedHealth && !cachedHealth.healthy) {\r\n            status = 'down';\r\n            reasons.push('health-check-failed');\r\n          }\r\n\r\n          return {\r\n            facilitatorId: facilitator.id,\r\n            name: facilitator.name,\r\n            status,\r\n            reasons: reasons.length > 0 ? reasons : undefined,\r\n            metrics: snapshot\r\n              ? {\r\n                  successRate: Number(snapshot.success_rate),\r\n                  p95LatencyMs: snapshot.p95_latency_ms,\r\n                  errorRate: Number(snapshot.error_rate),\r\n                  lastErrorType: snapshot.last_error_type,\r\n                  lastUpdated: snapshot.window_end,\r\n                }\r\n              : undefined,\r\n            cached: cachedHealth\r\n              ? {\r\n                  healthy: cachedHealth.healthy,\r\n                  lastChecked: new Date(cachedHealth.lastChecked).toISOString(),\r\n                }\r\n              : undefined,\r\n          };\r\n        } catch (error) {\r\n          logger.error({ error, facilitatorId: facilitator.id }, 'Failed to get health status');\r\n          return {\r\n            facilitatorId: facilitator.id,\r\n            name: facilitator.name,\r\n            status: 'down' as const,\r\n            reasons: ['health-check-error'],\r\n          };\r\n        }\r\n      })\r\n    );\r\n\r\n    // Determine overall system status\r\n    const healthyCount = healthStatus.filter((h) => h.status === 'healthy').length;\r\n    const degradedCount = healthStatus.filter((h) => h.status === 'degraded').length;\r\n    const downCount = healthStatus.filter((h) => h.status === 'down').length;\r\n\r\n    let systemStatus: 'healthy' | 'degraded' | 'down' = 'healthy';\r\n    if (downCount > 0) {\r\n      systemStatus = 'down';\r\n    } else if (degradedCount > 0) {\r\n      systemStatus = 'degraded';\r\n    }\r\n\r\n    return NextResponse.json({\r\n      status: systemStatus,\r\n      summary: {\r\n        total: facilitators.length,\r\n        healthy: healthyCount,\r\n        degraded: degradedCount,\r\n        down: downCount,\r\n      },\r\n      facilitators: healthStatus,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  } catch (error) {\r\n    logger.error({ error }, 'Failed to get SMF health');\r\n    return NextResponse.json(\r\n      {\r\n        status: 'down',\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        timestamp: new Date().toISOString(),\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,iBAAiB;AACjB,gFAAgF;AAChF,yBAAyB;AACzB,qDAAqD;;;;;AAErD;AACA;AACA;AACA;;;;;;;;;;AAEA,MAAM,SAAS,IAAA,sIAAY,EAAC;IAAE,WAAW;AAAe;AAEjD,eAAe;IACpB,IAAI;QACF,MAAM,SAAS,IAAA,8LAAoB;QACnC,MAAM,eAAe,OAAO,eAAe;QAE3C,MAAM,eAAe,MAAM,QAAQ,GAAG,CACpC,aAAa,GAAG,CAAC,OAAO;YACtB,IAAI;gBACF,6BAA6B;gBAC7B,MAAM,WAAW,MAAM,IAAA,6IAAuB,EAC5C,YAAY,EAAE,EACd,QACA,6CAA6C,2CAA2C;;gBAG1F,oBAAoB;gBACpB,MAAM,eAAe,OAAO,oBAAoB,CAAC,YAAY,EAAE;gBAE/D,2BAA2B;gBAC3B,IAAI,SAA0C;gBAC9C,IAAI,UAAoB,EAAE;gBAE1B,IAAI,UAAU;oBACZ,SAAS,SAAS,MAAM;oBACxB,IAAI,SAAS,YAAY,GAAG,KAAK;wBAC/B,QAAQ,IAAI,CAAC;oBACf;oBACA,IAAI,SAAS,cAAc,IAAI,SAAS,cAAc,GAAG,MAAM;wBAC7D,QAAQ,IAAI,CAAC;oBACf;oBACA,IAAI,SAAS,UAAU,GAAG,KAAK;wBAC7B,QAAQ,IAAI,CAAC;oBACf;gBACF;gBAEA,IAAI,gBAAgB,CAAC,aAAa,OAAO,EAAE;oBACzC,SAAS;oBACT,QAAQ,IAAI,CAAC;gBACf;gBAEA,OAAO;oBACL,eAAe,YAAY,EAAE;oBAC7B,MAAM,YAAY,IAAI;oBACtB;oBACA,SAAS,QAAQ,MAAM,GAAG,IAAI,UAAU;oBACxC,SAAS,WACL;wBACE,aAAa,OAAO,SAAS,YAAY;wBACzC,cAAc,SAAS,cAAc;wBACrC,WAAW,OAAO,SAAS,UAAU;wBACrC,eAAe,SAAS,eAAe;wBACvC,aAAa,SAAS,UAAU;oBAClC,IACA;oBACJ,QAAQ,eACJ;wBACE,SAAS,aAAa,OAAO;wBAC7B,aAAa,IAAI,KAAK,aAAa,WAAW,EAAE,WAAW;oBAC7D,IACA;gBACN;YACF,EAAE,OAAO,OAAO;gBACd,OAAO,KAAK,CAAC;oBAAE;oBAAO,eAAe,YAAY,EAAE;gBAAC,GAAG;gBACvD,OAAO;oBACL,eAAe,YAAY,EAAE;oBAC7B,MAAM,YAAY,IAAI;oBACtB,QAAQ;oBACR,SAAS;wBAAC;qBAAqB;gBACjC;YACF;QACF;QAGF,kCAAkC;QAClC,MAAM,eAAe,aAAa,MAAM,CAAC,CAAC,IAAM,EAAE,MAAM,KAAK,WAAW,MAAM;QAC9E,MAAM,gBAAgB,aAAa,MAAM,CAAC,CAAC,IAAM,EAAE,MAAM,KAAK,YAAY,MAAM;QAChF,MAAM,YAAY,aAAa,MAAM,CAAC,CAAC,IAAM,EAAE,MAAM,KAAK,QAAQ,MAAM;QAExE,IAAI,eAAgD;QACpD,IAAI,YAAY,GAAG;YACjB,eAAe;QACjB,OAAO,IAAI,gBAAgB,GAAG;YAC5B,eAAe;QACjB;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,QAAQ;YACR,SAAS;gBACP,OAAO,aAAa,MAAM;gBAC1B,SAAS;gBACT,UAAU;gBACV,MAAM;YACR;YACA,cAAc;YACd,WAAW,IAAI,OAAO,WAAW;QACnC;IACF,EAAE,OAAO,OAAO;QACd,OAAO,KAAK,CAAC;YAAE;QAAM,GAAG;QACxB,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,QAAQ;YACR,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;YAChD,WAAW,IAAI,OAAO,WAAW;QACnC,GACA;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}