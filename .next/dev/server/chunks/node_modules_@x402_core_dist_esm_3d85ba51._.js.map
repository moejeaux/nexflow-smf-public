{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/node_modules/%40x402/core/src/index.ts"],"sourcesContent":["export const x402Version = 2;\n"],"names":[],"mappings":";;;;;AAAO,IAAM,cAAc"}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/node_modules/%40x402/core/src/types/facilitator.ts"],"sourcesContent":["import { PaymentPayload, PaymentRequirements } from \"./payments\";\nimport { Network } from \"./\";\n\nexport type VerifyRequest = {\n  paymentPayload: PaymentPayload;\n  paymentRequirements: PaymentRequirements;\n};\n\nexport type VerifyResponse = {\n  isValid: boolean;\n  invalidReason?: string;\n  payer?: string;\n};\n\nexport type SettleRequest = {\n  paymentPayload: PaymentPayload;\n  paymentRequirements: PaymentRequirements;\n};\n\nexport type SettleResponse = {\n  success: boolean;\n  errorReason?: string;\n  payer?: string;\n  transaction: string;\n  network: Network;\n};\n\nexport type SupportedKind = {\n  x402Version: number;\n  scheme: string;\n  network: Network;\n  extra?: Record<string, unknown>;\n};\n\nexport type SupportedResponse = {\n  kinds: SupportedKind[];\n  extensions: string[];\n  signers: Record<string, string[]>; // CAIP family pattern â†’ Signer addresses\n};\n\n/**\n * Error thrown when payment verification fails.\n */\nexport class VerifyError extends Error {\n  readonly invalidReason?: string;\n  readonly payer?: string;\n  readonly statusCode: number;\n\n  /**\n   * Creates a VerifyError from a failed verification response.\n   *\n   * @param statusCode - HTTP status code from the facilitator\n   * @param response - The verify response containing error details\n   */\n  constructor(statusCode: number, response: VerifyResponse) {\n    super(`verification failed: ${response.invalidReason || \"unknown reason\"}`);\n    this.name = \"VerifyError\";\n    this.statusCode = statusCode;\n    this.invalidReason = response.invalidReason;\n    this.payer = response.payer;\n  }\n}\n\n/**\n * Error thrown when payment settlement fails.\n */\nexport class SettleError extends Error {\n  readonly errorReason?: string;\n  readonly payer?: string;\n  readonly transaction: string;\n  readonly network: Network;\n  readonly statusCode: number;\n\n  /**\n   * Creates a SettleError from a failed settlement response.\n   *\n   * @param statusCode - HTTP status code from the facilitator\n   * @param response - The settle response containing error details\n   */\n  constructor(statusCode: number, response: SettleResponse) {\n    super(`settlement failed: ${response.errorReason || \"unknown reason\"}`);\n    this.name = \"SettleError\";\n    this.statusCode = statusCode;\n    this.errorReason = response.errorReason;\n    this.payer = response.payer;\n    this.transaction = response.transaction;\n    this.network = response.network;\n  }\n}\n"],"names":[],"mappings":";;;;;;;AA2CO,IAAM,cAAN,cAA0B,MAAM;IAAA;;;;;GAAA,GAWrC,YAAY,UAAA,EAAoB,QAAA,CAA0B;QACxD,KAAA,CAAM,CAAA,qBAAA,EAAwB,SAAS,aAAA,IAAiB,gBAAgB,EAAE;QAC1E,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,UAAA,GAAa;QAClB,IAAA,CAAK,aAAA,GAAgB,SAAS,aAAA;QAC9B,IAAA,CAAK,KAAA,GAAQ,SAAS,KAAA;IACxB;AACF;AAKO,IAAM,cAAN,cAA0B,MAAM;IAAA;;;;;GAAA,GAarC,YAAY,UAAA,EAAoB,QAAA,CAA0B;QACxD,KAAA,CAAM,CAAA,mBAAA,EAAsB,SAAS,WAAA,IAAe,gBAAgB,EAAE;QACtE,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,UAAA,GAAa;QAClB,IAAA,CAAK,WAAA,GAAc,SAAS,WAAA;QAC5B,IAAA,CAAK,KAAA,GAAQ,SAAS,KAAA;QACtB,IAAA,CAAK,WAAA,GAAc,SAAS,WAAA;QAC5B,IAAA,CAAK,OAAA,GAAU,SAAS,OAAA;IAC1B;AACF"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/node_modules/%40x402/core/src/utils/index.ts"],"sourcesContent":["import { Network } from \"../types\";\n\n/**\n * Scheme data structure for facilitator storage\n */\nexport interface SchemeData<T> {\n  facilitator: T;\n  networks: Set<Network>;\n  pattern: Network;\n}\n\nexport const findSchemesByNetwork = <T>(\n  map: Map<string, Map<string, T>>,\n  network: Network,\n): Map<string, T> | undefined => {\n  // Direct match first\n  let implementationsByScheme = map.get(network);\n\n  if (!implementationsByScheme) {\n    // Try pattern matching for registered network patterns\n    for (const [registeredNetworkPattern, implementations] of map.entries()) {\n      // Convert the registered network pattern to a regex\n      // e.g., \"eip155:*\" becomes /^eip155:.*$/\n      const pattern = registeredNetworkPattern\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\") // Escape special regex chars except *\n        .replace(/\\\\\\*/g, \".*\"); // Replace escaped * with .*\n\n      const regex = new RegExp(`^${pattern}$`);\n\n      if (regex.test(network)) {\n        implementationsByScheme = implementations;\n        break;\n      }\n    }\n  }\n\n  return implementationsByScheme;\n};\n\nexport const findByNetworkAndScheme = <T>(\n  map: Map<string, Map<string, T>>,\n  scheme: string,\n  network: Network,\n): T | undefined => {\n  return findSchemesByNetwork(map, network)?.get(scheme);\n};\n\n/**\n * Finds a facilitator by scheme and network using pattern matching.\n * Works with new SchemeData storage structure.\n *\n * @param schemeMap - Map of scheme names to SchemeData\n * @param scheme - The scheme to find\n * @param network - The network to match against\n * @returns The facilitator if found, undefined otherwise\n */\nexport const findFacilitatorBySchemeAndNetwork = <T>(\n  schemeMap: Map<string, SchemeData<T>>,\n  scheme: string,\n  network: Network,\n): T | undefined => {\n  const schemeData = schemeMap.get(scheme);\n  if (!schemeData) return undefined;\n\n  // Check if network is in the stored networks set\n  if (schemeData.networks.has(network)) {\n    return schemeData.facilitator;\n  }\n\n  // Try pattern matching\n  const patternRegex = new RegExp(\"^\" + schemeData.pattern.replace(\"*\", \".*\") + \"$\");\n  if (patternRegex.test(network)) {\n    return schemeData.facilitator;\n  }\n\n  return undefined;\n};\n\nexport const Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n\n/**\n * Encodes a string to base64 format\n *\n * @param data - The string to be encoded to base64\n * @returns The base64 encoded string\n */\nexport function safeBase64Encode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return globalThis.btoa(data);\n  }\n  return Buffer.from(data).toString(\"base64\");\n}\n\n/**\n * Decodes a base64 string back to its original format\n *\n * @param data - The base64 encoded string to be decoded\n * @returns The decoded string in UTF-8 format\n */\nexport function safeBase64Decode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    return globalThis.atob(data);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n\n/**\n * Deep equality comparison for payment requirements\n * Uses a normalized JSON.stringify for consistent comparison\n *\n * @param obj1 - First object to compare\n * @param obj2 - Second object to compare\n * @returns True if objects are deeply equal\n */\nexport function deepEqual(obj1: unknown, obj2: unknown): boolean {\n  // Normalize and stringify both objects for comparison\n  // This handles nested objects, arrays, and different property orders\n  const normalize = (obj: unknown): string => {\n    // Handle primitives and null/undefined\n    if (obj === null || obj === undefined) return JSON.stringify(obj);\n    if (typeof obj !== \"object\") return JSON.stringify(obj);\n\n    // Handle arrays\n    if (Array.isArray(obj)) {\n      return JSON.stringify(\n        obj.map(item =>\n          typeof item === \"object\" && item !== null ? JSON.parse(normalize(item)) : item,\n        ),\n      );\n    }\n\n    // Handle objects - sort keys and recursively normalize values\n    const sorted: Record<string, unknown> = {};\n    Object.keys(obj as Record<string, unknown>)\n      .sort()\n      .forEach(key => {\n        const value = (obj as Record<string, unknown>)[key];\n        sorted[key] =\n          typeof value === \"object\" && value !== null ? JSON.parse(normalize(value)) : value;\n      });\n    return JSON.stringify(sorted);\n  };\n\n  try {\n    return normalize(obj1) === normalize(obj2);\n  } catch {\n    // Fallback to simple comparison if normalization fails\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAWO,IAAM,uBAAuB,CAClC,KACA,YAC+B;IAE/B,IAAI,0BAA0B,IAAI,GAAA,CAAI,OAAO;IAE7C,IAAI,CAAC,yBAAyB;QAE5B,KAAA,MAAW,CAAC,0BAA0B,eAAe,CAAA,IAAK,IAAI,OAAA,CAAQ,EAAG;YAGvE,MAAM,UAAU,yBACb,OAAA,CAAQ,uBAAuB,MAAM,EACrC,OAAA,CAAQ,SAAS,IAAI;YAExB,MAAM,QAAQ,IAAI,OAAO,CAAA,CAAA,EAAI,OAAO,CAAA,CAAA,CAAG;YAEvC,IAAI,MAAM,IAAA,CAAK,OAAO,GAAG;gBACvB,0BAA0B;gBAC1B;YACF;QACF;IACF;IAEA,OAAO;AACT;AAEO,IAAM,yBAAyB,CACpC,KACA,QACA,YACkB;IAClB,OAAO,qBAAqB,KAAK,OAAO,GAAG,IAAI,MAAM;AACvD;AAWO,IAAM,oCAAoC,CAC/C,WACA,QACA,YACkB;IAClB,MAAM,aAAa,UAAU,GAAA,CAAI,MAAM;IACvC,IAAI,CAAC,WAAY,CAAA,OAAO,KAAA;IAGxB,IAAI,WAAW,QAAA,CAAS,GAAA,CAAI,OAAO,GAAG;QACpC,OAAO,WAAW,WAAA;IACpB;IAGA,MAAM,eAAe,IAAI,OAAO,MAAM,WAAW,OAAA,CAAQ,OAAA,CAAQ,KAAK,IAAI,IAAI,GAAG;IACjF,IAAI,aAAa,IAAA,CAAK,OAAO,GAAG;QAC9B,OAAO,WAAW,WAAA;IACpB;IAEA,OAAO,KAAA;AACT;AAEO,IAAM,qBAAqB;AAQ3B,SAAS,iBAAiB,IAAA,EAAsB;IACrD,IAAI,OAAO,eAAe,eAAe,OAAO,WAAW,IAAA,KAAS,YAAY;QAC9E,OAAO,WAAW,IAAA,CAAK,IAAI;IAC7B;IACA,OAAO,OAAO,IAAA,CAAK,IAAI,EAAE,QAAA,CAAS,QAAQ;AAC5C;AAQO,SAAS,iBAAiB,IAAA,EAAsB;IACrD,IAAI,OAAO,eAAe,eAAe,OAAO,WAAW,IAAA,KAAS,YAAY;QAC9E,OAAO,WAAW,IAAA,CAAK,IAAI;IAC7B;IACA,OAAO,OAAO,IAAA,CAAK,MAAM,QAAQ,EAAE,QAAA,CAAS,OAAO;AACrD;AAUO,SAAS,UAAU,IAAA,EAAe,IAAA,EAAwB;IAG/D,MAAM,YAAY,CAAC,QAAyB;QAE1C,IAAI,QAAQ,QAAQ,QAAQ,KAAA,EAAW,CAAA,OAAO,KAAK,SAAA,CAAU,GAAG;QAChE,IAAI,OAAO,QAAQ,SAAU,CAAA,OAAO,KAAK,SAAA,CAAU,GAAG;QAGtD,IAAI,MAAM,OAAA,CAAQ,GAAG,GAAG;YACtB,OAAO,KAAK,SAAA,CACV,IAAI,GAAA,CAAI,CAAA,OACN,OAAO,SAAS,YAAY,SAAS,OAAO,KAAK,KAAA,CAAM,UAAU,IAAI,CAAC,IAAI;QAGhF;QAGA,MAAM,SAAkC,CAAC;QACzC,OAAO,IAAA,CAAK,GAA8B,EACvC,IAAA,CAAK,EACL,OAAA,CAAQ,CAAA,QAAO;YACd,MAAM,QAAS,GAAA,CAAgC,GAAG,CAAA;YAClD,MAAA,CAAO,GAAG,CAAA,GACR,OAAO,UAAU,YAAY,UAAU,OAAO,KAAK,KAAA,CAAM,UAAU,KAAK,CAAC,IAAI;QACjF,CAAC;QACH,OAAO,KAAK,SAAA,CAAU,MAAM;IAC9B;IAEA,IAAI;QACF,OAAO,UAAU,IAAI,MAAM,UAAU,IAAI;IAC3C,EAAA,OAAQ;QAEN,OAAO,KAAK,SAAA,CAAU,IAAI,MAAM,KAAK,SAAA,CAAU,IAAI;IACrD;AACF"}},
    {"offset": {"line": 144, "column": 0}, "map": {"version":3,"sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/node_modules/%40x402/core/src/http/x402HTTPResourceServer.ts","file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/node_modules/%40x402/core/src/http/httpFacilitatorClient.ts","file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/node_modules/%40x402/core/src/http/x402HTTPClient.ts","file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/node_modules/%40x402/core/src/http/index.ts"],"sourcesContent":["import { x402ResourceServer } from \"../server\";\nimport {\n  decodePaymentSignatureHeader,\n  encodePaymentRequiredHeader,\n  encodePaymentResponseHeader,\n} from \".\";\nimport {\n  PaymentPayload,\n  PaymentRequired,\n  SettleResponse,\n  SettleError,\n  Price,\n  Network,\n  PaymentRequirements,\n} from \"../types\";\nimport { x402Version } from \"..\";\n\n/**\n * Framework-agnostic HTTP adapter interface\n * Implementations provide framework-specific HTTP operations\n */\nexport interface HTTPAdapter {\n  getHeader(name: string): string | undefined;\n  getMethod(): string;\n  getPath(): string;\n  getUrl(): string;\n  getAcceptHeader(): string;\n  getUserAgent(): string;\n\n  /**\n   * Get query parameters from the request URL\n   *\n   * @returns Record of query parameter key-value pairs\n   */\n  getQueryParams?(): Record<string, string | string[]>;\n\n  /**\n   * Get a specific query parameter by name\n   *\n   * @param name - The query parameter name\n   * @returns The query parameter value(s) or undefined\n   */\n  getQueryParam?(name: string): string | string[] | undefined;\n\n  /**\n   * Get the parsed request body\n   * Framework adapters should parse JSON/form data appropriately\n   *\n   * @returns The parsed request body\n   */\n  getBody?(): unknown;\n}\n\n/**\n * Paywall configuration for HTML responses\n */\nexport interface PaywallConfig {\n  appName?: string;\n  appLogo?: string;\n  sessionTokenEndpoint?: string;\n  currentUrl?: string;\n  testnet?: boolean;\n}\n\n/**\n * Paywall provider interface for generating HTML\n */\nexport interface PaywallProvider {\n  generateHtml(paymentRequired: PaymentRequired, config?: PaywallConfig): string;\n}\n\n/**\n * Dynamic payTo function that receives HTTP request context\n */\nexport type DynamicPayTo = (context: HTTPRequestContext) => string | Promise<string>;\n\n/**\n * Dynamic price function that receives HTTP request context\n */\nexport type DynamicPrice = (context: HTTPRequestContext) => Price | Promise<Price>;\n\n/**\n * Result of the unpaid response callback containing content type and body.\n */\nexport interface UnpaidResponseResult {\n  /**\n   * The content type for the response (e.g., 'application/json', 'text/plain').\n   */\n  contentType: string;\n\n  /**\n   * The response body to include in the 402 response.\n   */\n  body: unknown;\n}\n\n/**\n * Dynamic function to generate a custom response for unpaid requests.\n * Receives the HTTP request context and returns the content type and body to include in the 402 response.\n */\nexport type UnpaidResponseBody = (\n  context: HTTPRequestContext,\n) => UnpaidResponseResult | Promise<UnpaidResponseResult>;\n\n/**\n * A single payment option for a route\n * Represents one way a client can pay for access to the resource\n */\nexport interface PaymentOption {\n  scheme: string;\n  payTo: string | DynamicPayTo;\n  price: Price | DynamicPrice;\n  network: Network;\n  maxTimeoutSeconds?: number;\n  extra?: Record<string, unknown>;\n}\n\n/**\n * Route configuration for HTTP endpoints\n *\n * The 'accepts' field defines payment options for the route.\n * Can be a single PaymentOption or an array of PaymentOptions for multiple payment methods.\n */\nexport interface RouteConfig {\n  // Payment option(s): single or array\n  accepts: PaymentOption | PaymentOption[];\n\n  // HTTP-specific metadata\n  resource?: string;\n  description?: string;\n  mimeType?: string;\n  customPaywallHtml?: string;\n\n  /**\n   * Optional callback to generate a custom response for unpaid API requests.\n   * This allows servers to return preview data, error messages, or other content\n   * when a request lacks payment.\n   *\n   * For browser requests (Accept: text/html), the paywall HTML takes precedence.\n   * This callback is only used for API clients.\n   *\n   * If not provided, defaults to { contentType: 'application/json', body: {} }.\n   *\n   * @param context - The HTTP request context\n   * @returns An object containing both contentType and body for the 402 response\n   */\n  unpaidResponseBody?: UnpaidResponseBody;\n\n  // Extensions\n  extensions?: Record<string, unknown>;\n}\n\n/**\n * Routes configuration - maps path patterns to route configs\n */\nexport type RoutesConfig = Record<string, RouteConfig> | RouteConfig;\n\n/**\n * Compiled route for efficient matching\n */\nexport interface CompiledRoute {\n  verb: string;\n  regex: RegExp;\n  config: RouteConfig;\n}\n\n/**\n * HTTP request context that encapsulates all request data\n */\nexport interface HTTPRequestContext {\n  adapter: HTTPAdapter;\n  path: string;\n  method: string;\n  paymentHeader?: string;\n}\n\n/**\n * HTTP response instructions for the framework middleware\n */\nexport interface HTTPResponseInstructions {\n  status: number;\n  headers: Record<string, string>;\n  body?: unknown; // e.g. Paywall for web browser requests, but could be any other type\n  isHtml?: boolean; // e.g. if body is a paywall, then isHtml is true\n}\n\n/**\n * Result of processing an HTTP request for payment\n */\nexport type HTTPProcessResult =\n  | { type: \"no-payment-required\" }\n  | {\n      type: \"payment-verified\";\n      paymentPayload: PaymentPayload;\n      paymentRequirements: PaymentRequirements;\n    }\n  | { type: \"payment-error\"; response: HTTPResponseInstructions };\n\n/**\n * Result of processSettlement\n */\nexport type ProcessSettleSuccessResponse = SettleResponse & {\n  success: true;\n  headers: Record<string, string>;\n  requirements: PaymentRequirements;\n};\n\nexport type ProcessSettleFailureResponse = SettleResponse & {\n  success: false;\n  errorReason: string;\n};\n\nexport type ProcessSettleResultResponse =\n  | ProcessSettleSuccessResponse\n  | ProcessSettleFailureResponse;\n\n/**\n * Represents a validation error for a specific route's payment configuration.\n */\nexport interface RouteValidationError {\n  /** The route pattern (e.g., \"GET /api/weather\") */\n  routePattern: string;\n  /** The payment scheme that failed validation */\n  scheme: string;\n  /** The network that failed validation */\n  network: Network;\n  /** The type of validation failure */\n  reason: \"missing_scheme\" | \"missing_facilitator\";\n  /** Human-readable error message */\n  message: string;\n}\n\n/**\n * Error thrown when route configuration validation fails.\n */\nexport class RouteConfigurationError extends Error {\n  /** The validation errors that caused this exception */\n  public readonly errors: RouteValidationError[];\n\n  /**\n   * Creates a new RouteConfigurationError with the given validation errors.\n   *\n   * @param errors - The validation errors that caused this exception.\n   */\n  constructor(errors: RouteValidationError[]) {\n    const message = `x402 Route Configuration Errors:\\n${errors.map(e => `  - ${e.message}`).join(\"\\n\")}`;\n    super(message);\n    this.name = \"RouteConfigurationError\";\n    this.errors = errors;\n  }\n}\n\n/**\n * HTTP-enhanced x402 resource server\n * Provides framework-agnostic HTTP protocol handling\n */\nexport class x402HTTPResourceServer {\n  private ResourceServer: x402ResourceServer;\n  private compiledRoutes: CompiledRoute[] = [];\n  private routesConfig: RoutesConfig;\n  private paywallProvider?: PaywallProvider;\n\n  /**\n   * Creates a new x402HTTPResourceServer instance.\n   *\n   * @param ResourceServer - The core x402ResourceServer instance to use\n   * @param routes - Route configuration for payment-protected endpoints\n   */\n  constructor(ResourceServer: x402ResourceServer, routes: RoutesConfig) {\n    this.ResourceServer = ResourceServer;\n    this.routesConfig = routes;\n\n    // Handle both single route and multiple routes\n    const normalizedRoutes =\n      typeof routes === \"object\" && !(\"accepts\" in routes)\n        ? (routes as Record<string, RouteConfig>)\n        : { \"*\": routes as RouteConfig };\n\n    for (const [pattern, config] of Object.entries(normalizedRoutes)) {\n      const parsed = this.parseRoutePattern(pattern);\n      this.compiledRoutes.push({\n        verb: parsed.verb,\n        regex: parsed.regex,\n        config,\n      });\n    }\n  }\n\n  /**\n   * Initialize the HTTP resource server.\n   *\n   * This method initializes the underlying resource server (fetching facilitator support)\n   * and then validates that all route payment configurations have corresponding\n   * registered schemes and facilitator support.\n   *\n   * @throws RouteConfigurationError if any route's payment options don't have\n   *         corresponding registered schemes or facilitator support\n   *\n   * @example\n   * ```typescript\n   * const httpServer = new x402HTTPResourceServer(server, routes);\n   * await httpServer.initialize();\n   * ```\n   */\n  async initialize(): Promise<void> {\n    // First, initialize the underlying resource server (fetches facilitator support)\n    await this.ResourceServer.initialize();\n\n    // Then validate route configuration\n    const errors = this.validateRouteConfiguration();\n    if (errors.length > 0) {\n      throw new RouteConfigurationError(errors);\n    }\n  }\n\n  /**\n   * Register a custom paywall provider for generating HTML\n   *\n   * @param provider - PaywallProvider instance\n   * @returns This service instance for chaining\n   */\n  registerPaywallProvider(provider: PaywallProvider): this {\n    this.paywallProvider = provider;\n    return this;\n  }\n\n  /**\n   * Process HTTP request and return response instructions\n   * This is the main entry point for framework middleware\n   *\n   * @param context - HTTP request context\n   * @param paywallConfig - Optional paywall configuration\n   * @returns Process result indicating next action for middleware\n   */\n  async processHTTPRequest(\n    context: HTTPRequestContext,\n    paywallConfig?: PaywallConfig,\n  ): Promise<HTTPProcessResult> {\n    const { adapter, path, method } = context;\n\n    // Find matching route\n    const routeConfig = this.getRouteConfig(path, method);\n    if (!routeConfig) {\n      return { type: \"no-payment-required\" }; // No payment required for this route\n    }\n\n    // Normalize accepts field to array of payment options\n    const paymentOptions = this.normalizePaymentOptions(routeConfig);\n\n    // Check for payment header (v1 or v2)\n    const paymentPayload = this.extractPayment(adapter);\n\n    // Create resource info, using config override if provided\n    const resourceInfo = {\n      url: routeConfig.resource || context.adapter.getUrl(),\n      description: routeConfig.description || \"\",\n      mimeType: routeConfig.mimeType || \"\",\n    };\n\n    // Build requirements from all payment options\n    // (this method handles resolving dynamic functions internally)\n    const requirements = await this.ResourceServer.buildPaymentRequirementsFromOptions(\n      paymentOptions,\n      context,\n    );\n\n    let extensions = routeConfig.extensions;\n    if (extensions) {\n      extensions = this.ResourceServer.enrichExtensions(extensions, context);\n    }\n\n    const paymentRequired = this.ResourceServer.createPaymentRequiredResponse(\n      requirements,\n      resourceInfo,\n      !paymentPayload ? \"Payment required\" : undefined,\n      extensions,\n    );\n\n    // If no payment provided\n    if (!paymentPayload) {\n      // Resolve custom unpaid response body if provided\n      const unpaidBody = routeConfig.unpaidResponseBody\n        ? await routeConfig.unpaidResponseBody(context)\n        : undefined;\n\n      return {\n        type: \"payment-error\",\n        response: this.createHTTPResponse(\n          paymentRequired,\n          this.isWebBrowser(adapter),\n          paywallConfig,\n          routeConfig.customPaywallHtml,\n          unpaidBody,\n        ),\n      };\n    }\n\n    // Verify payment\n    try {\n      const matchingRequirements = this.ResourceServer.findMatchingRequirements(\n        paymentRequired.accepts,\n        paymentPayload,\n      );\n\n      if (!matchingRequirements) {\n        const errorResponse = this.ResourceServer.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"No matching payment requirements\",\n          routeConfig.extensions,\n        );\n        return {\n          type: \"payment-error\",\n          response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n        };\n      }\n\n      const verifyResult = await this.ResourceServer.verifyPayment(\n        paymentPayload,\n        matchingRequirements,\n      );\n\n      if (!verifyResult.isValid) {\n        const errorResponse = this.ResourceServer.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          verifyResult.invalidReason,\n          routeConfig.extensions,\n        );\n        return {\n          type: \"payment-error\",\n          response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n        };\n      }\n\n      // Payment is valid, return data needed for settlement\n      return {\n        type: \"payment-verified\",\n        paymentPayload,\n        paymentRequirements: matchingRequirements,\n      };\n    } catch (error) {\n      const errorResponse = this.ResourceServer.createPaymentRequiredResponse(\n        requirements,\n        resourceInfo,\n        error instanceof Error ? error.message : \"Payment verification failed\",\n        routeConfig.extensions,\n      );\n      return {\n        type: \"payment-error\",\n        response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n      };\n    }\n  }\n\n  /**\n   * Process settlement after successful response\n   *\n   * @param paymentPayload - The verified payment payload\n   * @param requirements - The matching payment requirements\n   * @returns ProcessSettleResultResponse - SettleResponse with headers if success or errorReason if failure\n   */\n  async processSettlement(\n    paymentPayload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<ProcessSettleResultResponse> {\n    try {\n      const settleResponse = await this.ResourceServer.settlePayment(paymentPayload, requirements);\n\n      if (!settleResponse.success) {\n        return {\n          ...settleResponse,\n          success: false,\n          errorReason: settleResponse.errorReason || \"Settlement failed\",\n        };\n      }\n\n      return {\n        ...settleResponse,\n        success: true,\n        headers: this.createSettlementHeaders(settleResponse, requirements),\n        requirements,\n      };\n    } catch (error) {\n      if (error instanceof SettleError) {\n        return {\n          success: false,\n          errorReason: error.errorReason || error.message,\n          payer: error.payer,\n          network: error.network,\n          transaction: error.transaction,\n        };\n      }\n      return {\n        success: false,\n        errorReason: error instanceof Error ? error.message : \"Settlement failed\",\n        network: requirements.network as Network,\n        transaction: \"\",\n      };\n    }\n  }\n\n  /**\n   * Check if a request requires payment based on route configuration\n   *\n   * @param context - HTTP request context\n   * @returns True if the route requires payment, false otherwise\n   */\n  requiresPayment(context: HTTPRequestContext): boolean {\n    const routeConfig = this.getRouteConfig(context.path, context.method);\n    return routeConfig !== undefined;\n  }\n\n  /**\n   * Normalizes a RouteConfig's accepts field into an array of PaymentOptions\n   * Handles both single PaymentOption and array formats\n   *\n   * @param routeConfig - Route configuration\n   * @returns Array of payment options\n   */\n  private normalizePaymentOptions(routeConfig: RouteConfig): PaymentOption[] {\n    return Array.isArray(routeConfig.accepts) ? routeConfig.accepts : [routeConfig.accepts];\n  }\n\n  /**\n   * Validates that all payment options in routes have corresponding registered schemes\n   * and facilitator support.\n   *\n   * @returns Array of validation errors (empty if all routes are valid)\n   */\n  private validateRouteConfiguration(): RouteValidationError[] {\n    const errors: RouteValidationError[] = [];\n\n    // Normalize routes to array of [pattern, config] pairs\n    const normalizedRoutes =\n      typeof this.routesConfig === \"object\" && !(\"accepts\" in this.routesConfig)\n        ? Object.entries(this.routesConfig as Record<string, RouteConfig>)\n        : [[\"*\", this.routesConfig as RouteConfig] as [string, RouteConfig]];\n\n    for (const [pattern, config] of normalizedRoutes) {\n      const paymentOptions = this.normalizePaymentOptions(config);\n\n      for (const option of paymentOptions) {\n        // Check 1: Is scheme registered?\n        if (!this.ResourceServer.hasRegisteredScheme(option.network, option.scheme)) {\n          errors.push({\n            routePattern: pattern,\n            scheme: option.scheme,\n            network: option.network,\n            reason: \"missing_scheme\",\n            message: `Route \"${pattern}\": No scheme implementation registered for \"${option.scheme}\" on network \"${option.network}\"`,\n          });\n          // Skip facilitator check if scheme isn't registered\n          continue;\n        }\n\n        // Check 2: Does facilitator support this scheme/network combination?\n        const supportedKind = this.ResourceServer.getSupportedKind(\n          x402Version,\n          option.network,\n          option.scheme,\n        );\n\n        if (!supportedKind) {\n          errors.push({\n            routePattern: pattern,\n            scheme: option.scheme,\n            network: option.network,\n            reason: \"missing_facilitator\",\n            message: `Route \"${pattern}\": Facilitator does not support scheme \"${option.scheme}\" on network \"${option.network}\"`,\n          });\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Get route configuration for a request\n   *\n   * @param path - Request path\n   * @param method - HTTP method\n   * @returns Route configuration or undefined if no match\n   */\n  private getRouteConfig(path: string, method: string): RouteConfig | undefined {\n    const normalizedPath = this.normalizePath(path);\n    const upperMethod = method.toUpperCase();\n\n    const matchingRoute = this.compiledRoutes.find(\n      route =>\n        route.regex.test(normalizedPath) && (route.verb === \"*\" || route.verb === upperMethod),\n    );\n\n    return matchingRoute?.config;\n  }\n\n  /**\n   * Extract payment from HTTP headers (handles v1 and v2)\n   *\n   * @param adapter - HTTP adapter\n   * @returns Decoded payment payload or null\n   */\n  private extractPayment(adapter: HTTPAdapter): PaymentPayload | null {\n    // Check v2 header first (PAYMENT-SIGNATURE)\n    const header = adapter.getHeader(\"payment-signature\") || adapter.getHeader(\"PAYMENT-SIGNATURE\");\n\n    if (header) {\n      try {\n        return decodePaymentSignatureHeader(header);\n      } catch (error) {\n        console.warn(\"Failed to decode PAYMENT-SIGNATURE header:\", error);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if request is from a web browser\n   *\n   * @param adapter - HTTP adapter\n   * @returns True if request appears to be from a browser\n   */\n  private isWebBrowser(adapter: HTTPAdapter): boolean {\n    const accept = adapter.getAcceptHeader();\n    const userAgent = adapter.getUserAgent();\n    return accept.includes(\"text/html\") && userAgent.includes(\"Mozilla\");\n  }\n\n  /**\n   * Create HTTP response instructions from payment required\n   *\n   * @param paymentRequired - Payment requirements\n   * @param isWebBrowser - Whether request is from browser\n   * @param paywallConfig - Paywall configuration\n   * @param customHtml - Custom HTML template\n   * @param unpaidResponse - Optional custom response (content type and body) for unpaid API requests\n   * @returns Response instructions\n   */\n  private createHTTPResponse(\n    paymentRequired: PaymentRequired,\n    isWebBrowser: boolean,\n    paywallConfig?: PaywallConfig,\n    customHtml?: string,\n    unpaidResponse?: UnpaidResponseResult,\n  ): HTTPResponseInstructions {\n    if (isWebBrowser) {\n      const html = this.generatePaywallHTML(paymentRequired, paywallConfig, customHtml);\n      return {\n        status: 402,\n        headers: { \"Content-Type\": \"text/html\" },\n        body: html,\n        isHtml: true,\n      };\n    }\n\n    const response = this.createHTTPPaymentRequiredResponse(paymentRequired);\n\n    // Use callback result if provided, otherwise default to JSON with empty object\n    const contentType = unpaidResponse ? unpaidResponse.contentType : \"application/json\";\n    const body = unpaidResponse ? unpaidResponse.body : {};\n\n    return {\n      status: 402,\n      headers: {\n        \"Content-Type\": contentType,\n        ...response.headers,\n      },\n      body,\n    };\n  }\n\n  /**\n   * Create HTTP payment required response (v1 puts in body, v2 puts in header)\n   *\n   * @param paymentRequired - Payment required object\n   * @returns Headers and body for the HTTP response\n   */\n  private createHTTPPaymentRequiredResponse(paymentRequired: PaymentRequired): {\n    headers: Record<string, string>;\n  } {\n    return {\n      headers: {\n        \"PAYMENT-REQUIRED\": encodePaymentRequiredHeader(paymentRequired),\n      },\n    };\n  }\n\n  /**\n   * Create settlement response headers\n   *\n   * @param settleResponse - Settlement response\n   * @param requirements - Payment requirements that were settled\n   * @returns Headers to add to response\n   */\n  private createSettlementHeaders(\n    settleResponse: SettleResponse,\n    requirements: PaymentRequirements,\n  ): Record<string, string> {\n    const encoded = encodePaymentResponseHeader({\n      ...settleResponse,\n      requirements,\n    });\n    return { \"PAYMENT-RESPONSE\": encoded };\n  }\n\n  /**\n   * Parse route pattern into verb and regex\n   *\n   * @param pattern - Route pattern like \"GET /api/*\" or \"/api/[id]\"\n   * @returns Parsed pattern with verb and regex\n   */\n  private parseRoutePattern(pattern: string): { verb: string; regex: RegExp } {\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\n\n    const regex = new RegExp(\n      `^${\n        path\n          .replace(/[$()+.?^{|}]/g, \"\\\\$&\") // Escape regex special chars\n          .replace(/\\*/g, \".*?\") // Wildcards\n          .replace(/\\[([^\\]]+)\\]/g, \"[^/]+\") // Parameters\n          .replace(/\\//g, \"\\\\/\") // Escape slashes\n      }$`,\n      \"i\",\n    );\n\n    return { verb: verb.toUpperCase(), regex };\n  }\n\n  /**\n   * Normalize path for matching\n   *\n   * @param path - Raw path from request\n   * @returns Normalized path\n   */\n  private normalizePath(path: string): string {\n    try {\n      const pathWithoutQuery = path.split(/[?#]/)[0];\n      const decodedPath = decodeURIComponent(pathWithoutQuery);\n      return decodedPath\n        .replace(/\\\\/g, \"/\")\n        .replace(/\\/+/g, \"/\")\n        .replace(/(.+?)\\/+$/, \"$1\");\n    } catch {\n      return path;\n    }\n  }\n\n  /**\n   * Generate paywall HTML for browser requests\n   *\n   * @param paymentRequired - Payment required response\n   * @param paywallConfig - Optional paywall configuration\n   * @param customHtml - Optional custom HTML template\n   * @returns HTML string\n   */\n  private generatePaywallHTML(\n    paymentRequired: PaymentRequired,\n    paywallConfig?: PaywallConfig,\n    customHtml?: string,\n  ): string {\n    if (customHtml) {\n      return customHtml;\n    }\n\n    // Use custom paywall provider if set\n    if (this.paywallProvider) {\n      return this.paywallProvider.generateHtml(paymentRequired, paywallConfig);\n    }\n\n    // Try to use @x402/paywall if available (optional dependency)\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\n      const paywall = require(\"@x402/paywall\");\n      const displayAmount = this.getDisplayAmount(paymentRequired);\n      const resource = paymentRequired.resource;\n\n      return paywall.getPaywallHtml({\n        amount: displayAmount,\n        paymentRequired,\n        currentUrl: resource?.url || paywallConfig?.currentUrl || \"\",\n        testnet: paywallConfig?.testnet ?? true,\n        appName: paywallConfig?.appName,\n        appLogo: paywallConfig?.appLogo,\n        sessionTokenEndpoint: paywallConfig?.sessionTokenEndpoint,\n      });\n    } catch {\n      // @x402/paywall not installed, fall back to basic HTML\n    }\n\n    // Fallback: Basic HTML paywall\n    const resource = paymentRequired.resource;\n    const displayAmount = this.getDisplayAmount(paymentRequired);\n\n    return `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <title>Payment Required</title>\n          <meta charset=\"UTF-8\">\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        </head>\n        <body>\n          <div style=\"max-width: 600px; margin: 50px auto; padding: 20px; font-family: system-ui, -apple-system, sans-serif;\">\n            ${paywallConfig?.appLogo ? `<img src=\"${paywallConfig.appLogo}\" alt=\"${paywallConfig.appName || \"App\"}\" style=\"max-width: 200px; margin-bottom: 20px;\">` : \"\"}\n            <h1>Payment Required</h1>\n            ${resource ? `<p><strong>Resource:</strong> ${resource.description || resource.url}</p>` : \"\"}\n            <p><strong>Amount:</strong> $${displayAmount.toFixed(2)} USDC</p>\n            <div id=\"payment-widget\" \n                 data-requirements='${JSON.stringify(paymentRequired)}'\n                 data-app-name=\"${paywallConfig?.appName || \"\"}\"\n                 data-testnet=\"${paywallConfig?.testnet || false}\">\n              <!-- Install @x402/paywall for full wallet integration -->\n              <p style=\"margin-top: 2rem; padding: 1rem; background: #fef3c7; border-radius: 0.5rem;\">\n                <strong>Note:</strong> Install <code>@x402/paywall</code> for full wallet connection and payment UI.\n              </p>\n            </div>\n          </div>\n        </body>\n      </html>\n    `;\n  }\n\n  /**\n   * Extract display amount from payment requirements.\n   *\n   * @param paymentRequired - The payment required object\n   * @returns The display amount in decimal format\n   */\n  private getDisplayAmount(paymentRequired: PaymentRequired): number {\n    const accepts = paymentRequired.accepts;\n    if (accepts && accepts.length > 0) {\n      const firstReq = accepts[0];\n      if (\"amount\" in firstReq) {\n        // V2 format\n        return parseFloat(firstReq.amount) / 1000000; // Assuming USDC with 6 decimals\n      }\n    }\n    return 0;\n  }\n}\n","import { PaymentPayload, PaymentRequirements } from \"../types/payments\";\nimport {\n  VerifyResponse,\n  SettleResponse,\n  SupportedResponse,\n  VerifyError,\n  SettleError,\n} from \"../types/facilitator\";\n\nconst DEFAULT_FACILITATOR_URL = \"https://x402.org/facilitator\";\n\nexport interface FacilitatorConfig {\n  url?: string;\n  createAuthHeaders?: () => Promise<{\n    verify: Record<string, string>;\n    settle: Record<string, string>;\n    supported: Record<string, string>;\n  }>;\n}\n\n/**\n * Interface for facilitator clients\n * Can be implemented for HTTP-based or local facilitators\n */\nexport interface FacilitatorClient {\n  /**\n   * Verify a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to verify\n   * @param paymentRequirements - The requirements to verify against\n   * @returns Verification response\n   */\n  verify(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<VerifyResponse>;\n\n  /**\n   * Settle a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to settle\n   * @param paymentRequirements - The requirements for settlement\n   * @returns Settlement response\n   */\n  settle(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<SettleResponse>;\n\n  /**\n   * Get supported payment kinds and extensions from the facilitator\n   *\n   * @returns Supported payment kinds and extensions\n   */\n  getSupported(): Promise<SupportedResponse>;\n}\n\n/**\n * HTTP-based client for interacting with x402 facilitator services\n * Handles HTTP communication with facilitator endpoints\n */\nexport class HTTPFacilitatorClient implements FacilitatorClient {\n  readonly url: string;\n  private readonly _createAuthHeaders?: FacilitatorConfig[\"createAuthHeaders\"];\n\n  /**\n   * Creates a new HTTPFacilitatorClient instance.\n   *\n   * @param config - Configuration options for the facilitator client\n   */\n  constructor(config?: FacilitatorConfig) {\n    this.url = config?.url || DEFAULT_FACILITATOR_URL;\n    this._createAuthHeaders = config?.createAuthHeaders;\n  }\n\n  /**\n   * Verify a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to verify\n   * @param paymentRequirements - The requirements to verify against\n   * @returns Verification response\n   */\n  async verify(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"verify\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n\n    const response = await fetch(`${this.url}/verify`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        x402Version: paymentPayload.x402Version,\n        paymentPayload: this.toJsonSafe(paymentPayload),\n        paymentRequirements: this.toJsonSafe(paymentRequirements),\n      }),\n    });\n\n    const data = await response.json();\n\n    if (typeof data === \"object\" && data !== null && \"isValid\" in data) {\n      const verifyResponse = data as VerifyResponse;\n      if (!response.ok) {\n        throw new VerifyError(response.status, verifyResponse);\n      }\n      return verifyResponse;\n    }\n\n    throw new Error(`Facilitator verify failed (${response.status}): ${JSON.stringify(data)}`);\n  }\n\n  /**\n   * Settle a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to settle\n   * @param paymentRequirements - The requirements for settlement\n   * @returns Settlement response\n   */\n  async settle(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"settle\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n\n    const response = await fetch(`${this.url}/settle`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        x402Version: paymentPayload.x402Version,\n        paymentPayload: this.toJsonSafe(paymentPayload),\n        paymentRequirements: this.toJsonSafe(paymentRequirements),\n      }),\n    });\n\n    const data = await response.json();\n\n    if (typeof data === \"object\" && data !== null && \"success\" in data) {\n      const settleResponse = data as SettleResponse;\n      if (!response.ok) {\n        throw new SettleError(response.status, settleResponse);\n      }\n      return settleResponse;\n    }\n\n    throw new Error(`Facilitator settle failed (${response.status}): ${JSON.stringify(data)}`);\n  }\n\n  /**\n   * Get supported payment kinds and extensions from the facilitator\n   *\n   * @returns Supported payment kinds and extensions\n   */\n  async getSupported(): Promise<SupportedResponse> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"supported\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n\n    const response = await fetch(`${this.url}/supported`, {\n      method: \"GET\",\n      headers,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => response.statusText);\n      throw new Error(`Facilitator getSupported failed (${response.status}): ${errorText}`);\n    }\n\n    return (await response.json()) as SupportedResponse;\n  }\n\n  /**\n   * Creates authentication headers for a specific path.\n   *\n   * @param path - The path to create authentication headers for (e.g., \"verify\", \"settle\", \"supported\")\n   * @returns An object containing the authentication headers for the specified path\n   */\n  async createAuthHeaders(path: string): Promise<{\n    headers: Record<string, string>;\n  }> {\n    if (this._createAuthHeaders) {\n      const authHeaders = (await this._createAuthHeaders()) as Record<\n        string,\n        Record<string, string>\n      >;\n      return {\n        headers: authHeaders[path] ?? {},\n      };\n    }\n    return {\n      headers: {},\n    };\n  }\n\n  /**\n   * Helper to convert objects to JSON-safe format.\n   * Handles BigInt and other non-JSON types.\n   *\n   * @param obj - The object to convert\n   * @returns The JSON-safe representation of the object\n   */\n  private toJsonSafe(obj: unknown): unknown {\n    return JSON.parse(\n      JSON.stringify(obj, (_, value) => (typeof value === \"bigint\" ? value.toString() : value)),\n    );\n  }\n}\n","import {\n  decodePaymentRequiredHeader,\n  decodePaymentResponseHeader,\n  encodePaymentSignatureHeader,\n} from \".\";\nimport { SettleResponse } from \"../types\";\nimport { PaymentPayload, PaymentRequired } from \"../types/payments\";\nimport { x402Client } from \"../client/x402Client\";\n\n/**\n * HTTP-specific client for handling x402 payment protocol over HTTP.\n *\n * Wraps a x402Client to provide HTTP-specific encoding/decoding functionality\n * for payment headers and responses while maintaining the builder pattern.\n */\nexport class x402HTTPClient {\n  /**\n   * Creates a new x402HTTPClient instance.\n   *\n   * @param client - The underlying x402Client for payment logic\n   */\n  constructor(private readonly client: x402Client) {}\n\n  /**\n   * Encodes a payment payload into appropriate HTTP headers based on version.\n   *\n   * @param paymentPayload - The payment payload to encode\n   * @returns HTTP headers containing the encoded payment signature\n   */\n  encodePaymentSignatureHeader(paymentPayload: PaymentPayload): Record<string, string> {\n    switch (paymentPayload.x402Version) {\n      case 2:\n        return {\n          \"PAYMENT-SIGNATURE\": encodePaymentSignatureHeader(paymentPayload),\n        };\n      case 1:\n        return {\n          \"X-PAYMENT\": encodePaymentSignatureHeader(paymentPayload),\n        };\n      default:\n        throw new Error(\n          `Unsupported x402 version: ${(paymentPayload as PaymentPayload).x402Version}`,\n        );\n    }\n  }\n\n  /**\n   * Extracts payment required information from HTTP response.\n   *\n   * @param getHeader - Function to retrieve header value by name (case-insensitive)\n   * @param body - Optional response body for v1 compatibility\n   * @returns The payment required object\n   */\n  getPaymentRequiredResponse(\n    getHeader: (name: string) => string | null | undefined,\n    body?: unknown,\n  ): PaymentRequired {\n    // v2\n    const paymentRequired = getHeader(\"PAYMENT-REQUIRED\");\n    if (paymentRequired) {\n      return decodePaymentRequiredHeader(paymentRequired);\n    }\n\n    // v1\n    if (\n      body &&\n      body instanceof Object &&\n      \"x402Version\" in body &&\n      (body as PaymentRequired).x402Version === 1\n    ) {\n      return body as PaymentRequired;\n    }\n\n    throw new Error(\"Invalid payment required response\");\n  }\n\n  /**\n   * Extracts payment settlement response from HTTP headers.\n   *\n   * @param getHeader - Function to retrieve header value by name (case-insensitive)\n   * @returns The settlement response object\n   */\n  getPaymentSettleResponse(getHeader: (name: string) => string | null | undefined): SettleResponse {\n    // v2\n    const paymentResponse = getHeader(\"PAYMENT-RESPONSE\");\n    if (paymentResponse) {\n      return decodePaymentResponseHeader(paymentResponse);\n    }\n\n    // v1\n    const xPaymentResponse = getHeader(\"X-PAYMENT-RESPONSE\");\n    if (xPaymentResponse) {\n      return decodePaymentResponseHeader(xPaymentResponse);\n    }\n\n    throw new Error(\"Payment response header not found\");\n  }\n\n  /**\n   * Creates a payment payload for the given payment requirements.\n   * Delegates to the underlying x402Client.\n   *\n   * @param paymentRequired - The payment required response from the server\n   * @returns Promise resolving to the payment payload\n   */\n  async createPaymentPayload(paymentRequired: PaymentRequired): Promise<PaymentPayload> {\n    return this.client.createPaymentPayload(paymentRequired);\n  }\n}\n","import { SettleResponse } from \"../types\";\nimport { PaymentPayload, PaymentRequired, PaymentRequirements } from \"../types/payments\";\nimport { Base64EncodedRegex, safeBase64Decode, safeBase64Encode } from \"../utils\";\n\n// HTTP Methods that typically use query parameters\nexport type QueryParamMethods = \"GET\" | \"HEAD\" | \"DELETE\";\n\n// HTTP Methods that typically use request body\nexport type BodyMethods = \"POST\" | \"PUT\" | \"PATCH\";\n\n/**\n * Encodes a payment payload as a base64 header value.\n *\n * @param paymentPayload - The payment payload to encode\n * @returns Base64 encoded string representation of the payment payload\n */\nexport function encodePaymentSignatureHeader(paymentPayload: PaymentPayload): string {\n  return safeBase64Encode(JSON.stringify(paymentPayload));\n}\n\n/**\n * Decodes a base64 payment signature header into a payment payload.\n *\n * @param paymentSignatureHeader - The base64 encoded payment signature header\n * @returns The decoded payment payload\n */\nexport function decodePaymentSignatureHeader(paymentSignatureHeader: string): PaymentPayload {\n  if (!Base64EncodedRegex.test(paymentSignatureHeader)) {\n    throw new Error(\"Invalid payment signature header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentSignatureHeader)) as PaymentPayload;\n}\n\n/**\n * Encodes a payment required object as a base64 header value.\n *\n * @param paymentRequired - The payment required object to encode\n * @returns Base64 encoded string representation of the payment required object\n */\nexport function encodePaymentRequiredHeader(paymentRequired: PaymentRequired): string {\n  return safeBase64Encode(JSON.stringify(paymentRequired));\n}\n\n/**\n * Decodes a base64 payment required header into a payment required object.\n *\n * @param paymentRequiredHeader - The base64 encoded payment required header\n * @returns The decoded payment required object\n */\nexport function decodePaymentRequiredHeader(paymentRequiredHeader: string): PaymentRequired {\n  if (!Base64EncodedRegex.test(paymentRequiredHeader)) {\n    throw new Error(\"Invalid payment required header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentRequiredHeader)) as PaymentRequired;\n}\n\n/**\n * Encodes a payment response as a base64 header value.\n *\n * @param paymentResponse - The payment response to encode\n * @returns Base64 encoded string representation of the payment response\n */\nexport function encodePaymentResponseHeader(\n  paymentResponse: SettleResponse & { requirements: PaymentRequirements },\n): string {\n  return safeBase64Encode(JSON.stringify(paymentResponse));\n}\n\n/**\n * Decodes a base64 payment response header into a settle response.\n *\n * @param paymentResponseHeader - The base64 encoded payment response header\n * @returns The decoded settle response\n */\nexport function decodePaymentResponseHeader(paymentResponseHeader: string): SettleResponse {\n  if (!Base64EncodedRegex.test(paymentResponseHeader)) {\n    throw new Error(\"Invalid payment response header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentResponseHeader)) as SettleResponse;\n}\n\n// Export HTTP service and types\nexport {\n  x402HTTPResourceServer,\n  HTTPAdapter,\n  HTTPRequestContext,\n  HTTPResponseInstructions,\n  HTTPProcessResult,\n  PaywallConfig,\n  PaywallProvider,\n  PaymentOption,\n  RouteConfig,\n  RoutesConfig,\n  CompiledRoute,\n  DynamicPayTo,\n  DynamicPrice,\n  UnpaidResponseBody,\n  UnpaidResponseResult,\n  ProcessSettleResultResponse,\n  ProcessSettleSuccessResponse,\n  ProcessSettleFailureResponse,\n  RouteValidationError,\n  RouteConfigurationError,\n} from \"./x402HTTPResourceServer\";\nexport {\n  HTTPFacilitatorClient,\n  FacilitatorClient,\n  FacilitatorConfig,\n} from \"./httpFacilitatorClient\";\nexport { x402HTTPClient } from \"./x402HTTPClient\";\n"],"names":["displayAmount","resource"],"mappings":"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"}},
    {"offset": {"line": 861, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/node_modules/%40x402/core/src/server/x402ResourceServer.ts"],"sourcesContent":["import {\n  SettleResponse,\n  VerifyResponse,\n  SupportedResponse,\n  SupportedKind,\n} from \"../types/facilitator\";\nimport { PaymentPayload, PaymentRequirements, PaymentRequired } from \"../types/payments\";\nimport { SchemeNetworkServer } from \"../types/mechanisms\";\nimport { Price, Network, ResourceServerExtension } from \"../types\";\nimport { deepEqual, findByNetworkAndScheme } from \"../utils\";\nimport { FacilitatorClient, HTTPFacilitatorClient } from \"../http/httpFacilitatorClient\";\nimport { x402Version } from \"..\";\n\n/**\n * Configuration for a protected resource\n * Only contains payment-specific configuration, not resource metadata\n */\nexport interface ResourceConfig {\n  scheme: string;\n  payTo: string; // Payment recipient address\n  price: Price;\n  network: Network;\n  maxTimeoutSeconds?: number;\n}\n\n/**\n * Resource information for PaymentRequired response\n */\nexport interface ResourceInfo {\n  url: string;\n  description: string;\n  mimeType: string;\n}\n\n/**\n * Lifecycle Hook Context Interfaces\n */\n\nexport interface VerifyContext {\n  paymentPayload: PaymentPayload;\n  requirements: PaymentRequirements;\n}\n\nexport interface VerifyResultContext extends VerifyContext {\n  result: VerifyResponse;\n}\n\nexport interface VerifyFailureContext extends VerifyContext {\n  error: Error;\n}\n\nexport interface SettleContext {\n  paymentPayload: PaymentPayload;\n  requirements: PaymentRequirements;\n}\n\nexport interface SettleResultContext extends SettleContext {\n  result: SettleResponse;\n}\n\nexport interface SettleFailureContext extends SettleContext {\n  error: Error;\n}\n\n/**\n * Lifecycle Hook Type Definitions\n */\n\nexport type BeforeVerifyHook = (\n  context: VerifyContext,\n) => Promise<void | { abort: true; reason: string }>;\n\nexport type AfterVerifyHook = (context: VerifyResultContext) => Promise<void>;\n\nexport type OnVerifyFailureHook = (\n  context: VerifyFailureContext,\n) => Promise<void | { recovered: true; result: VerifyResponse }>;\n\nexport type BeforeSettleHook = (\n  context: SettleContext,\n) => Promise<void | { abort: true; reason: string }>;\n\nexport type AfterSettleHook = (context: SettleResultContext) => Promise<void>;\n\nexport type OnSettleFailureHook = (\n  context: SettleFailureContext,\n) => Promise<void | { recovered: true; result: SettleResponse }>;\n\n/**\n * Core x402 protocol server for resource protection\n * Transport-agnostic implementation of the x402 payment protocol\n */\nexport class x402ResourceServer {\n  private facilitatorClients: FacilitatorClient[];\n  private registeredServerSchemes: Map<string, Map<string, SchemeNetworkServer>> = new Map();\n  private supportedResponsesMap: Map<number, Map<string, Map<string, SupportedResponse>>> =\n    new Map();\n  private facilitatorClientsMap: Map<number, Map<string, Map<string, FacilitatorClient>>> =\n    new Map();\n  private registeredExtensions: Map<string, ResourceServerExtension> = new Map();\n\n  private beforeVerifyHooks: BeforeVerifyHook[] = [];\n  private afterVerifyHooks: AfterVerifyHook[] = [];\n  private onVerifyFailureHooks: OnVerifyFailureHook[] = [];\n  private beforeSettleHooks: BeforeSettleHook[] = [];\n  private afterSettleHooks: AfterSettleHook[] = [];\n  private onSettleFailureHooks: OnSettleFailureHook[] = [];\n\n  /**\n   * Creates a new x402ResourceServer instance.\n   *\n   * @param facilitatorClients - Optional facilitator client(s) for payment processing\n   */\n  constructor(facilitatorClients?: FacilitatorClient | FacilitatorClient[]) {\n    // Normalize facilitator clients to array\n    if (!facilitatorClients) {\n      // No clients provided, create a default HTTP client\n      this.facilitatorClients = [new HTTPFacilitatorClient()];\n    } else if (Array.isArray(facilitatorClients)) {\n      // Array of clients provided\n      this.facilitatorClients =\n        facilitatorClients.length > 0 ? facilitatorClients : [new HTTPFacilitatorClient()];\n    } else {\n      // Single client provided\n      this.facilitatorClients = [facilitatorClients];\n    }\n  }\n\n  /**\n   * Register a scheme/network server implementation.\n   *\n   * @param network - The network identifier\n   * @param server - The scheme/network server implementation\n   * @returns The x402ResourceServer instance for chaining\n   */\n  register(network: Network, server: SchemeNetworkServer): x402ResourceServer {\n    if (!this.registeredServerSchemes.has(network)) {\n      this.registeredServerSchemes.set(network, new Map());\n    }\n\n    const serverByScheme = this.registeredServerSchemes.get(network)!;\n    if (!serverByScheme.has(server.scheme)) {\n      serverByScheme.set(server.scheme, server);\n    }\n\n    return this;\n  }\n\n  /**\n   * Check if a scheme is registered for a given network.\n   *\n   * @param network - The network identifier\n   * @param scheme - The payment scheme name\n   * @returns True if the scheme is registered for the network, false otherwise\n   */\n  hasRegisteredScheme(network: Network, scheme: string): boolean {\n    return !!findByNetworkAndScheme(this.registeredServerSchemes, scheme, network);\n  }\n\n  /**\n   * Registers a resource service extension that can enrich extension declarations.\n   *\n   * @param extension - The extension to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  registerExtension(extension: ResourceServerExtension): this {\n    this.registeredExtensions.set(extension.key, extension);\n    return this;\n  }\n\n  /**\n   * Enriches declared extensions using registered extension hooks.\n   *\n   * @param declaredExtensions - Extensions declared on the route\n   * @param transportContext - Transport-specific context (HTTP, A2A, MCP, etc.)\n   * @returns Enriched extensions map\n   */\n  enrichExtensions(\n    declaredExtensions: Record<string, unknown>,\n    transportContext: unknown,\n  ): Record<string, unknown> {\n    const enriched: Record<string, unknown> = {};\n\n    for (const [key, declaration] of Object.entries(declaredExtensions)) {\n      const extension = this.registeredExtensions.get(key);\n\n      if (extension?.enrichDeclaration) {\n        enriched[key] = extension.enrichDeclaration(declaration, transportContext);\n      } else {\n        enriched[key] = declaration;\n      }\n    }\n\n    return enriched;\n  }\n\n  /**\n   * Register a hook to execute before payment verification.\n   * Can abort verification by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onBeforeVerify(hook: BeforeVerifyHook): x402ResourceServer {\n    this.beforeVerifyHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute after successful payment verification.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onAfterVerify(hook: AfterVerifyHook): x402ResourceServer {\n    this.afterVerifyHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute when payment verification fails.\n   * Can recover from failure by returning { recovered: true, result: VerifyResponse }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onVerifyFailure(hook: OnVerifyFailureHook): x402ResourceServer {\n    this.onVerifyFailureHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute before payment settlement.\n   * Can abort settlement by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onBeforeSettle(hook: BeforeSettleHook): x402ResourceServer {\n    this.beforeSettleHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute after successful payment settlement.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onAfterSettle(hook: AfterSettleHook): x402ResourceServer {\n    this.afterSettleHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute when payment settlement fails.\n   * Can recover from failure by returning { recovered: true, result: SettleResponse }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onSettleFailure(hook: OnSettleFailureHook): x402ResourceServer {\n    this.onSettleFailureHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Initialize by fetching supported kinds from all facilitators\n   * Creates mappings for supported responses and facilitator clients\n   * Earlier facilitators in the array get precedence\n   */\n  async initialize(): Promise<void> {\n    // Clear existing mappings\n    this.supportedResponsesMap.clear();\n    this.facilitatorClientsMap.clear();\n\n    // Fetch supported kinds from all facilitator clients\n    // Process in order to give precedence to earlier facilitators\n    for (const facilitatorClient of this.facilitatorClients) {\n      try {\n        const supported = await facilitatorClient.getSupported();\n\n        // Process each supported kind (now flat array with version in each element)\n        for (const kind of supported.kinds) {\n          const x402Version = kind.x402Version;\n\n          // Get or create version map for supported responses\n          if (!this.supportedResponsesMap.has(x402Version)) {\n            this.supportedResponsesMap.set(x402Version, new Map());\n          }\n          const responseVersionMap = this.supportedResponsesMap.get(x402Version)!;\n\n          // Get or create version map for facilitator clients\n          if (!this.facilitatorClientsMap.has(x402Version)) {\n            this.facilitatorClientsMap.set(x402Version, new Map());\n          }\n          const clientVersionMap = this.facilitatorClientsMap.get(x402Version)!;\n\n          // Get or create network map for responses\n          if (!responseVersionMap.has(kind.network)) {\n            responseVersionMap.set(kind.network, new Map());\n          }\n          const responseNetworkMap = responseVersionMap.get(kind.network)!;\n\n          // Get or create network map for clients\n          if (!clientVersionMap.has(kind.network)) {\n            clientVersionMap.set(kind.network, new Map());\n          }\n          const clientNetworkMap = clientVersionMap.get(kind.network)!;\n\n          // Only store if not already present (gives precedence to earlier facilitators)\n          if (!responseNetworkMap.has(kind.scheme)) {\n            responseNetworkMap.set(kind.scheme, supported);\n            clientNetworkMap.set(kind.scheme, facilitatorClient);\n          }\n        }\n      } catch (error) {\n        // Log error but continue with other facilitators\n        console.warn(`Failed to fetch supported kinds from facilitator: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Get supported kind for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The supported kind or undefined if not found\n   */\n  getSupportedKind(\n    x402Version: number,\n    network: Network,\n    scheme: string,\n  ): SupportedKind | undefined {\n    const versionMap = this.supportedResponsesMap.get(x402Version);\n    if (!versionMap) return undefined;\n\n    const supportedResponse = findByNetworkAndScheme(versionMap, scheme, network);\n    if (!supportedResponse) return undefined;\n\n    // Find the specific kind from the response (kinds are flat array with version in each element)\n    return supportedResponse.kinds.find(\n      kind =>\n        kind.x402Version === x402Version && kind.network === network && kind.scheme === scheme,\n    );\n  }\n\n  /**\n   * Get facilitator extensions for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The facilitator extensions or empty array if not found\n   */\n  getFacilitatorExtensions(x402Version: number, network: Network, scheme: string): string[] {\n    const versionMap = this.supportedResponsesMap.get(x402Version);\n    if (!versionMap) return [];\n\n    const supportedResponse = findByNetworkAndScheme(versionMap, scheme, network);\n    return supportedResponse?.extensions || [];\n  }\n\n  /**\n   * Build payment requirements for a protected resource\n   *\n   * @param resourceConfig - Configuration for the protected resource\n   * @returns Array of payment requirements\n   */\n  async buildPaymentRequirements(resourceConfig: ResourceConfig): Promise<PaymentRequirements[]> {\n    const requirements: PaymentRequirements[] = [];\n\n    // Find the matching server implementation\n    const scheme = resourceConfig.scheme;\n    const SchemeNetworkServer = findByNetworkAndScheme(\n      this.registeredServerSchemes,\n      scheme,\n      resourceConfig.network,\n    );\n\n    if (!SchemeNetworkServer) {\n      // Fallback to placeholder implementation if no server registered\n      // TODO: Remove this fallback once implementations are registered\n      console.warn(\n        `No server implementation registered for scheme: ${scheme}, network: ${resourceConfig.network}`,\n      );\n      return requirements;\n    }\n\n    // Find the matching supported kind from facilitator\n    const supportedKind = this.getSupportedKind(\n      x402Version,\n      resourceConfig.network,\n      SchemeNetworkServer.scheme,\n    );\n\n    if (!supportedKind) {\n      throw new Error(\n        `Facilitator does not support ${SchemeNetworkServer.scheme} on ${resourceConfig.network}. ` +\n          `Make sure to call initialize() to fetch supported kinds from facilitators.`,\n      );\n    }\n\n    // Get facilitator extensions for this combination\n    const facilitatorExtensions = this.getFacilitatorExtensions(\n      x402Version,\n      resourceConfig.network,\n      SchemeNetworkServer.scheme,\n    );\n\n    // Parse the price using the scheme's price parser\n    const parsedPrice = await SchemeNetworkServer.parsePrice(\n      resourceConfig.price,\n      resourceConfig.network,\n    );\n\n    // Build base payment requirements from resource config\n    const baseRequirements: PaymentRequirements = {\n      scheme: SchemeNetworkServer.scheme,\n      network: resourceConfig.network,\n      amount: parsedPrice.amount,\n      asset: parsedPrice.asset,\n      payTo: resourceConfig.payTo,\n      maxTimeoutSeconds: resourceConfig.maxTimeoutSeconds || 300, // Default 5 minutes\n      extra: {\n        ...parsedPrice.extra,\n      },\n    };\n\n    // Delegate to the implementation for scheme-specific enhancements\n    // Note: enhancePaymentRequirements expects x402Version in the kind, so we add it back\n    const requirement = await SchemeNetworkServer.enhancePaymentRequirements(\n      baseRequirements,\n      {\n        ...supportedKind,\n        x402Version,\n      },\n      facilitatorExtensions,\n    );\n\n    requirements.push(requirement);\n    return requirements;\n  }\n\n  /**\n   * Build payment requirements from multiple payment options\n   * This method handles resolving dynamic payTo/price functions and builds requirements for each option\n   *\n   * @param paymentOptions - Array of payment options to convert\n   * @param context - HTTP request context for resolving dynamic functions\n   * @returns Array of payment requirements (one per option)\n   */\n  async buildPaymentRequirementsFromOptions<TContext = unknown>(\n    paymentOptions: Array<{\n      scheme: string;\n      payTo: string | ((context: TContext) => string | Promise<string>);\n      price: Price | ((context: TContext) => Price | Promise<Price>);\n      network: Network;\n      maxTimeoutSeconds?: number;\n    }>,\n    context: TContext,\n  ): Promise<PaymentRequirements[]> {\n    const allRequirements: PaymentRequirements[] = [];\n\n    for (const option of paymentOptions) {\n      // Resolve dynamic payTo and price if they are functions\n      const resolvedPayTo =\n        typeof option.payTo === \"function\" ? await option.payTo(context) : option.payTo;\n      const resolvedPrice =\n        typeof option.price === \"function\" ? await option.price(context) : option.price;\n\n      const resourceConfig: ResourceConfig = {\n        scheme: option.scheme,\n        payTo: resolvedPayTo,\n        price: resolvedPrice,\n        network: option.network,\n        maxTimeoutSeconds: option.maxTimeoutSeconds,\n      };\n\n      // Use existing buildPaymentRequirements for each option\n      const requirements = await this.buildPaymentRequirements(resourceConfig);\n      allRequirements.push(...requirements);\n    }\n\n    return allRequirements;\n  }\n\n  /**\n   * Create a payment required response\n   *\n   * @param requirements - Payment requirements\n   * @param resourceInfo - Resource information\n   * @param error - Error message\n   * @param extensions - Optional extensions\n   * @returns Payment required response object\n   */\n  createPaymentRequiredResponse(\n    requirements: PaymentRequirements[],\n    resourceInfo: ResourceInfo,\n    error?: string,\n    extensions?: Record<string, unknown>,\n  ): PaymentRequired {\n    // V2 response with resource at top level\n    const response: PaymentRequired = {\n      x402Version: 2,\n      error,\n      resource: resourceInfo,\n      accepts: requirements as PaymentRequirements[],\n    };\n\n    // Add extensions if provided\n    if (extensions && Object.keys(extensions).length > 0) {\n      response.extensions = extensions;\n    }\n\n    return response;\n  }\n\n  /**\n   * Verify a payment against requirements\n   *\n   * @param paymentPayload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @returns Verification response\n   */\n  async verifyPayment(\n    paymentPayload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    const context: VerifyContext = {\n      paymentPayload,\n      requirements,\n    };\n\n    // Execute beforeVerify hooks\n    for (const hook of this.beforeVerifyHooks) {\n      const result = await hook(context);\n      if (result && \"abort\" in result && result.abort) {\n        return {\n          isValid: false,\n          invalidReason: result.reason,\n        };\n      }\n    }\n\n    try {\n      // Find the facilitator that supports this payment type\n      const facilitatorClient = this.getFacilitatorClient(\n        paymentPayload.x402Version,\n        requirements.network,\n        requirements.scheme,\n      );\n\n      let verifyResult: VerifyResponse;\n\n      if (!facilitatorClient) {\n        // Fallback: try all facilitators if no specific support found\n        let lastError: Error | undefined;\n\n        for (const client of this.facilitatorClients) {\n          try {\n            verifyResult = await client.verify(paymentPayload, requirements);\n            break;\n          } catch (error) {\n            lastError = error as Error;\n          }\n        }\n\n        if (!verifyResult!) {\n          throw (\n            lastError ||\n            new Error(\n              `No facilitator supports ${requirements.scheme} on ${requirements.network} for v${paymentPayload.x402Version}`,\n            )\n          );\n        }\n      } else {\n        // Use the specific facilitator that supports this payment\n        verifyResult = await facilitatorClient.verify(paymentPayload, requirements);\n      }\n\n      // Execute afterVerify hooks\n      const resultContext: VerifyResultContext = {\n        ...context,\n        result: verifyResult,\n      };\n\n      for (const hook of this.afterVerifyHooks) {\n        await hook(resultContext);\n      }\n\n      return verifyResult;\n    } catch (error) {\n      const failureContext: VerifyFailureContext = {\n        ...context,\n        error: error as Error,\n      };\n\n      // Execute onVerifyFailure hooks\n      for (const hook of this.onVerifyFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.result;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Settle a verified payment\n   *\n   * @param paymentPayload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @returns Settlement response\n   */\n  async settlePayment(\n    paymentPayload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    const context: SettleContext = {\n      paymentPayload,\n      requirements,\n    };\n\n    // Execute beforeSettle hooks\n    for (const hook of this.beforeSettleHooks) {\n      const result = await hook(context);\n      if (result && \"abort\" in result && result.abort) {\n        throw new Error(`Settlement aborted: ${result.reason}`);\n      }\n    }\n\n    try {\n      // Find the facilitator that supports this payment type\n      const facilitatorClient = this.getFacilitatorClient(\n        paymentPayload.x402Version,\n        requirements.network,\n        requirements.scheme,\n      );\n\n      let settleResult: SettleResponse;\n\n      if (!facilitatorClient) {\n        // Fallback: try all facilitators if no specific support found\n        let lastError: Error | undefined;\n\n        for (const client of this.facilitatorClients) {\n          try {\n            settleResult = await client.settle(paymentPayload, requirements);\n            break;\n          } catch (error) {\n            lastError = error as Error;\n          }\n        }\n\n        if (!settleResult!) {\n          throw (\n            lastError ||\n            new Error(\n              `No facilitator supports ${requirements.scheme} on ${requirements.network} for v${paymentPayload.x402Version}`,\n            )\n          );\n        }\n      } else {\n        // Use the specific facilitator that supports this payment\n        settleResult = await facilitatorClient.settle(paymentPayload, requirements);\n      }\n\n      // Execute afterSettle hooks\n      const resultContext: SettleResultContext = {\n        ...context,\n        result: settleResult,\n      };\n\n      for (const hook of this.afterSettleHooks) {\n        await hook(resultContext);\n      }\n\n      return settleResult;\n    } catch (error) {\n      const failureContext: SettleFailureContext = {\n        ...context,\n        error: error as Error,\n      };\n\n      // Execute onSettleFailure hooks\n      for (const hook of this.onSettleFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.result;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Find matching payment requirements for a payment\n   *\n   * @param availableRequirements - Array of available payment requirements\n   * @param paymentPayload - The payment payload\n   * @returns Matching payment requirements or undefined\n   */\n  findMatchingRequirements(\n    availableRequirements: PaymentRequirements[],\n    paymentPayload: PaymentPayload,\n  ): PaymentRequirements | undefined {\n    switch (paymentPayload.x402Version) {\n      case 2:\n        // For v2, match by accepted requirements\n        return availableRequirements.find(paymentRequirements =>\n          deepEqual(paymentRequirements, paymentPayload.accepted),\n        );\n      case 1:\n        // For v1, match by scheme and network\n        return availableRequirements.find(\n          req =>\n            req.scheme === paymentPayload.accepted.scheme &&\n            req.network === paymentPayload.accepted.network,\n        );\n      default:\n        throw new Error(\n          `Unsupported x402 version: ${(paymentPayload as PaymentPayload).x402Version}`,\n        );\n    }\n  }\n\n  /**\n   * Process a payment request\n   *\n   * @param paymentPayload - Optional payment payload if provided\n   * @param resourceConfig - Configuration for the protected resource\n   * @param resourceInfo - Information about the resource being accessed\n   * @param extensions - Optional extensions to include in the response\n   * @returns Processing result\n   */\n  async processPaymentRequest(\n    paymentPayload: PaymentPayload | null,\n    resourceConfig: ResourceConfig,\n    resourceInfo: ResourceInfo,\n    extensions?: Record<string, unknown>,\n  ): Promise<{\n    success: boolean;\n    requiresPayment?: PaymentRequired;\n    verificationResult?: VerifyResponse;\n    settlementResult?: SettleResponse;\n    error?: string;\n  }> {\n    const requirements = await this.buildPaymentRequirements(resourceConfig);\n\n    if (!paymentPayload) {\n      return {\n        success: false,\n        requiresPayment: this.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"Payment required\",\n          extensions,\n        ),\n      };\n    }\n\n    // Find matching requirements\n    const matchingRequirements = this.findMatchingRequirements(requirements, paymentPayload);\n    if (!matchingRequirements) {\n      return {\n        success: false,\n        requiresPayment: this.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"No matching payment requirements found\",\n          extensions,\n        ),\n      };\n    }\n\n    // Verify payment\n    const verificationResult = await this.verifyPayment(paymentPayload, matchingRequirements);\n    if (!verificationResult.isValid) {\n      return {\n        success: false,\n        error: verificationResult.invalidReason,\n        verificationResult,\n      };\n    }\n\n    // Payment verified, ready for settlement\n    return {\n      success: true,\n      verificationResult,\n    };\n  }\n\n  /**\n   * Get facilitator client for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The facilitator client or undefined if not found\n   */\n  private getFacilitatorClient(\n    x402Version: number,\n    network: Network,\n    scheme: string,\n  ): FacilitatorClient | undefined {\n    const versionMap = this.facilitatorClientsMap.get(x402Version);\n    if (!versionMap) return undefined;\n\n    // Use findByNetworkAndScheme for pattern matching\n    return findByNetworkAndScheme(versionMap, scheme, network);\n  }\n}\n\nexport default x402ResourceServer;\n"],"names":["x402Version"],"mappings":"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"}}]
}