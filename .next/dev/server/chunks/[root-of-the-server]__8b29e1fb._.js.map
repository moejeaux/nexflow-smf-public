{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/sentry.ts"],"sourcesContent":["// src/lib/sentry.ts\r\n\r\n// Temporary no-op Sentry shim to avoid module errors during dev\r\nconst Sentry = null as any;\r\n\r\nexport const sentry = {\r\n  captureException: (..._args: any[]) => {},\r\n  captureMessage: (..._args: any[]) => {},\r\n  withScope: (fn: (scope: any) => void) => fn({}),\r\n};\r\n\r\n// No-op functions for compatibility\r\nexport function initSentry() {}\r\nexport function setSentryUser(_userId?: string, _apiKeyId?: string) {}\r\nexport function setSentryContext(_context: any) {}\r\nexport function captureException(_error: Error, _context?: any) {}\r\nexport function captureMessage(_message: string, _level: any = 'info', _context?: any) {}\r\n"],"names":[],"mappings":"AAAA,oBAAoB;AAEpB,gEAAgE;;;;;;;;;;;;;;;AAChE,MAAM,SAAS;AAER,MAAM,SAAS;IACpB,kBAAkB,CAAC,GAAG,SAAkB;IACxC,gBAAgB,CAAC,GAAG,SAAkB;IACtC,WAAW,CAAC,KAA6B,GAAG,CAAC;AAC/C;AAGO,SAAS,cAAc;AACvB,SAAS,cAAc,OAAgB,EAAE,SAAkB,GAAG;AAC9D,SAAS,iBAAiB,QAAa,GAAG;AAC1C,SAAS,iBAAiB,MAAa,EAAE,QAAc,GAAG;AAC1D,SAAS,eAAe,QAAgB,EAAE,SAAc,MAAM,EAAE,QAAc,GAAG"}},
    {"offset": {"line": 155, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/logger.ts"],"sourcesContent":["// =============================================================================\r\n// Structured Logging\r\n// =============================================================================\r\n// Uses Pino for fast, structured logging\r\n// Supports request ID tracking and different log levels\r\n// All logs include standard fields: timestamp, level, message, requestId, etc.\r\n\r\nimport pino from 'pino';\r\n\r\n// Determine log level from environment\r\nconst logLevel = process.env.LOG_LEVEL || (process.env.NODE_ENV === 'production' ? 'info' : 'debug');\r\n\r\n// Create logger instance with structured output\r\n// In Next.js dev mode, disable pino-pretty transport to avoid worker thread issues\r\n// Use simple JSON output instead (can be prettified by other tools)\r\nconst isNextDev = process.env.NODE_ENV === 'development' && process.env.NEXT_RUNTIME;\r\nconst usePrettyTransport = process.env.NODE_ENV !== 'production' && !isNextDev;\r\n\r\nconst logger = pino({\r\n  level: logLevel,\r\n  transport: usePrettyTransport ? {\r\n    target: 'pino-pretty',\r\n    options: {\r\n      colorize: true,\r\n      translateTime: 'SYS:standard',\r\n      ignore: 'pid,hostname',\r\n    },\r\n  } : undefined,\r\n  formatters: {\r\n    level: (label) => {\r\n      return { level: label.toUpperCase() };\r\n    },\r\n  },\r\n  base: {\r\n    env: process.env.NODE_ENV || 'development',\r\n    service: 'nexflow-api',\r\n  },\r\n  // Ensure timestamps are included\r\n  timestamp: pino.stdTimeFunctions.isoTime,\r\n});\r\n\r\nexport type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';\r\n\r\n/**\r\n * Standard log context fields\r\n */\r\nexport interface LogContext {\r\n  // Request tracking\r\n  requestId?: string;\r\n  apiKeyId?: string;\r\n  endpoint?: string;\r\n  method?: string;\r\n  statusCode?: number;\r\n  durationMs?: number;\r\n  ip?: string;\r\n  \r\n  // Error context\r\n  errorCode?: string;\r\n  error?: Error | any;\r\n  stack?: string;\r\n  \r\n  // CDP/x402 context\r\n  cdpStatus?: string;\r\n  cdpErrorId?: string;\r\n  paymentIntentId?: string;\r\n  x402HeaderId?: string;\r\n  \r\n  // Rate limiting\r\n  rateLimitKey?: string;\r\n  rateLimitRemaining?: number;\r\n  \r\n  // Additional context\r\n  [key: string]: any;\r\n}\r\n\r\n/**\r\n * Create a child logger with additional context\r\n * Useful for request-scoped logging with request IDs\r\n */\r\nexport function createLogger(context?: LogContext | Record<string, any>) {\r\n  return context ? logger.child(context) : logger;\r\n}\r\n\r\n/**\r\n * Get the default logger instance\r\n */\r\nexport function getLogger() {\r\n  return logger;\r\n}\r\n\r\n/**\r\n * Sanitize sensitive data from log context\r\n * Removes API keys, tokens, payment headers, and PII\r\n */\r\nfunction sanitizeContext(context: LogContext): LogContext {\r\n  const sanitized = { ...context };\r\n  \r\n  // Remove sensitive fields\r\n  const sensitiveKeys = [\r\n    'apiKey', 'token', 'authorization', 'x-payment', 'paymentHeader',\r\n    'cardNumber', 'cvv', 'ssn', 'password', 'secret',\r\n  ];\r\n  \r\n  sensitiveKeys.forEach(key => {\r\n    if (key in sanitized) {\r\n      delete sanitized[key];\r\n    }\r\n  });\r\n  \r\n  // Truncate long strings that might contain sensitive data\r\n  Object.keys(sanitized).forEach(key => {\r\n    const value = sanitized[key];\r\n    if (typeof value === 'string' && value.length > 200) {\r\n      sanitized[key] = value.substring(0, 200) + '... [truncated]';\r\n    }\r\n  });\r\n  \r\n  return sanitized;\r\n}\r\n\r\n/**\r\n * Log levels with structured context\r\n */\r\nexport const log = {\r\n  trace: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.trace(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  debug: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.debug(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  info: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.info(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  warn: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.warn(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  error: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.error(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry if error object exists\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'UNKNOWN_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n  fatal: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.fatal(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry for fatal errors\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'FATAL_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n            severity: 'fatal',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport default logger;\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 347, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/upstream-proxy-enhanced.ts"],"sourcesContent":["// =============================================================================\r\n// Enhanced Upstream Proxy with Retry Logic and Circuit Breaker\r\n// =============================================================================\r\n// Production-grade proxy with:\r\n// - Exponential backoff retry\r\n// - Circuit breaker pattern\r\n// - Connection pooling\r\n// - Better error handling\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'UpstreamProxy' });\r\n\r\nexport interface ProxyOptions {\r\n  upstreamUrl: string;\r\n  method: string;\r\n  headers: Headers;\r\n  body?: string | null;\r\n  timeout?: number;\r\n  maxRetries?: number;\r\n  retryDelay?: number;\r\n  retryableStatusCodes?: number[];\r\n}\r\n\r\nexport interface ProxyResult {\r\n  success: boolean;\r\n  statusCode: number;\r\n  headers: Record<string, string>;\r\n  body: string;\r\n  responseTime: number;\r\n  error?: string;\r\n  retries?: number;\r\n}\r\n\r\n/**\r\n * Circuit breaker state\r\n */\r\ninterface CircuitBreakerState {\r\n  failures: number;\r\n  lastFailureTime: number;\r\n  state: 'closed' | 'open' | 'half-open';\r\n}\r\n\r\nconst circuitBreakers = new Map<string, CircuitBreakerState>();\r\n\r\nconst DEFAULT_CIRCUIT_BREAKER_CONFIG = {\r\n  failureThreshold: 5, // Open circuit after 5 failures\r\n  resetTimeout: 60000, // 60 seconds before attempting to close\r\n  halfOpenTimeout: 30000, // 30 seconds in half-open state\r\n};\r\n\r\n/**\r\n * Check if circuit breaker allows request\r\n */\r\nfunction checkCircuitBreaker(upstreamUrl: string): boolean {\r\n  const state = circuitBreakers.get(upstreamUrl);\r\n  if (!state) {\r\n    // Initialize as closed\r\n    circuitBreakers.set(upstreamUrl, {\r\n      failures: 0,\r\n      lastFailureTime: 0,\r\n      state: 'closed',\r\n    });\r\n    return true;\r\n  }\r\n\r\n  const now = Date.now();\r\n  const config = DEFAULT_CIRCUIT_BREAKER_CONFIG;\r\n\r\n  switch (state.state) {\r\n    case 'closed':\r\n      return true;\r\n    \r\n    case 'open':\r\n      // Check if we should transition to half-open\r\n      if (now - state.lastFailureTime > config.resetTimeout) {\r\n        state.state = 'half-open';\r\n        logger.info('Circuit breaker transitioning to half-open', { upstreamUrl });\r\n        return true;\r\n      }\r\n      return false;\r\n    \r\n    case 'half-open':\r\n      // Allow one request to test\r\n      return true;\r\n    \r\n    default:\r\n      return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Record circuit breaker success\r\n */\r\nfunction recordSuccess(upstreamUrl: string): void {\r\n  const state = circuitBreakers.get(upstreamUrl);\r\n  if (state) {\r\n    if (state.state === 'half-open') {\r\n      // Success in half-open means we can close the circuit\r\n      state.state = 'closed';\r\n      state.failures = 0;\r\n      logger.info('Circuit breaker closed after successful request', { upstreamUrl });\r\n    } else {\r\n      // Reset failure count on success\r\n      state.failures = 0;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Record circuit breaker failure\r\n */\r\nfunction recordFailure(upstreamUrl: string): void {\r\n  const state = circuitBreakers.get(upstreamUrl);\r\n  if (!state) {\r\n    circuitBreakers.set(upstreamUrl, {\r\n      failures: 1,\r\n      lastFailureTime: Date.now(),\r\n      state: 'closed',\r\n    });\r\n    return;\r\n  }\r\n\r\n  state.failures++;\r\n  state.lastFailureTime = Date.now();\r\n  const config = DEFAULT_CIRCUIT_BREAKER_CONFIG;\r\n\r\n  if (state.state === 'half-open') {\r\n    // Failure in half-open means we should open again\r\n    state.state = 'open';\r\n    logger.warn('Circuit breaker opened after failure in half-open state', {\r\n      upstreamUrl,\r\n      failures: state.failures,\r\n    });\r\n  } else if (state.failures >= config.failureThreshold) {\r\n    state.state = 'open';\r\n    logger.warn('Circuit breaker opened due to failure threshold', {\r\n      upstreamUrl,\r\n      failures: state.failures,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Sleep for specified milliseconds\r\n */\r\nfunction sleep(ms: number): Promise<void> {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n/**\r\n * Calculate exponential backoff delay\r\n */\r\nfunction calculateBackoffDelay(attempt: number, baseDelay: number): number {\r\n  return Math.min(baseDelay * Math.pow(2, attempt), 10000); // Max 10 seconds\r\n}\r\n\r\n/**\r\n * Enhanced proxy with retry logic and circuit breaker\r\n */\r\nexport async function proxyRequestWithRetry(options: ProxyOptions): Promise<ProxyResult> {\r\n  const {\r\n    upstreamUrl,\r\n    method,\r\n    headers,\r\n    body,\r\n    timeout = 30000,\r\n    maxRetries = 3,\r\n    retryDelay = 1000,\r\n    retryableStatusCodes = [502, 503, 504, 408, 429],\r\n  } = options;\r\n\r\n  // Check circuit breaker\r\n  if (!checkCircuitBreaker(upstreamUrl)) {\r\n    logger.warn('Circuit breaker is open, rejecting request', { upstreamUrl });\r\n    return {\r\n      success: false,\r\n      statusCode: 503,\r\n      headers: {},\r\n      body: JSON.stringify({\r\n        error: 'Service temporarily unavailable',\r\n        code: 'CIRCUIT_BREAKER_OPEN',\r\n        details: 'Upstream service is experiencing issues',\r\n      }),\r\n      responseTime: 0,\r\n      error: 'Circuit breaker is open',\r\n    };\r\n  }\r\n\r\n  let lastError: Error | null = null;\r\n  let lastResult: ProxyResult | null = null;\r\n\r\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Prepare headers (exclude host and connection headers)\r\n      const proxyHeaders: Record<string, string> = {};\r\n      headers.forEach((value, key) => {\r\n        const lowerKey = key.toLowerCase();\r\n        if (\r\n          lowerKey !== 'host' &&\r\n          lowerKey !== 'connection' &&\r\n          lowerKey !== 'x-payment' &&\r\n          lowerKey !== 'x-forwarded-host'\r\n        ) {\r\n          proxyHeaders[key] = value;\r\n        }\r\n      });\r\n\r\n      // Add forwarded headers\r\n      proxyHeaders['X-Forwarded-For'] = headers.get('x-forwarded-for') || 'unknown';\r\n      proxyHeaders['X-Forwarded-Proto'] = headers.get('x-forwarded-proto') || 'https';\r\n\r\n      // Create fetch request with timeout\r\n      const controller = new AbortController();\r\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\r\n\r\n      try {\r\n        const response = await fetch(upstreamUrl, {\r\n          method,\r\n          headers: proxyHeaders,\r\n          body: body || undefined,\r\n          signal: controller.signal,\r\n        });\r\n\r\n        clearTimeout(timeoutId);\r\n\r\n        // Read response body\r\n        const responseBody = await response.text();\r\n\r\n        // Convert response headers to object\r\n        const responseHeaders: Record<string, string> = {};\r\n        response.headers.forEach((value, key) => {\r\n          responseHeaders[key] = value;\r\n        });\r\n\r\n        const responseTime = Date.now() - startTime;\r\n\r\n        const result: ProxyResult = {\r\n          success: response.ok,\r\n          statusCode: response.status,\r\n          headers: responseHeaders,\r\n          body: responseBody,\r\n          responseTime,\r\n          retries: attempt,\r\n        };\r\n\r\n        // Check if we should retry\r\n        if (!response.ok && retryableStatusCodes.includes(response.status) && attempt < maxRetries) {\r\n          const backoffDelay = calculateBackoffDelay(attempt, retryDelay);\r\n          logger.warn('Upstream returned retryable error, retrying', {\r\n            upstreamUrl,\r\n            statusCode: response.status,\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            backoffDelay,\r\n          });\r\n          \r\n          await sleep(backoffDelay);\r\n          lastResult = result;\r\n          continue;\r\n        }\r\n\r\n        // Success or non-retryable error\r\n        recordSuccess(upstreamUrl);\r\n        return result;\r\n      } catch (fetchError) {\r\n        clearTimeout(timeoutId);\r\n        throw fetchError;\r\n      }\r\n    } catch (error) {\r\n      const responseTime = Date.now() - startTime;\r\n      lastError = error instanceof Error ? error : new Error('Unknown error');\r\n\r\n      // Check if error is retryable\r\n      const isRetryable = \r\n        (error instanceof Error && error.name === 'AbortError') || // Timeout\r\n        (error instanceof TypeError && error.message.includes('fetch')); // Network error\r\n\r\n      if (isRetryable && attempt < maxRetries) {\r\n        const backoffDelay = calculateBackoffDelay(attempt, retryDelay);\r\n        logger.warn('Upstream request failed, retrying', {\r\n          upstreamUrl,\r\n          error: lastError.message,\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          backoffDelay,\r\n        });\r\n        \r\n        await sleep(backoffDelay);\r\n        continue;\r\n      }\r\n\r\n      // Non-retryable error or max retries reached\r\n      recordFailure(upstreamUrl);\r\n      \r\n      if (lastError.name === 'AbortError') {\r\n        return {\r\n          success: false,\r\n          statusCode: 504,\r\n          headers: {},\r\n          body: JSON.stringify({ error: 'Upstream timeout' }),\r\n          responseTime,\r\n          error: 'Request timeout',\r\n          retries: attempt,\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: false,\r\n        statusCode: 502,\r\n        headers: {},\r\n        body: JSON.stringify({\r\n          error: 'Upstream error',\r\n          details: lastError.message,\r\n        }),\r\n        responseTime,\r\n        error: lastError.message,\r\n        retries: attempt,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Max retries reached\r\n  recordFailure(upstreamUrl);\r\n  \r\n  return {\r\n    success: false,\r\n    statusCode: lastResult?.statusCode || 502,\r\n    headers: lastResult?.headers || {},\r\n    body: lastResult?.body || JSON.stringify({\r\n      error: 'Upstream error after retries',\r\n      details: lastError?.message || 'Unknown error',\r\n    }),\r\n    responseTime: lastResult?.responseTime || 0,\r\n    error: lastError?.message || 'Unknown error',\r\n    retries: maxRetries,\r\n  };\r\n}\r\n\r\n/**\r\n * Get circuit breaker status for monitoring\r\n */\r\nexport function getCircuitBreakerStatus(upstreamUrl?: string): Record<string, any> {\r\n  if (upstreamUrl) {\r\n    const state = circuitBreakers.get(upstreamUrl);\r\n    return {\r\n      [upstreamUrl]: state || {\r\n        failures: 0,\r\n        lastFailureTime: 0,\r\n        state: 'closed',\r\n      },\r\n    };\r\n  }\r\n\r\n  // Return all circuit breakers\r\n  const status: Record<string, any> = {};\r\n  circuitBreakers.forEach((state, url) => {\r\n    status[url] = state;\r\n  });\r\n  return status;\r\n}\r\n\r\n/**\r\n * Reset circuit breaker (for testing/admin)\r\n */\r\nexport function resetCircuitBreaker(upstreamUrl: string): void {\r\n  circuitBreakers.delete(upstreamUrl);\r\n  logger.info('Circuit breaker reset', { upstreamUrl });\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,+DAA+D;AAC/D,gFAAgF;AAChF,+BAA+B;AAC/B,8BAA8B;AAC9B,4BAA4B;AAC5B,uBAAuB;AACvB,0BAA0B;;;;;;;;;AAE1B;;AAEA,MAAM,SAAS,IAAA,sIAAY,EAAC;IAAE,WAAW;AAAgB;AAgCzD,MAAM,kBAAkB,IAAI;AAE5B,MAAM,iCAAiC;IACrC,kBAAkB;IAClB,cAAc;IACd,iBAAiB;AACnB;AAEA;;CAEC,GACD,SAAS,oBAAoB,WAAmB;IAC9C,MAAM,QAAQ,gBAAgB,GAAG,CAAC;IAClC,IAAI,CAAC,OAAO;QACV,uBAAuB;QACvB,gBAAgB,GAAG,CAAC,aAAa;YAC/B,UAAU;YACV,iBAAiB;YACjB,OAAO;QACT;QACA,OAAO;IACT;IAEA,MAAM,MAAM,KAAK,GAAG;IACpB,MAAM,SAAS;IAEf,OAAQ,MAAM,KAAK;QACjB,KAAK;YACH,OAAO;QAET,KAAK;YACH,6CAA6C;YAC7C,IAAI,MAAM,MAAM,eAAe,GAAG,OAAO,YAAY,EAAE;gBACrD,MAAM,KAAK,GAAG;gBACd,OAAO,IAAI,CAAC,8CAA8C;oBAAE;gBAAY;gBACxE,OAAO;YACT;YACA,OAAO;QAET,KAAK;YACH,4BAA4B;YAC5B,OAAO;QAET;YACE,OAAO;IACX;AACF;AAEA;;CAEC,GACD,SAAS,cAAc,WAAmB;IACxC,MAAM,QAAQ,gBAAgB,GAAG,CAAC;IAClC,IAAI,OAAO;QACT,IAAI,MAAM,KAAK,KAAK,aAAa;YAC/B,sDAAsD;YACtD,MAAM,KAAK,GAAG;YACd,MAAM,QAAQ,GAAG;YACjB,OAAO,IAAI,CAAC,mDAAmD;gBAAE;YAAY;QAC/E,OAAO;YACL,iCAAiC;YACjC,MAAM,QAAQ,GAAG;QACnB;IACF;AACF;AAEA;;CAEC,GACD,SAAS,cAAc,WAAmB;IACxC,MAAM,QAAQ,gBAAgB,GAAG,CAAC;IAClC,IAAI,CAAC,OAAO;QACV,gBAAgB,GAAG,CAAC,aAAa;YAC/B,UAAU;YACV,iBAAiB,KAAK,GAAG;YACzB,OAAO;QACT;QACA;IACF;IAEA,MAAM,QAAQ;IACd,MAAM,eAAe,GAAG,KAAK,GAAG;IAChC,MAAM,SAAS;IAEf,IAAI,MAAM,KAAK,KAAK,aAAa;QAC/B,kDAAkD;QAClD,MAAM,KAAK,GAAG;QACd,OAAO,IAAI,CAAC,2DAA2D;YACrE;YACA,UAAU,MAAM,QAAQ;QAC1B;IACF,OAAO,IAAI,MAAM,QAAQ,IAAI,OAAO,gBAAgB,EAAE;QACpD,MAAM,KAAK,GAAG;QACd,OAAO,IAAI,CAAC,mDAAmD;YAC7D;YACA,UAAU,MAAM,QAAQ;QAC1B;IACF;AACF;AAEA;;CAEC,GACD,SAAS,MAAM,EAAU;IACvB,OAAO,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;AACpD;AAEA;;CAEC,GACD,SAAS,sBAAsB,OAAe,EAAE,SAAiB;IAC/D,OAAO,KAAK,GAAG,CAAC,YAAY,KAAK,GAAG,CAAC,GAAG,UAAU,QAAQ,iBAAiB;AAC7E;AAKO,eAAe,sBAAsB,OAAqB;IAC/D,MAAM,EACJ,WAAW,EACX,MAAM,EACN,OAAO,EACP,IAAI,EACJ,UAAU,KAAK,EACf,aAAa,CAAC,EACd,aAAa,IAAI,EACjB,uBAAuB;QAAC;QAAK;QAAK;QAAK;QAAK;KAAI,EACjD,GAAG;IAEJ,wBAAwB;IACxB,IAAI,CAAC,oBAAoB,cAAc;QACrC,OAAO,IAAI,CAAC,8CAA8C;YAAE;QAAY;QACxE,OAAO;YACL,SAAS;YACT,YAAY;YACZ,SAAS,CAAC;YACV,MAAM,KAAK,SAAS,CAAC;gBACnB,OAAO;gBACP,MAAM;gBACN,SAAS;YACX;YACA,cAAc;YACd,OAAO;QACT;IACF;IAEA,IAAI,YAA0B;IAC9B,IAAI,aAAiC;IAErC,IAAK,IAAI,UAAU,GAAG,WAAW,YAAY,UAAW;QACtD,MAAM,YAAY,KAAK,GAAG;QAE1B,IAAI;YACF,wDAAwD;YACxD,MAAM,eAAuC,CAAC;YAC9C,QAAQ,OAAO,CAAC,CAAC,OAAO;gBACtB,MAAM,WAAW,IAAI,WAAW;gBAChC,IACE,aAAa,UACb,aAAa,gBACb,aAAa,eACb,aAAa,oBACb;oBACA,YAAY,CAAC,IAAI,GAAG;gBACtB;YACF;YAEA,wBAAwB;YACxB,YAAY,CAAC,kBAAkB,GAAG,QAAQ,GAAG,CAAC,sBAAsB;YACpE,YAAY,CAAC,oBAAoB,GAAG,QAAQ,GAAG,CAAC,wBAAwB;YAExE,oCAAoC;YACpC,MAAM,aAAa,IAAI;YACvB,MAAM,YAAY,WAAW,IAAM,WAAW,KAAK,IAAI;YAEvD,IAAI;gBACF,MAAM,WAAW,MAAM,MAAM,aAAa;oBACxC;oBACA,SAAS;oBACT,MAAM,QAAQ;oBACd,QAAQ,WAAW,MAAM;gBAC3B;gBAEA,aAAa;gBAEb,qBAAqB;gBACrB,MAAM,eAAe,MAAM,SAAS,IAAI;gBAExC,qCAAqC;gBACrC,MAAM,kBAA0C,CAAC;gBACjD,SAAS,OAAO,CAAC,OAAO,CAAC,CAAC,OAAO;oBAC/B,eAAe,CAAC,IAAI,GAAG;gBACzB;gBAEA,MAAM,eAAe,KAAK,GAAG,KAAK;gBAElC,MAAM,SAAsB;oBAC1B,SAAS,SAAS,EAAE;oBACpB,YAAY,SAAS,MAAM;oBAC3B,SAAS;oBACT,MAAM;oBACN;oBACA,SAAS;gBACX;gBAEA,2BAA2B;gBAC3B,IAAI,CAAC,SAAS,EAAE,IAAI,qBAAqB,QAAQ,CAAC,SAAS,MAAM,KAAK,UAAU,YAAY;oBAC1F,MAAM,eAAe,sBAAsB,SAAS;oBACpD,OAAO,IAAI,CAAC,+CAA+C;wBACzD;wBACA,YAAY,SAAS,MAAM;wBAC3B,SAAS,UAAU;wBACnB;wBACA;oBACF;oBAEA,MAAM,MAAM;oBACZ,aAAa;oBACb;gBACF;gBAEA,iCAAiC;gBACjC,cAAc;gBACd,OAAO;YACT,EAAE,OAAO,YAAY;gBACnB,aAAa;gBACb,MAAM;YACR;QACF,EAAE,OAAO,OAAO;YACd,MAAM,eAAe,KAAK,GAAG,KAAK;YAClC,YAAY,iBAAiB,QAAQ,QAAQ,IAAI,MAAM;YAEvD,8BAA8B;YAC9B,MAAM,cACJ,AAAC,iBAAiB,SAAS,MAAM,IAAI,KAAK,gBACzC,iBAAiB,aAAa,MAAM,OAAO,CAAC,QAAQ,CAAC,UAAW,gBAAgB;YAEnF,IAAI,eAAe,UAAU,YAAY;gBACvC,MAAM,eAAe,sBAAsB,SAAS;gBACpD,OAAO,IAAI,CAAC,qCAAqC;oBAC/C;oBACA,OAAO,UAAU,OAAO;oBACxB,SAAS,UAAU;oBACnB;oBACA;gBACF;gBAEA,MAAM,MAAM;gBACZ;YACF;YAEA,6CAA6C;YAC7C,cAAc;YAEd,IAAI,UAAU,IAAI,KAAK,cAAc;gBACnC,OAAO;oBACL,SAAS;oBACT,YAAY;oBACZ,SAAS,CAAC;oBACV,MAAM,KAAK,SAAS,CAAC;wBAAE,OAAO;oBAAmB;oBACjD;oBACA,OAAO;oBACP,SAAS;gBACX;YACF;YAEA,OAAO;gBACL,SAAS;gBACT,YAAY;gBACZ,SAAS,CAAC;gBACV,MAAM,KAAK,SAAS,CAAC;oBACnB,OAAO;oBACP,SAAS,UAAU,OAAO;gBAC5B;gBACA;gBACA,OAAO,UAAU,OAAO;gBACxB,SAAS;YACX;QACF;IACF;IAEA,sBAAsB;IACtB,cAAc;IAEd,OAAO;QACL,SAAS;QACT,YAAY,YAAY,cAAc;QACtC,SAAS,YAAY,WAAW,CAAC;QACjC,MAAM,YAAY,QAAQ,KAAK,SAAS,CAAC;YACvC,OAAO;YACP,SAAS,WAAW,WAAW;QACjC;QACA,cAAc,YAAY,gBAAgB;QAC1C,OAAO,WAAW,WAAW;QAC7B,SAAS;IACX;AACF;AAKO,SAAS,wBAAwB,WAAoB;IAC1D,IAAI,aAAa;QACf,MAAM,QAAQ,gBAAgB,GAAG,CAAC;QAClC,OAAO;YACL,CAAC,YAAY,EAAE,SAAS;gBACtB,UAAU;gBACV,iBAAiB;gBACjB,OAAO;YACT;QACF;IACF;IAEA,8BAA8B;IAC9B,MAAM,SAA8B,CAAC;IACrC,gBAAgB,OAAO,CAAC,CAAC,OAAO;QAC9B,MAAM,CAAC,IAAI,GAAG;IAChB;IACA,OAAO;AACT;AAKO,SAAS,oBAAoB,WAAmB;IACrD,gBAAgB,MAAM,CAAC;IACvB,OAAO,IAAI,CAAC,yBAAyB;QAAE;IAAY;AACrD"}},
    {"offset": {"line": 646, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/app/api/v1/pulse/%5B...path%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { proxyRequestWithRetry } from '@/lib/upstream-proxy-enhanced';\r\n\r\n/**\r\n * Pulse Backend Proxy Route\r\n * \r\n * Proxies /api/v1/pulse/* requests to the Pulse backend running on\r\n * the configured PULSE_INTERNAL_BASE URL (default: http://165.245.129.101:3100)\r\n * \r\n * Supports: GET, POST, PUT, PATCH, DELETE\r\n */\r\n\r\n// Maximum request body size (10MB default, configurable via env)\r\nconst MAX_REQUEST_BODY_SIZE = parseInt(process.env.MAX_REQUEST_BODY_SIZE || '10485760', 10);\r\n\r\n/**\r\n * Build the target URL for the Pulse backend\r\n */\r\nfunction buildPulseUrl(pathSegments: string[], searchParams: URLSearchParams): string {\r\n  const pulseBase = process.env.PULSE_INTERNAL_BASE || 'http://165.245.129.101:3100';\r\n  \r\n  // Handle empty path segments (shouldn't happen with [...path] but handle gracefully)\r\n  const path = pathSegments.length > 0 ? pathSegments.join('/') : '';\r\n  const targetPath = path ? `/v1/pulse/${path}` : '/v1/pulse';\r\n  \r\n  // Preserve query string\r\n  const queryString = searchParams.toString();\r\n  const fullUrl = queryString \r\n    ? `${pulseBase}${targetPath}?${queryString}`\r\n    : `${pulseBase}${targetPath}`;\r\n  \r\n  return fullUrl;\r\n}\r\n\r\n/**\r\n * Handle all HTTP methods for Pulse proxy\r\n */\r\nasync function handlePulseRequest(\r\n  request: NextRequest,\r\n  pathSegments: string[]\r\n): Promise<NextResponse> {\r\n  try {\r\n    // Check request body size\r\n    const contentLength = request.headers.get('content-length');\r\n    if (contentLength) {\r\n      const bodySize = parseInt(contentLength, 10);\r\n      if (bodySize > MAX_REQUEST_BODY_SIZE) {\r\n        return NextResponse.json(\r\n          {\r\n            error: 'Request body too large',\r\n            code: 'REQUEST_TOO_LARGE',\r\n            maxSize: MAX_REQUEST_BODY_SIZE,\r\n            receivedSize: bodySize,\r\n          },\r\n          { status: 413 }\r\n        );\r\n      }\r\n    }\r\n\r\n    // Build target URL with path segments and query string\r\n    const searchParams = request.nextUrl.searchParams;\r\n    const targetUrl = buildPulseUrl(pathSegments, searchParams);\r\n\r\n    // Read request body (if any)\r\n    let requestBody: string | null = null;\r\n    if (request.method !== 'GET' && request.method !== 'HEAD') {\r\n      try {\r\n        const bodyText = await request.text();\r\n        const bodySize = new TextEncoder().encode(bodyText).length;\r\n        \r\n        if (bodySize > MAX_REQUEST_BODY_SIZE) {\r\n          return NextResponse.json(\r\n            {\r\n              error: 'Request body too large',\r\n              code: 'REQUEST_TOO_LARGE',\r\n              maxSize: MAX_REQUEST_BODY_SIZE,\r\n              receivedSize: bodySize,\r\n            },\r\n            { status: 413 }\r\n          );\r\n        }\r\n        \r\n        requestBody = bodyText || null;\r\n      } catch (error) {\r\n        // If body reading fails, continue with null\r\n        requestBody = null;\r\n      }\r\n    }\r\n\r\n    // Proxy request to Pulse backend using enhanced proxy with retry logic\r\n    const proxyResult = await proxyRequestWithRetry({\r\n      upstreamUrl: targetUrl,\r\n      method: request.method,\r\n      headers: request.headers,\r\n      body: requestBody,\r\n      timeout: 30000, // 30 seconds\r\n      maxRetries: 3,\r\n      retryDelay: 1000,\r\n      retryableStatusCodes: [502, 503, 504, 408, 429],\r\n    });\r\n\r\n    // Convert proxy result to NextResponse\r\n    const response = new NextResponse(proxyResult.body, {\r\n      status: proxyResult.statusCode,\r\n      headers: proxyResult.headers,\r\n    });\r\n\r\n    return response;\r\n  } catch (error) {\r\n    console.error('[Pulse Proxy] Error:', error);\r\n    return NextResponse.json(\r\n      {\r\n        error: 'Internal server error',\r\n        code: 'PROXY_ERROR',\r\n        details: error instanceof Error ? error.message : 'Unknown error',\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * GET /api/v1/pulse/[...path]\r\n */\r\nexport async function GET(\r\n  request: NextRequest,\r\n  { params }: { params: Promise<{ path: string[] }> }\r\n) {\r\n  const { path } = await params;\r\n  return handlePulseRequest(request, path);\r\n}\r\n\r\n/**\r\n * POST /api/v1/pulse/[...path]\r\n */\r\nexport async function POST(\r\n  request: NextRequest,\r\n  { params }: { params: Promise<{ path: string[] }> }\r\n) {\r\n  const { path } = await params;\r\n  return handlePulseRequest(request, path);\r\n}\r\n\r\n/**\r\n * PUT /api/v1/pulse/[...path]\r\n */\r\nexport async function PUT(\r\n  request: NextRequest,\r\n  { params }: { params: Promise<{ path: string[] }> }\r\n) {\r\n  const { path } = await params;\r\n  return handlePulseRequest(request, path);\r\n}\r\n\r\n/**\r\n * PATCH /api/v1/pulse/[...path]\r\n */\r\nexport async function PATCH(\r\n  request: NextRequest,\r\n  { params }: { params: Promise<{ path: string[] }> }\r\n) {\r\n  const { path } = await params;\r\n  return handlePulseRequest(request, path);\r\n}\r\n\r\n/**\r\n * DELETE /api/v1/pulse/[...path]\r\n */\r\nexport async function DELETE(\r\n  request: NextRequest,\r\n  { params }: { params: Promise<{ path: string[] }> }\r\n) {\r\n  const { path } = await params;\r\n  return handlePulseRequest(request, path);\r\n}\r\n"],"names":[],"mappings":"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"}}]
}