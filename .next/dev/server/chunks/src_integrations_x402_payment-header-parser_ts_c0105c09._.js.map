{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/payment-header-parser.ts"],"sourcesContent":["import { getCDPFacilitator, type CDPVerifyRequest } from './cdp-facilitator';\r\nimport type { PaymentAuthorization } from './signature-verifier';\r\n\r\n/**\r\n * Parsed x402 payment header structure\r\n */\r\nexport interface ParsedPaymentHeader {\r\n  invoiceId: string;\r\n  txHash?: string;\r\n  signature: string;\r\n  authorization: PaymentAuthorization;\r\n  network?: string;\r\n}\r\n\r\n/**\r\n * Parse x402 payment header from HTTP header value\r\n * \r\n * x402 payment headers are typically base64-encoded JSON containing:\r\n * - signature: EIP-712 signature\r\n * - authorization: Payment authorization object\r\n * - network: Blockchain network identifier\r\n * \r\n * Format: x402 <base64-encoded-json>\r\n */\r\nexport function parseX402Header(headerValue: string): {\r\n  valid: boolean;\r\n  parsed?: ParsedPaymentHeader;\r\n  error?: string;\r\n} {\r\n  try {\r\n    // Validate header is not empty\r\n    if (!headerValue || headerValue.trim().length === 0) {\r\n      return { valid: false, error: 'Payment header is empty' };\r\n    }\r\n\r\n    // Check for placeholder values\r\n    if (headerValue.includes('<your_payment_header>') || headerValue.includes('<placeholder>')) {\r\n      return { valid: false, error: 'Payment header contains placeholder value. Please provide a real x402 payment header.' };\r\n    }\r\n\r\n    // Remove 'x402 ' prefix if present\r\n    const cleanHeader = headerValue.startsWith('x402 ')\r\n      ? headerValue.slice(5).trim()\r\n      : headerValue.trim();\r\n\r\n    if (cleanHeader.length === 0) {\r\n      return { valid: false, error: 'Payment header value is empty after removing prefix' };\r\n    }\r\n\r\n    // Decode base64 (works in both Node.js and browser environments)\r\n    let decoded: string;\r\n    try {\r\n      decoded = typeof window === 'undefined'\r\n        ? Buffer.from(cleanHeader, 'base64').toString('utf-8')\r\n        : atob(cleanHeader);\r\n    } catch (base64Error) {\r\n      return { \r\n        valid: false, \r\n        error: `Invalid base64 encoding: ${base64Error instanceof Error ? base64Error.message : 'Failed to decode base64'}` \r\n      };\r\n    }\r\n\r\n    // Parse JSON\r\n    let payload: {\r\n      signature?: string;\r\n      authorization?: {\r\n        from?: string;\r\n        to?: string;\r\n        value?: string;\r\n        validAfter?: string;\r\n        validBefore?: string;\r\n        nonce?: string;\r\n      };\r\n      network?: string;\r\n      invoiceId?: string;\r\n      txHash?: string;\r\n    };\r\n    \r\n    try {\r\n      payload = JSON.parse(decoded);\r\n    } catch (jsonError) {\r\n      return { \r\n        valid: false, \r\n        error: `Invalid JSON in payment header: ${jsonError instanceof Error ? jsonError.message : 'Failed to parse JSON'}. Decoded value: ${decoded.substring(0, 100)}` \r\n      };\r\n    }\r\n\r\n    // Validate required fields\r\n    if (!payload.signature) {\r\n      return { valid: false, error: 'Missing signature in payment header' };\r\n    }\r\n\r\n    if (!payload.authorization) {\r\n      return { valid: false, error: 'Missing authorization in payment header' };\r\n    }\r\n\r\n    const auth = payload.authorization;\r\n    if (!auth.from || !auth.to || !auth.value || !auth.nonce) {\r\n      return { valid: false, error: 'Incomplete authorization fields' };\r\n    }\r\n\r\n    return {\r\n      valid: true,\r\n      parsed: {\r\n        invoiceId: payload.invoiceId || auth.nonce,\r\n        txHash: payload.txHash,\r\n        signature: payload.signature,\r\n        authorization: {\r\n          from: auth.from as `0x${string}`,\r\n          to: auth.to as `0x${string}`,\r\n          value: auth.value,\r\n          validAfter: auth.validAfter || Math.floor(Date.now() / 1000).toString(),\r\n          validBefore: auth.validBefore || (Math.floor(Date.now() / 1000) + 300).toString(),\r\n          nonce: auth.nonce,\r\n        },\r\n        network: payload.network || 'base',\r\n      },\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      valid: false,\r\n      error: error instanceof Error ? error.message : 'Failed to parse payment header',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Parse and verify x402 payment header with CDP facilitator\r\n * \r\n * This function:\r\n * 1. Parses the payment header\r\n * 2. Verifies the payment with CDP\r\n * 3. Returns the verification result\r\n */\r\nexport async function parseAndVerifyPaymentHeader(\r\n  headerValue: string\r\n): Promise<{\r\n  valid: boolean;\r\n  payment?: ParsedPaymentHeader;\r\n  transactionHash?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Parse the header\r\n    const parseResult = parseX402Header(headerValue);\r\n    if (!parseResult.valid || !parseResult.parsed) {\r\n      return {\r\n        valid: false,\r\n        error: parseResult.error || 'Invalid payment header format',\r\n      };\r\n    }\r\n\r\n    const parsed = parseResult.parsed;\r\n\r\n    // Create CDP verify request\r\n    const verifyRequest: CDPVerifyRequest = {\r\n      payment: headerValue,\r\n      paymentPayload: {\r\n        x402Version: 1,\r\n        scheme: 'x402',\r\n        network: parsed.network || 'base',\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: parsed.authorization,\r\n        },\r\n      },\r\n    };\r\n\r\n    // Verify with CDP\r\n    const cdp = getCDPFacilitator();\r\n    const verifyResult = await cdp.verifyPayment(verifyRequest);\r\n\r\n    if (!verifyResult.valid || !verifyResult.success) {\r\n      return {\r\n        valid: false,\r\n        error: verifyResult.error || 'Payment verification failed',\r\n      };\r\n    }\r\n\r\n    return {\r\n      valid: true,\r\n      payment: parsed,\r\n      transactionHash: verifyResult.transactionHash,\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      valid: false,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}}]
}