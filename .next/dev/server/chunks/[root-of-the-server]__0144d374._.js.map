{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/sentry.ts"],"sourcesContent":["// src/lib/sentry.ts\r\n\r\n// Temporary no-op Sentry shim to avoid module errors during dev\r\nconst Sentry = null as any;\r\n\r\nexport const sentry = {\r\n  captureException: (..._args: any[]) => {},\r\n  captureMessage: (..._args: any[]) => {},\r\n  withScope: (fn: (scope: any) => void) => fn({}),\r\n};\r\n\r\n// No-op functions for compatibility\r\nexport function initSentry() {}\r\nexport function setSentryUser(_userId?: string, _apiKeyId?: string) {}\r\nexport function setSentryContext(_context: any) {}\r\nexport function captureException(_error: Error, _context?: any) {}\r\nexport function captureMessage(_message: string, _level: any = 'info', _context?: any) {}\r\n"],"names":[],"mappings":"AAAA,oBAAoB;AAEpB,gEAAgE;;;;;;;;;;;;;;;AAChE,MAAM,SAAS;AAER,MAAM,SAAS;IACpB,kBAAkB,CAAC,GAAG,SAAkB;IACxC,gBAAgB,CAAC,GAAG,SAAkB;IACtC,WAAW,CAAC,KAA6B,GAAG,CAAC;AAC/C;AAGO,SAAS,cAAc;AACvB,SAAS,cAAc,OAAgB,EAAE,SAAkB,GAAG;AAC9D,SAAS,iBAAiB,QAAa,GAAG;AAC1C,SAAS,iBAAiB,MAAa,EAAE,QAAc,GAAG;AAC1D,SAAS,eAAe,QAAgB,EAAE,SAAc,MAAM,EAAE,QAAc,GAAG"}},
    {"offset": {"line": 155, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/logger.ts"],"sourcesContent":["// =============================================================================\r\n// Structured Logging\r\n// =============================================================================\r\n// Uses Pino for fast, structured logging\r\n// Supports request ID tracking and different log levels\r\n// All logs include standard fields: timestamp, level, message, requestId, etc.\r\n\r\nimport pino from 'pino';\r\n\r\n// Determine log level from environment\r\nconst logLevel = process.env.LOG_LEVEL || (process.env.NODE_ENV === 'production' ? 'info' : 'debug');\r\n\r\n// Create logger instance with structured output\r\n// In Next.js dev mode, disable pino-pretty transport to avoid worker thread issues\r\n// Use simple JSON output instead (can be prettified by other tools)\r\nconst isNextDev = process.env.NODE_ENV === 'development' && process.env.NEXT_RUNTIME;\r\nconst usePrettyTransport = process.env.NODE_ENV !== 'production' && !isNextDev;\r\n\r\nconst logger = pino({\r\n  level: logLevel,\r\n  transport: usePrettyTransport ? {\r\n    target: 'pino-pretty',\r\n    options: {\r\n      colorize: true,\r\n      translateTime: 'SYS:standard',\r\n      ignore: 'pid,hostname',\r\n    },\r\n  } : undefined,\r\n  formatters: {\r\n    level: (label) => {\r\n      return { level: label.toUpperCase() };\r\n    },\r\n  },\r\n  base: {\r\n    env: process.env.NODE_ENV || 'development',\r\n    service: 'nexflow-api',\r\n  },\r\n  // Ensure timestamps are included\r\n  timestamp: pino.stdTimeFunctions.isoTime,\r\n});\r\n\r\nexport type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';\r\n\r\n/**\r\n * Standard log context fields\r\n */\r\nexport interface LogContext {\r\n  // Request tracking\r\n  requestId?: string;\r\n  apiKeyId?: string;\r\n  endpoint?: string;\r\n  method?: string;\r\n  statusCode?: number;\r\n  durationMs?: number;\r\n  ip?: string;\r\n  \r\n  // Error context\r\n  errorCode?: string;\r\n  error?: Error | any;\r\n  stack?: string;\r\n  \r\n  // CDP/x402 context\r\n  cdpStatus?: string;\r\n  cdpErrorId?: string;\r\n  paymentIntentId?: string;\r\n  x402HeaderId?: string;\r\n  \r\n  // Rate limiting\r\n  rateLimitKey?: string;\r\n  rateLimitRemaining?: number;\r\n  \r\n  // Additional context\r\n  [key: string]: any;\r\n}\r\n\r\n/**\r\n * Create a child logger with additional context\r\n * Useful for request-scoped logging with request IDs\r\n */\r\nexport function createLogger(context?: LogContext | Record<string, any>) {\r\n  return context ? logger.child(context) : logger;\r\n}\r\n\r\n/**\r\n * Get the default logger instance\r\n */\r\nexport function getLogger() {\r\n  return logger;\r\n}\r\n\r\n/**\r\n * Sanitize sensitive data from log context\r\n * Removes API keys, tokens, payment headers, and PII\r\n */\r\nfunction sanitizeContext(context: LogContext): LogContext {\r\n  const sanitized = { ...context };\r\n  \r\n  // Remove sensitive fields\r\n  const sensitiveKeys = [\r\n    'apiKey', 'token', 'authorization', 'x-payment', 'paymentHeader',\r\n    'cardNumber', 'cvv', 'ssn', 'password', 'secret',\r\n  ];\r\n  \r\n  sensitiveKeys.forEach(key => {\r\n    if (key in sanitized) {\r\n      delete sanitized[key];\r\n    }\r\n  });\r\n  \r\n  // Truncate long strings that might contain sensitive data\r\n  Object.keys(sanitized).forEach(key => {\r\n    const value = sanitized[key];\r\n    if (typeof value === 'string' && value.length > 200) {\r\n      sanitized[key] = value.substring(0, 200) + '... [truncated]';\r\n    }\r\n  });\r\n  \r\n  return sanitized;\r\n}\r\n\r\n/**\r\n * Log levels with structured context\r\n */\r\nexport const log = {\r\n  trace: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.trace(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  debug: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.debug(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  info: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.info(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  warn: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.warn(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  error: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.error(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry if error object exists\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'UNKNOWN_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n  fatal: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.fatal(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry for fatal errors\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'FATAL_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n            severity: 'fatal',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport default logger;\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 359, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/services/facilitator-metrics-service.ts"],"sourcesContent":["// =============================================================================\r\n// FACILITATOR METRICS SERVICE\r\n// =============================================================================\r\n// Service for persisting and managing facilitator path metrics from x402scan\r\n// Uses Supabase/PostgreSQL in production, falls back to JSON files in development\r\n//\r\n// =============================================================================\r\n// RETENTION & COMPACTION PLAN (TODO)\r\n// =============================================================================\r\n// 1. Raw buckets (bucketMinutes < 60):\r\n//    - Keep for 7 days\r\n//    - After 7 days, compact into hourly rollups\r\n//\r\n// 2. Hourly rollups (bucketMinutes = 60):\r\n//    - Keep for 30 days\r\n//    - After 30 days, compact into daily rollups\r\n//\r\n// 3. Daily rollups (bucketMinutes = 1440):\r\n//    - Keep for 90 days\r\n//    - After 90 days, archive or delete\r\n//\r\n// Compaction strategy:\r\n//    - Sum invocations, successCount, failureCount, status buckets\r\n//    - Weighted average for latency percentiles (weight by invocations)\r\n//    - Recalculate errorRate from compacted counts\r\n//\r\n// TODO: Implement compactMetrics() function for scheduled compaction job\r\n// =============================================================================\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport {\r\n  type FacilitatorPathMetrics,\r\n  type FacilitatorSummary,\r\n  type FacilitatorPathMetricsTimeframe,\r\n  type FacilitatorMethodMetrics,\r\n} from '@/infra/x402scan/types';\r\nimport { Pool } from 'pg';\r\n\r\nconst logger = createLogger({ component: 'FacilitatorMetricsService' });\r\n\r\n// =============================================================================\r\n// DATABASE CONNECTION\r\n// =============================================================================\r\n\r\nlet pool: Pool | null = null;\r\n\r\nfunction getPool(): Pool | null {\r\n  if (pool) return pool;\r\n  \r\n  const databaseUrl = process.env.DATABASE_URL;\r\n  if (!databaseUrl || !databaseUrl.startsWith('postgresql://')) {\r\n    return null;\r\n  }\r\n  \r\n  pool = new Pool({\r\n    connectionString: databaseUrl,\r\n    max: 5,\r\n    idleTimeoutMillis: 30000,\r\n    connectionTimeoutMillis: 5000,\r\n  });\r\n  \r\n  return pool;\r\n}\r\n\r\n// =============================================================================\r\n// DATABASE STORAGE FUNCTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Upsert facilitator path metrics to the database\r\n */\r\nasync function upsertMetricsToDb(metrics: FacilitatorPathMetrics[]): Promise<void> {\r\n  const db = getPool();\r\n  if (!db || metrics.length === 0) return;\r\n\r\n  const client = await db.connect();\r\n  try {\r\n    await client.query('BEGIN');\r\n\r\n    for (const m of metrics) {\r\n      await client.query(`\r\n        INSERT INTO smf_facilitator_metrics (\r\n          kind, facilitator_id, resource_url, server_id, network,\r\n          timeframe, bucket_minutes, time_bucket_start, time_bucket_end,\r\n          invocations, success_count, failure_count,\r\n          count_2xx, count_3xx, count_4xx, count_5xx,\r\n          error_rate, avg_latency_ms, p50_latency_ms, p90_latency_ms, p95_latency_ms, p99_latency_ms,\r\n          methods, fetched_at, updated_at\r\n        ) VALUES (\r\n          $1, $2, $3, $4, $5,\r\n          $6, $7, $8, $9,\r\n          $10, $11, $12,\r\n          $13, $14, $15, $16,\r\n          $17, $18, $19, $20, $21, $22,\r\n          $23, $24, NOW()\r\n        )\r\n        ON CONFLICT (facilitator_id, timeframe, time_bucket_start)\r\n        DO UPDATE SET\r\n          kind = EXCLUDED.kind,\r\n          resource_url = EXCLUDED.resource_url,\r\n          server_id = EXCLUDED.server_id,\r\n          network = EXCLUDED.network,\r\n          bucket_minutes = EXCLUDED.bucket_minutes,\r\n          time_bucket_end = EXCLUDED.time_bucket_end,\r\n          invocations = EXCLUDED.invocations,\r\n          success_count = EXCLUDED.success_count,\r\n          failure_count = EXCLUDED.failure_count,\r\n          count_2xx = EXCLUDED.count_2xx,\r\n          count_3xx = EXCLUDED.count_3xx,\r\n          count_4xx = EXCLUDED.count_4xx,\r\n          count_5xx = EXCLUDED.count_5xx,\r\n          error_rate = EXCLUDED.error_rate,\r\n          avg_latency_ms = EXCLUDED.avg_latency_ms,\r\n          p50_latency_ms = EXCLUDED.p50_latency_ms,\r\n          p90_latency_ms = EXCLUDED.p90_latency_ms,\r\n          p95_latency_ms = EXCLUDED.p95_latency_ms,\r\n          p99_latency_ms = EXCLUDED.p99_latency_ms,\r\n          methods = EXCLUDED.methods,\r\n          fetched_at = EXCLUDED.fetched_at,\r\n          updated_at = NOW()\r\n      `, [\r\n        m.kind,\r\n        m.facilitatorId,\r\n        m.resourceUrl || null,\r\n        m.serverId || null,\r\n        m.network || null,\r\n        m.timeframe,\r\n        m.bucketMinutes,\r\n        m.timeBucketStart,\r\n        m.timeBucketEnd,\r\n        m.invocations,\r\n        m.successCount,\r\n        m.failureCount,\r\n        m.count2xx,\r\n        m.count3xx,\r\n        m.count4xx,\r\n        m.count5xx,\r\n        m.errorRate,\r\n        m.avgLatencyMs || null,\r\n        m.p50LatencyMs || null,\r\n        m.p90LatencyMs || null,\r\n        m.p95LatencyMs || null,\r\n        m.p99LatencyMs || null,\r\n        m.methods ? JSON.stringify(m.methods) : null,\r\n        m.fetchedAt,\r\n      ]);\r\n    }\r\n\r\n    await client.query('COMMIT');\r\n    \r\n    logger.info({\r\n      count: metrics.length,\r\n      facilitatorId: metrics[0]?.facilitatorId,\r\n      timeframe: metrics[0]?.timeframe,\r\n      msg: 'Facilitator metrics upserted to database',\r\n    });\r\n  } catch (error) {\r\n    await client.query('ROLLBACK');\r\n    throw error;\r\n  } finally {\r\n    client.release();\r\n  }\r\n}\r\n\r\n/**\r\n * Load metrics from database\r\n */\r\nasync function loadMetricsFromDb(\r\n  facilitatorId?: string,\r\n  timeframe?: FacilitatorPathMetricsTimeframe\r\n): Promise<FacilitatorPathMetrics[]> {\r\n  const db = getPool();\r\n  if (!db) return [];\r\n\r\n  let query = `\r\n    SELECT * FROM smf_facilitator_metrics\r\n    WHERE fetched_at > NOW() - INTERVAL '30 days'\r\n  `;\r\n  const params: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (facilitatorId) {\r\n    query += ` AND facilitator_id = $${paramIndex}`;\r\n    params.push(facilitatorId);\r\n    paramIndex++;\r\n  }\r\n\r\n  if (timeframe) {\r\n    query += ` AND timeframe = $${paramIndex}`;\r\n    params.push(timeframe);\r\n    paramIndex++;\r\n  }\r\n\r\n  query += ' ORDER BY time_bucket_start DESC LIMIT 1000';\r\n\r\n  const result = await db.query(query, params);\r\n  return result.rows.map(mapDbRowToMetrics);\r\n}\r\n\r\n/**\r\n * Map database row to FacilitatorPathMetrics\r\n */\r\nfunction mapDbRowToMetrics(row: any): FacilitatorPathMetrics {\r\n  return {\r\n    kind: row.kind || 'facilitator-global',\r\n    facilitatorId: row.facilitator_id,\r\n    resourceUrl: row.resource_url || undefined,\r\n    serverId: row.server_id || undefined,\r\n    network: row.network || undefined,\r\n    timeframe: row.timeframe,\r\n    bucketMinutes: row.bucket_minutes,\r\n    timeBucketStart: row.time_bucket_start?.toISOString() || row.time_bucket_start,\r\n    timeBucketEnd: row.time_bucket_end?.toISOString() || row.time_bucket_end,\r\n    invocations: row.invocations,\r\n    successCount: row.success_count,\r\n    failureCount: row.failure_count,\r\n    count2xx: row.count_2xx,\r\n    count3xx: row.count_3xx,\r\n    count4xx: row.count_4xx,\r\n    count5xx: row.count_5xx,\r\n    errorRate: parseFloat(row.error_rate) || 0,\r\n    avgLatencyMs: row.avg_latency_ms ? parseFloat(row.avg_latency_ms) : undefined,\r\n    p50LatencyMs: row.p50_latency_ms ? parseFloat(row.p50_latency_ms) : undefined,\r\n    p90LatencyMs: row.p90_latency_ms ? parseFloat(row.p90_latency_ms) : undefined,\r\n    p95LatencyMs: row.p95_latency_ms ? parseFloat(row.p95_latency_ms) : undefined,\r\n    p99LatencyMs: row.p99_latency_ms ? parseFloat(row.p99_latency_ms) : undefined,\r\n    methods: row.methods || undefined,\r\n    fetchedAt: row.fetched_at?.toISOString() || row.fetched_at,\r\n  };\r\n}\r\n\r\n/**\r\n * Upsert summary to database\r\n */\r\nasync function upsertSummaryToDb(summary: FacilitatorSummary): Promise<void> {\r\n  const db = getPool();\r\n  if (!db) return;\r\n\r\n  // Handle empty timestamps - skip if no valid data\r\n  const dataStart = summary.dataStart && summary.dataStart.length > 0 ? summary.dataStart : null;\r\n  const dataEnd = summary.dataEnd && summary.dataEnd.length > 0 ? summary.dataEnd : null;\r\n  \r\n  // Skip summaries with no actual data\r\n  if (summary.totalInvocations === 0 && !dataStart && !dataEnd) {\r\n    logger.debug({\r\n      facilitatorId: summary.facilitatorId,\r\n      timeframe: summary.timeframe,\r\n      msg: 'Skipping summary with no data',\r\n    });\r\n    return;\r\n  }\r\n\r\n  await db.query(`\r\n    INSERT INTO smf_facilitator_summaries (\r\n      facilitator_id, timeframe,\r\n      total_invocations, total_successes, total_failures, overall_error_rate,\r\n      avg_p50_latency_ms, avg_p90_latency_ms, avg_p99_latency_ms,\r\n      top_methods, data_start, data_end, fetched_at, updated_at\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, NOW())\r\n    ON CONFLICT (facilitator_id, timeframe)\r\n    DO UPDATE SET\r\n      total_invocations = EXCLUDED.total_invocations,\r\n      total_successes = EXCLUDED.total_successes,\r\n      total_failures = EXCLUDED.total_failures,\r\n      overall_error_rate = EXCLUDED.overall_error_rate,\r\n      avg_p50_latency_ms = EXCLUDED.avg_p50_latency_ms,\r\n      avg_p90_latency_ms = EXCLUDED.avg_p90_latency_ms,\r\n      avg_p99_latency_ms = EXCLUDED.avg_p99_latency_ms,\r\n      top_methods = EXCLUDED.top_methods,\r\n      data_start = COALESCE(EXCLUDED.data_start, smf_facilitator_summaries.data_start),\r\n      data_end = COALESCE(EXCLUDED.data_end, smf_facilitator_summaries.data_end),\r\n      fetched_at = EXCLUDED.fetched_at,\r\n      updated_at = NOW()\r\n  `, [\r\n    summary.facilitatorId,\r\n    summary.timeframe,\r\n    summary.totalInvocations,\r\n    summary.totalSuccesses,\r\n    summary.totalFailures,\r\n    summary.overallErrorRate,\r\n    summary.avgP50LatencyMs || null,\r\n    summary.avgP90LatencyMs || null,\r\n    summary.avgP99LatencyMs || null,\r\n    JSON.stringify(summary.topMethods),\r\n    dataStart,\r\n    dataEnd,\r\n    summary.fetchedAt,\r\n  ]);\r\n\r\n  logger.info({\r\n    facilitatorId: summary.facilitatorId,\r\n    timeframe: summary.timeframe,\r\n    totalInvocations: summary.totalInvocations,\r\n    msg: 'Facilitator summary upserted to database',\r\n  });\r\n}\r\n\r\n/**\r\n * Load all summaries from database\r\n */\r\nasync function loadSummariesFromDb(): Promise<Record<string, FacilitatorSummary>> {\r\n  const db = getPool();\r\n  if (!db) return {};\r\n\r\n  const result = await db.query(`\r\n    SELECT * FROM smf_facilitator_summaries\r\n    ORDER BY fetched_at DESC\r\n  `);\r\n\r\n  const summaries: Record<string, FacilitatorSummary> = {};\r\n  for (const row of result.rows) {\r\n    const key = `${row.facilitator_id}:${row.timeframe}`;\r\n    summaries[key] = {\r\n      facilitatorId: row.facilitator_id,\r\n      timeframe: row.timeframe,\r\n      totalInvocations: parseInt(row.total_invocations) || 0,\r\n      totalSuccesses: parseInt(row.total_successes) || 0,\r\n      totalFailures: parseInt(row.total_failures) || 0,\r\n      overallErrorRate: parseFloat(row.overall_error_rate) || 0,\r\n      avgP50LatencyMs: row.avg_p50_latency_ms ? parseFloat(row.avg_p50_latency_ms) : undefined,\r\n      avgP90LatencyMs: row.avg_p90_latency_ms ? parseFloat(row.avg_p90_latency_ms) : undefined,\r\n      avgP99LatencyMs: row.avg_p99_latency_ms ? parseFloat(row.avg_p99_latency_ms) : undefined,\r\n      topMethods: row.top_methods || [],\r\n      dataStart: row.data_start?.toISOString() || row.data_start,\r\n      dataEnd: row.data_end?.toISOString() || row.data_end,\r\n      fetchedAt: row.fetched_at?.toISOString() || row.fetched_at,\r\n    };\r\n  }\r\n\r\n  return summaries;\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API - Abstracts storage backend\r\n// =============================================================================\r\n\r\n/**\r\n * Check if database is available\r\n */\r\nexport function isDatabaseAvailable(): boolean {\r\n  return getPool() !== null;\r\n}\r\n\r\n/**\r\n * Load all stored metrics\r\n */\r\nexport async function loadAllMetrics(): Promise<FacilitatorPathMetrics[]> {\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      return await loadMetricsFromDb();\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to load metrics from database, returning empty' });\r\n      return [];\r\n    }\r\n  }\r\n  // Fallback: return empty in production if DB not available\r\n  logger.warn({ msg: 'Database not available, returning empty metrics' });\r\n  return [];\r\n}\r\n\r\n/**\r\n * Upsert facilitator path metrics\r\n * Updates existing records or inserts new ones based on (facilitatorId, timeframe, timeBucketStart)\r\n */\r\nexport async function upsertFacilitatorPathMetrics(\r\n  metrics: FacilitatorPathMetrics[]\r\n): Promise<void> {\r\n  if (metrics.length === 0) {\r\n    logger.debug('No metrics to upsert');\r\n    return;\r\n  }\r\n\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      await upsertMetricsToDb(metrics);\r\n      return;\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to upsert metrics to database' });\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  // In production without DB, log warning\r\n  logger.warn({ \r\n    count: metrics.length, \r\n    msg: 'Database not available, metrics not persisted' \r\n  });\r\n}\r\n\r\n/**\r\n * Load stored summaries\r\n */\r\nexport async function loadAllSummaries(): Promise<Record<string, FacilitatorSummary>> {\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      return await loadSummariesFromDb();\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to load summaries from database' });\r\n      return {};\r\n    }\r\n  }\r\n  return {};\r\n}\r\n\r\n/**\r\n * Upsert facilitator summary\r\n */\r\nexport async function upsertFacilitatorSummary(summary: FacilitatorSummary): Promise<void> {\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      await upsertSummaryToDb(summary);\r\n      return;\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to upsert summary to database' });\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  logger.warn({ \r\n    facilitatorId: summary.facilitatorId, \r\n    msg: 'Database not available, summary not persisted' \r\n  });\r\n}\r\n\r\n/**\r\n * Upsert multiple facilitator summaries\r\n */\r\nexport async function upsertFacilitatorSummaries(summaries: FacilitatorSummary[]): Promise<void> {\r\n  for (const summary of summaries) {\r\n    await upsertFacilitatorSummary(summary);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// QUERY FUNCTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Get metrics for a specific facilitator\r\n */\r\nexport async function getMetricsForFacilitator(\r\n  facilitatorId: string,\r\n  timeframe?: FacilitatorPathMetricsTimeframe\r\n): Promise<FacilitatorPathMetrics[]> {\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      return await loadMetricsFromDb(facilitatorId, timeframe);\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to get metrics for facilitator' });\r\n      return [];\r\n    }\r\n  }\r\n  return [];\r\n}\r\n\r\n/**\r\n * Get summary for a specific facilitator and timeframe\r\n */\r\nexport async function getSummary(\r\n  facilitatorId: string,\r\n  timeframe: FacilitatorPathMetricsTimeframe\r\n): Promise<FacilitatorSummary | null> {\r\n  const summaries = await loadAllSummaries();\r\n  const key = `${facilitatorId}:${timeframe}`;\r\n  return summaries[key] ?? null;\r\n}\r\n\r\n/**\r\n * Get all summaries for a specific facilitator across all timeframes\r\n */\r\nexport async function getSummariesForFacilitator(\r\n  facilitatorId: string\r\n): Promise<FacilitatorSummary[]> {\r\n  const summaries = await loadAllSummaries();\r\n  return Object.values(summaries).filter((s) => s.facilitatorId === facilitatorId);\r\n}\r\n\r\n/**\r\n * Get latest metrics across all facilitators\r\n */\r\nexport async function getLatestMetrics(\r\n  limit: number = 100\r\n): Promise<FacilitatorPathMetrics[]> {\r\n  const allMetrics = await loadAllMetrics();\r\n  return allMetrics.slice(0, limit);\r\n}\r\n\r\n/**\r\n * Get metrics comparison across facilitators for a timeframe\r\n */\r\nexport async function compareFacilitators(\r\n  facilitatorIds: string[],\r\n  timeframe: FacilitatorPathMetricsTimeframe\r\n): Promise<Map<string, FacilitatorSummary | null>> {\r\n  const summaries = await loadAllSummaries();\r\n  const result = new Map<string, FacilitatorSummary | null>();\r\n\r\n  for (const id of facilitatorIds) {\r\n    const key = `${id}:${timeframe}`;\r\n    result.set(id, summaries[key] ?? null);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// =============================================================================\r\n// CLEANUP\r\n// =============================================================================\r\n\r\n/**\r\n * Clean up old metrics data\r\n */\r\nexport async function cleanupOldMetrics(daysToKeep: number = 30): Promise<number> {\r\n  const db = getPool();\r\n  if (!db) return 0;\r\n\r\n  const result = await db.query(`\r\n    DELETE FROM smf_facilitator_metrics\r\n    WHERE time_bucket_start < NOW() - INTERVAL '${daysToKeep} days'\r\n  `);\r\n\r\n  const removed = result.rowCount || 0;\r\n  if (removed > 0) {\r\n    logger.info({ removed, daysToKeep, msg: 'Old metrics cleaned up from database' });\r\n  }\r\n\r\n  return removed;\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 826, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/services/facilitator-volume-service.ts"],"sourcesContent":["// =============================================================================\r\n// FACILITATOR VOLUME SERVICE\r\n// =============================================================================\r\n// Service for persisting and managing facilitator volume/activity metrics from Scattering\r\n// Uses Supabase/PostgreSQL in production, falls back to logging-only in development\r\n//\r\n// =============================================================================\r\n// RETENTION PLAN (TODO)\r\n// =============================================================================\r\n// 1. Current period snapshots (3d):\r\n//    - Keep last 30 snapshots (approx 1 month if pulled daily)\r\n//    - Each snapshot is a full picture of facilitator activity\r\n//\r\n// 2. Historical rollups:\r\n//    - Weekly: Keep 12 weeks of weekly summaries\r\n//    - Monthly: Keep 12 months of monthly summaries\r\n//\r\n// Compaction strategy:\r\n//    - Average volumeUsd3d, txCount3d across period\r\n//    - Track min/max/avg for trend analysis\r\n//    - Keep peak values for market awareness\r\n//\r\n// TODO: Implement weekly/monthly compaction\r\n// =============================================================================\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport { type ScatteringFacilitatorMetrics } from '@/infra/scattering/types';\r\nimport { Pool } from 'pg';\r\n\r\nconst logger = createLogger({ component: 'FacilitatorVolumeService' });\r\n\r\n// =============================================================================\r\n// DATABASE CONNECTION\r\n// =============================================================================\r\n\r\nlet pool: Pool | null = null;\r\n\r\nfunction getPool(): Pool | null {\r\n  if (pool) return pool;\r\n  \r\n  const databaseUrl = process.env.DATABASE_URL;\r\n  if (!databaseUrl || !databaseUrl.startsWith('postgresql://')) {\r\n    return null;\r\n  }\r\n  \r\n  pool = new Pool({\r\n    connectionString: databaseUrl,\r\n    max: 5,\r\n    idleTimeoutMillis: 30000,\r\n    connectionTimeoutMillis: 5000,\r\n  });\r\n  \r\n  return pool;\r\n}\r\n\r\n// =============================================================================\r\n// DATABASE STORAGE FUNCTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Upsert Scattering metrics to database\r\n */\r\nasync function upsertScatteringToDb(metrics: ScatteringFacilitatorMetrics[]): Promise<void> {\r\n  const db = getPool();\r\n  if (!db || metrics.length === 0) return;\r\n\r\n  const client = await db.connect();\r\n  const fetchedAt = new Date().toISOString();\r\n  const snapshotId = crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(36).slice(2)}`;\r\n  \r\n  try {\r\n    await client.query('BEGIN');\r\n\r\n    for (const m of metrics) {\r\n      // Upsert current metrics\r\n      await client.query(`\r\n        INSERT INTO smf_scattering_metrics (\r\n          facilitator_id, period,\r\n          volume_usd_3d, tx_count_3d, unique_buyers_3d, unique_sellers_3d,\r\n          volume_usd_all_time, chains, volume_change_rate, tx_change_rate,\r\n          fetched_at, updated_at\r\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW())\r\n        ON CONFLICT (facilitator_id, period)\r\n        DO UPDATE SET\r\n          volume_usd_3d = EXCLUDED.volume_usd_3d,\r\n          tx_count_3d = EXCLUDED.tx_count_3d,\r\n          unique_buyers_3d = EXCLUDED.unique_buyers_3d,\r\n          unique_sellers_3d = EXCLUDED.unique_sellers_3d,\r\n          volume_usd_all_time = EXCLUDED.volume_usd_all_time,\r\n          chains = EXCLUDED.chains,\r\n          volume_change_rate = EXCLUDED.volume_change_rate,\r\n          tx_change_rate = EXCLUDED.tx_change_rate,\r\n          fetched_at = EXCLUDED.fetched_at,\r\n          updated_at = NOW()\r\n      `, [\r\n        m.facilitatorId,\r\n        m.period,\r\n        m.volumeUsd3d,\r\n        m.txCount3d,\r\n        m.uniqueBuyers3d,\r\n        m.uniqueSellers3d,\r\n        m.volumeUsdAllTime,\r\n        JSON.stringify(m.chains),\r\n        m.volumeChangeRate ?? null,\r\n        m.txChangeRate ?? null,\r\n        fetchedAt,\r\n      ]);\r\n\r\n      // Insert into history table\r\n      await client.query(`\r\n        INSERT INTO smf_scattering_history (\r\n          snapshot_id, facilitator_id, period,\r\n          volume_usd_3d, tx_count_3d, unique_buyers_3d, unique_sellers_3d,\r\n          volume_usd_all_time, chains, volume_change_rate, tx_change_rate,\r\n          fetched_at\r\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\r\n      `, [\r\n        snapshotId,\r\n        m.facilitatorId,\r\n        m.period,\r\n        m.volumeUsd3d,\r\n        m.txCount3d,\r\n        m.uniqueBuyers3d,\r\n        m.uniqueSellers3d,\r\n        m.volumeUsdAllTime,\r\n        JSON.stringify(m.chains),\r\n        m.volumeChangeRate ?? null,\r\n        m.txChangeRate ?? null,\r\n        fetchedAt,\r\n      ]);\r\n    }\r\n\r\n    await client.query('COMMIT');\r\n    \r\n    // Log summary\r\n    const totalVolume = metrics.reduce((sum, m) => sum + m.volumeUsd3d, 0);\r\n    const totalTxns = metrics.reduce((sum, m) => sum + m.txCount3d, 0);\r\n\r\n    logger.info({\r\n      facilitatorCount: metrics.length,\r\n      totalVolume3d: `$${formatNumber(totalVolume)}`,\r\n      totalTxns3d: formatNumber(totalTxns),\r\n      msg: 'Scattering metrics upserted to database',\r\n    });\r\n  } catch (error) {\r\n    await client.query('ROLLBACK');\r\n    throw error;\r\n  } finally {\r\n    client.release();\r\n  }\r\n}\r\n\r\n/**\r\n * Load current Scattering metrics from database\r\n */\r\nasync function loadScatteringFromDb(): Promise<Record<string, ScatteringFacilitatorMetrics>> {\r\n  const db = getPool();\r\n  if (!db) return {};\r\n\r\n  const result = await db.query(`\r\n    SELECT * FROM smf_scattering_metrics\r\n    ORDER BY fetched_at DESC\r\n  `);\r\n\r\n  const metrics: Record<string, ScatteringFacilitatorMetrics> = {};\r\n  for (const row of result.rows) {\r\n    metrics[row.facilitator_id] = mapDbRowToScattering(row);\r\n  }\r\n\r\n  return metrics;\r\n}\r\n\r\n/**\r\n * Map database row to ScatteringFacilitatorMetrics\r\n */\r\nfunction mapDbRowToScattering(row: any): ScatteringFacilitatorMetrics {\r\n  return {\r\n    facilitatorId: row.facilitator_id,\r\n    period: row.period || '3d',\r\n    volumeUsd3d: parseFloat(row.volume_usd_3d) || 0,\r\n    txCount3d: parseInt(row.tx_count_3d) || 0,\r\n    uniqueBuyers3d: row.unique_buyers_3d || 0,\r\n    uniqueSellers3d: row.unique_sellers_3d || 0,\r\n    volumeUsdAllTime: parseFloat(row.volume_usd_all_time) || 0,\r\n    chains: row.chains || [],\r\n    volumeChangeRate: row.volume_change_rate ? parseFloat(row.volume_change_rate) : undefined,\r\n    txChangeRate: row.tx_change_rate ? parseFloat(row.tx_change_rate) : undefined,\r\n    fetchedAt: row.fetched_at?.toISOString() || row.fetched_at,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API\r\n// =============================================================================\r\n\r\n/**\r\n * Check if database is available\r\n */\r\nexport function isDatabaseAvailable(): boolean {\r\n  return getPool() !== null;\r\n}\r\n\r\n/**\r\n * Upsert Scattering metrics\r\n * - Updates the \"current\" snapshot with latest data\r\n * - Appends to history for trend analysis\r\n */\r\nexport async function upsertScatteringMetrics(\r\n  metrics: ScatteringFacilitatorMetrics[]\r\n): Promise<void> {\r\n  if (metrics.length === 0) {\r\n    logger.debug('No Scattering metrics to upsert');\r\n    return;\r\n  }\r\n\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      await upsertScatteringToDb(metrics);\r\n      return;\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to upsert Scattering metrics to database' });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Log summary even without DB\r\n  const totalVolume = metrics.reduce((sum, m) => sum + m.volumeUsd3d, 0);\r\n  const totalTxns = metrics.reduce((sum, m) => sum + m.txCount3d, 0);\r\n\r\n  logger.warn({\r\n    facilitatorCount: metrics.length,\r\n    totalVolume3d: `$${formatNumber(totalVolume)}`,\r\n    totalTxns3d: formatNumber(totalTxns),\r\n    msg: 'Database not available, Scattering metrics not persisted',\r\n  });\r\n}\r\n\r\n/**\r\n * Load all current Scattering metrics\r\n */\r\nexport async function loadAllScatteringMetrics(): Promise<ScatteringFacilitatorMetrics[]> {\r\n  const db = getPool();\r\n  if (db) {\r\n    try {\r\n      const metrics = await loadScatteringFromDb();\r\n      return Object.values(metrics);\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to load Scattering metrics from database' });\r\n      return [];\r\n    }\r\n  }\r\n  return [];\r\n}\r\n\r\n/**\r\n * Get Scattering metrics for a specific facilitator\r\n */\r\nexport async function getScatteringMetricsForFacilitator(\r\n  facilitatorId: string\r\n): Promise<ScatteringFacilitatorMetrics | null> {\r\n  const db = getPool();\r\n  if (!db) return null;\r\n\r\n  try {\r\n    const result = await db.query(`\r\n      SELECT * FROM smf_scattering_metrics\r\n      WHERE facilitator_id = $1\r\n      ORDER BY fetched_at DESC\r\n      LIMIT 1\r\n    `, [facilitatorId]);\r\n\r\n    if (result.rows.length === 0) return null;\r\n    return mapDbRowToScattering(result.rows[0]);\r\n  } catch (error) {\r\n    logger.error({ error, facilitatorId, msg: 'Failed to get Scattering metrics' });\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get Scattering metrics for multiple facilitators\r\n */\r\nexport async function getScatteringMetricsForFacilitators(\r\n  facilitatorIds: string[]\r\n): Promise<Map<string, ScatteringFacilitatorMetrics | null>> {\r\n  const result = new Map<string, ScatteringFacilitatorMetrics | null>();\r\n  \r\n  const db = getPool();\r\n  if (!db) {\r\n    for (const id of facilitatorIds) {\r\n      result.set(id, null);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  try {\r\n    const metrics = await loadScatteringFromDb();\r\n    for (const id of facilitatorIds) {\r\n      result.set(id, metrics[id] ?? null);\r\n    }\r\n    return result;\r\n  } catch (error) {\r\n    logger.error({ error, msg: 'Failed to get Scattering metrics for facilitators' });\r\n    for (const id of facilitatorIds) {\r\n      result.set(id, null);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n/**\r\n * Get historical snapshots for trend analysis\r\n */\r\nexport async function getScatteringHistory(\r\n  limit: number = 10\r\n): Promise<{ fetchedAt: string; metrics: ScatteringFacilitatorMetrics[] }[]> {\r\n  const db = getPool();\r\n  if (!db) return [];\r\n\r\n  try {\r\n    // Get distinct snapshots\r\n    const snapshotsResult = await db.query(`\r\n      SELECT DISTINCT snapshot_id, fetched_at \r\n      FROM smf_scattering_history\r\n      ORDER BY fetched_at DESC\r\n      LIMIT $1\r\n    `, [limit]);\r\n\r\n    const history: { fetchedAt: string; metrics: ScatteringFacilitatorMetrics[] }[] = [];\r\n\r\n    for (const snapshot of snapshotsResult.rows) {\r\n      const metricsResult = await db.query(`\r\n        SELECT * FROM smf_scattering_history\r\n        WHERE snapshot_id = $1\r\n      `, [snapshot.snapshot_id]);\r\n\r\n      history.push({\r\n        fetchedAt: snapshot.fetched_at?.toISOString() || snapshot.fetched_at,\r\n        metrics: metricsResult.rows.map(mapDbRowToScattering),\r\n      });\r\n    }\r\n\r\n    return history;\r\n  } catch (error) {\r\n    logger.error({ error, msg: 'Failed to get Scattering history' });\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get historical metrics for a specific facilitator\r\n */\r\nexport async function getFacilitatorVolumeHistory(\r\n  facilitatorId: string,\r\n  limit: number = 10\r\n): Promise<ScatteringFacilitatorMetrics[]> {\r\n  const db = getPool();\r\n  if (!db) return [];\r\n\r\n  try {\r\n    const result = await db.query(`\r\n      SELECT * FROM smf_scattering_history\r\n      WHERE facilitator_id = $1\r\n      ORDER BY fetched_at DESC\r\n      LIMIT $2\r\n    `, [facilitatorId, limit]);\r\n\r\n    return result.rows.map(mapDbRowToScattering);\r\n  } catch (error) {\r\n    logger.error({ error, facilitatorId, msg: 'Failed to get volume history' });\r\n    return [];\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// ANALYSIS HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Get top facilitators by 3-day volume\r\n */\r\nexport async function getTopFacilitatorsByVolume(\r\n  limit: number = 10\r\n): Promise<ScatteringFacilitatorMetrics[]> {\r\n  const metrics = await loadAllScatteringMetrics();\r\n  \r\n  return metrics\r\n    .sort((a, b) => b.volumeUsd3d - a.volumeUsd3d)\r\n    .slice(0, limit);\r\n}\r\n\r\n/**\r\n * Get top facilitators by 3-day transaction count\r\n */\r\nexport async function getTopFacilitatorsByTxCount(\r\n  limit: number = 10\r\n): Promise<ScatteringFacilitatorMetrics[]> {\r\n  const metrics = await loadAllScatteringMetrics();\r\n  \r\n  return metrics\r\n    .sort((a, b) => b.txCount3d - a.txCount3d)\r\n    .slice(0, limit);\r\n}\r\n\r\n/**\r\n * Get facilitators with positive volume growth\r\n */\r\nexport async function getGrowingFacilitators(): Promise<ScatteringFacilitatorMetrics[]> {\r\n  const metrics = await loadAllScatteringMetrics();\r\n  \r\n  return metrics\r\n    .filter((m) => m.volumeChangeRate !== undefined && m.volumeChangeRate > 0)\r\n    .sort((a, b) => (b.volumeChangeRate ?? 0) - (a.volumeChangeRate ?? 0));\r\n}\r\n\r\n/**\r\n * Calculate activity score for a facilitator (0-1 scale)\r\n * Used by SMF scoring to evaluate facilitator health\r\n */\r\nexport function computeActivityScore(metrics: ScatteringFacilitatorMetrics): number {\r\n  // Weights for different factors\r\n  const VOLUME_WEIGHT = 0.3;\r\n  const TX_WEIGHT = 0.3;\r\n  const BUYERS_WEIGHT = 0.2;\r\n  const SELLERS_WEIGHT = 0.1;\r\n  const GROWTH_WEIGHT = 0.1;\r\n\r\n  // Reference values (approximate top-tier facilitator numbers)\r\n  const MAX_VOLUME = 200_000; // $200K 3d volume\r\n  const MAX_TX = 3_000_000;   // 3M txns\r\n  const MAX_BUYERS = 15_000;  // 15K unique buyers\r\n  const MAX_SELLERS = 1_000;  // 1K unique sellers\r\n\r\n  // Normalize each factor to 0-1\r\n  const volumeScore = Math.min(metrics.volumeUsd3d / MAX_VOLUME, 1);\r\n  const txScore = Math.min(metrics.txCount3d / MAX_TX, 1);\r\n  const buyersScore = Math.min(metrics.uniqueBuyers3d / MAX_BUYERS, 1);\r\n  const sellersScore = Math.min(metrics.uniqueSellers3d / MAX_SELLERS, 1);\r\n\r\n  // Growth bonus (positive growth adds to score, negative subtracts)\r\n  let growthScore = 0.5; // neutral\r\n  if (metrics.volumeChangeRate !== undefined) {\r\n    // Clamp growth between -100% and +100%\r\n    const clampedGrowth = Math.max(-100, Math.min(100, metrics.volumeChangeRate));\r\n    growthScore = (clampedGrowth + 100) / 200; // normalize to 0-1\r\n  }\r\n\r\n  // Calculate weighted score\r\n  const score = \r\n    volumeScore * VOLUME_WEIGHT +\r\n    txScore * TX_WEIGHT +\r\n    buyersScore * BUYERS_WEIGHT +\r\n    sellersScore * SELLERS_WEIGHT +\r\n    growthScore * GROWTH_WEIGHT;\r\n\r\n  return Math.min(Math.max(score, 0), 1); // clamp to 0-1\r\n}\r\n\r\n// =============================================================================\r\n// CLEANUP\r\n// =============================================================================\r\n\r\n/**\r\n * Clean up old history snapshots\r\n */\r\nexport async function cleanupOldSnapshots(keepDays: number = 30): Promise<number> {\r\n  const db = getPool();\r\n  if (!db) return 0;\r\n\r\n  try {\r\n    const result = await db.query(`\r\n      DELETE FROM smf_scattering_history\r\n      WHERE fetched_at < NOW() - INTERVAL '${keepDays} days'\r\n    `);\r\n\r\n    const removed = result.rowCount || 0;\r\n    if (removed > 0) {\r\n      logger.info({ removed, keepDays, msg: 'Old Scattering snapshots cleaned up' });\r\n    }\r\n\r\n    return removed;\r\n  } catch (error) {\r\n    logger.error({ error, msg: 'Failed to cleanup old snapshots' });\r\n    return 0;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// UTILITY\r\n// =============================================================================\r\n\r\n/**\r\n * Format number for logging (e.g., 137535 -> \"137.5K\")\r\n */\r\nfunction formatNumber(num: number): string {\r\n  if (num >= 1_000_000) {\r\n    return `${(num / 1_000_000).toFixed(1)}M`;\r\n  }\r\n  if (num >= 1_000) {\r\n    return `${(num / 1_000).toFixed(1)}K`;\r\n  }\r\n  return num.toFixed(2);\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1264, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/services/facilitator-metrics-reader.ts"],"sourcesContent":["// =============================================================================\n// FACILITATOR METRICS READER\n// =============================================================================\n// Read-side helper for SMF to access facilitator path metrics\n// Used by the SMF router to inform routing decisions\n//\n// Scoring blends two data sources:\n// 1. x402scan: Observability metrics (success rate, latency, confidence)\n// 2. Scattering: Activity metrics (volume, tx count, unique buyers)\n\nimport { createLogger } from '@/lib/logger';\nimport {\n  type FacilitatorPathMetrics,\n  type FacilitatorSummary,\n  type FacilitatorPathMetricsTimeframe,\n} from '@/infra/x402scan/types';\nimport {\n  loadAllMetrics,\n  loadAllSummaries,\n  getSummary,\n  getMetricsForFacilitator,\n} from './facilitator-metrics-service';\nimport {\n  getScatteringMetricsForFacilitator,\n  computeActivityScore,\n} from './facilitator-volume-service';\nimport type { ScatteringFacilitatorMetrics } from '@/infra/scattering/types';\n\nconst logger = createLogger({ component: 'FacilitatorMetricsReader' });\n\n// =============================================================================\n// FRESHNESS & CONFIDENCE CONFIGURATION\n// =============================================================================\n\n/**\n * Configuration for determining when metrics are trustworthy\n * These thresholds prevent routing decisions based on stale or thin data\n */\nexport interface MetricsTrustConfig {\n  /** Maximum age of data to trust (hours) */\n  maxDataAgeHours: number;\n  /** Minimum invocations for high confidence scoring */\n  minInvocationsHighConfidence: number;\n  /** Minimum invocations to use data at all */\n  minInvocationsMinimum: number;\n  /** Penalty multiplier for low confidence data (0-1) */\n  lowConfidencePenalty: number;\n}\n\n/**\n * Default trust configuration\n * Can be overridden via environment variables\n */\nexport const DEFAULT_TRUST_CONFIG: MetricsTrustConfig = {\n  maxDataAgeHours: parseFloat(process.env.METRICS_MAX_AGE_HOURS ?? '4'),\n  minInvocationsHighConfidence: parseInt(process.env.METRICS_MIN_INVOCATIONS_HIGH ?? '1000', 10),\n  minInvocationsMinimum: parseInt(process.env.METRICS_MIN_INVOCATIONS ?? '100', 10),\n  lowConfidencePenalty: parseFloat(process.env.METRICS_LOW_CONFIDENCE_PENALTY ?? '0.5'),\n};\n\n/**\n * Check if metrics should be trusted for routing decisions\n */\nexport function shouldTrustMetrics(\n  dataAgeHours: number,\n  invocations: number,\n  config: MetricsTrustConfig = DEFAULT_TRUST_CONFIG\n): { trust: boolean; confidence: 'high' | 'medium' | 'low' | 'none'; reason: string } {\n  // Data too old\n  if (dataAgeHours > config.maxDataAgeHours) {\n    return {\n      trust: false,\n      confidence: 'none',\n      reason: `data-stale:${dataAgeHours.toFixed(1)}h-old`,\n    };\n  }\n\n  // Not enough data\n  if (invocations < config.minInvocationsMinimum) {\n    return {\n      trust: false,\n      confidence: 'none',\n      reason: `insufficient-data:${invocations}-invocations`,\n    };\n  }\n\n  // High confidence\n  if (invocations >= config.minInvocationsHighConfidence) {\n    return {\n      trust: true,\n      confidence: 'high',\n      reason: `high-confidence:${invocations}-invocations`,\n    };\n  }\n\n  // Medium confidence\n  return {\n    trust: true,\n    confidence: 'medium',\n    reason: `medium-confidence:${invocations}-invocations`,\n  };\n}\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface GetBestPathsParams {\n  /** Facilitator ID (NexFlow format, e.g., \"cdp\", \"payai\") */\n  facilitatorId: string;\n  \n  /** Network filter (optional) */\n  network?: string;\n  \n  /** Timeframe to consider (default: \"1d\") */\n  timeframe?: FacilitatorPathMetricsTimeframe;\n  \n  /** Maximum number of results */\n  limit?: number;\n}\n\nexport interface FacilitatorScoreParams {\n  /** Facilitator ID */\n  facilitatorId: string;\n  \n  /** Timeframe to consider */\n  timeframe?: FacilitatorPathMetricsTimeframe;\n}\n\nexport interface FacilitatorScore {\n  facilitatorId: string;\n  score: number;             // 0-100, higher is better\n  successRate: number;       // 0-1\n  avgLatencyMs?: number;\n  p95LatencyMs?: number;\n  totalInvocations: number;\n  dataFreshness: number;     // hours since last data\n  confidence: 'high' | 'medium' | 'low' | 'none';  // based on data availability\n  reasons: string[];\n  // Scattering activity metrics\n  scatteringActivityScore?: number;    // 0-1 activity score from Scattering\n  scatteringVolume3d?: number;         // 3-day volume in USD\n  scatteringTxCount3d?: number;        // 3-day transaction count\n  scatteringUniqueBuyers3d?: number;   // 3-day unique buyers\n  scatteringLowActivity?: boolean;     // true if below thresholds\n}\n\nexport interface FacilitatorRanking {\n  rankings: FacilitatorScore[];\n  timestamp: string;\n  timeframe: FacilitatorPathMetricsTimeframe;\n}\n\n// =============================================================================\n// SCORING WEIGHTS & CONFIGURATION\n// =============================================================================\n\n/**\n * Scattering score weight (0-1)\n * Controls how much Scattering activity metrics influence the final score\n * Default: 0.2 (20%) - configurable via SCATTERING_SCORE_WEIGHT env var\n */\nconst SCATTERING_SCORE_WEIGHT = parseFloat(process.env.SCATTERING_SCORE_WEIGHT ?? '0.2');\n\n/**\n * Minimum thresholds for Scattering data to be considered meaningful\n * Below these thresholds, activity is flagged as \"low\" and doesn't boost score\n */\nconst SCATTERING_MIN_TX_COUNT_3D = parseInt(process.env.SCATTERING_MIN_TX_COUNT ?? '100', 10);\nconst SCATTERING_MIN_VOLUME_USD_3D = parseFloat(process.env.SCATTERING_MIN_VOLUME ?? '100');\n\n/**\n * x402scan score weight (the remainder after Scattering)\n * x402scan measures reliability (success rate, latency, confidence)\n */\nconst X402SCAN_SCORE_WEIGHT = 1 - SCATTERING_SCORE_WEIGHT;\n\n/**\n * Internal weights for x402scan sub-components\n * These are applied to the x402scan portion of the score\n */\nconst SCORING_WEIGHTS = {\n  successRate: 50,     // 50% weight on success rate\n  latency: 30,         // 30% weight on latency\n  volume: 10,          // 10% weight on volume (more volume = more confidence)\n  freshness: 10,       // 10% weight on data freshness\n};\n\n// =============================================================================\n// QUERY FUNCTIONS\n// =============================================================================\n\n/**\n * Get best performing facilitator paths\n * Sorted by success rate, then by latency\n */\nexport async function getBestFacilitatorPaths(\n  params: GetBestPathsParams\n): Promise<FacilitatorPathMetrics[]> {\n  const timeframe = params.timeframe ?? '1d';\n  const limit = params.limit ?? 10;\n\n  try {\n    const metrics = await getMetricsForFacilitator(params.facilitatorId, timeframe);\n\n    if (metrics.length === 0) {\n      logger.debug({\n        facilitatorId: params.facilitatorId,\n        timeframe,\n        msg: 'No metrics found for facilitator',\n      });\n      return [];\n    }\n\n    // Sort by success rate (descending), then by latency (ascending)\n    const sorted = [...metrics].sort((a, b) => {\n      // Primary: higher success rate is better\n      const successRateDiff = (1 - b.errorRate) - (1 - a.errorRate);\n      if (Math.abs(successRateDiff) > 0.01) {\n        return successRateDiff > 0 ? 1 : -1;\n      }\n\n      // Secondary: lower latency is better\n      const aLatency = a.p95LatencyMs ?? a.avgLatencyMs ?? Infinity;\n      const bLatency = b.p95LatencyMs ?? b.avgLatencyMs ?? Infinity;\n      return aLatency - bLatency;\n    });\n\n    return sorted.slice(0, limit);\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId: params.facilitatorId,\n      msg: 'Failed to get best facilitator paths',\n    });\n    return [];\n  }\n}\n\n/**\n * Calculate a composite score for a facilitator blending:\n * 1. x402scan: reliability metrics (success rate, latency, confidence)\n * 2. Scattering: activity metrics (volume, tx count, unique buyers)\n * \n * Score is 0-100, higher is better\n * \n * The blend is controlled by SCATTERING_SCORE_WEIGHT (default 0.2):\n * - x402scan contributes (1 - SCATTERING_SCORE_WEIGHT) * x402scanScore\n * - Scattering contributes SCATTERING_SCORE_WEIGHT * scatteringScore\n */\nexport async function getFacilitatorScore(\n  params: FacilitatorScoreParams\n): Promise<FacilitatorScore | null> {\n  const timeframe = params.timeframe ?? '1d';\n  const reasons: string[] = [];\n\n  try {\n    // ==========================================================================\n    // PART 1: x402scan reliability metrics\n    // ==========================================================================\n    const summary = await getSummary(params.facilitatorId, timeframe);\n    \n    let x402scanScore = 50; // Default neutral\n    let successRate = 0;\n    let hoursOld = Infinity;\n    let totalInvocations = 0;\n    let avgLatencyMs: number | undefined;\n    let p95LatencyMs: number | undefined;\n    let hasX402scanData = false;\n\n    if (summary) {\n      hasX402scanData = true;\n      \n      // Calculate success rate score (0-50)\n      successRate = 1 - summary.overallErrorRate;\n      const successRateScore = successRate * SCORING_WEIGHTS.successRate;\n      reasons.push(`success-rate:${(successRate * 100).toFixed(1)}%`);\n\n      // Calculate latency score (0-30)\n      let latencyScore = SCORING_WEIGHTS.latency;\n      const p95 = summary.avgP90LatencyMs ?? summary.avgP99LatencyMs;\n      if (p95 !== undefined) {\n        const normalizedLatency = Math.min(p95, 2000) / 2000;\n        latencyScore = (1 - normalizedLatency) * SCORING_WEIGHTS.latency;\n        reasons.push(`p95-latency:${p95.toFixed(0)}ms`);\n        p95LatencyMs = summary.avgP90LatencyMs;\n      } else {\n        latencyScore = SCORING_WEIGHTS.latency * 0.5;\n        reasons.push('latency:unknown');\n      }\n\n      // Calculate volume score (0-10)\n      const volumeThreshold = 1000;\n      const volumeRatio = Math.min(summary.totalInvocations / volumeThreshold, 1);\n      const volumeScore = volumeRatio * SCORING_WEIGHTS.volume;\n      totalInvocations = summary.totalInvocations;\n      reasons.push(`x402scan:${summary.totalInvocations}/${summary.totalInvocations >= 1000 ? 'high' : summary.totalInvocations >= 100 ? 'medium' : 'low'}-confidence`);\n\n      // Calculate freshness score (0-10)\n      const fetchedAt = new Date(summary.fetchedAt);\n      hoursOld = (Date.now() - fetchedAt.getTime()) / (1000 * 60 * 60);\n      const freshnessRatio = Math.max(0, 1 - hoursOld / 24);\n      const freshnessScore = freshnessRatio * SCORING_WEIGHTS.freshness;\n\n      x402scanScore = successRateScore + latencyScore + volumeScore + freshnessScore;\n      avgLatencyMs = summary.avgP50LatencyMs;\n    } else {\n      reasons.push('x402scan:no-data');\n    }\n\n    // ==========================================================================\n    // PART 2: Scattering activity metrics\n    // ==========================================================================\n    let scatteringActivityScore = 0;\n    let scatteringVolume3d: number | undefined;\n    let scatteringTxCount3d: number | undefined;\n    let scatteringUniqueBuyers3d: number | undefined;\n    let scatteringLowActivity = false;\n    let hasScatteringData = false;\n\n    try {\n      const scattering = await getScatteringMetricsForFacilitator(params.facilitatorId);\n      \n      if (scattering) {\n        hasScatteringData = true;\n        scatteringVolume3d = scattering.volumeUsd3d;\n        scatteringTxCount3d = scattering.txCount3d;\n        scatteringUniqueBuyers3d = scattering.uniqueBuyers3d;\n\n        // Check for low activity guardrail\n        const isLowActivity = \n          scattering.txCount3d < SCATTERING_MIN_TX_COUNT_3D &&\n          scattering.volumeUsd3d < SCATTERING_MIN_VOLUME_USD_3D;\n\n        if (isLowActivity) {\n          scatteringLowActivity = true;\n          scatteringActivityScore = 0.1; // Minimal score for low activity\n          reasons.push(`scattering-low-activity:${scattering.txCount3d}tx/$${scattering.volumeUsd3d.toFixed(0)}`);\n        } else {\n          // Compute normalized activity score (0-1)\n          scatteringActivityScore = computeActivityScore(scattering);\n          reasons.push(`scattering-activity:${scatteringActivityScore.toFixed(2)}`);\n        }\n      } else {\n        reasons.push('scattering:no-data');\n      }\n    } catch (error) {\n      logger.debug({\n        error: error instanceof Error ? error.message : 'Unknown',\n        facilitatorId: params.facilitatorId,\n        msg: 'Failed to fetch Scattering metrics for scoring',\n      });\n      reasons.push('scattering:error');\n    }\n\n    // ==========================================================================\n    // PART 3: Blend x402scan and Scattering scores\n    // ==========================================================================\n    let finalScore: number;\n    \n    if (hasX402scanData && hasScatteringData) {\n      // Both sources available - blend according to weights\n      // x402scan score is 0-100, Scattering score is 0-1 (convert to 0-100)\n      finalScore = (X402SCAN_SCORE_WEIGHT * x402scanScore) + \n                   (SCATTERING_SCORE_WEIGHT * scatteringActivityScore * 100);\n    } else if (hasX402scanData) {\n      // Only x402scan - use full weight\n      finalScore = x402scanScore;\n    } else if (hasScatteringData) {\n      // Only Scattering - convert to 0-100 scale\n      finalScore = scatteringActivityScore * 100;\n    } else {\n      // No data - neutral score\n      finalScore = 50;\n    }\n\n    // ==========================================================================\n    // PART 4: Determine confidence level\n    // ==========================================================================\n    let confidence: 'high' | 'medium' | 'low' | 'none' = 'none';\n    \n    if (hasX402scanData) {\n      if (totalInvocations >= 1000 && hoursOld < 6) {\n        confidence = 'high';\n      } else if (totalInvocations >= 100 && hoursOld < 24) {\n        confidence = 'medium';\n      } else {\n        confidence = 'low';\n      }\n    } else if (hasScatteringData && !scatteringLowActivity) {\n      // Scattering-only data provides some confidence\n      confidence = scatteringActivityScore > 0.5 ? 'medium' : 'low';\n    }\n\n    return {\n      facilitatorId: params.facilitatorId,\n      score: Math.round(finalScore),\n      successRate,\n      avgLatencyMs,\n      p95LatencyMs,\n      totalInvocations,\n      dataFreshness: hoursOld,\n      confidence,\n      reasons,\n      // Scattering fields\n      scatteringActivityScore: hasScatteringData ? scatteringActivityScore : undefined,\n      scatteringVolume3d,\n      scatteringTxCount3d,\n      scatteringUniqueBuyers3d,\n      scatteringLowActivity: scatteringLowActivity || undefined,\n    };\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId: params.facilitatorId,\n      msg: 'Failed to get facilitator score',\n    });\n    return null;\n  }\n}\n\n/**\n * Rank multiple facilitators by their x402scan-derived score\n * Enforces freshness and confidence thresholds - only returns trusted scores\n * \n * @param facilitatorIds - List of facilitator IDs to rank\n * @param timeframe - Timeframe for metrics (default: '1d')\n * @param config - Trust configuration (default: DEFAULT_TRUST_CONFIG)\n */\nexport async function rankFacilitators(\n  facilitatorIds: string[],\n  timeframe: FacilitatorPathMetricsTimeframe = '1d',\n  config: MetricsTrustConfig = DEFAULT_TRUST_CONFIG\n): Promise<FacilitatorRanking> {\n  const scores: FacilitatorScore[] = [];\n  const untrusted: Array<{ id: string; reason: string }> = [];\n\n  for (const id of facilitatorIds) {\n    const score = await getFacilitatorScore({ facilitatorId: id, timeframe });\n    \n    if (!score) {\n      untrusted.push({ id, reason: 'no-data' });\n      continue;\n    }\n\n    // Check if metrics meet trust thresholds\n    const trustCheck = shouldTrustMetrics(\n      score.dataFreshness,\n      score.totalInvocations,\n      config\n    );\n\n    if (!trustCheck.trust) {\n      untrusted.push({ id, reason: trustCheck.reason });\n      // Still include in rankings but with penalized score\n      scores.push({\n        ...score,\n        score: score.score * config.lowConfidencePenalty, // Heavy penalty\n        confidence: 'low',\n        reasons: [...score.reasons, `untrusted:${trustCheck.reason}`],\n      });\n      continue;\n    }\n\n    // Apply confidence-based adjustments\n    if (trustCheck.confidence === 'medium') {\n      // Slight penalty for medium confidence\n      scores.push({\n        ...score,\n        score: score.score * 0.9, // 10% penalty\n        confidence: 'medium',\n        reasons: [...score.reasons, trustCheck.reason],\n      });\n    } else {\n      // High confidence - use score as-is\n      scores.push({\n        ...score,\n        reasons: [...score.reasons, trustCheck.reason],\n      });\n    }\n  }\n\n  // Log untrusted facilitators for visibility\n  if (untrusted.length > 0) {\n    logger.debug({\n      untrusted,\n      trusted: scores.filter((s) => s.confidence !== 'low').map((s) => s.facilitatorId),\n      msg: 'Facilitator metrics trust check results',\n    });\n  }\n\n  // Sort by score descending\n  scores.sort((a, b) => b.score - a.score);\n\n  return {\n    rankings: scores,\n    timestamp: new Date().toISOString(),\n    timeframe,\n  };\n}\n\n/**\n * Get recommended facilitator for a given context\n * Uses x402scan data to inform the recommendation\n * Falls back to default candidate when metrics are stale/missing\n */\nexport async function getRecommendedFacilitator(\n  candidateIds: string[],\n  options?: {\n    network?: string;\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    prioritize?: 'latency' | 'reliability' | 'balanced';\n    trustConfig?: MetricsTrustConfig;\n  }\n): Promise<{\n  recommended: string | null;\n  ranking: FacilitatorRanking;\n  reason: string;\n  usedFallback: boolean;\n}> {\n  const timeframe = options?.timeframe ?? '1d';\n  const trustConfig = options?.trustConfig ?? DEFAULT_TRUST_CONFIG;\n  const ranking = await rankFacilitators(candidateIds, timeframe, trustConfig);\n\n  // Check if we have any trusted rankings\n  const trustedRankings = ranking.rankings.filter((r) => r.confidence !== 'low');\n\n  if (trustedRankings.length === 0) {\n    // No trusted data - fall back to first candidate\n    logger.warn({\n      candidates: candidateIds,\n      rankings: ranking.rankings.map((r) => ({\n        id: r.facilitatorId,\n        confidence: r.confidence,\n        reasons: r.reasons,\n      })),\n      msg: 'No trusted x402scan data available, using fallback',\n    });\n\n    return {\n      recommended: candidateIds[0] ?? null,\n      ranking,\n      reason: 'No trusted x402scan data (stale or insufficient), using default order',\n      usedFallback: true,\n    };\n  }\n\n  const prioritize = options?.prioritize ?? 'balanced';\n  let recommended: FacilitatorScore;\n\n  switch (prioritize) {\n    case 'latency':\n      // Sort by latency (ascending), filter out unknown latency, only trusted\n      const byLatency = trustedRankings\n        .filter((r) => r.p95LatencyMs !== undefined)\n        .sort((a, b) => (a.p95LatencyMs ?? Infinity) - (b.p95LatencyMs ?? Infinity));\n      recommended = byLatency[0] ?? trustedRankings[0];\n      break;\n\n    case 'reliability':\n      // Sort by success rate (descending), only trusted\n      const byReliability = [...trustedRankings].sort((a, b) => b.successRate - a.successRate);\n      recommended = byReliability[0];\n      break;\n\n    case 'balanced':\n    default:\n      // Use overall score from trusted rankings\n      recommended = trustedRankings[0];\n      break;\n  }\n\n  return {\n    recommended: recommended.facilitatorId,\n    ranking,\n    reason: `Selected ${recommended.facilitatorId} with score ${recommended.score} ` +\n      `(${recommended.confidence} confidence, ${recommended.reasons.slice(0, 3).join(', ')})`,\n    usedFallback: false,\n  };\n}\n\n/**\n * Check if a facilitator should be avoided based on recent performance\n */\nexport async function shouldAvoidFacilitator(\n  facilitatorId: string,\n  threshold: {\n    maxErrorRate?: number;    // Default: 0.2 (20%)\n    minInvocations?: number;  // Default: 10\n  } = {}\n): Promise<{\n  avoid: boolean;\n  reason?: string;\n}> {\n  const maxErrorRate = threshold.maxErrorRate ?? 0.2;\n  const minInvocations = threshold.minInvocations ?? 10;\n\n  try {\n    const score = await getFacilitatorScore({ facilitatorId, timeframe: '1d' });\n\n    if (!score) {\n      return { avoid: false, reason: 'No data available' };\n    }\n\n    // Not enough data to make a decision\n    if (score.totalInvocations < minInvocations) {\n      return { avoid: false, reason: `Insufficient data (${score.totalInvocations} invocations)` };\n    }\n\n    // Check error rate\n    const errorRate = 1 - score.successRate;\n    if (errorRate > maxErrorRate) {\n      return {\n        avoid: true,\n        reason: `Error rate ${(errorRate * 100).toFixed(1)}% exceeds threshold ${(maxErrorRate * 100).toFixed(1)}%`,\n      };\n    }\n\n    return { avoid: false };\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId,\n      msg: 'Failed to check if facilitator should be avoided',\n    });\n    return { avoid: false, reason: 'Error checking metrics' };\n  }\n}\n\n/**\n * Get all available facilitator summaries\n * Useful for dashboard/monitoring\n */\nexport async function getAllFacilitatorSummaries(): Promise<Record<string, FacilitatorSummary>> {\n  return loadAllSummaries();\n}\n\n// =============================================================================\n// SMF EXPLAINER\n// =============================================================================\n\n/**\n * Structured explanation for SMF routing decisions\n */\nexport interface FacilitatorExplanation {\n  facilitatorId: string;\n  selected: boolean;\n  score: number;\n  confidence: 'high' | 'medium' | 'low' | 'none';\n  shortReason: string;      // One-line summary\n  detailedReasons: string[];\n  metrics: {\n    successRate?: number;\n    errorRate?: number;\n    p95LatencyMs?: number;\n    invocations?: number;\n    dataAgeHours?: number;\n  };\n}\n\n/**\n * Get a structured explanation for why a facilitator was/wasn't selected\n * Used by SMF to provide transparent routing decisions\n * \n * @example\n * const explanation = await getFacilitatorExplainer('cdp', { timeframe: '1d' });\n * console.log(explanation.shortReason);\n * // \"cdp: 98.5% success, 185ms p95, high confidence (12K invocations)\"\n */\nexport async function getFacilitatorExplainer(\n  facilitatorId: string,\n  options?: {\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    wasSelected?: boolean;\n  }\n): Promise<FacilitatorExplanation> {\n  const timeframe = options?.timeframe ?? '1d';\n  const wasSelected = options?.wasSelected ?? false;\n\n  const score = await getFacilitatorScore({ facilitatorId, timeframe });\n\n  if (!score) {\n    return {\n      facilitatorId,\n      selected: wasSelected,\n      score: 50,\n      confidence: 'low',\n      shortReason: `${facilitatorId}: no x402scan data available`,\n      detailedReasons: ['No observability data from x402scan'],\n      metrics: {},\n    };\n  }\n\n  // Build short reason string\n  const successPct = (score.successRate * 100).toFixed(1);\n  const latencyStr = score.p95LatencyMs ? `${score.p95LatencyMs.toFixed(0)}ms p95` : 'latency unknown';\n  const volumeStr = score.totalInvocations >= 1000 \n    ? `${(score.totalInvocations / 1000).toFixed(1)}K invocations`\n    : `${score.totalInvocations} invocations`;\n\n  const shortReason = `${facilitatorId}: ${successPct}% success, ${latencyStr}, ${score.confidence} confidence (${volumeStr})`;\n\n  // Build detailed reasons\n  const detailedReasons: string[] = [];\n  \n  if (score.successRate >= 0.99) {\n    detailedReasons.push(`Excellent success rate: ${successPct}%`);\n  } else if (score.successRate >= 0.95) {\n    detailedReasons.push(`Good success rate: ${successPct}%`);\n  } else if (score.successRate >= 0.90) {\n    detailedReasons.push(`Acceptable success rate: ${successPct}%`);\n  } else {\n    detailedReasons.push(` Low success rate: ${successPct}%`);\n  }\n\n  if (score.p95LatencyMs !== undefined) {\n    if (score.p95LatencyMs < 200) {\n      detailedReasons.push(`Fast response times: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    } else if (score.p95LatencyMs < 500) {\n      detailedReasons.push(`Moderate latency: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    } else {\n      detailedReasons.push(` High latency: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    }\n  }\n\n  if (score.confidence === 'high') {\n    detailedReasons.push(`High confidence: ${volumeStr}, data ${score.dataFreshness.toFixed(1)}h old`);\n  } else if (score.confidence === 'medium') {\n    detailedReasons.push(`Medium confidence: ${volumeStr}`);\n  } else {\n    detailedReasons.push(`Low confidence: limited data (${volumeStr})`);\n  }\n\n  if (score.dataFreshness > 12) {\n    detailedReasons.push(` Data is ${score.dataFreshness.toFixed(1)} hours old`);\n  }\n\n  return {\n    facilitatorId,\n    selected: wasSelected,\n    score: score.score,\n    confidence: score.confidence,\n    shortReason,\n    detailedReasons,\n    metrics: {\n      successRate: score.successRate,\n      errorRate: 1 - score.successRate,\n      p95LatencyMs: score.p95LatencyMs,\n      invocations: score.totalInvocations,\n      dataAgeHours: score.dataFreshness,\n    },\n  };\n}\n\n/**\n * Get explanations for multiple facilitators (for comparison)\n */\nexport async function getMultipleFacilitatorExplanations(\n  facilitatorIds: string[],\n  options?: {\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    selectedId?: string;\n  }\n): Promise<FacilitatorExplanation[]> {\n  const explanations: FacilitatorExplanation[] = [];\n\n  for (const id of facilitatorIds) {\n    const explanation = await getFacilitatorExplainer(id, {\n      timeframe: options?.timeframe,\n      wasSelected: id === options?.selectedId,\n    });\n    explanations.push(explanation);\n  }\n\n  // Sort by score descending\n  return explanations.sort((a, b) => b.score - a.score);\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1817, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/base-facilitator.ts"],"sourcesContent":["// =============================================================================\n// FACILITATOR ABSTRACTION LAYER\n// =============================================================================\n// Base interface and types for pluggable x402 facilitators\n// Enables multi-facilitator orchestration and routing\n\nimport { createLogger } from '@/lib/logger';\n\nconst logger = createLogger({ component: 'BaseFacilitator' });\n\n/**\n * CAIP-2 Network Identifier (e.g., \"eip155:8453\" for Base)\n * CAIP-19 Asset Identifier (e.g., \"eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\" for USDC on Base)\n */\nexport type CAIPNetworkId = string; // e.g., \"eip155:8453\", \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\", \"bip122:000000000019d6689c085ae165831e93\"\nexport type CAIPAssetId = string; // e.g., \"eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\"\n\n/**\n * Settlement mode for payments\n */\nexport type SettlementMode = 'immediate' | 'deferred' | 'batch';\n\n/**\n * Payment requirements for x402 payment verification\n * Extended to support CAIP identifiers and settlement modes\n */\nexport interface PaymentRequirements {\n  scheme: string; // 'exact', 'x402', etc.\n  network: string; // Legacy: 'base', 'ethereum', 'solana', etc.\n  networks?: CAIPNetworkId[]; // CAIP-2 network identifiers (multi-network support)\n  maxAmountRequired: string; // Amount in smallest units\n  resource: string; // Resource URL\n  description?: string;\n  mimeType?: string;\n  payTo: string; // Recipient address\n  maxTimeoutSeconds?: number;\n  asset: string; // Legacy: Token address\n  assets?: CAIPAssetId[]; // CAIP-19 asset identifiers (multi-asset support)\n  settlementMode?: SettlementMode; // 'immediate', 'deferred', or 'batch'\n}\n\n/**\n * Payment verification result\n */\nexport interface VerificationResult {\n  success: boolean;\n  valid: boolean;\n  transactionHash?: string;\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\n  error?: string;\n  errorDetails?: Record<string, any>;\n  facilitatorId: string; // Which facilitator verified this\n  verifiedAt: string; // ISO timestamp\n}\n\n/**\n * Facilitator health status\n */\nexport interface FacilitatorHealth {\n  healthy: boolean;\n  latency?: number; // ms\n  lastChecked: string; // ISO timestamp\n  error?: string;\n  capabilities: {\n    networks: string[];\n    assets: string[];\n    schemes: string[];\n  };\n}\n\n/**\n * Pricing information for a facilitator\n */\nexport interface PricingInfo {\n  network: string;\n  asset: string;\n  baseFee?: string; // Base fee in smallest units\n  percentageFee?: number; // Percentage fee (0-1)\n  estimatedGas?: string; // Estimated gas cost\n  currency: string; // Fee currency\n}\n\n/**\n * Facilitator configuration\n */\nexport interface FacilitatorConfig {\n  id: string;\n  name: string;\n  enabled: boolean;\n  priority: number; // Lower = higher priority\n  networks: string[]; // Legacy: Supported networks\n  networksCAIP?: CAIPNetworkId[]; // CAIP-2 network identifiers\n  assets: string[]; // Legacy: Supported assets\n  assetsCAIP?: CAIPAssetId[]; // CAIP-19 asset identifiers\n  schemes: string[]; // Supported schemes ('exact', 'x402', etc.)\n  settlementModes?: SettlementMode[]; // Supported settlement modes\n  healthCheckUrl?: string;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Base facilitator interface\n * All facilitators must implement this interface\n */\nexport interface IFacilitator {\n  /**\n   * Unique identifier for this facilitator\n   */\n  readonly id: string;\n\n  /**\n   * Human-readable name\n   */\n  readonly name: string;\n\n  /**\n   * Facilitator configuration\n   */\n  readonly config: FacilitatorConfig;\n\n  /**\n   * Verify an x402 payment\n   */\n  verify(\n    payment: string,\n    requirements: PaymentRequirements\n  ): Promise<VerificationResult>;\n\n  /**\n   * Check facilitator health\n   */\n  getHealth(): Promise<FacilitatorHealth>;\n\n  /**\n   * Get pricing information for a network/asset combination\n   */\n  getPricing(network: string, asset: string): Promise<PricingInfo | null>;\n\n  /**\n   * Check if facilitator supports a given network/asset/scheme\n   * Extended to support settlement modes\n   */\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean;\n}\n\n/**\n * Base facilitator class with common functionality\n */\nexport abstract class BaseFacilitator implements IFacilitator {\n  abstract readonly id: string;\n  abstract readonly name: string;\n  abstract readonly config: FacilitatorConfig;\n\n  protected getLogger() {\n    return logger.child({ facilitator: this.constructor.name });\n  }\n\n  /**\n   * Verify payment (must be implemented by subclasses)\n   */\n  abstract verify(\n    payment: string,\n    requirements: PaymentRequirements\n  ): Promise<VerificationResult>;\n\n  /**\n   * Get health status (must be implemented by subclasses)\n   */\n  abstract getHealth(): Promise<FacilitatorHealth>;\n\n  /**\n   * Get pricing (default implementation returns null)\n   */\n  async getPricing(network: string, asset: string): Promise<PricingInfo | null> {\n    // Default: no pricing info available\n    return null;\n  }\n\n  /**\n   * Check if facilitator supports network/asset/scheme\n   * Enhanced to support both legacy and CAIP identifiers\n   */\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n\n    // Check scheme support\n    if (!this.config.schemes.includes(scheme)) {\n      return false;\n    }\n\n    // Check settlement mode support\n    if (settlementMode && this.config.settlementModes && !this.config.settlementModes.includes(settlementMode)) {\n      return false;\n    }\n\n    // Check network support (legacy or CAIP)\n    const supportsNetwork = \n      this.config.networks.includes(network) ||\n      (this.config.networksCAIP && this.config.networksCAIP.includes(network as CAIPNetworkId));\n\n    if (!supportsNetwork) {\n      return false;\n    }\n\n    // Check asset support (legacy or CAIP)\n    const supportsAsset = \n      this.config.assets.includes(asset) ||\n      (this.config.assetsCAIP && this.config.assetsCAIP.includes(asset as CAIPAssetId));\n\n    return supportsAsset;\n  }\n\n  /**\n   * Check if facilitator supports a CAIP-2 network identifier\n   */\n  supportsCAIPNetwork(caip: CAIPNetworkId): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n    return this.config.networksCAIP?.includes(caip) || false;\n  }\n\n  /**\n   * Check if facilitator supports a CAIP-19 asset identifier\n   */\n  supportsCAIPAsset(caip: CAIPAssetId): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n    return this.config.assetsCAIP?.includes(caip) || false;\n  }\n\n  /**\n   * Validate payment requirements\n   * Enhanced to support CAIP identifiers\n   */\n  protected validateRequirements(\n    requirements: PaymentRequirements\n  ): { valid: boolean; error?: string } {\n    // Check network (legacy or CAIP)\n    const hasNetwork = \n      !!requirements.network || \n      (requirements.networks && requirements.networks.length > 0);\n    \n    if (!hasNetwork) {\n      return { valid: false, error: 'Network is required' };\n    }\n\n    // Check asset (legacy or CAIP)\n    const hasAsset = \n      !!requirements.asset || \n      (requirements.assets && requirements.assets.length > 0);\n    \n    if (!hasAsset) {\n      return { valid: false, error: 'Asset is required' };\n    }\n\n    if (!requirements.payTo) {\n      return { valid: false, error: 'Recipient address (payTo) is required' };\n    }\n    if (!requirements.maxAmountRequired) {\n      return { valid: false, error: 'Amount is required' };\n    }\n\n    // Check support (use legacy network/asset for supports() check, or check CAIP directly)\n    const networkToCheck = requirements.network || (requirements.networks?.[0] || '');\n    const assetToCheck = requirements.asset || (requirements.assets?.[0] || '');\n    \n    // Check CAIP support if CAIP identifiers are provided\n    if (requirements.networks && requirements.networks.length > 0) {\n      const supportsAnyNetwork = requirements.networks.some((n) => \n        this.supportsCAIPNetwork(n) || this.config.networks.includes(n)\n      );\n      if (!supportsAnyNetwork) {\n        return {\n          valid: false,\n          error: `Facilitator ${this.id} does not support any of the requested networks: ${requirements.networks.join(', ')}`,\n        };\n      }\n    }\n\n    if (requirements.assets && requirements.assets.length > 0) {\n      const supportsAnyAsset = requirements.assets.some((a) => \n        this.supportsCAIPAsset(a) || this.config.assets.includes(a)\n      );\n      if (!supportsAnyAsset) {\n        return {\n          valid: false,\n          error: `Facilitator ${this.id} does not support any of the requested assets: ${requirements.assets.join(', ')}`,\n        };\n      }\n    }\n\n    // Check legacy support\n    if (!this.supports(networkToCheck, assetToCheck, requirements.scheme, requirements.settlementMode)) {\n      return {\n        valid: false,\n        error: `Facilitator ${this.id} does not support ${networkToCheck}/${assetToCheck}/${requirements.scheme}`,\n      };\n    }\n    return { valid: true };\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1959, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/cdp-jwt.ts"],"sourcesContent":["import { generateJwt } from '@coinbase/cdp-sdk/auth';\r\n\r\nexport interface CDPJWTPayload {\r\n  sub: string;\r\n  iss: string;\r\n  aud: string[];\r\n  nbf: number;\r\n  exp: number;\r\n  uris?: string[];\r\n}\r\n\r\nexport class CDPJWTGenerator {\r\n  private apiKeyId: string;\r\n  private apiKeySecret: string;\r\n\r\n  constructor(apiKeyId: string, apiKeySecret: string) {\r\n    this.apiKeyId = apiKeyId;\r\n    this.apiKeySecret = apiKeySecret;\r\n  }\r\n\r\n  /**\r\n   * Generate JWT token for CDP API authentication.\r\n   *\r\n   * Uses CDP SDK's generateJwt helper, which signs with the correct\r\n   * algorithm (ES256/EdDSA) for your CDP API key.\r\n   * \r\n   * @param requestMethod - HTTP method (GET, POST, etc.) or null for generic auth\r\n   * @param requestHost - Request host or null\r\n   * @param requestPath - Request path or null\r\n   */\r\n  async generateToken(\r\n    requestMethod: string | null = null,\r\n    requestHost: string | null = null,\r\n    requestPath: string | null = null,\r\n  ): Promise<string> {\r\n    // For REST requests, CDP expects method/host/path\r\n    // For generic facilitator auth, nulls are allowed\r\n    const token = await generateJwt({\r\n      apiKeyId: this.apiKeyId,\r\n      apiKeySecret: this.apiKeySecret,\r\n      requestMethod: requestMethod || null,\r\n      requestHost: requestHost || null,\r\n      requestPath: requestPath || null,\r\n      expiresIn: 120,\r\n      // CDP SDK will handle the JWT payload and headers correctly.\r\n    });\r\n\r\n    return token;\r\n  }\r\n\r\n  isTokenValid(_token: string): boolean {\r\n    // Keep simple: rely on short expiry and CDP errors instead of local decode.\r\n    return true;\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet jwtGenerator: CDPJWTGenerator | null = null;\r\n\r\nexport function getCDPJWTGenerator(): CDPJWTGenerator {\r\n  if (!jwtGenerator) {\r\n    const apiKeyId = process.env.CDP_API_KEY_ID;\r\n    const apiKeySecret = process.env.CDP_API_KEY_SECRET;\r\n\r\n    if (!apiKeyId || !apiKeySecret) {\r\n      throw new Error('CDP_API_KEY_ID and CDP_API_KEY_SECRET must be set');\r\n    }\r\n\r\n    jwtGenerator = new CDPJWTGenerator(apiKeyId, apiKeySecret);\r\n  }\r\n  return jwtGenerator;\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAWO,MAAM;IACH,SAAiB;IACjB,aAAqB;IAE7B,YAAY,QAAgB,EAAE,YAAoB,CAAE;QAClD,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,YAAY,GAAG;IACtB;IAEA;;;;;;;;;GASC,GACD,MAAM,cACJ,gBAA+B,IAAI,EACnC,cAA6B,IAAI,EACjC,cAA6B,IAAI,EAChB;QACjB,kDAAkD;QAClD,kDAAkD;QAClD,MAAM,QAAQ,MAAM,IAAA,yLAAW,EAAC;YAC9B,UAAU,IAAI,CAAC,QAAQ;YACvB,cAAc,IAAI,CAAC,YAAY;YAC/B,eAAe,iBAAiB;YAChC,aAAa,eAAe;YAC5B,aAAa,eAAe;YAC5B,WAAW;QAEb;QAEA,OAAO;IACT;IAEA,aAAa,MAAc,EAAW;QACpC,4EAA4E;QAC5E,OAAO;IACT;AACF;AAEA,qBAAqB;AACrB,IAAI,eAAuC;AAEpC,SAAS;IACd,IAAI,CAAC,cAAc;QACjB,MAAM,WAAW,QAAQ,GAAG,CAAC,cAAc;QAC3C,MAAM,eAAe,QAAQ,GAAG,CAAC,kBAAkB;QAEnD,IAAI,CAAC,YAAY,CAAC,cAAc;YAC9B,MAAM,IAAI,MAAM;QAClB;QAEA,eAAe,IAAI,gBAAgB,UAAU;IAC/C;IACA,OAAO;AACT"}},
    {"offset": {"line": 2018, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/signature-verifier.ts"],"sourcesContent":["import { verifyTypedData, type Address } from 'viem';\r\nimport { base } from 'viem/chains';\r\n\r\nexport interface EIP712Domain {\r\n  name: string;\r\n  version: string;\r\n  chainId: number;\r\n  verifyingContract: Address;\r\n}\r\n\r\nexport interface PaymentAuthorization {\r\n  from: Address;\r\n  to: Address;\r\n  value: string;\r\n  validAfter: string;\r\n  validBefore: string;\r\n  nonce: string;\r\n}\r\n\r\n/**\r\n * Verify EIP-712 signature for x402 payment authorization\r\n * Uses EIP-3009 TransferWithAuthorization domain for USDC\r\n * This provides an additional security layer before CDP verification\r\n */\r\nexport async function verifyPaymentSignature(\r\n  signature: string,\r\n  authorization: PaymentAuthorization,\r\n  signerAddress: Address,\r\n  chainId: number = 8453, // Base mainnet\r\n  asset?: string // Token contract address (optional, defaults to USDC)\r\n): Promise<boolean> {\r\n  try {\r\n    // EIP-3009 domain for USDC on Base (per official @x402/evm SDK)\r\n    // The domain comes from the token contract itself\r\n    const domain: EIP712Domain = {\r\n      name: 'USD Coin',\r\n      version: '2',\r\n      chainId,\r\n      verifyingContract: (asset || '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913') as Address, // Base USDC\r\n    };\r\n\r\n    // EIP-3009 TransferWithAuthorization types\r\n    const types = {\r\n      TransferWithAuthorization: [\r\n        { name: 'from', type: 'address' },\r\n        { name: 'to', type: 'address' },\r\n        { name: 'value', type: 'uint256' },\r\n        { name: 'validAfter', type: 'uint256' },\r\n        { name: 'validBefore', type: 'uint256' },\r\n        { name: 'nonce', type: 'bytes32' },\r\n      ],\r\n    };\r\n\r\n    // Verify the signature\r\n    const isValid = await verifyTypedData({\r\n      address: signerAddress,\r\n      domain,\r\n      types,\r\n      primaryType: 'TransferWithAuthorization',\r\n      message: authorization as Record<string, unknown>,\r\n      signature: signature as `0x${string}`,\r\n    });\r\n\r\n    return isValid;\r\n  } catch (error) {\r\n    console.error('[SignatureVerifier] Verification error:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Validate payment authorization fields\r\n */\r\nexport function validatePaymentAuthorization(\r\n  authorization: PaymentAuthorization\r\n): { valid: boolean; error?: string } {\r\n  const now = Math.floor(Date.now() / 1000);\r\n  const validAfter = parseInt(authorization.validAfter);\r\n  const validBefore = parseInt(authorization.validBefore);\r\n\r\n  if (now < validAfter) {\r\n    return { valid: false, error: 'Payment not yet valid' };\r\n  }\r\n\r\n  if (now >= validBefore) {\r\n    return { valid: false, error: 'Payment has expired' };\r\n  }\r\n\r\n  if (!authorization.from || !authorization.to) {\r\n    return { valid: false, error: 'Missing from or to address' };\r\n  }\r\n\r\n  if (!authorization.value || BigInt(authorization.value) <= BigInt(0)) {\r\n    return { valid: false, error: 'Invalid payment amount' };\r\n  }\r\n\r\n  if (!authorization.nonce) {\r\n    return { valid: false, error: 'Missing nonce' };\r\n  }\r\n\r\n  return { valid: true };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAwBO,eAAe,uBACpB,SAAiB,EACjB,aAAmC,EACnC,aAAsB,EACtB,UAAkB,IAAI,EACtB,KAAc,AAAC,sDAAsD;;IAErE,IAAI;QACF,gEAAgE;QAChE,kDAAkD;QAClD,MAAM,SAAuB;YAC3B,MAAM;YACN,SAAS;YACT;YACA,mBAAoB,SAAS;QAC/B;QAEA,2CAA2C;QAC3C,MAAM,QAAQ;YACZ,2BAA2B;gBACzB;oBAAE,MAAM;oBAAQ,MAAM;gBAAU;gBAChC;oBAAE,MAAM;oBAAM,MAAM;gBAAU;gBAC9B;oBAAE,MAAM;oBAAS,MAAM;gBAAU;gBACjC;oBAAE,MAAM;oBAAc,MAAM;gBAAU;gBACtC;oBAAE,MAAM;oBAAe,MAAM;gBAAU;gBACvC;oBAAE,MAAM;oBAAS,MAAM;gBAAU;aAClC;QACH;QAEA,uBAAuB;QACvB,MAAM,UAAU,MAAM,IAAA,0LAAe,EAAC;YACpC,SAAS;YACT;YACA;YACA,aAAa;YACb,SAAS;YACT,WAAW;QACb;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2CAA2C;QACzD,OAAO;IACT;AACF;AAKO,SAAS,6BACd,aAAmC;IAEnC,MAAM,MAAM,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;IACpC,MAAM,aAAa,SAAS,cAAc,UAAU;IACpD,MAAM,cAAc,SAAS,cAAc,WAAW;IAEtD,IAAI,MAAM,YAAY;QACpB,OAAO;YAAE,OAAO;YAAO,OAAO;QAAwB;IACxD;IAEA,IAAI,OAAO,aAAa;QACtB,OAAO;YAAE,OAAO;YAAO,OAAO;QAAsB;IACtD;IAEA,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,EAAE,EAAE;QAC5C,OAAO;YAAE,OAAO;YAAO,OAAO;QAA6B;IAC7D;IAEA,IAAI,CAAC,cAAc,KAAK,IAAI,OAAO,cAAc,KAAK,KAAK,OAAO,IAAI;QACpE,OAAO;YAAE,OAAO;YAAO,OAAO;QAAyB;IACzD;IAEA,IAAI,CAAC,cAAc,KAAK,EAAE;QACxB,OAAO;YAAE,OAAO;YAAO,OAAO;QAAgB;IAChD;IAEA,OAAO;QAAE,OAAO;IAAK;AACvB"}},
    {"offset": {"line": 2123, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/amount-utils.ts"],"sourcesContent":["// =============================================================================\r\n// AMOUNT UTILITIES\r\n// =============================================================================\r\n// Helper functions for converting between human-readable amounts and atomic units\r\n\r\n/**\r\n * Convert human-readable amount to atomic units\r\n * \r\n * For USDC on Base: 1 USDC = 1,000,000 atomic units (6 decimals)\r\n * \r\n * @param humanAmount - Human-readable amount (e.g., \"1\" for 1 USDC)\r\n * @param decimals - Number of decimals (default: 6 for USDC)\r\n * @returns Atomic units as string (e.g., \"1000000\" for 1 USDC)\r\n * \r\n * @example\r\n * toAtomicUnits(\"1\", 6) // \"1000000\"\r\n * toAtomicUnits(\"0.5\", 6) // \"500000\"\r\n * toAtomicUnits(\"1.5\", 6) // \"1500000\"\r\n */\r\nexport function toAtomicUnits(humanAmount: string, decimals: number = 6): string {\r\n  // Remove any whitespace\r\n  const cleanAmount = humanAmount.trim();\r\n  \r\n  // Parse as decimal number\r\n  const amount = parseFloat(cleanAmount);\r\n  \r\n  if (isNaN(amount) || amount < 0) {\r\n    throw new Error(`Invalid amount: ${humanAmount}`);\r\n  }\r\n  \r\n  // Convert to atomic units: multiply by 10^decimals\r\n  const atomicUnits = BigInt(Math.floor(amount * Math.pow(10, decimals)));\r\n  \r\n  // Return as string\r\n  return atomicUnits.toString();\r\n}\r\n\r\n/**\r\n * Convert atomic units to human-readable amount\r\n * \r\n * @param atomicUnits - Atomic units as string (e.g., \"1000000\")\r\n * @param decimals - Number of decimals (default: 6 for USDC)\r\n * @returns Human-readable amount as string (e.g., \"1\")\r\n * \r\n * @example\r\n * fromAtomicUnits(\"1000000\", 6) // \"1\"\r\n * fromAtomicUnits(\"500000\", 6) // \"0.5\"\r\n */\r\nexport function fromAtomicUnits(atomicUnits: string, decimals: number = 6): string {\r\n  const atomic = BigInt(atomicUnits);\r\n  const divisor = BigInt(Math.pow(10, decimals));\r\n  const whole = atomic / divisor;\r\n  const remainder = atomic % divisor;\r\n  \r\n  if (remainder === BigInt(0)) {\r\n    return whole.toString();\r\n  }\r\n  \r\n  // Format with proper decimal places\r\n  const remainderStr = remainder.toString().padStart(decimals, '0');\r\n  const trimmed = remainderStr.replace(/0+$/, '');\r\n  return `${whole}.${trimmed}`;\r\n}\r\n\r\n/**\r\n * Normalize network identifier to CAIP-2 format\r\n * \r\n * @param network - Network identifier (e.g., \"base\", \"eip155:8453\")\r\n * @returns CAIP-2 format network identifier\r\n * \r\n * @example\r\n * normalizeNetwork(\"base\") // \"eip155:8453\"\r\n * normalizeNetwork(\"eip155:8453\") // \"eip155:8453\"\r\n */\r\nexport function normalizeNetwork(network: string): string {\r\n  // If already in CAIP format, return as-is\r\n  if (network.includes(':')) {\r\n    return network;\r\n  }\r\n  \r\n  // Map common network names to CAIP-2 format\r\n  const networkMap: Record<string, string> = {\r\n    'base': 'eip155:8453',\r\n    'ethereum': 'eip155:1',\r\n    'polygon': 'eip155:137',\r\n    'arbitrum': 'eip155:42161',\r\n    'optimism': 'eip155:10',\r\n    'avalanche': 'eip155:43114',\r\n    'bnb': 'eip155:56',\r\n  };\r\n  \r\n  const normalized = networkMap[network.toLowerCase()];\r\n  if (normalized) {\r\n    return normalized;\r\n  }\r\n  \r\n  // If not found, assume it's already in the correct format or return as-is\r\n  return network;\r\n}\r\n\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,mBAAmB;AACnB,gFAAgF;AAChF,kFAAkF;AAElF;;;;;;;;;;;;;CAaC;;;;;;;;AACM,SAAS,cAAc,WAAmB,EAAE,WAAmB,CAAC;IACrE,wBAAwB;IACxB,MAAM,cAAc,YAAY,IAAI;IAEpC,0BAA0B;IAC1B,MAAM,SAAS,WAAW;IAE1B,IAAI,MAAM,WAAW,SAAS,GAAG;QAC/B,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,aAAa;IAClD;IAEA,mDAAmD;IACnD,MAAM,cAAc,OAAO,KAAK,KAAK,CAAC,SAAS,KAAK,GAAG,CAAC,IAAI;IAE5D,mBAAmB;IACnB,OAAO,YAAY,QAAQ;AAC7B;AAaO,SAAS,gBAAgB,WAAmB,EAAE,WAAmB,CAAC;IACvE,MAAM,SAAS,OAAO;IACtB,MAAM,UAAU,OAAO,KAAK,GAAG,CAAC,IAAI;IACpC,MAAM,QAAQ,SAAS;IACvB,MAAM,YAAY,SAAS;IAE3B,IAAI,cAAc,OAAO,IAAI;QAC3B,OAAO,MAAM,QAAQ;IACvB;IAEA,oCAAoC;IACpC,MAAM,eAAe,UAAU,QAAQ,GAAG,QAAQ,CAAC,UAAU;IAC7D,MAAM,UAAU,aAAa,OAAO,CAAC,OAAO;IAC5C,OAAO,GAAG,MAAM,CAAC,EAAE,SAAS;AAC9B;AAYO,SAAS,iBAAiB,OAAe;IAC9C,0CAA0C;IAC1C,IAAI,QAAQ,QAAQ,CAAC,MAAM;QACzB,OAAO;IACT;IAEA,4CAA4C;IAC5C,MAAM,aAAqC;QACzC,QAAQ;QACR,YAAY;QACZ,WAAW;QACX,YAAY;QACZ,YAAY;QACZ,aAAa;QACb,OAAO;IACT;IAEA,MAAM,aAAa,UAAU,CAAC,QAAQ,WAAW,GAAG;IACpD,IAAI,YAAY;QACd,OAAO;IACT;IAEA,0EAA0E;IAC1E,OAAO;AACT"}},
    {"offset": {"line": 2200, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/cdp-client.ts"],"sourcesContent":["// =============================================================================\r\n// CDP/x402 Client Wrapper\r\n// =============================================================================\r\n// Wraps all calls to Coinbase/CDP/x402 with normalized error handling\r\n// and structured logging\r\n\r\nimport { createLogger, type LogContext } from './logger';\r\n\r\nconst logger = createLogger({ component: 'CDPClient' });\r\n\r\n/**\r\n * Normalized CDP error codes\r\n */\r\nexport enum CDPErrorCode {\r\n  CDP_TIMEOUT = 'CDP_TIMEOUT',\r\n  CDP_4XX = 'CDP_4XX',\r\n  CDP_5XX = 'CDP_5XX',\r\n  CDP_INVALID_RESPONSE = 'CDP_INVALID_RESPONSE',\r\n  CDP_NETWORK_ERROR = 'CDP_NETWORK_ERROR',\r\n  CDP_AUTH_ERROR = 'CDP_AUTH_ERROR',\r\n  CDP_RATE_LIMIT = 'CDP_RATE_LIMIT',\r\n  CDP_UNKNOWN_ERROR = 'CDP_UNKNOWN_ERROR',\r\n}\r\n\r\n/**\r\n * Normalized CDP error\r\n */\r\nexport class CDPError extends Error {\r\n  constructor(\r\n    public code: CDPErrorCode,\r\n    message: string,\r\n    public statusCode?: number,\r\n    public cdpErrorId?: string,\r\n    public responseBody?: any\r\n  ) {\r\n    super(message);\r\n    this.name = 'CDPError';\r\n    // Ensure stack trace is captured\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, CDPError);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Normalize HTTP status code to CDP error code\r\n */\r\nfunction normalizeErrorCode(statusCode: number | undefined): CDPErrorCode {\r\n  if (!statusCode) {\r\n    return CDPErrorCode.CDP_UNKNOWN_ERROR;\r\n  }\r\n  \r\n  if (statusCode >= 500) {\r\n    return CDPErrorCode.CDP_5XX;\r\n  }\r\n  \r\n  if (statusCode === 401 || statusCode === 403) {\r\n    return CDPErrorCode.CDP_AUTH_ERROR;\r\n  }\r\n  \r\n  if (statusCode === 429) {\r\n    return CDPErrorCode.CDP_RATE_LIMIT;\r\n  }\r\n  \r\n  if (statusCode >= 400) {\r\n    return CDPErrorCode.CDP_4XX;\r\n  }\r\n  \r\n  return CDPErrorCode.CDP_UNKNOWN_ERROR;\r\n}\r\n\r\n/**\r\n * Extract safe excerpt from response body for logging\r\n * Removes sensitive data and truncates long responses\r\n */\r\nfunction extractSafeResponseExcerpt(body: any, maxLength: number = 500): string {\r\n  if (!body) return '';\r\n  \r\n  try {\r\n    const str = typeof body === 'string' ? body : JSON.stringify(body);\r\n    if (str.length <= maxLength) {\r\n      return str;\r\n    }\r\n    return str.substring(0, maxLength) + '... [truncated]';\r\n  } catch {\r\n    return '[unable to serialize response]';\r\n  }\r\n}\r\n\r\n/**\r\n * Wrapper for CDP API calls with error handling and logging\r\n */\r\nexport async function callCDP<T>(\r\n  operation: string,\r\n  requestFn: () => Promise<Response>,\r\n  context: {\r\n    requestId?: string;\r\n    apiKeyId?: string;\r\n    endpointId?: string;\r\n    targetUrl?: string;\r\n  }\r\n): Promise<T> {\r\n  const startTime = Date.now();\r\n  const logContext: LogContext = {\r\n    requestId: context.requestId,\r\n    apiKeyId: context.apiKeyId,\r\n    endpoint: context.endpointId,\r\n    cdpStatus: 'pending',\r\n  };\r\n  \r\n  try {\r\n    logger.debug({ ...logContext, operation, targetUrl: context.targetUrl }, `CDP call: ${operation}`);\r\n    \r\n    const response = await requestFn();\r\n    const duration = Date.now() - startTime;\r\n    \r\n    // Extract response body safely\r\n    let responseBody: any = null;\r\n    let responseText = '';\r\n    try {\r\n      responseText = await response.text();\r\n      if (responseText) {\r\n        responseBody = JSON.parse(responseText);\r\n      }\r\n    } catch {\r\n      // Response might not be JSON, that's okay\r\n      responseBody = responseText;\r\n    }\r\n    \r\n    // Check if response is successful\r\n    if (!response.ok) {\r\n      const errorCode = normalizeErrorCode(response.status);\r\n      const cdpErrorId = responseBody?.error?.id || responseBody?.errorId || response.headers.get('x-request-id');\r\n      const errorMessage = responseBody?.error?.message || responseBody?.message || `CDP API error: ${response.statusText}`;\r\n      \r\n      const error = new CDPError(\r\n        errorCode,\r\n        errorMessage,\r\n        response.status,\r\n        cdpErrorId,\r\n        responseBody\r\n      );\r\n      \r\n      // Log structured error\r\n      logger.error({\r\n        ...logContext,\r\n        operation,\r\n        targetUrl: context.targetUrl,\r\n        errorCode: error.code,\r\n        cdpErrorId: error.cdpErrorId,\r\n        statusCode: response.status,\r\n        durationMs: duration,\r\n        responseExcerpt: extractSafeResponseExcerpt(responseBody),\r\n      }, `CDP call failed: ${operation}`);\r\n      \r\n      throw error;\r\n    }\r\n    \r\n    // Log successful call\r\n    logger.info({\r\n      ...logContext,\r\n      operation,\r\n      targetUrl: context.targetUrl,\r\n      cdpStatus: 'success',\r\n      statusCode: response.status,\r\n      durationMs: duration,\r\n    }, `CDP call succeeded: ${operation}`);\r\n    \r\n    return responseBody as T;\r\n  } catch (error) {\r\n    const duration = Date.now() - startTime;\r\n    \r\n    // Handle network errors\r\n    if (error instanceof TypeError && error.message.includes('fetch')) {\r\n      const cdpError = new CDPError(\r\n        CDPErrorCode.CDP_NETWORK_ERROR,\r\n        `Network error calling CDP: ${error.message}`,\r\n        undefined,\r\n        undefined,\r\n        undefined\r\n      );\r\n      \r\n      logger.error({\r\n        ...logContext,\r\n        operation,\r\n        targetUrl: context.targetUrl,\r\n        errorCode: cdpError.code,\r\n        durationMs: duration,\r\n        error: error,\r\n      }, `CDP network error: ${operation}`);\r\n      \r\n      throw cdpError;\r\n    }\r\n    \r\n    // Handle timeout errors\r\n    if (error instanceof Error && (error.message.includes('timeout') || error.message.includes('aborted'))) {\r\n      const cdpError = new CDPError(\r\n        CDPErrorCode.CDP_TIMEOUT,\r\n        `CDP call timed out: ${operation}`,\r\n        undefined,\r\n        undefined,\r\n        undefined\r\n      );\r\n      \r\n      logger.error({\r\n        ...logContext,\r\n        operation,\r\n        targetUrl: context.targetUrl,\r\n        errorCode: cdpError.code,\r\n        durationMs: duration,\r\n        error: error,\r\n      }, `CDP timeout: ${operation}`);\r\n      \r\n      throw cdpError;\r\n    }\r\n    \r\n    // Re-throw CDPError as-is\r\n    if (error instanceof CDPError) {\r\n      throw error;\r\n    }\r\n    \r\n    // Wrap unknown errors\r\n    const cdpError = new CDPError(\r\n      CDPErrorCode.CDP_UNKNOWN_ERROR,\r\n      `Unknown error calling CDP: ${error instanceof Error ? error.message : String(error)}`,\r\n      undefined,\r\n      undefined,\r\n      undefined\r\n    );\r\n    \r\n    logger.error({\r\n      ...logContext,\r\n      operation,\r\n      targetUrl: context.targetUrl,\r\n      errorCode: cdpError.code,\r\n      durationMs: duration,\r\n      error: error,\r\n    }, `CDP unknown error: ${operation}`);\r\n    \r\n    throw cdpError;\r\n  }\r\n}\r\n\r\n/**\r\n * Helper to add request ID to CDP API calls\r\n */\r\nexport function addRequestIdToCDPHeaders(\r\n  headers: HeadersInit,\r\n  requestId?: string\r\n): HeadersInit {\r\n  const headersObj = headers instanceof Headers ? Object.fromEntries(headers.entries()) : \r\n                     Array.isArray(headers) ? Object.fromEntries(headers) : \r\n                     headers;\r\n  \r\n  if (requestId) {\r\n    return {\r\n      ...headersObj,\r\n      'x-request-id': requestId,\r\n    };\r\n  }\r\n  \r\n  return headersObj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2396, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/cdp-facilitator.ts"],"sourcesContent":["import { getCDPJWTGenerator } from './cdp-jwt';\r\nimport { verifyPaymentSignature, validatePaymentAuthorization, type PaymentAuthorization } from './signature-verifier';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { toAtomicUnits, normalizeNetwork } from './amount-utils';\r\nimport { callCDP, addRequestIdToCDPHeaders, CDPError, CDPErrorCode } from '@/lib/cdp-client';\r\n\r\nconst logger = createLogger({ component: 'CDPFacilitator' });\r\n\r\n/**\r\n * CDP (Coinbase Developer Platform) Facilitator\r\n * \r\n * Primary facilitator for x402 payment verification on Base network.\r\n * Handles JWT authentication, payment verification, and compliance checks.\r\n */\r\n\r\nexport interface CDPPaymentPayload {\r\n  x402Version: number;\r\n  scheme: 'x402';\r\n  network: string;\r\n  payload: {\r\n    signature: string;\r\n    authorization: PaymentAuthorization;\r\n  };\r\n}\r\n\r\nexport interface X402PaymentRequirements {\r\n  scheme: string;\r\n  network: string;\r\n  to?: string; // Internal field name\r\n  payTo?: string; // CDP field name\r\n  value?: string; // Internal field name\r\n  maxAmountRequired?: string; // CDP field name\r\n  resource: string;\r\n  validAfter?: string; // Validity window start\r\n  validBefore?: string; // Validity window end\r\n  asset: string;\r\n  // Optional fields\r\n  description?: string;\r\n  mimeType?: string;\r\n  maxTimeoutSeconds?: number;\r\n  outputSchema?: any; // Optional JSON schema\r\n  extra?: any; // Optional scheme-specific data\r\n  payer?: string; // Optional: payer address (internal only)\r\n}\r\n\r\n// CDP Verify Request Body - matches CDP x402 v2 API schema exactly\r\n// Per: https://docs.cdp.coinbase.com/api-reference/v2/rest-api/x402-facilitator/verify-a-payment\r\n// This type matches the v2 VerifyRequest schema exactly - no v1 fields or schemas\r\nexport interface CDPVerifyRequestBody {\r\n  x402Version: 2; // CDP x402 v2 - top level (must be 2, not 1)\r\n  paymentPayload: {\r\n    x402Version: 2; // CDP x402 v2 - inside paymentPayload (must match top level, must be 2)\r\n    scheme: string; // 'exact' for EVM\r\n    network: string; // 'base', 'ethereum', etc.\r\n    payload: {\r\n      signature: string; // EIP-712 signature\r\n      authorization: {\r\n        from: string; // EVM address\r\n        to: string; // EVM address\r\n        value: string; // Amount in atomic units\r\n        validAfter: string; // Unix timestamp\r\n        validBefore: string; // Unix timestamp\r\n        nonce: string; // Hex-encoded nonce\r\n      };\r\n    };\r\n  };\r\n  paymentRequirements: {\r\n    scheme: string; // 'exact' for EVM\r\n    network: string; // 'base', 'ethereum', etc.\r\n    payTo: string; // CDP v2 field name (destination address)\r\n    // CDP x402 v2: maxAmountRequired must be a string of atomic units (integer, not decimal)\r\n    // Example: \"1000000\" for 1 USDC (6 decimals), not \"1.0\" or 1000000\r\n    // Must match authorization.value exactly\r\n    maxAmountRequired: string; // Amount in atomic units as string (e.g., \"1000000\" for 1 USDC)\r\n    resource: string; // URI of the resource\r\n    description: string; // Description of the resource\r\n    mimeType: string; // MIME type of the resource response\r\n    maxTimeoutSeconds: number; // Maximum time for server to respond\r\n    asset: string; // Asset contract address (e.g., USDC)\r\n    validAfter?: string; // Optional: validity window start\r\n    validBefore?: string; // Optional: validity window end\r\n    outputSchema?: any; // Optional: JSON schema describing resource output\r\n    extra?: any; // Optional: scheme-specific payment information\r\n  };\r\n}\r\n\r\nexport interface CDPVerifyRequest {\r\n  payment: string; // Payment header or transaction hash\r\n  paymentPayload: CDPPaymentPayload;\r\n  paymentRequirements?: X402PaymentRequirements; // Optional - will be constructed if not provided\r\n}\r\n\r\nexport interface CDPVerifyResponse {\r\n  success: boolean;\r\n  valid: boolean;\r\n  transactionHash?: string;\r\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\r\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\r\n  error?: string;\r\n  errorDetails?: {\r\n    error: string;\r\n    cdpResponse?: any;\r\n    httpStatus?: number;\r\n  };\r\n}\r\n\r\nexport class CDPFacilitator {\r\n  private apiKeyId: string;\r\n  private facilitatorUrl: string;\r\n  private jwtGenerator: ReturnType<typeof getCDPJWTGenerator>;\r\n  private cachedToken: string | null = null;\r\n  private tokenExpiry: number = 0;\r\n\r\n  constructor(\r\n    apiKeyId: string,\r\n    facilitatorUrl: string = 'https://api.cdp.coinbase.com/platform/v2/x402'\r\n  ) {\r\n    this.apiKeyId = apiKeyId;\r\n    this.facilitatorUrl = facilitatorUrl;\r\n    this.jwtGenerator = getCDPJWTGenerator();\r\n  }\r\n\r\n  /**\r\n   * Generate JWT token for CDP API authentication\r\n   * Uses cached token if still valid, otherwise generates new one\r\n   * \r\n   * @param requestMethod - HTTP method for REST calls (optional)\r\n   * @param requestPath - Request path for REST calls (optional)\r\n   */\r\n  private async generateJWT(\r\n    requestMethod: string | null = null,\r\n    requestPath: string | null = null\r\n  ): Promise<string> {\r\n    const now = Date.now();\r\n    \r\n    // For REST calls with specific method/path, don't cache (must be request-specific)\r\n    if (requestMethod && requestPath) {\r\n      const url = new URL(this.facilitatorUrl);\r\n      return await this.jwtGenerator.generateToken(\r\n        requestMethod,\r\n        url.host,\r\n        requestPath\r\n      );\r\n    }\r\n    \r\n    // Return cached token if still valid (with 10 second buffer) - for generic auth\r\n    if (this.cachedToken && this.tokenExpiry > now + 10000) {\r\n      return this.cachedToken;\r\n    }\r\n\r\n    // Generate new token for generic facilitator auth\r\n    const token = await this.jwtGenerator.generateToken(null, null, null);\r\n    this.cachedToken = token;\r\n    this.tokenExpiry = now + 120000; // 2 minutes expiry\r\n\r\n    return token;\r\n  }\r\n\r\n  /**\r\n   * Call CDP /verify endpoint with retry logic for transient errors\r\n   * \r\n   * Retries on: 429 (rate limit), 500-504 (server errors), network timeouts\r\n   * Does NOT retry on: 400 (invalid_request), 401 (unauthorized), other 4xx\r\n   * \r\n   * Returns normalized result with success, valid, status, errorType, errorMessage, etc.\r\n   */\r\n  private async callCdpVerifyWithRetries(\r\n    verifyBody: any,\r\n    isProbe: boolean,\r\n    headers: HeadersInit\r\n  ): Promise<{\r\n    success: boolean;\r\n    valid: boolean;\r\n    status: number;\r\n    errorType?: string;\r\n    errorMessage?: string;\r\n    isRateLimited: boolean;\r\n    isNetworkError: boolean;\r\n    latencyMs: number;\r\n    data?: any;\r\n  }> {\r\n    const url = new URL('https://api.cdp.coinbase.com/platform/v2/x402/verify');\r\n    const maxRetries = 3;\r\n    const retryableStatuses = [429, 500, 502, 503, 504];\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const response = await fetch(url.toString(), {\r\n          method: 'POST',\r\n          headers,\r\n          body: JSON.stringify(verifyBody),\r\n          signal: AbortSignal.timeout(10000), // 10 second timeout\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data = text ? JSON.parse(text) : {};\r\n        const latencyMs = Date.now() - startTime;\r\n\r\n        // Success case\r\n        if (response.ok && data.isValid) {\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            status: response.status,\r\n            isRateLimited: false,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Check if retryable error\r\n        const isRetryable = retryableStatuses.includes(response.status);\r\n        const isRateLimit = response.status === 429;\r\n        \r\n        // If not retryable or last attempt, return error\r\n        if (!isRetryable || attempt === maxRetries - 1) {\r\n          const errorMessage = data.errorMessage || data.error || data.invalidReason || `HTTP ${response.status}`;\r\n          const errorType = data.errorType || data.code || (isRateLimit ? 'rate_limit' : 'CDP_VERIFY_FAILED');\r\n          \r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            status: response.status,\r\n            errorType,\r\n            errorMessage,\r\n            isRateLimited: isRateLimit,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Retry with exponential backoff\r\n        const delay = 100 * Math.pow(2, attempt); // 100ms, 200ms, 400ms\r\n        logger.info({\r\n          component: 'CDPFacilitator',\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          status: response.status,\r\n          delay,\r\n          isProbe,\r\n          msg: 'Retrying CDP verification after transient error',\r\n        });\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        \r\n      } catch (error: any) {\r\n        const latencyMs = Date.now() - startTime;\r\n        const isTimeout = error?.name === 'AbortError' || error?.message?.toLowerCase().includes('timeout');\r\n        const isNetworkError = error?.message?.toLowerCase().includes('network') || \r\n                              error?.message?.toLowerCase().includes('fetch') ||\r\n                              error?.message?.toLowerCase().includes('econnrefused');\r\n        \r\n        // If network error and not last attempt, retry\r\n        if ((isTimeout || isNetworkError) && attempt < maxRetries - 1) {\r\n          const delay = 100 * Math.pow(2, attempt);\r\n          logger.info({\r\n            component: 'CDPFacilitator',\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error?.message,\r\n            delay,\r\n            isProbe,\r\n            msg: 'Retrying CDP verification after network error',\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n        \r\n        // Last attempt or non-network error\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          status: 0,\r\n          errorType: isTimeout ? 'timeout' : isNetworkError ? 'network_error' : 'CDP_VERIFY_FAILED',\r\n          errorMessage: error?.message || 'CDP verification failed',\r\n          isRateLimited: false,\r\n          isNetworkError: isTimeout || isNetworkError,\r\n          latencyMs,\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Should never reach here, but TypeScript needs a return\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      status: 0,\r\n      errorType: 'CDP_VERIFY_FAILED',\r\n      errorMessage: 'Max retries exceeded',\r\n      isRateLimited: false,\r\n      isNetworkError: false,\r\n      latencyMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify payment with CDP facilitator API\r\n   * \r\n   * This method:\r\n   * 1. Validates payment authorization fields locally\r\n   * 2. Optionally verifies EIP-712 signature locally\r\n   * 3. Calls CDP API for on-chain verification with retry logic\r\n   * 4. Returns verification result with KYT/OFAC status\r\n   */\r\n  async verifyPayment(request: CDPVerifyRequest): Promise<CDPVerifyResponse> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // Step 1: Parse payment header to extract paymentPayload (build from decoded JSON)\r\n      // For probe mode, we need to decode the base64 payment header and build the payload\r\n      let paymentPayload: CDPPaymentPayload;\r\n      let parsedPayment: any;\r\n      \r\n      try {\r\n        const { parseX402Header } = await import('./payment-header-parser');\r\n        const parseResult = parseX402Header(request.payment);\r\n        \r\n        if (parseResult.valid && parseResult.parsed) {\r\n          parsedPayment = parseResult.parsed;\r\n          // Build paymentPayload from decoded payment JSON\r\n          // Note: parsedPayment.network might be legacy format (e.g., \"8453\" or \"base\")\r\n          // CDP requires CAIP-2 format (e.g., \"eip155:8453\"), so normalize it\r\n          const parsedNetwork = parsedPayment.network || request.paymentPayload.network;\r\n          const normalizedParsedNetwork = normalizeNetwork(parsedNetwork);\r\n          \r\n          paymentPayload = {\r\n            x402Version: 1, // CDP x402 v1 (per user instruction, use 1 unless docs specify 2)\r\n            scheme: 'x402' as const,\r\n            network: normalizedParsedNetwork, // Use normalized CAIP-2 format\r\n            payload: {\r\n              signature: parsedPayment.signature,\r\n              authorization: parsedPayment.authorization,\r\n            },\r\n          };\r\n        } else {\r\n          // Fallback to request.paymentPayload if parsing fails\r\n          paymentPayload = request.paymentPayload;\r\n        }\r\n      } catch (parseError) {\r\n        logger.warn({ error: parseError }, 'Failed to parse payment header, using request.paymentPayload');\r\n        paymentPayload = request.paymentPayload;\r\n      }\r\n      \r\n      // Step 2: Validate payment authorization fields locally\r\n      const authValidation = validatePaymentAuthorization(paymentPayload.payload.authorization);\r\n      if (!authValidation.valid) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: authValidation.error || 'Invalid payment authorization',\r\n        };\r\n      }\r\n\r\n      // Step 3: Extract authorization for use throughout\r\n      const auth = paymentPayload.payload.authorization;\r\n      const signature = paymentPayload.payload.signature;\r\n\r\n      // Step 4: Detect probe mode and skip local signature verification for probes\r\n      // Probe mode is detected by checking if signature is all zeros (dummy signature)\r\n      const isDummySignature = signature === '0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000' ||\r\n                               signature === '0x' + '0'.repeat(128);\r\n      const isProbe = isDummySignature || auth.from === '0x0000000000000000000000000000000000000000';\r\n\r\n      // Step 4: Optionally verify signature locally (additional security layer)\r\n      // Note: CDP will also verify, but local check catches issues early\r\n      // Skip local verification for probe mode to avoid viem errors with dummy signatures\r\n      if (isProbe) {\r\n        logger.warn({\r\n          component: 'CDPFacilitator',\r\n          isProbe: true,\r\n          msg: 'Skipping local signature verification for probe payload',\r\n        });\r\n      } else {\r\n        try {\r\n          const signatureValid = await verifyPaymentSignature(\r\n            signature,\r\n            auth,\r\n            auth.from as `0x${string}`\r\n          );\r\n          if (!signatureValid) {\r\n            logger.warn('Local signature verification failed, but continuing to CDP');\r\n            // Don't fail here - let CDP make the final decision\r\n          }\r\n        } catch (sigError) {\r\n          logger.warn({ error: sigError }, 'Signature verification error, continuing to CDP');\r\n          // Continue to CDP verification\r\n        }\r\n      }\r\n\r\n      // Step 5: Use paymentRequirements from request (must be provided by caller)\r\n      // CDP requires paymentRequirements that match the challenge\r\n      // For probe mode, build minimal valid paymentRequirements if missing\r\n      let finalPaymentRequirements = request.paymentRequirements;\r\n      \r\n      if (!finalPaymentRequirements || (!finalPaymentRequirements.to && !(finalPaymentRequirements as any)?.payTo)) {\r\n        // If in probe mode, build minimal valid paymentRequirements\r\n        if (isProbe) {\r\n          logger.info({\r\n            component: 'CDPFacilitator',\r\n            isProbe: true,\r\n            msg: 'Building minimal paymentRequirements for probe mode',\r\n          });\r\n          \r\n          // Extract network from paymentPayload (built from decoded payment)\r\n          // paymentPayload.network should already be in CAIP-2 format from normalization above\r\n          // If not, normalize it to ensure CAIP-2 format\r\n          const network = normalizeNetwork(paymentPayload.network || 'eip155:8453');\r\n          \r\n          // USDC contract address on Base\r\n          const USDC_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';\r\n          // Test receiver address for probes\r\n          const PROBE_RECEIVER = '0x0000000000000000000000000000000000000001';\r\n          \r\n          const now = Math.floor(Date.now() / 1000);\r\n          \r\n          // Build minimal valid paymentRequirements for probe\r\n          // CDP requires 'exact' scheme for EVM fixed-amount flows\r\n          // CDP requires CAIP-2 format (e.g., \"eip155:8453\") for network\r\n          finalPaymentRequirements = {\r\n            scheme: 'exact', // CDP expects 'exact' for EVM, not 'x402'\r\n            network: network, // Use CAIP-2 format (e.g., \"eip155:8453\")\r\n            to: PROBE_RECEIVER,\r\n            payTo: PROBE_RECEIVER,\r\n            value: '1000000', // 1 USDC in atomic units (must match authorization.value)\r\n            maxAmountRequired: '1000000', // 1 USDC in atomic units\r\n            resource: `https://probe.nexflow.dev/health/cdp/${network}/USDC`,\r\n            asset: USDC_BASE,\r\n            description: 'Health probe for CDP',\r\n            mimeType: 'application/json',\r\n            validAfter: now.toString(),\r\n            validBefore: (now + 300).toString(), // 5 minutes validity\r\n            maxTimeoutSeconds: 300,\r\n            // EIP-712 domain info required for EVM networks (USDC on Base)\r\n            extra: {\r\n              name: 'USD Coin',\r\n              version: '2',\r\n            },\r\n          };\r\n          \r\n          logger.info({\r\n            component: 'CDPFacilitator',\r\n            isProbe: true,\r\n            hasPaymentRequirements: true,\r\n            network: network, // CAIP-2 format\r\n            asset: USDC_BASE,\r\n            msg: 'Built probe paymentRequirements',\r\n          });\r\n        } else {\r\n          // Not probe mode and missing paymentRequirements - error\r\n          logger.error({\r\n            hasPaymentRequirements: !!request.paymentRequirements,\r\n            paymentRequirements: request.paymentRequirements,\r\n            isProbe: false,\r\n          }, 'Missing paymentRequirements');\r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            error: 'paymentRequirements must be provided for CDP verification',\r\n          };\r\n        }\r\n      }\r\n      // Normalize paymentRequirements to CDP's expected format\r\n      // CDP expects: scheme, network, to, value, resource, validAfter, validBefore, asset\r\n      // Remove any fields that CDP doesn't expect (payer, maxTimeoutSeconds, description, mimeType might be optional)\r\n      // Ensure network is in CAIP-2 format (CDP requires this)\r\n      const paymentRequirementsNetwork = normalizeNetwork(finalPaymentRequirements?.network || paymentPayload.network || 'eip155:8453');\r\n      const paymentRequirements: any = {\r\n        scheme: finalPaymentRequirements?.scheme || 'exact',\r\n        network: paymentRequirementsNetwork, // CAIP-2 format (e.g., \"eip155:8453\")\r\n        // Convert legacy field names to CDP format\r\n        to: finalPaymentRequirements?.to || (finalPaymentRequirements as any)?.payTo || auth.to,\r\n        value: finalPaymentRequirements?.value || (finalPaymentRequirements as any)?.maxAmountRequired || auth.value,\r\n        // Ensure validity window is included\r\n        validAfter: finalPaymentRequirements?.validAfter || auth.validAfter,\r\n        validBefore: finalPaymentRequirements?.validBefore || auth.validBefore,\r\n        // Required fields - ensure they exist\r\n        resource: finalPaymentRequirements?.resource,\r\n        asset: finalPaymentRequirements?.asset,\r\n        // Optional fields (only include if present)\r\n        ...(finalPaymentRequirements?.description && { description: finalPaymentRequirements.description }),\r\n        ...(finalPaymentRequirements?.mimeType && { mimeType: finalPaymentRequirements.mimeType }),\r\n        ...((finalPaymentRequirements as any)?.maxTimeoutSeconds && { maxTimeoutSeconds: (finalPaymentRequirements as any).maxTimeoutSeconds }),\r\n        // EIP-712 domain info required for EVM signature verification\r\n        ...((finalPaymentRequirements as any)?.extra && { extra: (finalPaymentRequirements as any).extra }),\r\n      };\r\n      \r\n      // Validate that required fields are present\r\n      // In probe mode, we already built complete requirements, so this should not fail\r\n      if (!paymentRequirements.resource || !paymentRequirements.asset) {\r\n        // If in probe mode and still missing fields, build them\r\n        if (isProbe) {\r\n          // Normalize network to CAIP-2 format\r\n          const network = normalizeNetwork(paymentPayload.network || 'eip155:8453');\r\n          const USDC_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';\r\n          \r\n          if (!paymentRequirements.resource) {\r\n            paymentRequirements.resource = `https://probe.nexflow.dev/health/cdp/${network}/USDC`;\r\n          }\r\n          if (!paymentRequirements.asset) {\r\n            paymentRequirements.asset = USDC_BASE;\r\n          }\r\n          // Ensure network is in CAIP-2 format\r\n          if (!paymentRequirements.network || !paymentRequirements.network.includes(':')) {\r\n            paymentRequirements.network = network;\r\n          }\r\n          \r\n          logger.info({\r\n            component: 'CDPFacilitator',\r\n            isProbe: true,\r\n            msg: 'Completed missing resource/asset fields for probe mode',\r\n          });\r\n        } else {\r\n          // Not probe mode - error\r\n          logger.error({\r\n            hasResource: !!paymentRequirements.resource,\r\n            hasAsset: !!paymentRequirements.asset,\r\n            paymentRequirements: request.paymentRequirements,\r\n            isProbe: false,\r\n          }, 'Missing required paymentRequirements fields (resource or asset)');\r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            error: 'paymentRequirements must include resource and asset',\r\n          };\r\n        }\r\n      }\r\n\r\n      // Step 5: Parse payment header to check for transaction hash\r\n      // CDP may require transaction hash for on-chain verification\r\n      let txHash: string | undefined;\r\n      try {\r\n        const { parseX402Header } = await import('./payment-header-parser');\r\n        const parsed = parseX402Header(request.payment);\r\n        if (parsed.valid && parsed.parsed?.txHash) {\r\n          txHash = parsed.parsed.txHash;\r\n          logger.debug({ txHash }, 'Found transaction hash in payment header');\r\n        }\r\n      } catch (error) {\r\n        logger.warn({ error }, 'Failed to parse payment header for txHash');\r\n      }\r\n\r\n      // Step 6: Construct request body matching CDP x402 v2 schema exactly\r\n      // CDP v2 schema per docs: https://docs.cdp.coinbase.com/api-reference/v2/rest-api/x402-facilitator/verify-a-payment\r\n      // \r\n      // CDP Requirements for USDC on Base:\r\n      // - 1 USDC = 1,000,000 atomic units (6 decimals)\r\n      // - network must be \"eip155:8453\" (not \"base\")\r\n      // - value and maxAmountRequired must be strings of atomic units\r\n      \r\n      // Normalize network to CAIP-2 format (e.g., \"base\" -> \"eip155:8453\")\r\n      const normalizedNetwork = normalizeNetwork(paymentPayload.network || paymentRequirements.network || 'base');\r\n      \r\n      // Convert authorization.value to atomic units if needed\r\n      // auth.value might already be in atomic units (string), or might be human-readable\r\n      // For now, assume it's already in atomic units if it's a large number string\r\n      // If it looks like a human amount (small number), convert it\r\n      let authorizationValue: string;\r\n      const authValueStr = String(auth.value);\r\n      const authValueNum = parseFloat(authValueStr);\r\n      \r\n      // If the value is less than 1000, assume it's human-readable (e.g., \"1\" = 1 USDC)\r\n      // Otherwise, assume it's already in atomic units\r\n      if (authValueNum < 1000 && authValueNum > 0) {\r\n        // Convert human amount to atomic units\r\n        authorizationValue = toAtomicUnits(authValueStr, 6);\r\n        logger.debug({ \r\n          original: authValueStr, \r\n          converted: authorizationValue \r\n        }, 'Converted human amount to atomic units');\r\n      } else {\r\n        // Already in atomic units, ensure it's a string\r\n        authorizationValue = authValueStr;\r\n      }\r\n      \r\n      // Convert maxAmountRequired to atomic units if needed\r\n      const maxAmountRaw = paymentRequirements.value || (paymentRequirements as any).maxAmountRequired || authorizationValue;\r\n      const maxAmountStr = String(maxAmountRaw);\r\n      const maxAmountNum = parseFloat(maxAmountStr);\r\n      \r\n      let maxAmountRequired: string;\r\n      if (maxAmountNum < 1000 && maxAmountNum > 0) {\r\n        // Convert human amount to atomic units\r\n        maxAmountRequired = toAtomicUnits(maxAmountStr, 6);\r\n        logger.debug({ \r\n          original: maxAmountStr, \r\n          converted: maxAmountRequired \r\n        }, 'Converted maxAmountRequired to atomic units');\r\n      } else {\r\n        // Already in atomic units, ensure it's a string\r\n        maxAmountRequired = maxAmountStr;\r\n      }\r\n      \r\n      // Ensure both are strings and digit-only (atomic units)\r\n      if (!/^[0-9]+$/.test(authorizationValue) || !/^[0-9]+$/.test(maxAmountRequired)) {\r\n        const error = new Error('Amount fields must be digit-only strings in atomic units');\r\n        logger.error({\r\n          authorizationValue,\r\n          maxAmountRequired,\r\n          authorizationValueType: typeof authorizationValue,\r\n          maxAmountRequiredType: typeof maxAmountRequired,\r\n        }, 'Amount validation failed');\r\n        throw error;\r\n      }\r\n      \r\n      // Log the final values being sent\r\n      logger.debug({\r\n        network: normalizedNetwork,\r\n        authorizationValue,\r\n        maxAmountRequired,\r\n        payTo: paymentRequirements.to || (paymentRequirements as any).payTo,\r\n      }, 'CDP verify request payload (amounts in atomic units)');\r\n      \r\n      // Build paymentRequirements object matching CDP's x402 /verify schema\r\n      // CDP expects: scheme, network, payTo, maxAmountRequired, resource, asset, description, mimeType, maxTimeoutSeconds\r\n      // For EVM networks, scheme should be 'exact', network can be CAIP-2 format (eip155:8453)\r\n      const paymentRequirementsBody: {\r\n        scheme: string;\r\n        network: string;\r\n        payTo: string;\r\n        maxAmountRequired: string;\r\n        resource: string;\r\n        asset: string;\r\n        description: string;\r\n        mimeType: string;\r\n        maxTimeoutSeconds: number;\r\n        validAfter?: string;\r\n        validBefore?: string;\r\n        outputSchema?: any;\r\n        extra?: any;\r\n      } = {\r\n        scheme: paymentRequirements.scheme || 'exact', // 'exact' for EVM fixed-amount flows\r\n        network: normalizedNetwork, // CAIP-2 format: \"eip155:8453\" (CDP accepts this)\r\n        payTo: paymentRequirements.to || (paymentRequirements as any).payTo || '',\r\n        maxAmountRequired: maxAmountRequired, // String of atomic units (e.g., \"1000000\" for 1 USDC)\r\n        resource: paymentRequirements.resource || '',\r\n        asset: paymentRequirements.asset || '',\r\n        description: paymentRequirements.description || 'x402 Payment Verification',\r\n        mimeType: paymentRequirements.mimeType || 'application/json',\r\n        maxTimeoutSeconds: (paymentRequirements as any).maxTimeoutSeconds || 300,\r\n      };\r\n      \r\n      // Add optional fields only if they exist\r\n      if (paymentRequirements.validAfter) {\r\n        paymentRequirementsBody.validAfter = paymentRequirements.validAfter;\r\n      }\r\n      if (paymentRequirements.validBefore) {\r\n        paymentRequirementsBody.validBefore = paymentRequirements.validBefore;\r\n      }\r\n      if ((paymentRequirements as any).outputSchema) {\r\n        paymentRequirementsBody.outputSchema = (paymentRequirements as any).outputSchema;\r\n      }\r\n      if ((paymentRequirements as any).extra) {\r\n        paymentRequirementsBody.extra = (paymentRequirements as any).extra;\r\n      }\r\n\r\n      // Parse payment header to extract the payment payload\r\n      let paymentHeaderString = request.payment;\r\n      if (paymentHeaderString.startsWith('x402 ')) {\r\n        paymentHeaderString = paymentHeaderString.slice(5);\r\n      }\r\n      \r\n      // Decode and parse the payment header\r\n      let parsedPaymentPayload: any;\r\n      try {\r\n        const decoded = Buffer.from(paymentHeaderString, 'base64').toString('utf-8');\r\n        parsedPaymentPayload = JSON.parse(decoded);\r\n      } catch (parseError) {\r\n        logger.error({ error: parseError }, 'Failed to parse payment header for CDP request');\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: 'Invalid payment header format',\r\n        };\r\n      }\r\n      \r\n      // Convert CAIP-2 network (eip155:8453) to legacy format (base) for CDP\r\n      const legacyNetworkMap: Record<string, string> = {\r\n        'eip155:8453': 'base',\r\n        'eip155:84532': 'base-sepolia',\r\n        'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp': 'solana',\r\n        'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1': 'solana-devnet',\r\n      };\r\n      const legacyNetwork = legacyNetworkMap[normalizedNetwork] || normalizedNetwork.replace('eip155:', '');\r\n      \r\n      // Build request body matching CDP's x402 /verify schema\r\n      // CDP expects legacy network format ('base', not 'eip155:8453')\r\n      const verifyBody = {\r\n        x402Version: 1, // CDP only supports version 1\r\n        paymentPayload: {\r\n          x402Version: 1,\r\n          scheme: 'exact' as const,\r\n          network: legacyNetwork, // CDP expects legacy format ('base')\r\n          payload: {\r\n            signature: parsedPaymentPayload.signature,\r\n            authorization: parsedPaymentPayload.authorization,\r\n          },\r\n        },\r\n        paymentRequirements: {\r\n          scheme: paymentRequirementsBody.scheme || 'exact',\r\n          network: legacyNetwork, // CDP expects legacy format ('base')\r\n          // CDP expects 'maxAmountRequired' for the amount field\r\n          maxAmountRequired: paymentRequirementsBody.maxAmountRequired || paymentRequirementsBody.amount,\r\n          resource: paymentRequirementsBody.resource,\r\n          description: paymentRequirementsBody.description || 'x402 payment verification',\r\n          mimeType: paymentRequirementsBody.mimeType || 'application/json',\r\n          // CDP expects 'payTo' for the recipient address\r\n          payTo: paymentRequirementsBody.payTo || paymentRequirementsBody.recipient,\r\n          maxTimeoutSeconds: paymentRequirementsBody.maxTimeoutSeconds || 300,\r\n          // CDP expects asset contract address, not symbol\r\n          asset: paymentRequirementsBody.asset,\r\n          // EIP-712 domain info required for EVM signature verification\r\n          ...(paymentRequirementsBody.extra && { extra: paymentRequirementsBody.extra }),\r\n        },\r\n      };\r\n      \r\n      // Log request details before sending\r\n      logger.info({\r\n        component: \"CDPFacilitator\",\r\n        isProbe,\r\n        network: paymentRequirementsBody.network,\r\n        asset: paymentRequirementsBody.asset,\r\n        hasPaymentHeader: typeof paymentHeaderString === \"string\" && paymentHeaderString.length > 0,\r\n        paymentHeaderPreview: paymentHeaderString.slice(0, 60),\r\n        msg: \"Sending CDP /verify request\"\r\n      });\r\n      \r\n      // DEBUG: Log full payload for troubleshooting CDP rejection\r\n      logger.info({\r\n        component: \"CDPFacilitator\",\r\n        debug: true,\r\n        fullPaymentPayload: {\r\n          x402Version: verifyBody.paymentPayload.x402Version,\r\n          scheme: verifyBody.paymentPayload.scheme,\r\n          network: verifyBody.paymentPayload.network,\r\n          hasSignature: !!verifyBody.paymentPayload.payload.signature,\r\n          signaturePreview: verifyBody.paymentPayload.payload.signature?.slice(0, 20),\r\n          authorization: verifyBody.paymentPayload.payload.authorization,\r\n        },\r\n        fullPaymentRequirements: verifyBody.paymentRequirements,\r\n        parsedPayloadKeys: Object.keys(parsedPaymentPayload || {}),\r\n        msg: \"CDP verify request full payload\"\r\n      });\r\n      \r\n      // TODO: CDP Support Mode - Add optional enhanced logging for non-production\r\n      // When CDP_SUPPORT_MODE=true, log full request/response for debugging with CDP support\r\n      // if (process.env.CDP_SUPPORT_MODE === 'true' && process.env.NODE_ENV !== 'production') {\r\n      //   logger.debug({ fullRequestBody: verifyBody, fullPaymentRequirements: paymentRequirementsBody }, 'CDP Support Mode: Full request details');\r\n      // }\r\n\r\n      // Note: Transaction hash is included in the paymentHeader string itself\r\n      // CDP will extract it from the payment header, so we don't need to add it separately\r\n      if (txHash) {\r\n        logger.debug({ txHash }, 'Transaction hash is included in paymentHeader');\r\n      }\r\n\r\n      // Step 5: Generate JWT token for CDP API\r\n      const url = new URL('https://api.cdp.coinbase.com/platform/v2/x402/verify');\r\n      const token = await this.generateJWT('POST', url.pathname);\r\n\r\n      // Log request details (without sensitive data)\r\n      logger.debug({\r\n        url: url.toString(),\r\n        x402Version: verifyBody.x402Version,\r\n        paymentPayload: {\r\n          x402Version: verifyBody.paymentPayload.x402Version,\r\n          scheme: verifyBody.paymentPayload.scheme,\r\n          network: verifyBody.paymentPayload.network,\r\n          hasSignature: !!verifyBody.paymentPayload.payload.signature,\r\n          hasAuthorization: !!verifyBody.paymentPayload.payload.authorization,\r\n        },\r\n        paymentRequirements: verifyBody.paymentRequirements,\r\n        isProbe: isProbe,\r\n      }, 'Sending verification request to CDP');\r\n\r\n      // Step 6: Call CDP API with retry logic\r\n      // Extract request ID from context if available (passed via verifyPaymentWithRetry)\r\n      const requestId = (request as any).requestId;\r\n      const headers: HeadersInit = {\r\n        'Content-Type': 'application/json',\r\n        'Authorization': `Bearer ${token}`,\r\n        'X-CDP-API-Key': this.apiKeyId,\r\n      };\r\n      \r\n      // Add request ID to CDP call for correlation\r\n      if (requestId) {\r\n        Object.assign(headers, addRequestIdToCDPHeaders(headers, requestId));\r\n      }\r\n      \r\n      // Call CDP /verify with retry logic\r\n      const result = await this.callCdpVerifyWithRetries(\r\n        verifyBody,\r\n        isProbe,\r\n        headers\r\n      );\r\n\r\n      // Log CDP response\r\n      logger.debug({\r\n        status: result.status,\r\n        success: result.success,\r\n        valid: result.valid,\r\n        errorType: result.errorType,\r\n        errorMessage: result.errorMessage,\r\n        isRateLimited: result.isRateLimited,\r\n        isNetworkError: result.isNetworkError,\r\n        latencyMs: result.latencyMs,\r\n      }, 'CDP verification response');\r\n\r\n      // Handle success\r\n      if (result.success && result.valid) {\r\n        logger.info({ latencyMs: result.latencyMs }, 'Payment verified successfully');\r\n        return {\r\n          success: true,\r\n          valid: true,\r\n          transactionHash: undefined, // CDP verify doesn't return transaction hash\r\n          kytStatus: 'passed', // CDP verify doesn't return KYT/OFAC status\r\n          ofacStatus: 'passed',\r\n        };\r\n      } else {\r\n        // Handle error - map CDP errorType/errorMessage to our error classification\r\n        const cdpErrorType = result.errorType || 'CDP_VERIFY_FAILED';\r\n        const cdpErrorMessage = result.errorMessage || 'CDP verification failed';\r\n        \r\n        // Map error types to result/errorCode\r\n        let errorCode = 'facilitator_error';\r\n        if (result.isRateLimited || cdpErrorType === 'rate_limit') {\r\n          errorCode = 'rate_limited';\r\n        } else if (result.isNetworkError) {\r\n          errorCode = 'network_error';\r\n        } else if (cdpErrorType === 'invalid_request' || result.status === 400) {\r\n          errorCode = 'invalid_request';\r\n        } else if (result.status === 401) {\r\n          errorCode = 'unauthorized';\r\n        }\r\n        \r\n        // Log detailed error information including request body for debugging\r\n        logger.error({\r\n          status: result.status,\r\n          errorType: cdpErrorType,\r\n          errorMessage: cdpErrorMessage,\r\n          errorCode,\r\n          isRateLimited: result.isRateLimited,\r\n          isNetworkError: result.isNetworkError,\r\n          cdpResponse: result.data,\r\n          requestBody: {\r\n            x402Version: verifyBody.x402Version,\r\n            paymentPayload: {\r\n              x402Version: verifyBody.paymentPayload.x402Version,\r\n              scheme: verifyBody.paymentPayload.scheme,\r\n              network: verifyBody.paymentPayload.network,\r\n            },\r\n            paymentRequirements: verifyBody.paymentRequirements,\r\n          },\r\n        }, 'Payment verification failed');\r\n        \r\n        // Extract authorization details from the parsed payment header for logging\r\n          let authorizationFrom = 'UNKNOWN';\r\n          let authorizationTo = 'UNKNOWN';\r\n          let transactionHash = 'NOT PROVIDED';\r\n          if (parsedPayment) {\r\n            authorizationFrom = parsedPayment.authorization.from;\r\n            authorizationTo = parsedPayment.authorization.to;\r\n            transactionHash = parsedPayment.txHash || 'NOT PROVIDED';\r\n          }\r\n          \r\n          const errorDetails = {\r\n            error: cdpErrorMessage, // Use CDP's errorMessage\r\n            errorType: cdpErrorType, // Use CDP's errorType\r\n            cdpResponse: result.data,\r\n            httpStatus: result.status,\r\n            errorCode,\r\n            isRateLimited: result.isRateLimited,\r\n            isNetworkError: result.isNetworkError,\r\n            // Include request details for debugging\r\n            requestDetails: {\r\n              scheme: verifyBody.paymentRequirements?.scheme || 'MISSING',\r\n              network: verifyBody.paymentRequirements?.network || 'MISSING',\r\n              payTo: verifyBody.paymentRequirements?.payTo || 'MISSING',\r\n              maxAmountRequired: verifyBody.paymentRequirements?.maxAmountRequired || 'MISSING',\r\n              validAfter: verifyBody.paymentRequirements?.validAfter || 'MISSING',\r\n              validBefore: verifyBody.paymentRequirements?.validBefore || 'MISSING',\r\n              resource: verifyBody.paymentRequirements?.resource || 'MISSING',\r\n              asset: verifyBody.paymentRequirements?.asset || 'MISSING',\r\n              fullPaymentRequirements: verifyBody.paymentRequirements,\r\n              authorizationFrom,\r\n              authorizationTo,\r\n              transactionHash,\r\n            },\r\n          };\r\n\r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            error: cdpErrorMessage, // Use CDP's errorMessage\r\n            errorDetails: {\r\n              ...errorDetails,\r\n              errorType: cdpErrorType, // Include CDP's errorType\r\n            },\r\n            kytStatus: undefined,\r\n            ofacStatus: undefined,\r\n          };\r\n      }\r\n    } catch (error: any) {\r\n      // Handle network errors with enhanced logging\r\n      const errorMessage = error?.message || 'CDP_VERIFY_FAILED';\r\n      const isTimeout = error?.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout');\r\n      const isNetworkError = errorMessage.toLowerCase().includes('network') || \r\n                            errorMessage.toLowerCase().includes('fetch') ||\r\n                            errorMessage.toLowerCase().includes('econnrefused');\r\n      \r\n      logger.error({ \r\n        error,\r\n        errorMessage,\r\n        isTimeout,\r\n        isNetworkError,\r\n        component: 'cdp-facilitator',\r\n        operation: 'verifyPayment',\r\n        requestId: (request as any).requestId,\r\n      }, 'CDP API request error');\r\n      \r\n      const errorDetails = {\r\n        error: errorMessage,\r\n        cdpResponse: undefined,\r\n        httpStatus: 500,\r\n        errorType: isTimeout ? 'timeout' : isNetworkError ? 'network' : 'unknown',\r\n      };\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: errorMessage,\r\n        errorDetails: errorDetails,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify payment with retry logic and exponential backoff\r\n   * \r\n   * Retries on network errors and timeouts, but not on validation failures\r\n   */\r\n  private async verifyPaymentWithRetry(\r\n    request: CDPVerifyRequest,\r\n    maxRetries: number = 3\r\n  ): Promise<CDPVerifyResponse> {\r\n    let lastError: Error | null = null;\r\n\r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const result = await this.verifyPayment(request);\r\n        \r\n        // If verification succeeded, return immediately\r\n        if (result.success && result.valid) {\r\n          return result;\r\n        }\r\n\r\n        // If verification failed due to validation (not network), don't retry\r\n        if (result.error && \r\n            !result.error.includes('timeout') && \r\n            !result.error.includes('network') &&\r\n            !result.error.includes('Unable to reach')) {\r\n          return result;\r\n        }\r\n\r\n        // If blocked by KYT/OFAC, don't retry\r\n        if (result.kytStatus === 'blocked' || result.ofacStatus === 'blocked') {\r\n          return result;\r\n        }\r\n\r\n        lastError = new Error(result.error || 'Verification failed');\r\n      } catch (error) {\r\n        lastError = error instanceof Error ? error : new Error(String(error));\r\n      }\r\n\r\n      // Exponential backoff: 100ms, 200ms, 400ms\r\n      if (attempt < maxRetries - 1) {\r\n        const delay = 100 * Math.pow(2, attempt);\r\n        logger.info({ attempt: attempt + 1, maxRetries, delay }, 'Retrying CDP verification');\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n      }\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      error: lastError?.message || 'Max retries exceeded',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Health check - verify CDP facilitator is accessible\r\n   * \r\n   * Note: CDP may not have a /health endpoint. This is a best-effort check.\r\n   * If it fails, it doesn't necessarily mean CDP is unavailable.\r\n   * \r\n   * IMPORTANT: If the facilitator URL domain doesn't resolve (DNS error),\r\n   * this will return unhealthy, but actual payment verification might\r\n   * still work if it uses a different endpoint.\r\n   */\r\n  async healthCheck(): Promise<{ healthy: boolean; error?: string }> {\r\n    try {\r\n      // For REST API calls, CDP requires request-specific JWT\r\n      // Generate JWT with the actual request details\r\n      const url = new URL(`${this.facilitatorUrl}/health`);\r\n      const token = await this.generateJWT('GET', url.pathname);\r\n      \r\n      const response = await fetch(url.toString(), {\r\n        method: 'GET',\r\n        headers: {\r\n          'Authorization': `Bearer ${token}`,\r\n          'X-CDP-API-Key': this.apiKeyId,\r\n        },\r\n        signal: AbortSignal.timeout(5000), // 5 second timeout\r\n      });\r\n\r\n      if (response.ok) {\r\n        return { healthy: true };\r\n      } else {\r\n        // 401/403 might mean auth is working but endpoint doesn't exist or keys are wrong\r\n        // 404 means endpoint doesn't exist (but auth might be working)\r\n        // For now, we'll consider it healthy if we get any response (not a network error)\r\n        if (response.status === 404) {\r\n          return { \r\n            healthy: true, \r\n            error: 'Health endpoint not found, but CDP is reachable' \r\n          };\r\n        }\r\n        \r\n        // Get error details from response if available\r\n        let errorMsg = `Health check failed: ${response.status} ${response.statusText}`;\r\n        try {\r\n          const errorBody = await response.text();\r\n          if (errorBody) {\r\n            errorMsg += ` - ${errorBody.substring(0, 200)}`;\r\n          }\r\n        } catch {\r\n          // Ignore parsing errors\r\n        }\r\n        \r\n        return { \r\n          healthy: false, \r\n          error: errorMsg\r\n        };\r\n      }\r\n    } catch (error) {\r\n      // Network errors or timeouts indicate CDP is not reachable\r\n      // This includes DNS resolution failures (domain doesn't exist)\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      \r\n      // If it's a DNS/network error, note that payment verification might still work\r\n      if (errorMessage.includes('fetch failed') || \r\n          errorMessage.includes('ENOTFOUND') || \r\n          errorMessage.includes('getaddrinfo')) {\r\n        return {\r\n          healthy: false,\r\n          error: `Facilitator URL not reachable (${errorMessage}). Payment verification may use a different endpoint.`,\r\n        };\r\n      }\r\n      \r\n      return {\r\n        healthy: false,\r\n        error: errorMessage,\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet cdpFacilitator: CDPFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton CDP facilitator instance\r\n */\r\nexport function getCDPFacilitator(): CDPFacilitator {\r\n  if (!cdpFacilitator) {\r\n    const apiKeyId = process.env.CDP_API_KEY_ID;\r\n    const facilitatorUrl = process.env.CDP_FACILITATOR_URL || 'https://api.cdp.coinbase.com/platform/v2/x402';\r\n\r\n    if (!apiKeyId) {\r\n      throw new Error('CDP_API_KEY_ID must be set in environment variables');\r\n    }\r\n\r\n    cdpFacilitator = new CDPFacilitator(apiKeyId, facilitatorUrl);\r\n  }\r\n  return cdpFacilitator;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3279, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/cdp-facilitator-adapter.ts"],"sourcesContent":["// =============================================================================\r\n// CDP FACILITATOR ADAPTER\r\n// =============================================================================\r\n// Adapter to make CDP facilitator conform to IFacilitator interface\r\n\r\nimport { BaseFacilitator, type IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorHealth, type FacilitatorConfig, type CAIPNetworkId, type CAIPAssetId } from './base-facilitator';\r\nimport { getCDPFacilitator, type CDPVerifyRequest, type CDPVerifyResponse, type X402PaymentRequirements } from '../cdp-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\n// Logger will be created per instance\r\n\r\n/**\r\n * Build CDP-specific payment requirements for probe mode\r\n * Uses known-good values for Base + USDC that CDP expects\r\n * CDP x402 v2 API expects: scheme, network, payTo, maxAmountRequired, resource, asset, etc.\r\n */\r\nfunction buildCdpProbePaymentRequirements(config: FacilitatorProbeConfig): X402PaymentRequirements {\r\n  // USDC contract address on Base\r\n  const USDC_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';\r\n  \r\n  // Use a test receiver address (can be any valid address you control)\r\n  // For probes, we use a known test address that won't cause issues\r\n  const PROBE_RECEIVER = '0x0000000000000000000000000000000000000001'; // Test address\r\n  \r\n  // CDP requires CAIP-2 format (e.g., \"eip155:8453\") for network\r\n  // Keep network in CAIP-2 format, don't convert to legacy\r\n  const network = config.network; // Already in CAIP-2 format (e.g., \"eip155:8453\")\r\n  \r\n  const now = Math.floor(Date.now() / 1000);\r\n  \r\n  return {\r\n    scheme: 'exact', // CDP expects 'exact' scheme for EVM fixed-amount flows\r\n    network: network, // Use CAIP-2 format (e.g., \"eip155:8453\")\r\n    to: PROBE_RECEIVER, // Internal field name\r\n    payTo: PROBE_RECEIVER, // CDP field name (required)\r\n    value: '1000000', // Internal field name (1 USDC in atomic units, must match authorization.value)\r\n    maxAmountRequired: '1000000', // CDP field name (required) - 1 USDC in atomic units\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    asset: USDC_BASE,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    maxTimeoutSeconds: 10, // Short timeout for probes\r\n    validAfter: now.toString(),\r\n    validBefore: (now + 300).toString(), // 5 minutes validity window\r\n  };\r\n}\r\n\r\n/**\r\n * CDP Facilitator Adapter\r\n * Wraps the existing CDP facilitator to implement IFacilitator interface\r\n */\r\nexport class CDPFacilitatorAdapter extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'cdp';\r\n  readonly name = 'Coinbase Developer Platform';\r\n  \r\n  readonly config: FacilitatorConfig = {\r\n    id: 'cdp',\r\n    name: 'Coinbase Developer Platform',\r\n    enabled: true,\r\n    priority: 1, // High priority (primary facilitator)\r\n    networks: ['base'], // Legacy: Currently Base only\r\n    networksCAIP: ['eip155:8453'], // CAIP-2: Base mainnet\r\n    assets: ['0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // Legacy: USDC on Base\r\n    assetsCAIP: ['eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // CAIP-19: USDC on Base\r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'], // CDP supports immediate settlement\r\n    healthCheckUrl: process.env.CDP_FACILITATOR_URL || 'https://api.cdp.coinbase.com/platform/v2/x402',\r\n    metadata: {\r\n      provider: 'Coinbase',\r\n      kytEnabled: true,\r\n      ofacEnabled: true,\r\n      complianceLevel: 'enterprise',\r\n    },\r\n  };\r\n\r\n  private cdpFacilitator = getCDPFacilitator();\r\n\r\n  /**\r\n   * Verify payment using CDP facilitator\r\n   * \r\n   * Note: This adapter expects the payment header to be passed as-is.\r\n   * The CDP facilitator will parse it internally. For a more complete\r\n   * adapter, we could parse the header here and extract the authorization,\r\n   * but for now we rely on CDP's internal parsing.\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Import payment header parser to extract authorization\r\n      const { parseAndVerifyPaymentHeader } = await import('../payment-header-parser');\r\n      const parsed = await parseAndVerifyPaymentHeader(payment);\r\n\r\n      if (!parsed.valid || !parsed.payment) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parsed.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Detect probe mode: check if resource URL matches probe pattern\r\n      // Probe resources use pattern: https://probe.nexflow.dev/health/{facilitatorId}/{network}/{token}\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n      \r\n      // For probe mode, build CDP-specific probe paymentRequirements\r\n      // Extract probe config from resource URL if in probe mode\r\n      let cdpPaymentRequirements: X402PaymentRequirements;\r\n      if (isProbe) {\r\n        // Extract facilitatorId, network, token from resource URL\r\n        // Format: https://probe.nexflow.dev/health/{facilitatorId}/{network}/{token}\r\n        const resourceMatch = requirements.resource.match(/\\/health\\/([^/]+)\\/([^/]+)\\/([^/]+)/);\r\n        if (resourceMatch) {\r\n          const [, facilitatorId, network, token] = resourceMatch;\r\n          const probeConfig: FacilitatorProbeConfig = {\r\n            id: `${facilitatorId}-${network}-${token.toLowerCase()}`,\r\n            facilitatorId,\r\n            network,\r\n            token,\r\n            desiredIntervalSeconds: 30, // Default, not used for building requirements\r\n            enabled: true,\r\n          };\r\n          cdpPaymentRequirements = buildCdpProbePaymentRequirements(probeConfig);\r\n          this.getLogger().info({\r\n            component: 'CDPFacilitatorAdapter',\r\n            isProbe: true,\r\n            probeConfigId: probeConfig.id,\r\n            hasPaymentRequirements: true,\r\n            msg: 'Using probe-specific paymentRequirements for CDP',\r\n          });\r\n        } else {\r\n          // Fallback: use requirements as-is if we can't parse probe config\r\n          cdpPaymentRequirements = {\r\n            scheme: requirements.scheme,\r\n            network: requirements.network,\r\n            maxAmountRequired: requirements.maxAmountRequired,\r\n            resource: requirements.resource,\r\n            description: requirements.description || '',\r\n            mimeType: requirements.mimeType || 'application/json',\r\n            payTo: requirements.payTo,\r\n            maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n            asset: requirements.asset,\r\n          };\r\n        }\r\n      } else {\r\n        // Normal mode: use requirements from caller\r\n        cdpPaymentRequirements = {\r\n          scheme: requirements.scheme,\r\n          network: requirements.network,\r\n          maxAmountRequired: requirements.maxAmountRequired,\r\n          resource: requirements.resource,\r\n          description: requirements.description || '',\r\n          mimeType: requirements.mimeType || 'application/json',\r\n          payTo: requirements.payTo,\r\n          maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n          asset: requirements.asset,\r\n        };\r\n      }\r\n\r\n      // Build CDP request with parsed payment data\r\n      const cdpRequest: CDPVerifyRequest = {\r\n        payment,\r\n        paymentPayload: {\r\n          x402Version: 1,\r\n          scheme: 'x402' as const,\r\n          network: parsed.payment.network || requirements.network,\r\n          payload: {\r\n            signature: parsed.payment.signature,\r\n            authorization: parsed.payment.authorization,\r\n          },\r\n        },\r\n        paymentRequirements: cdpPaymentRequirements,\r\n      };\r\n\r\n      // Verify with CDP\r\n      const result = await this.cdpFacilitator.verifyPaymentWithRetry(cdpRequest);\r\n\r\n      return {\r\n        success: result.success,\r\n        valid: result.valid,\r\n        transactionHash: result.transactionHash,\r\n        kytStatus: result.kytStatus,\r\n        ofacStatus: result.ofacStatus,\r\n        error: result.error,\r\n        errorDetails: result.errorDetails,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      this.getLogger().error({ error, requirements }, 'CDP verification error');\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: error instanceof Error ? error.message : 'Verification failed',\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get CDP facilitator health\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    try {\r\n      const start = Date.now();\r\n      const health = await this.cdpFacilitator.healthCheck();\r\n      const latency = Date.now() - start;\r\n\r\n      return {\r\n        healthy: health.healthy,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        healthy: false,\r\n        lastChecked: new Date().toISOString(),\r\n        error: error instanceof Error ? error.message : 'Health check failed',\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing (CDP doesn't charge fees, but we track gas costs)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    if (network === 'base' && asset === '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913') {\r\n      return {\r\n        network: 'base',\r\n        asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n        baseFee: '0', // CDP doesn't charge fees\r\n        percentageFee: 0,\r\n        estimatedGas: '21000', // Typical gas for USDC transfer\r\n        currency: 'USDC',\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get CDP facilitator adapter instance\r\n */\r\nlet cdpAdapter: CDPFacilitatorAdapter | null = null;\r\n\r\nexport function getCDPFacilitatorAdapter(): CDPFacilitatorAdapter {\r\n  if (!cdpAdapter) {\r\n    cdpAdapter = new CDPFacilitatorAdapter();\r\n  }\r\n  return cdpAdapter;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3548, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/payai-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// PAYAI FACILITATOR\r\n// =============================================================================\r\n// Multi-chain facilitator for x402 payment verification\r\n// Supports Base, Solana, Ethereum, BNB Chain, and other networks\r\n\r\nimport { BaseFacilitator, type IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorHealth, type FacilitatorConfig, type CAIPNetworkId, type CAIPAssetId } from './base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\nconst logger = createLogger({ component: 'PayAIFacilitator' });\r\n\r\n/**\r\n * Build PayAI-specific payment requirements for probe mode\r\n * Uses known-good values for Base + USDC that PayAI expects\r\n */\r\nfunction buildPayAIProbePaymentRequirements(config: FacilitatorProbeConfig): PaymentRequirements {\r\n  // USDC contract address on Base\r\n  const USDC_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';\r\n  \r\n  // Use a test receiver address (can be any valid address you control)\r\n  // For probes, we use a known test address that won't cause issues\r\n  const PROBE_RECEIVER = '0x0000000000000000000000000000000000000001'; // Test address\r\n  \r\n  // Convert CAIP-2 network to legacy format\r\n  let legacyNetwork = config.network;\r\n  if (config.network === 'eip155:8453') {\r\n    legacyNetwork = 'base';\r\n  }\r\n  \r\n  return {\r\n    scheme: 'x402',\r\n    network: legacyNetwork,\r\n    asset: USDC_BASE,\r\n    maxAmountRequired: '1', // Minimal amount (1 atomic unit)\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    payTo: PROBE_RECEIVER, // Use test receiver address for probes\r\n    maxTimeoutSeconds: 10, // Short timeout for probes\r\n    settlementMode: 'immediate',\r\n  };\r\n}\r\n\r\n/**\r\n * PayAI Facilitator\r\n * \r\n * Multi-chain facilitator supporting multiple networks beyond Base.\r\n * Implements x402 payment verification via PayAI facilitator API.\r\n */\r\nexport class PayAIFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'payai';\r\n  readonly name = 'PayAI Facilitator';\r\n\r\n  readonly config: FacilitatorConfig = {\r\n    id: 'payai',\r\n    name: 'PayAI Facilitator',\r\n    enabled: process.env.PAYAI_ENABLED !== 'false', // Enabled by default, can be disabled via env\r\n    priority: 2, // Lower priority than CDP (CDP = 1, PayAI = 2)\r\n    \r\n    // Legacy network identifiers\r\n    networks: ['base', 'ethereum', 'solana', 'bnb', 'polygon'],\r\n    \r\n    // CAIP-2 network identifiers (multi-chain support)\r\n    networksCAIP: [\r\n      'eip155:1',      // Ethereum mainnet\r\n      'eip155:8453',   // Base mainnet\r\n      'eip155:56',     // BNB Chain\r\n      'eip155:137',    // Polygon\r\n      'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp', // Solana mainnet\r\n    ],\r\n    \r\n    // Legacy asset identifiers\r\n    assets: [\r\n      '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base\r\n      '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC on Ethereum\r\n    ],\r\n    \r\n    // CAIP-19 asset identifiers (multi-chain support)\r\n    assetsCAIP: [\r\n      // Ethereum USDC\r\n      'eip155:1/erc20:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\r\n      // Base USDC\r\n      'eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n      // BNB Chain USDC\r\n      'eip155:56/erc20:0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d',\r\n      // Polygon USDC\r\n      'eip155:137/erc20:0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\r\n      // Solana USDC (EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v)\r\n      // Note: Solana CAIP-19 format may differ, adding placeholder\r\n      // 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp/spl:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',\r\n    ],\r\n    \r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'], // PayAI supports immediate settlement\r\n    \r\n    healthCheckUrl: process.env.PAYAI_FACILITATOR_URL || 'https://facilitator.payai.network',\r\n    \r\n    metadata: {\r\n      provider: 'PayAI',\r\n      multiChain: true,\r\n      complianceLevel: 'standard',\r\n      website: 'https://payai.network',\r\n    },\r\n  };\r\n\r\n  private baseUrl: string;\r\n\r\n  constructor(\r\n    baseUrl?: string\r\n  ) {\r\n    super();\r\n    // No API key required for hosted facilitator\r\n    this.baseUrl = baseUrl || process.env.PAYAI_FACILITATOR_URL || 'https://facilitator.payai.network';\r\n  }\r\n\r\n  /**\r\n   * Call PayAI /verify endpoint with retry logic for transient errors\r\n   * \r\n   * Retries on: 429 (rate limit), 500-504 (server errors), network timeouts\r\n   * Does NOT retry on: 400 (invalid_request), 401 (unauthorized), other 4xx\r\n   * \r\n   * Returns normalized result with success, valid, status, errorType, errorMessage, etc.\r\n   */\r\n  private async callPayAIVerifyWithRetries(\r\n    verifyUrl: string,\r\n    requestBody: any,\r\n    isProbe: boolean\r\n  ): Promise<{\r\n    success: boolean;\r\n    valid: boolean;\r\n    status: number;\r\n    errorType?: string;\r\n    errorMessage?: string;\r\n    isRateLimited: boolean;\r\n    isNetworkError: boolean;\r\n    latencyMs: number;\r\n    data?: any;\r\n  }> {\r\n    const maxRetries = 3;\r\n    const retryableStatuses = [429, 500, 502, 503, 504];\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const response = await fetch(verifyUrl, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify(requestBody),\r\n          signal: AbortSignal.timeout(10000), // 10 second timeout\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data = text ? JSON.parse(text) : {};\r\n        const latencyMs = Date.now() - startTime;\r\n\r\n        // Success case\r\n        if (response.ok && data.valid === true) {\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            status: response.status,\r\n            isRateLimited: false,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Check if retryable error\r\n        const isRetryable = retryableStatuses.includes(response.status);\r\n        const isRateLimit = response.status === 429;\r\n        \r\n        // If not retryable or last attempt, return error\r\n        if (!isRetryable || attempt === maxRetries - 1) {\r\n          const errorMessage = data.message || data.reason || data.error || `HTTP ${response.status}`;\r\n          const errorType = data.errorType || data.code || (isRateLimit ? 'rate_limit' : 'PAYAI_VERIFY_FAILED');\r\n          \r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            status: response.status,\r\n            errorType,\r\n            errorMessage,\r\n            isRateLimited: isRateLimit,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Retry with exponential backoff\r\n        const delay = 100 * Math.pow(2, attempt); // 100ms, 200ms, 400ms\r\n        logger.info({\r\n          component: 'PayAIFacilitator',\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          status: response.status,\r\n          delay,\r\n          isProbe,\r\n          msg: 'Retrying PayAI verification after transient error',\r\n        });\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        \r\n      } catch (error: any) {\r\n        const latencyMs = Date.now() - startTime;\r\n        const isTimeout = error?.name === 'AbortError' || error?.message?.toLowerCase().includes('timeout');\r\n        const isNetworkError = error?.message?.toLowerCase().includes('network') || \r\n                              error?.message?.toLowerCase().includes('fetch') ||\r\n                              error?.message?.toLowerCase().includes('econnrefused');\r\n        \r\n        // If network error and not last attempt, retry\r\n        if ((isTimeout || isNetworkError) && attempt < maxRetries - 1) {\r\n          const delay = 100 * Math.pow(2, attempt);\r\n          logger.info({\r\n            component: 'PayAIFacilitator',\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error?.message,\r\n            delay,\r\n            isProbe,\r\n            msg: 'Retrying PayAI verification after network error',\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n        \r\n        // Last attempt or non-network error\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          status: 0,\r\n          errorType: isTimeout ? 'timeout' : isNetworkError ? 'network_error' : 'PAYAI_VERIFY_FAILED',\r\n          errorMessage: error?.message || 'PayAI verification failed',\r\n          isRateLimited: false,\r\n          isNetworkError: isTimeout || isNetworkError,\r\n          latencyMs,\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Should never reach here, but TypeScript needs a return\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      status: 0,\r\n      errorType: 'PAYAI_VERIFY_FAILED',\r\n      errorMessage: 'Max retries exceeded',\r\n      isRateLimited: false,\r\n      isNetworkError: false,\r\n      latencyMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify payment using PayAI facilitator\r\n   * \r\n   * POST to /verify endpoint with paymentPayload and paymentRequirements.\r\n   * No authentication required for hosted facilitator.\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    const start = Date.now();\r\n\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Parse payment header to extract authorization details\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Detect probe mode: check if resource URL matches probe pattern\r\n      // Probe resources use pattern: https://probe.nexflow.dev/health/{facilitatorId}/{network}/{token}\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n      \r\n      // For probe mode, build PayAI-specific probe paymentRequirements\r\n      // Extract probe config from resource URL if in probe mode\r\n      let probeRequirements: PaymentRequirements;\r\n      if (isProbe) {\r\n        // Extract facilitatorId, network, token from resource URL\r\n        // Format: https://probe.nexflow.dev/health/{facilitatorId}/{network}/{token}\r\n        const resourceMatch = requirements.resource.match(/\\/health\\/([^/]+)\\/([^/]+)\\/([^/]+)/);\r\n        if (resourceMatch) {\r\n          const [, facilitatorId, network, token] = resourceMatch;\r\n          const probeConfig: FacilitatorProbeConfig = {\r\n            id: `${facilitatorId}-${network}-${token.toLowerCase()}`,\r\n            facilitatorId,\r\n            network,\r\n            token,\r\n            desiredIntervalSeconds: 120, // Default, not used for building requirements\r\n            enabled: true,\r\n          };\r\n          probeRequirements = buildPayAIProbePaymentRequirements(probeConfig);\r\n          logger.info({\r\n            component: 'PayAIFacilitator',\r\n            isProbe: true,\r\n            probeConfigId: probeConfig.id,\r\n            hasPaymentRequirements: true,\r\n            msg: 'Using probe-specific paymentRequirements for PayAI',\r\n          });\r\n        } else {\r\n          // Fallback: use requirements as-is if we can't parse probe config\r\n          probeRequirements = requirements;\r\n        }\r\n      } else {\r\n        // Normal mode: use requirements from caller\r\n        probeRequirements = requirements;\r\n      }\r\n\r\n      // Build paymentPayload from parsed payment header\r\n      const paymentPayload = {\r\n        x402Version: 2, // x402 v2\r\n        scheme: probeRequirements.scheme || 'x402',\r\n        network: parsed.network || probeRequirements.network,\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: {\r\n            from: parsed.authorization.from,\r\n            to: parsed.authorization.to,\r\n            value: parsed.authorization.value,\r\n            validAfter: parsed.authorization.validAfter,\r\n            validBefore: parsed.authorization.validBefore,\r\n            nonce: parsed.authorization.nonce,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Build paymentRequirements from requirements (use probe-specific if in probe mode)\r\n      const paymentRequirements = {\r\n        scheme: probeRequirements.scheme,\r\n        network: probeRequirements.network,\r\n        maxAmountRequired: probeRequirements.maxAmountRequired,\r\n        resource: probeRequirements.resource,\r\n        description: probeRequirements.description || '',\r\n        mimeType: probeRequirements.mimeType || 'application/json',\r\n        payTo: probeRequirements.payTo,\r\n        maxTimeoutSeconds: probeRequirements.maxTimeoutSeconds || 300,\r\n        asset: probeRequirements.asset,\r\n      };\r\n\r\n      // POST to PayAI verification endpoint with retry logic\r\n      const verifyUrl = `${this.baseUrl}/verify`;\r\n      const requestBody = {\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      };\r\n\r\n      // isProbe already declared above (line 300), reuse it\r\n      logger.info({\r\n        component: \"PayAIFacilitator\",\r\n        isProbe,\r\n        network: paymentRequirements.network,\r\n        asset: paymentRequirements.asset,\r\n        url: verifyUrl,\r\n        msg: \"Sending PayAI /verify request\"\r\n      });\r\n\r\n      // Call PayAI /verify with retry logic\r\n      const result = await this.callPayAIVerifyWithRetries(\r\n        verifyUrl,\r\n        requestBody,\r\n        isProbe\r\n      );\r\n\r\n      const latency = result.latencyMs;\r\n\r\n      // Handle success\r\n      if (result.success && result.valid) {\r\n        logger.info({ latencyMs: result.latencyMs }, 'Payment verified successfully by PayAI');\r\n        return {\r\n          success: true,\r\n          valid: true,\r\n          transactionHash: result.data?.transactionHash || result.data?.txHash,\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Handle error - map PayAI errorType/errorMessage to our error classification\r\n      const payaiErrorType = result.errorType || 'PAYAI_VERIFY_FAILED';\r\n      const payaiErrorMessage = result.errorMessage || 'PayAI verification failed';\r\n      \r\n      // Map error types to result/errorCode\r\n      let errorCode = 'facilitator_error';\r\n      if (result.isRateLimited || payaiErrorType === 'rate_limit') {\r\n        errorCode = 'rate_limited';\r\n      } else if (result.isNetworkError) {\r\n        errorCode = 'network_error';\r\n      } else if (payaiErrorType === 'invalid_request' || result.status === 400) {\r\n        errorCode = 'invalid_request';\r\n      } else if (result.status === 401) {\r\n        errorCode = 'unauthorized';\r\n      }\r\n\r\n      logger.debug({\r\n        status: result.status,\r\n        errorType: payaiErrorType,\r\n        errorMessage: payaiErrorMessage,\r\n        errorCode,\r\n        isRateLimited: result.isRateLimited,\r\n        isNetworkError: result.isNetworkError,\r\n        latencyMs: result.latencyMs,\r\n      }, 'PayAI verification failed');\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: payaiErrorMessage,\r\n        errorDetails: {\r\n          error: payaiErrorMessage,\r\n          errorType: payaiErrorType,\r\n          httpStatus: result.status,\r\n          errorCode,\r\n          isRateLimited: result.isRateLimited,\r\n          isNetworkError: result.isNetworkError,\r\n          payaiResponse: result.data,\r\n        },\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'PayAI verification error');\r\n      \r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: isTimeout ? 'PayAI_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get PayAI facilitator health\r\n   * \r\n   * Calls GET /list endpoint. If 200 with non-empty networks/assets, returns healthy.\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // PayAI redirects /list to /discovery/resources\r\n      const healthUrl = `${this.baseUrl}/discovery/resources`;\r\n      \r\n      const response = await fetch(healthUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000), // 5 second timeout\r\n      });\r\n\r\n      const latency = Date.now() - start;\r\n\r\n      if (response.ok) {\r\n        const data = await response.json();\r\n        \r\n        // Check if response has networks/assets (non-empty)\r\n        const hasNetworks = data.networks && Array.isArray(data.networks) && data.networks.length > 0;\r\n        const hasAssets = data.assets && Array.isArray(data.assets) && data.assets.length > 0;\r\n\r\n        if (hasNetworks || hasAssets) {\r\n          return {\r\n            healthy: true,\r\n            latency,\r\n            lastChecked: new Date().toISOString(),\r\n            capabilities: {\r\n              networks: data.networks || this.config.networks,\r\n              assets: data.assets || this.config.assets,\r\n              schemes: data.schemes || this.config.schemes,\r\n            },\r\n          };\r\n        }\r\n\r\n        // 200 but empty response - consider unhealthy\r\n        return {\r\n          healthy: false,\r\n          latency,\r\n          lastChecked: new Date().toISOString(),\r\n          error: 'Health check returned empty networks/assets',\r\n          capabilities: {\r\n            networks: this.config.networks,\r\n            assets: this.config.assets,\r\n            schemes: this.config.schemes,\r\n          },\r\n        };\r\n      }\r\n\r\n      // Non-2xx response\r\n      const errorText = await response.text().catch(() => `HTTP ${response.status}`);\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: errorText,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Health check failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: isTimeout ? 'Health check timeout' : errorMessage,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing information\r\n   * \r\n   * Returns null for now - can be implemented once PayAI pricing API is available.\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    // TODO: Implement pricing lookup if PayAI provides pricing API\r\n    // For now, return null (allowed by interface)\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   * Uses base class implementation which checks config\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: string): boolean {\r\n    return super.supports(network, asset, scheme, settlementMode as any);\r\n  }\r\n}\r\n\r\n/**\r\n * Singleton PayAI facilitator instance\r\n */\r\nlet payaiFacilitator: PayAIFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton PayAI facilitator instance\r\n */\r\nexport function getPayAIFacilitator(): PayAIFacilitator {\r\n  if (!payaiFacilitator) {\r\n    payaiFacilitator = new PayAIFacilitator();\r\n  }\r\n  return payaiFacilitator;\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,oBAAoB;AACpB,gFAAgF;AAChF,wDAAwD;AACxD,iEAAiE;;;;;;;AAEjE;AACA;;;AAGA,MAAM,SAAS,IAAA,sIAAY,EAAC;IAAE,WAAW;AAAmB;AAE5D;;;CAGC,GACD,SAAS,mCAAmC,MAA8B;IACxE,gCAAgC;IAChC,MAAM,YAAY;IAElB,qEAAqE;IACrE,kEAAkE;IAClE,MAAM,iBAAiB,8CAA8C,eAAe;IAEpF,0CAA0C;IAC1C,IAAI,gBAAgB,OAAO,OAAO;IAClC,IAAI,OAAO,OAAO,KAAK,eAAe;QACpC,gBAAgB;IAClB;IAEA,OAAO;QACL,QAAQ;QACR,SAAS;QACT,OAAO;QACP,mBAAmB;QACnB,UAAU,CAAC,iCAAiC,EAAE,OAAO,aAAa,CAAC,CAAC,EAAE,OAAO,OAAO,CAAC,CAAC,EAAE,OAAO,KAAK,EAAE;QACtG,aAAa,CAAC,iBAAiB,EAAE,OAAO,aAAa,CAAC,IAAI,EAAE,OAAO,OAAO,EAAE;QAC5E,UAAU;QACV,OAAO;QACP,mBAAmB;QACnB,gBAAgB;IAClB;AACF;AAQO,MAAM,yBAAyB,uLAAe;IAC1C,KAAK,QAAQ;IACb,OAAO,oBAAoB;IAE3B,SAA4B;QACnC,IAAI;QACJ,MAAM;QACN,SAAS,QAAQ,GAAG,CAAC,aAAa,KAAK;QACvC,UAAU;QAEV,6BAA6B;QAC7B,UAAU;YAAC;YAAQ;YAAY;YAAU;YAAO;SAAU;QAE1D,mDAAmD;QACnD,cAAc;YACZ;YACA;YACA;YACA;YACA;SACD;QAED,2BAA2B;QAC3B,QAAQ;YACN;YACA;SACD;QAED,kDAAkD;QAClD,YAAY;YACV,gBAAgB;YAChB;YACA,YAAY;YACZ;YACA,iBAAiB;YACjB;YACA,eAAe;YACf;SAID;QAED,SAAS;YAAC;YAAS;SAAO;QAC1B,iBAAiB;YAAC;SAAY;QAE9B,gBAAgB,QAAQ,GAAG,CAAC,qBAAqB,IAAI;QAErD,UAAU;YACR,UAAU;YACV,YAAY;YACZ,iBAAiB;YACjB,SAAS;QACX;IACF,EAAE;IAEM,QAAgB;IAExB,YACE,OAAgB,CAChB;QACA,KAAK;QACL,6CAA6C;QAC7C,IAAI,CAAC,OAAO,GAAG,WAAW,QAAQ,GAAG,CAAC,qBAAqB,IAAI;IACjE;IAEA;;;;;;;GAOC,GACD,MAAc,2BACZ,SAAiB,EACjB,WAAgB,EAChB,OAAgB,EAWf;QACD,MAAM,aAAa;QACnB,MAAM,oBAAoB;YAAC;YAAK;YAAK;YAAK;YAAK;SAAI;QACnD,MAAM,YAAY,KAAK,GAAG;QAE1B,IAAK,IAAI,UAAU,GAAG,UAAU,YAAY,UAAW;YACrD,IAAI;gBACF,MAAM,WAAW,MAAM,MAAM,WAAW;oBACtC,QAAQ;oBACR,SAAS;wBACP,gBAAgB;oBAClB;oBACA,MAAM,KAAK,SAAS,CAAC;oBACrB,QAAQ,YAAY,OAAO,CAAC;gBAC9B;gBAEA,MAAM,OAAO,MAAM,SAAS,IAAI;gBAChC,MAAM,OAAO,OAAO,KAAK,KAAK,CAAC,QAAQ,CAAC;gBACxC,MAAM,YAAY,KAAK,GAAG,KAAK;gBAE/B,eAAe;gBACf,IAAI,SAAS,EAAE,IAAI,KAAK,KAAK,KAAK,MAAM;oBACtC,OAAO;wBACL,SAAS;wBACT,OAAO;wBACP,QAAQ,SAAS,MAAM;wBACvB,eAAe;wBACf,gBAAgB;wBAChB;wBACA;oBACF;gBACF;gBAEA,2BAA2B;gBAC3B,MAAM,cAAc,kBAAkB,QAAQ,CAAC,SAAS,MAAM;gBAC9D,MAAM,cAAc,SAAS,MAAM,KAAK;gBAExC,iDAAiD;gBACjD,IAAI,CAAC,eAAe,YAAY,aAAa,GAAG;oBAC9C,MAAM,eAAe,KAAK,OAAO,IAAI,KAAK,MAAM,IAAI,KAAK,KAAK,IAAI,CAAC,KAAK,EAAE,SAAS,MAAM,EAAE;oBAC3F,MAAM,YAAY,KAAK,SAAS,IAAI,KAAK,IAAI,IAAI,CAAC,cAAc,eAAe,qBAAqB;oBAEpG,OAAO;wBACL,SAAS;wBACT,OAAO;wBACP,QAAQ,SAAS,MAAM;wBACvB;wBACA;wBACA,eAAe;wBACf,gBAAgB;wBAChB;wBACA;oBACF;gBACF;gBAEA,iCAAiC;gBACjC,MAAM,QAAQ,MAAM,KAAK,GAAG,CAAC,GAAG,UAAU,sBAAsB;gBAChE,OAAO,IAAI,CAAC;oBACV,WAAW;oBACX,SAAS,UAAU;oBACnB;oBACA,QAAQ,SAAS,MAAM;oBACvB;oBACA;oBACA,KAAK;gBACP;gBACA,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;YAEnD,EAAE,OAAO,OAAY;gBACnB,MAAM,YAAY,KAAK,GAAG,KAAK;gBAC/B,MAAM,YAAY,OAAO,SAAS,gBAAgB,OAAO,SAAS,cAAc,SAAS;gBACzF,MAAM,iBAAiB,OAAO,SAAS,cAAc,SAAS,cACxC,OAAO,SAAS,cAAc,SAAS,YACvC,OAAO,SAAS,cAAc,SAAS;gBAE7D,+CAA+C;gBAC/C,IAAI,CAAC,aAAa,cAAc,KAAK,UAAU,aAAa,GAAG;oBAC7D,MAAM,QAAQ,MAAM,KAAK,GAAG,CAAC,GAAG;oBAChC,OAAO,IAAI,CAAC;wBACV,WAAW;wBACX,SAAS,UAAU;wBACnB;wBACA,OAAO,OAAO;wBACd;wBACA;wBACA,KAAK;oBACP;oBACA,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;oBACjD;gBACF;gBAEA,oCAAoC;gBACpC,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,QAAQ;oBACR,WAAW,YAAY,YAAY,iBAAiB,kBAAkB;oBACtE,cAAc,OAAO,WAAW;oBAChC,eAAe;oBACf,gBAAgB,aAAa;oBAC7B;gBACF;YACF;QACF;QAEA,yDAAyD;QACzD,OAAO;YACL,SAAS;YACT,OAAO;YACP,QAAQ;YACR,WAAW;YACX,cAAc;YACd,eAAe;YACf,gBAAgB;YAChB,WAAW,KAAK,GAAG,KAAK;QAC1B;IACF;IAEA;;;;;GAKC,GACD,MAAM,OACJ,OAAe,EACf,YAAiC,EACJ;QAC7B,MAAM,QAAQ,KAAK,GAAG;QAEtB,wBAAwB;QACxB,MAAM,aAAa,IAAI,CAAC,oBAAoB,CAAC;QAC7C,IAAI,CAAC,WAAW,KAAK,EAAE;YACrB,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,OAAO,WAAW,KAAK;gBACvB,eAAe,IAAI,CAAC,EAAE;gBACtB,YAAY,IAAI,OAAO,WAAW;YACpC;QACF;QAEA,IAAI;YACF,wDAAwD;YACxD,MAAM,EAAE,eAAe,EAAE,GAAG;YAC5B,MAAM,cAAc,gBAAgB;YAEpC,IAAI,CAAC,YAAY,KAAK,IAAI,CAAC,YAAY,MAAM,EAAE;gBAC7C,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,OAAO,YAAY,KAAK,IAAI;oBAC5B,eAAe,IAAI,CAAC,EAAE;oBACtB,YAAY,IAAI,OAAO,WAAW;gBACpC;YACF;YAEA,MAAM,SAAS,YAAY,MAAM;YAEjC,iEAAiE;YACjE,kGAAkG;YAClG,MAAM,UAAU,aAAa,QAAQ,EAAE,WAAW,wCAAwC;YAE1F,iEAAiE;YACjE,0DAA0D;YAC1D,IAAI;YACJ,IAAI,SAAS;gBACX,0DAA0D;gBAC1D,6EAA6E;gBAC7E,MAAM,gBAAgB,aAAa,QAAQ,CAAC,KAAK,CAAC;gBAClD,IAAI,eAAe;oBACjB,MAAM,GAAG,eAAe,SAAS,MAAM,GAAG;oBAC1C,MAAM,cAAsC;wBAC1C,IAAI,GAAG,cAAc,CAAC,EAAE,QAAQ,CAAC,EAAE,MAAM,WAAW,IAAI;wBACxD;wBACA;wBACA;wBACA,wBAAwB;wBACxB,SAAS;oBACX;oBACA,oBAAoB,mCAAmC;oBACvD,OAAO,IAAI,CAAC;wBACV,WAAW;wBACX,SAAS;wBACT,eAAe,YAAY,EAAE;wBAC7B,wBAAwB;wBACxB,KAAK;oBACP;gBACF,OAAO;oBACL,kEAAkE;oBAClE,oBAAoB;gBACtB;YACF,OAAO;gBACL,4CAA4C;gBAC5C,oBAAoB;YACtB;YAEA,kDAAkD;YAClD,MAAM,iBAAiB;gBACrB,aAAa;gBACb,QAAQ,kBAAkB,MAAM,IAAI;gBACpC,SAAS,OAAO,OAAO,IAAI,kBAAkB,OAAO;gBACpD,SAAS;oBACP,WAAW,OAAO,SAAS;oBAC3B,eAAe;wBACb,MAAM,OAAO,aAAa,CAAC,IAAI;wBAC/B,IAAI,OAAO,aAAa,CAAC,EAAE;wBAC3B,OAAO,OAAO,aAAa,CAAC,KAAK;wBACjC,YAAY,OAAO,aAAa,CAAC,UAAU;wBAC3C,aAAa,OAAO,aAAa,CAAC,WAAW;wBAC7C,OAAO,OAAO,aAAa,CAAC,KAAK;oBACnC;gBACF;YACF;YAEA,oFAAoF;YACpF,MAAM,sBAAsB;gBAC1B,QAAQ,kBAAkB,MAAM;gBAChC,SAAS,kBAAkB,OAAO;gBAClC,mBAAmB,kBAAkB,iBAAiB;gBACtD,UAAU,kBAAkB,QAAQ;gBACpC,aAAa,kBAAkB,WAAW,IAAI;gBAC9C,UAAU,kBAAkB,QAAQ,IAAI;gBACxC,OAAO,kBAAkB,KAAK;gBAC9B,mBAAmB,kBAAkB,iBAAiB,IAAI;gBAC1D,OAAO,kBAAkB,KAAK;YAChC;YAEA,uDAAuD;YACvD,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC;YAC1C,MAAM,cAAc;gBAClB;gBACA;YACF;YAEA,sDAAsD;YACtD,OAAO,IAAI,CAAC;gBACV,WAAW;gBACX;gBACA,SAAS,oBAAoB,OAAO;gBACpC,OAAO,oBAAoB,KAAK;gBAChC,KAAK;gBACL,KAAK;YACP;YAEA,sCAAsC;YACtC,MAAM,SAAS,MAAM,IAAI,CAAC,0BAA0B,CAClD,WACA,aACA;YAGF,MAAM,UAAU,OAAO,SAAS;YAEhC,iBAAiB;YACjB,IAAI,OAAO,OAAO,IAAI,OAAO,KAAK,EAAE;gBAClC,OAAO,IAAI,CAAC;oBAAE,WAAW,OAAO,SAAS;gBAAC,GAAG;gBAC7C,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,iBAAiB,OAAO,IAAI,EAAE,mBAAmB,OAAO,IAAI,EAAE;oBAC9D,eAAe,IAAI,CAAC,EAAE;oBACtB,YAAY,IAAI,OAAO,WAAW;gBACpC;YACF;YAEA,8EAA8E;YAC9E,MAAM,iBAAiB,OAAO,SAAS,IAAI;YAC3C,MAAM,oBAAoB,OAAO,YAAY,IAAI;YAEjD,sCAAsC;YACtC,IAAI,YAAY;YAChB,IAAI,OAAO,aAAa,IAAI,mBAAmB,cAAc;gBAC3D,YAAY;YACd,OAAO,IAAI,OAAO,cAAc,EAAE;gBAChC,YAAY;YACd,OAAO,IAAI,mBAAmB,qBAAqB,OAAO,MAAM,KAAK,KAAK;gBACxE,YAAY;YACd,OAAO,IAAI,OAAO,MAAM,KAAK,KAAK;gBAChC,YAAY;YACd;YAEA,OAAO,KAAK,CAAC;gBACX,QAAQ,OAAO,MAAM;gBACrB,WAAW;gBACX,cAAc;gBACd;gBACA,eAAe,OAAO,aAAa;gBACnC,gBAAgB,OAAO,cAAc;gBACrC,WAAW,OAAO,SAAS;YAC7B,GAAG;YAEH,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,OAAO;gBACP,cAAc;oBACZ,OAAO;oBACP,WAAW;oBACX,YAAY,OAAO,MAAM;oBACzB;oBACA,eAAe,OAAO,aAAa;oBACnC,gBAAgB,OAAO,cAAc;oBACrC,eAAe,OAAO,IAAI;gBAC5B;gBACA,eAAe,IAAI,CAAC,EAAE;gBACtB,YAAY,IAAI,OAAO,WAAW;YACpC;QACF,EAAE,OAAO,OAAO;YACd,MAAM,UAAU,KAAK,GAAG,KAAK;YAC7B,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;YAC9D,MAAM,YAAY,iBAAiB,SAAS,CAAC,MAAM,IAAI,KAAK,gBAAgB,aAAa,WAAW,GAAG,QAAQ,CAAC,UAAU;YAE1H,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;gBAAE;gBAAO;gBAAc;gBAAS;YAAU,GAAG;YAEpE,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,OAAO,YAAY,0BAA0B;gBAC7C,eAAe,IAAI,CAAC,EAAE;gBACtB,YAAY,IAAI,OAAO,WAAW;YACpC;QACF;IACF;IAEA;;;;GAIC,GACD,MAAM,YAAwC;QAC5C,MAAM,QAAQ,KAAK,GAAG;QAEtB,IAAI;YACF,gDAAgD;YAChD,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,oBAAoB,CAAC;YAEvD,MAAM,WAAW,MAAM,MAAM,WAAW;gBACtC,QAAQ;gBACR,SAAS;oBACP,gBAAgB;gBAClB;gBACA,QAAQ,YAAY,OAAO,CAAC;YAC9B;YAEA,MAAM,UAAU,KAAK,GAAG,KAAK;YAE7B,IAAI,SAAS,EAAE,EAAE;gBACf,MAAM,OAAO,MAAM,SAAS,IAAI;gBAEhC,oDAAoD;gBACpD,MAAM,cAAc,KAAK,QAAQ,IAAI,MAAM,OAAO,CAAC,KAAK,QAAQ,KAAK,KAAK,QAAQ,CAAC,MAAM,GAAG;gBAC5F,MAAM,YAAY,KAAK,MAAM,IAAI,MAAM,OAAO,CAAC,KAAK,MAAM,KAAK,KAAK,MAAM,CAAC,MAAM,GAAG;gBAEpF,IAAI,eAAe,WAAW;oBAC5B,OAAO;wBACL,SAAS;wBACT;wBACA,aAAa,IAAI,OAAO,WAAW;wBACnC,cAAc;4BACZ,UAAU,KAAK,QAAQ,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ;4BAC/C,QAAQ,KAAK,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM;4BACzC,SAAS,KAAK,OAAO,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO;wBAC9C;oBACF;gBACF;gBAEA,8CAA8C;gBAC9C,OAAO;oBACL,SAAS;oBACT;oBACA,aAAa,IAAI,OAAO,WAAW;oBACnC,OAAO;oBACP,cAAc;wBACZ,UAAU,IAAI,CAAC,MAAM,CAAC,QAAQ;wBAC9B,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM;wBAC1B,SAAS,IAAI,CAAC,MAAM,CAAC,OAAO;oBAC9B;gBACF;YACF;YAEA,mBAAmB;YACnB,MAAM,YAAY,MAAM,SAAS,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,KAAK,EAAE,SAAS,MAAM,EAAE;YAC7E,OAAO;gBACL,SAAS;gBACT;gBACA,aAAa,IAAI,OAAO,WAAW;gBACnC,OAAO;gBACP,cAAc;oBACZ,UAAU,IAAI,CAAC,MAAM,CAAC,QAAQ;oBAC9B,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM;oBAC1B,SAAS,IAAI,CAAC,MAAM,CAAC,OAAO;gBAC9B;YACF;QACF,EAAE,OAAO,OAAO;YACd,MAAM,UAAU,KAAK,GAAG,KAAK;YAC7B,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;YAC9D,MAAM,YAAY,iBAAiB,SAAS,CAAC,MAAM,IAAI,KAAK,gBAAgB,aAAa,WAAW,GAAG,QAAQ,CAAC,UAAU;YAE1H,OAAO;gBACL,SAAS;gBACT;gBACA,aAAa,IAAI,OAAO,WAAW;gBACnC,OAAO,YAAY,yBAAyB;gBAC5C,cAAc;oBACZ,UAAU,IAAI,CAAC,MAAM,CAAC,QAAQ;oBAC9B,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM;oBAC1B,SAAS,IAAI,CAAC,MAAM,CAAC,OAAO;gBAC9B;YACF;QACF;IACF;IAEA;;;;GAIC,GACD,MAAM,WAAW,OAAe,EAAE,KAAa,EAAE;QAC/C,+DAA+D;QAC/D,8CAA8C;QAC9C,OAAO;IACT;IAEA;;;GAGC,GACD,SAAS,OAAe,EAAE,KAAa,EAAE,MAAc,EAAE,cAAuB,EAAW;QACzF,OAAO,KAAK,CAAC,SAAS,SAAS,OAAO,QAAQ;IAChD;AACF;AAEA;;CAEC,GACD,IAAI,mBAA4C;AAKzC,SAAS;IACd,IAAI,CAAC,kBAAkB;QACrB,mBAAmB,IAAI;IACzB;IACA,OAAO;AACT"}},
    {"offset": {"line": 4063, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/x402rs-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// X402RS FACILITATOR\r\n// =============================================================================\r\n// Rust-based x402 facilitator operated by the x402 community\r\n// Public hosted endpoint: https://facilitator.x402.rs\r\n// Can also be self-hosted via Docker: https://github.com/x402-rs/x402-rs\r\n// Supported networks: Base, Base Sepolia, XDC, Solana (configurable)\r\n\r\nimport {\r\n  BaseFacilitator,\r\n  type IFacilitator,\r\n  type PaymentRequirements,\r\n  type VerificationResult,\r\n  type FacilitatorHealth,\r\n  type FacilitatorConfig,\r\n  type CAIPNetworkId,\r\n  type CAIPAssetId,\r\n  type SettlementMode,\r\n} from './base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\nconst logger = createLogger({ component: 'X402rsFacilitator' });\r\n\r\n/**\r\n * Build X402rs-specific payment requirements for probe mode\r\n * Uses known-good values that X402rs expects\r\n */\r\nfunction buildX402rsProbePaymentRequirements(config: FacilitatorProbeConfig): PaymentRequirements {\r\n  // USDC contract address on Base\r\n  const USDC_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';\r\n  // USDC on Base Sepolia (testnet)\r\n  const USDC_BASE_SEPOLIA = '0x036CbD53842c5426634e7929541eC2318f3dCF7e';\r\n  \r\n  // Determine asset based on network\r\n  let asset = USDC_BASE;\r\n  if (config.network === 'eip155:84532') {\r\n    asset = USDC_BASE_SEPOLIA;\r\n  }\r\n  \r\n  // Use a test receiver address for probes\r\n  const PROBE_RECEIVER = '0x0000000000000000000000000000000000000001';\r\n  \r\n  return {\r\n    scheme: 'x402',\r\n    network: config.network,\r\n    asset,\r\n    maxAmountRequired: '1', // Minimal amount (1 atomic unit)\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    payTo: PROBE_RECEIVER,\r\n    maxTimeoutSeconds: 10,\r\n    settlementMode: 'immediate',\r\n  };\r\n}\r\n\r\n/**\r\n * X402rs Facilitator\r\n * \r\n * Rust-based community facilitator with public hosted endpoint.\r\n * Public URL: https://facilitator.x402.rs\r\n * GitHub: https://github.com/x402-rs/x402-rs\r\n * \r\n * Supports Base, Base Sepolia, XDC, and Solana networks.\r\n */\r\nexport class X402rsFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'x402rs';\r\n  readonly name = 'X402rs Facilitator';\r\n\r\n  readonly config: FacilitatorConfig = {\r\n    id: 'x402rs',\r\n    name: 'X402rs Facilitator',\r\n    enabled: process.env.X402RS_ENABLED !== 'false', // Enabled by default\r\n    priority: 2, // Same priority tier as PayAI\r\n    \r\n    // Legacy network identifiers\r\n    networks: ['base', 'base-sepolia', 'xdc'],\r\n    \r\n    // CAIP-2 network identifiers\r\n    networksCAIP: [\r\n      'eip155:84532',  // Base Sepolia (testnet)\r\n      'eip155:8453',   // Base mainnet\r\n      'xdc:50',        // XDC mainnet\r\n    ],\r\n    \r\n    // Legacy asset identifiers (include both contract addresses and symbols for probe compatibility)\r\n    assets: [\r\n      'USDC', // Symbol alias for probes\r\n      '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base mainnet\r\n      '0x036CbD53842c5426634e7929541eC2318f3dCF7e', // USDC on Base Sepolia\r\n    ],\r\n    \r\n    // CAIP-19 asset identifiers\r\n    assetsCAIP: [\r\n      'eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',   // USDC on Base mainnet\r\n      'eip155:84532/erc20:0x036CbD53842c5426634e7929541eC2318f3dCF7e',  // USDC on Base Sepolia\r\n    ],\r\n    \r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'],\r\n    \r\n    healthCheckUrl: process.env.X402RS_FACILITATOR_URL || 'https://facilitator.x402.rs',\r\n    \r\n    metadata: {\r\n      provider: 'x402 Community',\r\n      label: 'X402rs Facilitator',\r\n      url: 'https://facilitator.x402.rs',\r\n      website: 'https://x402.org',\r\n      rustBased: true,\r\n      openSource: true,\r\n      complianceLevel: 'community',\r\n    },\r\n  };\r\n\r\n  private baseUrl: string;\r\n\r\n  constructor(baseUrl?: string) {\r\n    super();\r\n    this.baseUrl = baseUrl || process.env.X402RS_FACILITATOR_URL || 'https://facilitator.x402.rs';\r\n  }\r\n\r\n  /**\r\n   * Get the facilitator URL\r\n   */\r\n  getUrl(): string {\r\n    return this.baseUrl;\r\n  }\r\n\r\n  /**\r\n   * Call X402rs /verify endpoint with retry logic for transient errors\r\n   */\r\n  private async callX402rsVerifyWithRetries(\r\n    verifyUrl: string,\r\n    requestBody: any,\r\n    isProbe: boolean\r\n  ): Promise<{\r\n    success: boolean;\r\n    valid: boolean;\r\n    status: number;\r\n    errorType?: string;\r\n    errorMessage?: string;\r\n    isRateLimited: boolean;\r\n    isNetworkError: boolean;\r\n    latencyMs: number;\r\n    data?: any;\r\n  }> {\r\n    const maxRetries = 3;\r\n    const retryableStatuses = [429, 500, 502, 503, 504];\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const response = await fetch(verifyUrl, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify(requestBody),\r\n          signal: AbortSignal.timeout(10000), // 10 second timeout\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data = text ? JSON.parse(text) : {};\r\n        const latencyMs = Date.now() - startTime;\r\n\r\n        // Success case\r\n        if (response.ok && data.valid === true) {\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            status: response.status,\r\n            isRateLimited: false,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Check if retryable error\r\n        const isRetryable = retryableStatuses.includes(response.status);\r\n        const isRateLimit = response.status === 429;\r\n        \r\n        // If not retryable or last attempt, return error\r\n        if (!isRetryable || attempt === maxRetries - 1) {\r\n          const errorMessage = data.message || data.reason || data.error || `HTTP ${response.status}`;\r\n          const errorType = data.errorType || data.code || (isRateLimit ? 'rate_limit' : 'X402RS_VERIFY_FAILED');\r\n          \r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            status: response.status,\r\n            errorType,\r\n            errorMessage,\r\n            isRateLimited: isRateLimit,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Retry with exponential backoff\r\n        const delay = 100 * Math.pow(2, attempt);\r\n        logger.info({\r\n          component: 'X402rsFacilitator',\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          status: response.status,\r\n          delay,\r\n          isProbe,\r\n          msg: 'Retrying X402rs verification after transient error',\r\n        });\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        \r\n      } catch (error: any) {\r\n        const latencyMs = Date.now() - startTime;\r\n        const isTimeout = error?.name === 'AbortError' || error?.message?.toLowerCase().includes('timeout');\r\n        const isNetworkError = error?.message?.toLowerCase().includes('network') || \r\n                              error?.message?.toLowerCase().includes('fetch') ||\r\n                              error?.message?.toLowerCase().includes('econnrefused');\r\n        \r\n        if ((isTimeout || isNetworkError) && attempt < maxRetries - 1) {\r\n          const delay = 100 * Math.pow(2, attempt);\r\n          logger.info({\r\n            component: 'X402rsFacilitator',\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error?.message,\r\n            delay,\r\n            isProbe,\r\n            msg: 'Retrying X402rs verification after network error',\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n        \r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          status: 0,\r\n          errorType: isTimeout ? 'timeout' : isNetworkError ? 'network_error' : 'X402RS_VERIFY_FAILED',\r\n          errorMessage: error?.message || 'X402rs verification failed',\r\n          isRateLimited: false,\r\n          isNetworkError: isTimeout || isNetworkError,\r\n          latencyMs,\r\n        };\r\n      }\r\n    }\r\n    \r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      status: 0,\r\n      errorType: 'X402RS_VERIFY_FAILED',\r\n      errorMessage: 'Max retries exceeded',\r\n      isRateLimited: false,\r\n      isNetworkError: false,\r\n      latencyMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify payment using X402rs facilitator\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    const start = Date.now();\r\n\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Parse payment header\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Detect probe mode\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n      \r\n      // Build payment payload\r\n      const paymentPayload = {\r\n        x402Version: 2,\r\n        scheme: requirements.scheme || 'x402',\r\n        network: parsed.network || requirements.network,\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: {\r\n            from: parsed.authorization.from,\r\n            to: parsed.authorization.to,\r\n            value: parsed.authorization.value,\r\n            validAfter: parsed.authorization.validAfter,\r\n            validBefore: parsed.authorization.validBefore,\r\n            nonce: parsed.authorization.nonce,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Build payment requirements\r\n      const paymentRequirements = {\r\n        scheme: requirements.scheme,\r\n        network: requirements.network,\r\n        maxAmountRequired: requirements.maxAmountRequired,\r\n        resource: requirements.resource,\r\n        description: requirements.description || '',\r\n        mimeType: requirements.mimeType || 'application/json',\r\n        payTo: requirements.payTo,\r\n        maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n        asset: requirements.asset,\r\n      };\r\n\r\n      // POST to X402rs verification endpoint\r\n      const verifyUrl = `${this.baseUrl}/verify`;\r\n      const requestBody = {\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      };\r\n\r\n      logger.info({\r\n        component: 'X402rsFacilitator',\r\n        isProbe,\r\n        network: paymentRequirements.network,\r\n        asset: paymentRequirements.asset,\r\n        url: verifyUrl,\r\n        facilitatorId: this.id,\r\n        facilitatorUrl: this.baseUrl,\r\n        msg: 'Sending X402rs /verify request',\r\n      });\r\n\r\n      // Call with retry logic\r\n      const result = await this.callX402rsVerifyWithRetries(verifyUrl, requestBody, isProbe);\r\n\r\n      // Handle success\r\n      if (result.success && result.valid) {\r\n        logger.info({\r\n          component: 'X402rsFacilitator',\r\n          facilitatorId: this.id,\r\n          facilitatorUrl: this.baseUrl,\r\n          latencyMs: result.latencyMs,\r\n          network: requirements.network,\r\n          msg: 'Payment verified successfully by X402rs',\r\n        });\r\n        return {\r\n          success: true,\r\n          valid: true,\r\n          transactionHash: result.data?.transactionHash || result.data?.txHash,\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Handle error\r\n      const errorType = result.errorType || 'X402RS_VERIFY_FAILED';\r\n      const errorMessage = result.errorMessage || 'X402rs verification failed';\r\n      \r\n      let errorCode = 'facilitator_error';\r\n      if (result.isRateLimited || errorType === 'rate_limit') {\r\n        errorCode = 'rate_limited';\r\n      } else if (result.isNetworkError) {\r\n        errorCode = 'network_error';\r\n      } else if (errorType === 'invalid_request' || result.status === 400) {\r\n        errorCode = 'invalid_request';\r\n      }\r\n\r\n      logger.debug({\r\n        component: 'X402rsFacilitator',\r\n        facilitatorId: this.id,\r\n        status: result.status,\r\n        errorType,\r\n        errorMessage,\r\n        errorCode,\r\n        isRateLimited: result.isRateLimited,\r\n        isNetworkError: result.isNetworkError,\r\n        latencyMs: result.latencyMs,\r\n        msg: 'X402rs verification failed',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: errorMessage,\r\n        errorDetails: {\r\n          error: errorMessage,\r\n          errorType,\r\n          httpStatus: result.status,\r\n          errorCode,\r\n          isRateLimited: result.isRateLimited,\r\n          isNetworkError: result.isNetworkError,\r\n          x402rsResponse: result.data,\r\n        },\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'X402rs verification error');\r\n      \r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: isTimeout ? 'X402RS_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get X402rs facilitator health\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // X402rs health check endpoint\r\n      const healthUrl = `${this.baseUrl}/health`;\r\n      \r\n      const response = await fetch(healthUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n\r\n      const latency = Date.now() - start;\r\n\r\n      if (response.ok) {\r\n        let data: any = {};\r\n        try {\r\n          data = await response.json();\r\n        } catch {\r\n          // Health endpoint might return simple OK\r\n        }\r\n\r\n        return {\r\n          healthy: true,\r\n          latency,\r\n          lastChecked: new Date().toISOString(),\r\n          capabilities: {\r\n            networks: data.networks || this.config.networks,\r\n            assets: data.assets || this.config.assets,\r\n            schemes: data.schemes || this.config.schemes,\r\n          },\r\n        };\r\n      }\r\n\r\n      const errorText = await response.text().catch(() => `HTTP ${response.status}`);\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: errorText,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Health check failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: isTimeout ? 'Health check timeout' : errorMessage,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing information (not available for X402rs yet)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    // TODO: Implement if X402rs provides pricing API\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\r\n    return super.supports(network, asset, scheme, settlementMode);\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet x402rsFacilitator: X402rsFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton X402rs facilitator instance\r\n */\r\nexport function getX402rsFacilitator(): X402rsFacilitator {\r\n  if (!x402rsFacilitator) {\r\n    x402rsFacilitator = new X402rsFacilitator();\r\n  }\r\n  return x402rsFacilitator;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4519, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/dexter-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// DEXTER FACILITATOR\r\n// =============================================================================\r\n// Solana-native x402 facilitator operated by Dexter\r\n// Public hosted endpoint: https://facilitator.dexter.cash\r\n// Standard x402 endpoints: /verify and /settle\r\n// Supports Solana mainnet and devnet networks\r\n\r\nimport {\r\n  BaseFacilitator,\r\n  type IFacilitator,\r\n  type PaymentRequirements,\r\n  type VerificationResult,\r\n  type FacilitatorHealth,\r\n  type FacilitatorConfig,\r\n  type CAIPNetworkId,\r\n  type CAIPAssetId,\r\n  type SettlementMode,\r\n} from './base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\nconst logger = createLogger({ component: 'DexterFacilitator' });\r\n\r\n/**\r\n * Dexter verify request body shape\r\n * Standard x402 payment verification format\r\n */\r\nexport interface DexterVerifyRequest {\r\n  paymentPayload: {\r\n    x402Version: number;\r\n    scheme: string;\r\n    network: string;\r\n    payload: {\r\n      signature: string;\r\n      authorization: {\r\n        from: string;\r\n        to: string;\r\n        value: string;\r\n        validAfter: string;\r\n        validBefore: string;\r\n        nonce: string;\r\n      };\r\n    };\r\n  };\r\n  paymentRequirements: {\r\n    scheme: string;\r\n    network: string;\r\n    maxAmountRequired: string;\r\n    resource: string;\r\n    description: string;\r\n    mimeType: string;\r\n    payTo: string;\r\n    maxTimeoutSeconds: number;\r\n    asset: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Dexter settle request body shape\r\n * Standard x402 settlement format\r\n */\r\nexport interface DexterSettleRequest {\r\n  paymentPayload: {\r\n    x402Version: number;\r\n    scheme: string;\r\n    network: string;\r\n    payload: {\r\n      signature: string;\r\n      authorization: {\r\n        from: string;\r\n        to: string;\r\n        value: string;\r\n        validAfter: string;\r\n        validBefore: string;\r\n        nonce: string;\r\n      };\r\n    };\r\n  };\r\n  paymentRequirements: {\r\n    scheme: string;\r\n    network: string;\r\n    maxAmountRequired: string;\r\n    resource: string;\r\n    description: string;\r\n    mimeType: string;\r\n    payTo: string;\r\n    maxTimeoutSeconds: number;\r\n    asset: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Facilitator verify result shape\r\n */\r\nexport interface FacilitatorVerifyResult {\r\n  success: boolean;\r\n  valid: boolean;\r\n  transactionHash?: string;\r\n  error?: string;\r\n  errorDetails?: Record<string, any>;\r\n  facilitatorId: string;\r\n  verifiedAt: string;\r\n}\r\n\r\n/**\r\n * Facilitator settle result shape\r\n */\r\nexport interface FacilitatorSettleResult {\r\n  success: boolean;\r\n  settled: boolean;\r\n  transactionHash?: string;\r\n  error?: string;\r\n  errorDetails?: Record<string, any>;\r\n  facilitatorId: string;\r\n  settledAt: string;\r\n}\r\n\r\n/**\r\n * Build Dexter-specific payment requirements for probe mode\r\n * Uses known-good values that Dexter expects\r\n */\r\nfunction buildDexterProbePaymentRequirements(config: FacilitatorProbeConfig): PaymentRequirements {\r\n  // USDC on Solana mainnet (SPL token mint address)\r\n  const USDC_SOLANA_MAINNET = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';\r\n  // USDC on Solana devnet (SPL token mint address)\r\n  const USDC_SOLANA_DEVNET = '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU';\r\n  \r\n  // Determine asset based on network\r\n  let asset = USDC_SOLANA_MAINNET;\r\n  if (config.network === 'solana:102' || config.network === 'solana:devnet') {\r\n    asset = USDC_SOLANA_DEVNET;\r\n  }\r\n  \r\n  // Use a test receiver address for probes\r\n  const PROBE_RECEIVER = '11111111111111111111111111111111'; // System program (placeholder)\r\n  \r\n  return {\r\n    scheme: 'x402',\r\n    network: config.network,\r\n    asset,\r\n    maxAmountRequired: '1', // Minimal amount (1 atomic unit)\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    payTo: PROBE_RECEIVER,\r\n    maxTimeoutSeconds: 10,\r\n    settlementMode: 'immediate',\r\n  };\r\n}\r\n\r\n/**\r\n * Dexter Facilitator\r\n * \r\n * Solana-native community facilitator with public hosted endpoint.\r\n * Public URL: https://facilitator.dexter.cash\r\n * \r\n * Supports Solana mainnet and devnet networks.\r\n */\r\nexport class DexterFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'dexter';\r\n  readonly name = 'Dexter Facilitator';\r\n\r\n  readonly config: FacilitatorConfig = {\r\n    id: 'dexter',\r\n    name: 'Dexter Facilitator',\r\n    enabled: process.env.DEXTER_ENABLED !== 'false', // Enabled by default\r\n    priority: 2, // Same priority tier as X402rs/PayAI for auto-routing\r\n    \r\n    // Legacy network identifiers\r\n    networks: ['solana', 'solana-mainnet', 'solana-devnet'],\r\n    \r\n    // CAIP-2 network identifiers\r\n    networksCAIP: [\r\n      'solana:101',    // Solana mainnet\r\n      'solana:102',    // Solana devnet\r\n      'solana:mainnet', // Legacy alias\r\n      'solana:devnet',  // Legacy alias\r\n    ],\r\n    \r\n    // Legacy asset identifiers (include both contract addresses and symbols for probe compatibility)\r\n    assets: [\r\n      'USDC', // Symbol alias for probes\r\n      'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC on Solana mainnet\r\n      '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU', // USDC on Solana devnet\r\n    ],\r\n    \r\n    // CAIP-19 asset identifiers\r\n    assetsCAIP: [\r\n      'solana:101/spl:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC on Solana mainnet\r\n      'solana:102/spl:4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU', // USDC on Solana devnet\r\n    ],\r\n    \r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'],\r\n    \r\n    healthCheckUrl: process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash',\r\n    \r\n    metadata: {\r\n      provider: 'Dexter',\r\n      label: 'Dexter Facilitator',\r\n      url: 'https://facilitator.dexter.cash',\r\n      website: 'https://dexter.cash',\r\n      solanaNative: true,\r\n      complianceLevel: 'community',\r\n      notes: 'Solana-native x402 facilitator',\r\n    },\r\n  };\r\n\r\n  private baseUrl: string;\r\n\r\n  constructor(baseUrl?: string) {\r\n    super();\r\n    this.baseUrl = baseUrl || process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash';\r\n  }\r\n\r\n  /**\r\n   * Get the facilitator URL\r\n   */\r\n  getUrl(): string {\r\n    return this.baseUrl;\r\n  }\r\n\r\n  /**\r\n   * Call Dexter /verify endpoint with retry logic for transient errors\r\n   */\r\n  private async callDexterVerifyWithRetries(\r\n    verifyUrl: string,\r\n    requestBody: DexterVerifyRequest,\r\n    isProbe: boolean\r\n  ): Promise<{\r\n    success: boolean;\r\n    valid: boolean;\r\n    status: number;\r\n    errorType?: string;\r\n    errorMessage?: string;\r\n    isRateLimited: boolean;\r\n    isNetworkError: boolean;\r\n    latencyMs: number;\r\n    data?: any;\r\n  }> {\r\n    const maxRetries = 3;\r\n    const retryableStatuses = [429, 500, 502, 503, 504];\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const response = await fetch(verifyUrl, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify(requestBody),\r\n          signal: AbortSignal.timeout(10000), // 10 second timeout\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data = text ? JSON.parse(text) : {};\r\n        const latencyMs = Date.now() - startTime;\r\n\r\n        // Success case\r\n        if (response.ok && data.valid === true) {\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            status: response.status,\r\n            isRateLimited: false,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Check if retryable error\r\n        const isRetryable = retryableStatuses.includes(response.status);\r\n        const isRateLimit = response.status === 429;\r\n        \r\n        // If not retryable or last attempt, return error\r\n        if (!isRetryable || attempt === maxRetries - 1) {\r\n          const errorMessage = data.message || data.reason || data.error || `HTTP ${response.status}`;\r\n          const errorType = data.errorType || data.code || (isRateLimit ? 'rate_limit' : 'DEXTER_VERIFY_FAILED');\r\n          \r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            status: response.status,\r\n            errorType,\r\n            errorMessage,\r\n            isRateLimited: isRateLimit,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Retry with exponential backoff\r\n        const delay = 100 * Math.pow(2, attempt);\r\n        logger.info({\r\n          component: 'DexterFacilitator',\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          status: response.status,\r\n          delay,\r\n          isProbe,\r\n          msg: 'Retrying Dexter verification after transient error',\r\n        });\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        \r\n      } catch (error: any) {\r\n        const latencyMs = Date.now() - startTime;\r\n        const isTimeout = error?.name === 'AbortError' || error?.message?.toLowerCase().includes('timeout');\r\n        const isNetworkError = error?.message?.toLowerCase().includes('network') || \r\n                              error?.message?.toLowerCase().includes('fetch') ||\r\n                              error?.message?.toLowerCase().includes('econnrefused');\r\n        \r\n        if ((isTimeout || isNetworkError) && attempt < maxRetries - 1) {\r\n          const delay = 100 * Math.pow(2, attempt);\r\n          logger.info({\r\n            component: 'DexterFacilitator',\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error?.message,\r\n            delay,\r\n            isProbe,\r\n            msg: 'Retrying Dexter verification after network error',\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n        \r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          status: 0,\r\n          errorType: isTimeout ? 'timeout' : isNetworkError ? 'network_error' : 'DEXTER_VERIFY_FAILED',\r\n          errorMessage: error?.message || 'Dexter verification failed',\r\n          isRateLimited: false,\r\n          isNetworkError: isTimeout || isNetworkError,\r\n          latencyMs,\r\n        };\r\n      }\r\n    }\r\n    \r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      status: 0,\r\n      errorType: 'DEXTER_VERIFY_FAILED',\r\n      errorMessage: 'Max retries exceeded',\r\n      isRateLimited: false,\r\n      isNetworkError: false,\r\n      latencyMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify payment using Dexter facilitator\r\n   * POST https://facilitator.dexter.cash/verify\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    const start = Date.now();\r\n\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Parse payment header\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Detect probe mode\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n      \r\n      // Build payment payload\r\n      const paymentPayload = {\r\n        x402Version: 2,\r\n        scheme: requirements.scheme || 'x402',\r\n        network: parsed.network || requirements.network,\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: {\r\n            from: parsed.authorization.from,\r\n            to: parsed.authorization.to,\r\n            value: parsed.authorization.value,\r\n            validAfter: parsed.authorization.validAfter,\r\n            validBefore: parsed.authorization.validBefore,\r\n            nonce: parsed.authorization.nonce,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Build payment requirements\r\n      const paymentRequirements = {\r\n        scheme: requirements.scheme,\r\n        network: requirements.network,\r\n        maxAmountRequired: requirements.maxAmountRequired,\r\n        resource: requirements.resource,\r\n        description: requirements.description || '',\r\n        mimeType: requirements.mimeType || 'application/json',\r\n        payTo: requirements.payTo,\r\n        maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n        asset: requirements.asset,\r\n      };\r\n\r\n      // POST to Dexter verification endpoint\r\n      const verifyUrl = `${this.baseUrl}/verify`;\r\n      const requestBody: DexterVerifyRequest = {\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      };\r\n\r\n      logger.info({\r\n        component: 'DexterFacilitator',\r\n        isProbe,\r\n        network: paymentRequirements.network,\r\n        asset: paymentRequirements.asset,\r\n        url: verifyUrl,\r\n        facilitatorId: this.id,\r\n        facilitatorUrl: this.baseUrl,\r\n        msg: 'Sending Dexter /verify request',\r\n      });\r\n\r\n      // Call with retry logic\r\n      const result = await this.callDexterVerifyWithRetries(verifyUrl, requestBody, isProbe);\r\n\r\n      // Handle success\r\n      if (result.success && result.valid) {\r\n        logger.info({\r\n          component: 'DexterFacilitator',\r\n          facilitatorId: this.id,\r\n          facilitatorUrl: this.baseUrl,\r\n          latencyMs: result.latencyMs,\r\n          network: requirements.network,\r\n          msg: 'Payment verified successfully by Dexter',\r\n        });\r\n        return {\r\n          success: true,\r\n          valid: true,\r\n          transactionHash: result.data?.transactionHash || result.data?.txHash,\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Handle error\r\n      const errorType = result.errorType || 'DEXTER_VERIFY_FAILED';\r\n      const errorMessage = result.errorMessage || 'Dexter verification failed';\r\n      \r\n      let errorCode = 'facilitator_error';\r\n      if (result.isRateLimited || errorType === 'rate_limit') {\r\n        errorCode = 'rate_limited';\r\n      } else if (result.isNetworkError) {\r\n        errorCode = 'network_error';\r\n      } else if (errorType === 'invalid_request' || result.status === 400) {\r\n        errorCode = 'invalid_request';\r\n      }\r\n\r\n      logger.debug({\r\n        component: 'DexterFacilitator',\r\n        facilitatorId: this.id,\r\n        status: result.status,\r\n        errorType,\r\n        errorMessage,\r\n        errorCode,\r\n        isRateLimited: result.isRateLimited,\r\n        isNetworkError: result.isNetworkError,\r\n        latencyMs: result.latencyMs,\r\n        msg: 'Dexter verification failed',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: errorMessage,\r\n        errorDetails: {\r\n          error: errorMessage,\r\n          errorType,\r\n          httpStatus: result.status,\r\n          errorCode,\r\n          isRateLimited: result.isRateLimited,\r\n          isNetworkError: result.isNetworkError,\r\n          dexterResponse: result.data,\r\n        },\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'Dexter verification error');\r\n      \r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: isTimeout ? 'DEXTER_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Settle payment using Dexter facilitator\r\n   * POST https://facilitator.dexter.cash/settle\r\n   */\r\n  async settle(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<FacilitatorSettleResult> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // Parse payment header\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          settled: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          settledAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Build payment payload\r\n      const paymentPayload = {\r\n        x402Version: 2,\r\n        scheme: requirements.scheme || 'x402',\r\n        network: parsed.network || requirements.network,\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: {\r\n            from: parsed.authorization.from,\r\n            to: parsed.authorization.to,\r\n            value: parsed.authorization.value,\r\n            validAfter: parsed.authorization.validAfter,\r\n            validBefore: parsed.authorization.validBefore,\r\n            nonce: parsed.authorization.nonce,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Build payment requirements\r\n      const paymentRequirements = {\r\n        scheme: requirements.scheme,\r\n        network: requirements.network,\r\n        maxAmountRequired: requirements.maxAmountRequired,\r\n        resource: requirements.resource,\r\n        description: requirements.description || '',\r\n        mimeType: requirements.mimeType || 'application/json',\r\n        payTo: requirements.payTo,\r\n        maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n        asset: requirements.asset,\r\n      };\r\n\r\n      // POST to Dexter settlement endpoint\r\n      const settleUrl = `${this.baseUrl}/settle`;\r\n      const requestBody: DexterSettleRequest = {\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      };\r\n\r\n      logger.info({\r\n        component: 'DexterFacilitator',\r\n        network: paymentRequirements.network,\r\n        asset: paymentRequirements.asset,\r\n        url: settleUrl,\r\n        facilitatorId: this.id,\r\n        facilitatorUrl: this.baseUrl,\r\n        msg: 'Sending Dexter /settle request',\r\n      });\r\n\r\n      const response = await fetch(settleUrl, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(requestBody),\r\n        signal: AbortSignal.timeout(30000), // 30 second timeout for settlement\r\n      });\r\n\r\n      const latencyMs = Date.now() - start;\r\n      const text = await response.text();\r\n      const data = text ? JSON.parse(text) : {};\r\n\r\n      if (response.ok && (data.settled === true || data.success === true)) {\r\n        logger.info({\r\n          component: 'DexterFacilitator',\r\n          facilitatorId: this.id,\r\n          facilitatorUrl: this.baseUrl,\r\n          latencyMs,\r\n          network: requirements.network,\r\n          transactionHash: data.transactionHash || data.txHash,\r\n          msg: 'Payment settled successfully by Dexter',\r\n        });\r\n        return {\r\n          success: true,\r\n          settled: true,\r\n          transactionHash: data.transactionHash || data.txHash,\r\n          facilitatorId: this.id,\r\n          settledAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const errorMessage = data.message || data.reason || data.error || `HTTP ${response.status}`;\r\n      logger.error({\r\n        component: 'DexterFacilitator',\r\n        facilitatorId: this.id,\r\n        status: response.status,\r\n        errorMessage,\r\n        latencyMs,\r\n        msg: 'Dexter settlement failed',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        settled: false,\r\n        error: errorMessage,\r\n        errorDetails: {\r\n          httpStatus: response.status,\r\n          dexterResponse: data,\r\n        },\r\n        facilitatorId: this.id,\r\n        settledAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Settlement failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'Dexter settlement error');\r\n      \r\n      return {\r\n        success: false,\r\n        settled: false,\r\n        error: isTimeout ? 'DEXTER_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        settledAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get Dexter facilitator health\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // Dexter health check endpoint\r\n      const healthUrl = `${this.baseUrl}/health`;\r\n      \r\n      const response = await fetch(healthUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n\r\n      const latency = Date.now() - start;\r\n\r\n      if (response.ok) {\r\n        let data: any = {};\r\n        try {\r\n          data = await response.json();\r\n        } catch {\r\n          // Health endpoint might return simple OK\r\n        }\r\n\r\n        return {\r\n          healthy: true,\r\n          latency,\r\n          lastChecked: new Date().toISOString(),\r\n          capabilities: {\r\n            networks: data.networks || this.config.networks,\r\n            assets: data.assets || this.config.assets,\r\n            schemes: data.schemes || this.config.schemes,\r\n          },\r\n        };\r\n      }\r\n\r\n      const errorText = await response.text().catch(() => `HTTP ${response.status}`);\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: errorText,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Health check failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: isTimeout ? 'Health check timeout' : errorMessage,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing information (not available for Dexter yet)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    // TODO: Implement if Dexter provides pricing API\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\r\n    return super.supports(network, asset, scheme, settlementMode);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// STANDALONE VERIFY/SETTLE FUNCTIONS\r\n// =============================================================================\r\n// These functions can be used directly without the facilitator class\r\n\r\n/**\r\n * Verify payment using Dexter facilitator\r\n * Direct function for standalone use\r\n */\r\nexport async function dexterVerify(payload: DexterVerifyRequest): Promise<FacilitatorVerifyResult> {\r\n  const baseUrl = process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash';\r\n  const verifyUrl = `${baseUrl}/verify`;\r\n  const start = Date.now();\r\n\r\n  try {\r\n    const response = await fetch(verifyUrl, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify(payload),\r\n      signal: AbortSignal.timeout(10000),\r\n    });\r\n\r\n    const latencyMs = Date.now() - start;\r\n    const text = await response.text();\r\n    const data = text ? JSON.parse(text) : {};\r\n\r\n    if (response.ok && data.valid === true) {\r\n      return {\r\n        success: true,\r\n        valid: true,\r\n        transactionHash: data.transactionHash || data.txHash,\r\n        facilitatorId: 'dexter',\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      error: data.message || data.error || `HTTP ${response.status}`,\r\n      errorDetails: {\r\n        httpStatus: response.status,\r\n        dexterResponse: data,\r\n        latencyMs,\r\n      },\r\n      facilitatorId: 'dexter',\r\n      verifiedAt: new Date().toISOString(),\r\n    };\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      error: errorMessage,\r\n      facilitatorId: 'dexter',\r\n      verifiedAt: new Date().toISOString(),\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Settle payment using Dexter facilitator\r\n * Direct function for standalone use\r\n */\r\nexport async function dexterSettle(payload: DexterSettleRequest): Promise<FacilitatorSettleResult> {\r\n  const baseUrl = process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash';\r\n  const settleUrl = `${baseUrl}/settle`;\r\n  const start = Date.now();\r\n\r\n  try {\r\n    const response = await fetch(settleUrl, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify(payload),\r\n      signal: AbortSignal.timeout(30000),\r\n    });\r\n\r\n    const latencyMs = Date.now() - start;\r\n    const text = await response.text();\r\n    const data = text ? JSON.parse(text) : {};\r\n\r\n    if (response.ok && (data.settled === true || data.success === true)) {\r\n      return {\r\n        success: true,\r\n        settled: true,\r\n        transactionHash: data.transactionHash || data.txHash,\r\n        facilitatorId: 'dexter',\r\n        settledAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      settled: false,\r\n      error: data.message || data.error || `HTTP ${response.status}`,\r\n      errorDetails: {\r\n        httpStatus: response.status,\r\n        dexterResponse: data,\r\n        latencyMs,\r\n      },\r\n      facilitatorId: 'dexter',\r\n      settledAt: new Date().toISOString(),\r\n    };\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Settlement failed';\r\n    return {\r\n      success: false,\r\n      settled: false,\r\n      error: errorMessage,\r\n      facilitatorId: 'dexter',\r\n      settledAt: new Date().toISOString(),\r\n    };\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet dexterFacilitator: DexterFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton Dexter facilitator instance\r\n */\r\nexport function getDexterFacilitator(): DexterFacilitator {\r\n  if (!dexterFacilitator) {\r\n    dexterFacilitator = new DexterFacilitator();\r\n  }\r\n  return dexterFacilitator;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5214, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/adapters/sqlite-adapter.ts"],"sourcesContent":["// =============================================================================\r\n// SQLITE ADAPTER\r\n// =============================================================================\r\n// SQLite implementation of DatabaseAdapter\r\n// Wraps existing better-sqlite3 code for adapter pattern\r\n\r\nimport Database from 'better-sqlite3';\r\nimport path from 'path';\r\nimport fs from 'fs';\r\nimport type { DatabaseAdapter } from './base-adapter';\r\nimport type { MeteredEndpoint, Payment, UsageLog } from '../metered-endpoints';\r\n\r\n// Re-export the schema initialization from metered-endpoints\r\nfunction initializeSchema(db: Database.Database) {\r\n  // Endpoints table\r\n  db.exec(`\r\n    CREATE TABLE IF NOT EXISTS endpoints (\r\n      id TEXT PRIMARY KEY,\r\n      name TEXT NOT NULL,\r\n      description TEXT,\r\n      upstream_url TEXT NOT NULL,\r\n      price TEXT NOT NULL,\r\n      network TEXT NOT NULL DEFAULT 'base',\r\n      token_address TEXT NOT NULL,\r\n      token_symbol TEXT NOT NULL DEFAULT 'USDC',\r\n      chain_id INTEGER NOT NULL DEFAULT 8453,\r\n      recipient_address TEXT,\r\n      status TEXT NOT NULL DEFAULT 'active',\r\n      created_at TEXT NOT NULL,\r\n      updated_at TEXT NOT NULL,\r\n      created_by TEXT\r\n    )\r\n  `);\r\n\r\n  // Migration: Add recipient_address column if it doesn't exist\r\n  try {\r\n    const tableInfo = db.prepare(\"PRAGMA table_info(endpoints)\").all() as Array<{ name: string }>;\r\n    const hasRecipientAddress = tableInfo.some(col => col.name === 'recipient_address');\r\n    \r\n    if (!hasRecipientAddress) {\r\n      db.exec(`ALTER TABLE endpoints ADD COLUMN recipient_address TEXT`);\r\n      console.log('[db] Added recipient_address column');\r\n    }\r\n  } catch (error: any) {\r\n    if (!error.message?.includes('duplicate column name') && !error.message?.includes('no such column')) {\r\n      console.warn('[db] Migration warning:', error.message);\r\n    }\r\n  }\r\n\r\n  // Payments table\r\n  db.exec(`\r\n    CREATE TABLE IF NOT EXISTS payments (\r\n      id TEXT PRIMARY KEY,\r\n      endpoint_id TEXT NOT NULL,\r\n      tx_hash TEXT NOT NULL UNIQUE,\r\n      from_address TEXT NOT NULL,\r\n      to_address TEXT NOT NULL,\r\n      amount TEXT NOT NULL,\r\n      token_address TEXT NOT NULL,\r\n      network TEXT NOT NULL,\r\n      verified_at TEXT NOT NULL,\r\n      kyt_status TEXT,\r\n      ofac_status TEXT,\r\n      facilitator TEXT NOT NULL DEFAULT 'cdp',\r\n      FOREIGN KEY (endpoint_id) REFERENCES endpoints(id)\r\n    )\r\n  `);\r\n\r\n  // Usage logs table\r\n  db.exec(`\r\n    CREATE TABLE IF NOT EXISTS usage_logs (\r\n      id TEXT PRIMARY KEY,\r\n      endpoint_id TEXT NOT NULL,\r\n      payment_id TEXT,\r\n      timestamp TEXT NOT NULL,\r\n      method TEXT NOT NULL,\r\n      path TEXT NOT NULL,\r\n      status_code INTEGER NOT NULL,\r\n      response_time INTEGER NOT NULL,\r\n      units INTEGER NOT NULL DEFAULT 1,\r\n      ip_address TEXT,\r\n      user_agent TEXT,\r\n      FOREIGN KEY (endpoint_id) REFERENCES endpoints(id),\r\n      FOREIGN KEY (payment_id) REFERENCES payments(id)\r\n    )\r\n  `);\r\n\r\n  // API keys table\r\n  db.exec(`\r\n    CREATE TABLE IF NOT EXISTS api_keys (\r\n      id TEXT PRIMARY KEY,\r\n      key_hash TEXT UNIQUE NOT NULL,\r\n      name TEXT NOT NULL,\r\n      role TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('admin', 'user', 'read-only')),\r\n      user_id TEXT,\r\n      rate_limit INTEGER DEFAULT 1000,\r\n      last_used_at TEXT,\r\n      last_used_ip TEXT,\r\n      expires_at TEXT,\r\n      x402_demo_calls_used INTEGER DEFAULT 0,\r\n      x402_demo_calls_limit INTEGER DEFAULT 200,\r\n      x402_demo_amount_used TEXT DEFAULT '0',\r\n      x402_demo_amount_limit TEXT DEFAULT '1000000',\r\n      created_at TEXT NOT NULL,\r\n      updated_at TEXT NOT NULL,\r\n      revoked_at TEXT\r\n    )\r\n  `);\r\n\r\n  // Indexes\r\n  db.exec(`\r\n    CREATE INDEX IF NOT EXISTS idx_payments_endpoint_id ON payments(endpoint_id);\r\n    CREATE INDEX IF NOT EXISTS idx_payments_tx_hash ON payments(tx_hash);\r\n    CREATE INDEX IF NOT EXISTS idx_payments_verified_at ON payments(verified_at);\r\n    CREATE INDEX IF NOT EXISTS idx_usage_logs_endpoint_id ON usage_logs(endpoint_id);\r\n    CREATE INDEX IF NOT EXISTS idx_usage_logs_timestamp ON usage_logs(timestamp);\r\n    CREATE INDEX IF NOT EXISTS idx_usage_logs_payment_id ON usage_logs(payment_id);\r\n    CREATE INDEX IF NOT EXISTS idx_endpoints_status ON endpoints(status);\r\n    CREATE UNIQUE INDEX IF NOT EXISTS idx_api_keys_key_hash ON api_keys(key_hash);\r\n    CREATE INDEX IF NOT EXISTS idx_api_keys_user_id ON api_keys(user_id);\r\n    CREATE INDEX IF NOT EXISTS idx_api_keys_role ON api_keys(role);\r\n    CREATE INDEX IF NOT EXISTS idx_api_keys_revoked_at ON api_keys(revoked_at);\r\n  `);\r\n}\r\n\r\nexport class SqliteAdapter implements DatabaseAdapter {\r\n  private db: Database.Database;\r\n\r\n  constructor(dbPath?: string) {\r\n    const DB_PATH = dbPath || path.join(process.cwd(), 'data', 'metered-endpoints.db');\r\n    \r\n    // Ensure data directory exists\r\n    if (!fs.existsSync(path.dirname(DB_PATH))) {\r\n      fs.mkdirSync(path.dirname(DB_PATH), { recursive: true });\r\n    }\r\n    \r\n    this.db = new Database(DB_PATH);\r\n    this.db.pragma('journal_mode = WAL');\r\n    \r\n    // Initialize schema\r\n    initializeSchema(this.db);\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    try {\r\n      this.db.prepare('SELECT 1').get();\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // =============================================================================\r\n  // ENDPOINTS\r\n  // =============================================================================\r\n\r\n  async createEndpoint(endpoint: Omit<MeteredEndpoint, 'id' | 'createdAt' | 'updatedAt'> & { id?: string }): Promise<MeteredEndpoint> {\r\n    const id = endpoint.id || `ep_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const now = new Date().toISOString();\r\n\r\n    this.db.prepare(`\r\n      INSERT INTO endpoints (\r\n        id, name, description, upstream_url, price, network, token_address,\r\n        token_symbol, chain_id, recipient_address, status, created_at, updated_at, created_by\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `).run(\r\n      id,\r\n      endpoint.name,\r\n      endpoint.description || null,\r\n      endpoint.upstreamUrl,\r\n      endpoint.price,\r\n      endpoint.network,\r\n      endpoint.tokenAddress,\r\n      endpoint.tokenSymbol,\r\n      endpoint.chainId,\r\n      endpoint.recipientAddress,\r\n      endpoint.status,\r\n      now,\r\n      now,\r\n      endpoint.createdBy || null\r\n    );\r\n\r\n    return Promise.resolve({\r\n      ...endpoint,\r\n      id,\r\n      createdAt: now,\r\n      updatedAt: now,\r\n    });\r\n  }\r\n\r\n  async getEndpoint(endpointId: string): Promise<MeteredEndpoint | null> {\r\n    const row = this.db.prepare('SELECT * FROM endpoints WHERE id = ? AND status != ?').get(endpointId, 'deleted') as any;\r\n    if (!row) return Promise.resolve(null);\r\n    return Promise.resolve(this.mapRowToEndpoint(row));\r\n  }\r\n\r\n  async listEndpoints(filters?: { status?: string; createdBy?: string }): Promise<MeteredEndpoint[]> {\r\n    let query = 'SELECT * FROM endpoints WHERE status != ?';\r\n    const params: any[] = ['deleted'];\r\n\r\n    if (filters?.status) {\r\n      query += ' AND status = ?';\r\n      params.push(filters.status);\r\n    }\r\n\r\n    if (filters?.createdBy) {\r\n      query += ' AND created_by = ?';\r\n      params.push(filters.createdBy);\r\n    }\r\n\r\n    query += ' ORDER BY created_at DESC';\r\n\r\n    const rows = this.db.prepare(query).all(...params) as any[];\r\n    return Promise.resolve(rows.map(row => this.mapRowToEndpoint(row)));\r\n  }\r\n\r\n  async updateEndpoint(endpointId: string, updates: Partial<MeteredEndpoint>): Promise<MeteredEndpoint | null> {\r\n    const allowedFields = [\r\n      'name', 'description', 'upstreamUrl', 'price', 'network',\r\n      'tokenAddress', 'tokenSymbol', 'chainId', 'recipientAddress', 'status'\r\n    ];\r\n\r\n    const setClauses: string[] = [];\r\n    const values: any[] = [];\r\n\r\n    for (const [key, value] of Object.entries(updates)) {\r\n      if (allowedFields.includes(key) && value !== undefined) {\r\n        const dbKey = key === 'upstreamUrl' ? 'upstream_url' :\r\n                     key === 'tokenAddress' ? 'token_address' :\r\n                     key === 'tokenSymbol' ? 'token_symbol' :\r\n                     key === 'chainId' ? 'chain_id' :\r\n                     key === 'recipientAddress' ? 'recipient_address' :\r\n                     key === 'createdAt' ? 'created_at' :\r\n                     key === 'updatedAt' ? 'updated_at' :\r\n                     key === 'createdBy' ? 'created_by' : key;\r\n        setClauses.push(`${dbKey} = ?`);\r\n        values.push(value);\r\n      }\r\n    }\r\n\r\n    if (setClauses.length === 0) {\r\n      return this.getEndpoint(endpointId);\r\n    }\r\n\r\n    setClauses.push('updated_at = ?');\r\n    values.push(new Date().toISOString());\r\n    values.push(endpointId);\r\n\r\n    this.db.prepare(`UPDATE endpoints SET ${setClauses.join(', ')} WHERE id = ?`).run(...values);\r\n    return this.getEndpoint(endpointId);\r\n  }\r\n\r\n  async deleteEndpoint(endpointId: string): Promise<boolean> {\r\n    const result = this.db.prepare('UPDATE endpoints SET status = ?, updated_at = ? WHERE id = ?').run(\r\n      'deleted',\r\n      new Date().toISOString(),\r\n      endpointId\r\n    );\r\n    return Promise.resolve(result.changes > 0);\r\n  }\r\n\r\n  // =============================================================================\r\n  // PAYMENTS\r\n  // =============================================================================\r\n\r\n  async createPayment(payment: Omit<Payment, 'id' | 'verifiedAt'>): Promise<Payment> {\r\n    const id = `pay_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const verifiedAt = new Date().toISOString();\r\n\r\n    this.db.prepare(`\r\n      INSERT INTO payments (\r\n        id, endpoint_id, tx_hash, from_address, to_address, amount,\r\n        token_address, network, verified_at, kyt_status, ofac_status, facilitator\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `).run(\r\n      id,\r\n      payment.endpointId,\r\n      payment.txHash,\r\n      payment.fromAddress,\r\n      payment.toAddress,\r\n      payment.amount,\r\n      payment.tokenAddress,\r\n      payment.network,\r\n      verifiedAt,\r\n      payment.kytStatus || null,\r\n      payment.ofacStatus || null,\r\n      payment.facilitator\r\n    );\r\n\r\n    return Promise.resolve({\r\n      ...payment,\r\n      id,\r\n      verifiedAt,\r\n    });\r\n  }\r\n\r\n  async getPayment(paymentId: string): Promise<Payment | null> {\r\n    const row = this.db.prepare('SELECT * FROM payments WHERE id = ?').get(paymentId) as any;\r\n    if (!row) return Promise.resolve(null);\r\n    return Promise.resolve(this.mapRowToPayment(row));\r\n  }\r\n\r\n  async getPaymentByTxHash(txHash: string): Promise<Payment | null> {\r\n    const row = this.db.prepare('SELECT * FROM payments WHERE tx_hash = ?').get(txHash) as any;\r\n    if (!row) return Promise.resolve(null);\r\n    return Promise.resolve(this.mapRowToPayment(row));\r\n  }\r\n\r\n  async listPayments(filters?: { endpointId?: string; fromAddress?: string }): Promise<Payment[]> {\r\n    let query = 'SELECT * FROM payments WHERE 1=1';\r\n    const params: any[] = [];\r\n\r\n    if (filters?.endpointId) {\r\n      query += ' AND endpoint_id = ?';\r\n      params.push(filters.endpointId);\r\n    }\r\n\r\n    if (filters?.fromAddress) {\r\n      query += ' AND from_address = ?';\r\n      params.push(filters.fromAddress);\r\n    }\r\n\r\n    query += ' ORDER BY verified_at DESC';\r\n\r\n    const rows = this.db.prepare(query).all(...params) as any[];\r\n    return Promise.resolve(rows.map(row => this.mapRowToPayment(row)));\r\n  }\r\n\r\n  async getPaymentsForEndpoint(endpointId: string, limit: number = 100): Promise<Payment[]> {\r\n    const rows = this.db.prepare(\r\n      'SELECT * FROM payments WHERE endpoint_id = ? ORDER BY verified_at DESC LIMIT ?'\r\n    ).all(endpointId, limit) as any[];\r\n    return Promise.resolve(rows.map(row => this.mapRowToPayment(row)));\r\n  }\r\n\r\n  // =============================================================================\r\n  // USAGE LOGS\r\n  // =============================================================================\r\n\r\n  async createUsageLog(log: Omit<UsageLog, 'id' | 'timestamp'>): Promise<UsageLog> {\r\n    const id = `log_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const timestamp = new Date().toISOString();\r\n\r\n    // Add tracing columns if they don't exist (migration support)\r\n    try {\r\n      this.db.exec(`\r\n        ALTER TABLE usage_logs ADD COLUMN conversation_id TEXT;\r\n        ALTER TABLE usage_logs ADD COLUMN agent_id TEXT;\r\n        ALTER TABLE usage_logs ADD COLUMN x402_tx_hash TEXT;\r\n        ALTER TABLE usage_logs ADD COLUMN failure_code TEXT;\r\n      `);\r\n    } catch (e: any) {\r\n      // Columns may already exist, ignore error\r\n      if (!e.message?.includes('duplicate column')) {\r\n        console.warn('[SQLite] Migration warning:', e.message);\r\n      }\r\n    }\r\n\r\n    try {\r\n      this.db.prepare(`\r\n        INSERT INTO usage_logs (\r\n          id, endpoint_id, payment_id, timestamp, method, path,\r\n          status_code, response_time, units, ip_address, user_agent,\r\n          conversation_id, agent_id, x402_tx_hash, failure_code\r\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n      `).run(\r\n        id,\r\n        log.endpointId,\r\n        log.paymentId || null,\r\n        timestamp,\r\n        log.method,\r\n        log.path,\r\n        log.statusCode,\r\n        log.responseTime,\r\n        log.units,\r\n        log.ipAddress || null,\r\n        log.userAgent || null,\r\n        log.conversationId || null,\r\n        log.agentId || null,\r\n        log.x402TxHash || null,\r\n        log.failureCode || null\r\n      );\r\n    } catch (dbError: any) {\r\n      // Log full error details for debugging\r\n      const errorInfo = {\r\n        message: dbError.message || String(dbError),\r\n        code: dbError.code || 'unknown',\r\n        errno: dbError.errno,\r\n        sql: dbError.sql,\r\n        endpointId: log.endpointId,\r\n        table: 'usage_logs',\r\n      };\r\n      \r\n      console.error('[SQLite] Insert error details:', JSON.stringify(errorInfo, null, 2));\r\n      \r\n      // Re-throw with more context\r\n      throw new Error(\r\n        `SQLite insert failed: ${dbError.message || String(dbError)}. ` +\r\n        `Table: usage_logs, EndpointId: ${log.endpointId}, ` +\r\n        `Error code: ${dbError.code || 'unknown'}, ` +\r\n        `SQL: ${dbError.sql || 'N/A'}`\r\n      );\r\n    }\r\n\r\n    return Promise.resolve({\r\n      ...log,\r\n      id,\r\n      timestamp,\r\n    });\r\n  }\r\n\r\n  async listUsageLogs(filters?: { endpointId?: string; paymentId?: string }): Promise<UsageLog[]> {\r\n    let query = 'SELECT * FROM usage_logs WHERE 1=1';\r\n    const params: any[] = [];\r\n\r\n    if (filters?.endpointId) {\r\n      query += ' AND endpoint_id = ?';\r\n      params.push(filters.endpointId);\r\n    }\r\n\r\n    if (filters?.paymentId) {\r\n      query += ' AND payment_id = ?';\r\n      params.push(filters.paymentId);\r\n    }\r\n\r\n    query += ' ORDER BY timestamp DESC LIMIT 1000';\r\n\r\n    const rows = this.db.prepare(query).all(...params) as any[];\r\n    return Promise.resolve(rows.map(row => this.mapRowToUsageLog(row)));\r\n  }\r\n\r\n  async getUsageStats(endpointId: string, startDate?: string, endDate?: string): Promise<{\r\n    totalRequests: number;\r\n    totalPayments: number;\r\n    totalRevenue: string;\r\n    averageResponseTime: number;\r\n  }> {\r\n    let query = `\r\n      SELECT\r\n        COUNT(*) as total_requests,\r\n        COUNT(DISTINCT payment_id) as total_payments,\r\n        COALESCE(SUM(CAST(p.amount AS INTEGER)), 0) as total_revenue,\r\n        COALESCE(AVG(response_time), 0) as avg_response_time\r\n      FROM usage_logs ul\r\n      LEFT JOIN payments p ON ul.payment_id = p.id\r\n      WHERE ul.endpoint_id = ?\r\n    `;\r\n    const params: any[] = [endpointId];\r\n\r\n    if (startDate) {\r\n      query += ' AND ul.timestamp >= ?';\r\n      params.push(startDate);\r\n    }\r\n\r\n    if (endDate) {\r\n      query += ' AND ul.timestamp <= ?';\r\n      params.push(endDate);\r\n    }\r\n\r\n    const row = this.db.prepare(query).get(...params) as any;\r\n\r\n    return Promise.resolve({\r\n      totalRequests: row.total_requests || 0,\r\n      totalPayments: row.total_payments || 0,\r\n      totalRevenue: row.total_revenue?.toString() || '0',\r\n      averageResponseTime: row.avg_response_time || 0,\r\n    });\r\n  }\r\n\r\n  // =============================================================================\r\n  // HELPERS\r\n  // =============================================================================\r\n\r\n  private mapRowToEndpoint(row: any): MeteredEndpoint {\r\n    return {\r\n      id: row.id,\r\n      name: row.name,\r\n      description: row.description,\r\n      upstreamUrl: row.upstream_url,\r\n      price: row.price,\r\n      network: row.network,\r\n      tokenAddress: row.token_address,\r\n      tokenSymbol: row.token_symbol,\r\n      chainId: row.chain_id,\r\n      recipientAddress: row.recipient_address,\r\n      status: row.status,\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      createdBy: row.created_by,\r\n    };\r\n  }\r\n\r\n  private mapRowToPayment(row: any): Payment {\r\n    return {\r\n      id: row.id,\r\n      endpointId: row.endpoint_id,\r\n      txHash: row.tx_hash,\r\n      fromAddress: row.from_address,\r\n      toAddress: row.to_address,\r\n      amount: row.amount,\r\n      tokenAddress: row.token_address,\r\n      network: row.network,\r\n      verifiedAt: row.verified_at,\r\n      kytStatus: row.kyt_status,\r\n      ofacStatus: row.ofac_status,\r\n      facilitator: row.facilitator,\r\n    };\r\n  }\r\n\r\n  private mapRowToUsageLog(row: any): UsageLog {\r\n    return {\r\n      id: row.id,\r\n      endpointId: row.endpoint_id,\r\n      paymentId: row.payment_id,\r\n      timestamp: row.timestamp,\r\n      method: row.method,\r\n      path: row.path,\r\n      statusCode: row.status_code,\r\n      responseTime: row.response_time,\r\n      units: row.units,\r\n      ipAddress: row.ip_address,\r\n      userAgent: row.user_agent,\r\n      conversationId: row.conversation_id,\r\n      agentId: row.agent_id,\r\n      x402TxHash: row.x402_tx_hash,\r\n      failureCode: row.failure_code,\r\n    };\r\n  }\r\n\r\n  // =============================================================================\r\n  // API KEYS\r\n  // =============================================================================\r\n\r\n  async createApiKey(apiKey: { id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; expiresAt?: string; createdAt: string; updatedAt: string }): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }> {\r\n    this.db.prepare(\r\n      `INSERT INTO api_keys (id, key_hash, name, role, user_id, rate_limit, expires_at, x402_demo_calls_used, x402_demo_calls_limit, x402_demo_amount_used, x402_demo_amount_limit, created_at, updated_at)\r\n       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\r\n    ).run(\r\n      apiKey.id, apiKey.keyHash, apiKey.name, apiKey.role, apiKey.userId || null,\r\n      apiKey.rateLimit, apiKey.expiresAt || null,\r\n      apiKey.x402DemoCallsUsed || 0, apiKey.x402DemoCallsLimit || 200,\r\n      apiKey.x402DemoAmountUsed || '0', apiKey.x402DemoAmountLimit || '1000000',\r\n      apiKey.createdAt, apiKey.updatedAt\r\n    );\r\n    return this.findApiKeyByHash(apiKey.keyHash) as Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }>;\r\n  }\r\n\r\n  async findApiKeyByHash(keyHash: string): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string } | null> {\r\n    const row = this.db.prepare(\r\n      `SELECT * FROM api_keys WHERE key_hash = ? AND revoked_at IS NULL`\r\n    ).get(keyHash) as any;\r\n    if (!row) return null;\r\n    return {\r\n      id: row.id,\r\n      keyHash: row.key_hash,\r\n      name: row.name,\r\n      role: row.role,\r\n      userId: row.user_id,\r\n      rateLimit: row.rate_limit,\r\n      lastUsedAt: row.last_used_at,\r\n      lastUsedIp: row.last_used_ip,\r\n      expiresAt: row.expires_at,\r\n      x402DemoCallsUsed: row.x402_demo_calls_used || 0,\r\n      x402DemoCallsLimit: row.x402_demo_calls_limit || 200,\r\n      x402DemoAmountUsed: row.x402_demo_amount_used || '0',\r\n      x402DemoAmountLimit: row.x402_demo_amount_limit || '1000000',\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      revokedAt: row.revoked_at,\r\n    };\r\n  }\r\n\r\n  async updateApiKeyLastUsed(keyId: string, ipAddress?: string): Promise<void> {\r\n    const now = new Date().toISOString();\r\n    this.db.prepare(\r\n      `UPDATE api_keys SET last_used_at = ?, last_used_ip = ?, updated_at = ? WHERE id = ?`\r\n    ).run(now, ipAddress || null, now, keyId);\r\n  }\r\n\r\n  async updateApiKeyX402DemoAllowance(keyId: string, callsUsed: number, amountUsed: string): Promise<void> {\r\n    const now = new Date().toISOString();\r\n    this.db.prepare(\r\n      `UPDATE api_keys SET x402_demo_calls_used = ?, x402_demo_amount_used = ?, updated_at = ? WHERE id = ?`\r\n    ).run(callsUsed, amountUsed, now, keyId);\r\n  }\r\n\r\n  async updateApiKeyX402DemoLimits(keyId: string, callsLimit?: number, amountLimit?: string): Promise<void> {\r\n    const now = new Date().toISOString();\r\n    if (callsLimit !== undefined && amountLimit !== undefined) {\r\n      this.db.prepare(\r\n        `UPDATE api_keys SET x402_demo_calls_limit = ?, x402_demo_amount_limit = ?, updated_at = ? WHERE id = ?`\r\n      ).run(callsLimit, amountLimit, now, keyId);\r\n    } else if (callsLimit !== undefined) {\r\n      this.db.prepare(\r\n        `UPDATE api_keys SET x402_demo_calls_limit = ?, updated_at = ? WHERE id = ?`\r\n      ).run(callsLimit, now, keyId);\r\n    } else if (amountLimit !== undefined) {\r\n      this.db.prepare(\r\n        `UPDATE api_keys SET x402_demo_amount_limit = ?, updated_at = ? WHERE id = ?`\r\n      ).run(amountLimit, now, keyId);\r\n    }\r\n  }\r\n\r\n  async revokeApiKey(keyId: string): Promise<boolean> {\r\n    const now = new Date().toISOString();\r\n    const result = this.db.prepare(\r\n      `UPDATE api_keys SET revoked_at = ?, updated_at = ? WHERE id = ? AND revoked_at IS NULL`\r\n    ).run(now, now, keyId);\r\n    return result.changes > 0;\r\n  }\r\n\r\n  async listApiKeys(userId?: string): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }[]> {\r\n    let query = `SELECT * FROM api_keys WHERE revoked_at IS NULL`;\r\n    const params: any[] = [];\r\n    if (userId) {\r\n      query += ` AND user_id = ?`;\r\n      params.push(userId);\r\n    }\r\n    query += ` ORDER BY created_at DESC`;\r\n    const rows = this.db.prepare(query).all(...params) as any[];\r\n    return Promise.resolve(rows.map((row) => ({\r\n      id: row.id,\r\n      keyHash: row.key_hash,\r\n      name: row.name,\r\n      role: row.role,\r\n      userId: row.user_id,\r\n      rateLimit: row.rate_limit,\r\n      lastUsedAt: row.last_used_at,\r\n      lastUsedIp: row.last_used_ip,\r\n      expiresAt: row.expires_at,\r\n      x402DemoCallsUsed: row.x402_demo_calls_used || 0,\r\n      x402DemoCallsLimit: row.x402_demo_calls_limit || 200,\r\n      x402DemoAmountUsed: row.x402_demo_amount_used || '0',\r\n      x402DemoAmountLimit: row.x402_demo_amount_limit || '1000000',\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      revokedAt: row.revoked_at,\r\n    })));\r\n  }\r\n\r\n  close(): void {\r\n    this.db.close();\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,iBAAiB;AACjB,gFAAgF;AAChF,2CAA2C;AAC3C,yDAAyD;;;;;AAEzD;AACA;AACA;;;;AAIA,6DAA6D;AAC7D,SAAS,iBAAiB,EAAqB;IAC7C,kBAAkB;IAClB,GAAG,IAAI,CAAC,CAAC;;;;;;;;;;;;;;;;;EAiBT,CAAC;IAED,8DAA8D;IAC9D,IAAI;QACF,MAAM,YAAY,GAAG,OAAO,CAAC,gCAAgC,GAAG;QAChE,MAAM,sBAAsB,UAAU,IAAI,CAAC,CAAA,MAAO,IAAI,IAAI,KAAK;QAE/D,IAAI,CAAC,qBAAqB;YACxB,GAAG,IAAI,CAAC,CAAC,uDAAuD,CAAC;YACjE,QAAQ,GAAG,CAAC;QACd;IACF,EAAE,OAAO,OAAY;QACnB,IAAI,CAAC,MAAM,OAAO,EAAE,SAAS,4BAA4B,CAAC,MAAM,OAAO,EAAE,SAAS,mBAAmB;YACnG,QAAQ,IAAI,CAAC,2BAA2B,MAAM,OAAO;QACvD;IACF;IAEA,iBAAiB;IACjB,GAAG,IAAI,CAAC,CAAC;;;;;;;;;;;;;;;;EAgBT,CAAC;IAED,mBAAmB;IACnB,GAAG,IAAI,CAAC,CAAC;;;;;;;;;;;;;;;;EAgBT,CAAC;IAED,iBAAiB;IACjB,GAAG,IAAI,CAAC,CAAC;;;;;;;;;;;;;;;;;;;EAmBT,CAAC;IAED,UAAU;IACV,GAAG,IAAI,CAAC,CAAC;;;;;;;;;;;;EAYT,CAAC;AACH;AAEO,MAAM;IACH,GAAsB;IAE9B,YAAY,MAAe,CAAE;QAC3B,MAAM,UAAU,UAAU,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ;QAE3D,+BAA+B;QAC/B,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,4GAAI,CAAC,OAAO,CAAC,WAAW;YACzC,wGAAE,CAAC,SAAS,CAAC,4GAAI,CAAC,OAAO,CAAC,UAAU;gBAAE,WAAW;YAAK;QACxD;QAEA,IAAI,CAAC,EAAE,GAAG,IAAI,sIAAQ,CAAC;QACvB,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC;QAEf,oBAAoB;QACpB,iBAAiB,IAAI,CAAC,EAAE;IAC1B;IAEA,MAAM,cAAgC;QACpC,IAAI;YACF,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,YAAY,GAAG;YAC/B,OAAO;QACT,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,gFAAgF;IAChF,YAAY;IACZ,gFAAgF;IAEhF,MAAM,eAAe,QAAmF,EAA4B;QAClI,MAAM,KAAK,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,IAAI;QAC1F,MAAM,MAAM,IAAI,OAAO,WAAW;QAElC,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;;;;;IAKjB,CAAC,EAAE,GAAG,CACJ,IACA,SAAS,IAAI,EACb,SAAS,WAAW,IAAI,MACxB,SAAS,WAAW,EACpB,SAAS,KAAK,EACd,SAAS,OAAO,EAChB,SAAS,YAAY,EACrB,SAAS,WAAW,EACpB,SAAS,OAAO,EAChB,SAAS,gBAAgB,EACzB,SAAS,MAAM,EACf,KACA,KACA,SAAS,SAAS,IAAI;QAGxB,OAAO,QAAQ,OAAO,CAAC;YACrB,GAAG,QAAQ;YACX;YACA,WAAW;YACX,WAAW;QACb;IACF;IAEA,MAAM,YAAY,UAAkB,EAAmC;QACrE,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,wDAAwD,GAAG,CAAC,YAAY;QACpG,IAAI,CAAC,KAAK,OAAO,QAAQ,OAAO,CAAC;QACjC,OAAO,QAAQ,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC;IAC/C;IAEA,MAAM,cAAc,OAAiD,EAA8B;QACjG,IAAI,QAAQ;QACZ,MAAM,SAAgB;YAAC;SAAU;QAEjC,IAAI,SAAS,QAAQ;YACnB,SAAS;YACT,OAAO,IAAI,CAAC,QAAQ,MAAM;QAC5B;QAEA,IAAI,SAAS,WAAW;YACtB,SAAS;YACT,OAAO,IAAI,CAAC,QAAQ,SAAS;QAC/B;QAEA,SAAS;QAET,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI;QAC3C,OAAO,QAAQ,OAAO,CAAC,KAAK,GAAG,CAAC,CAAA,MAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/D;IAEA,MAAM,eAAe,UAAkB,EAAE,OAAiC,EAAmC;QAC3G,MAAM,gBAAgB;YACpB;YAAQ;YAAe;YAAe;YAAS;YAC/C;YAAgB;YAAe;YAAW;YAAoB;SAC/D;QAED,MAAM,aAAuB,EAAE;QAC/B,MAAM,SAAgB,EAAE;QAExB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,SAAU;YAClD,IAAI,cAAc,QAAQ,CAAC,QAAQ,UAAU,WAAW;gBACtD,MAAM,QAAQ,QAAQ,gBAAgB,iBACzB,QAAQ,iBAAiB,kBACzB,QAAQ,gBAAgB,iBACxB,QAAQ,YAAY,aACpB,QAAQ,qBAAqB,sBAC7B,QAAQ,cAAc,eACtB,QAAQ,cAAc,eACtB,QAAQ,cAAc,eAAe;gBAClD,WAAW,IAAI,CAAC,GAAG,MAAM,IAAI,CAAC;gBAC9B,OAAO,IAAI,CAAC;YACd;QACF;QAEA,IAAI,WAAW,MAAM,KAAK,GAAG;YAC3B,OAAO,IAAI,CAAC,WAAW,CAAC;QAC1B;QAEA,WAAW,IAAI,CAAC;QAChB,OAAO,IAAI,CAAC,IAAI,OAAO,WAAW;QAClC,OAAO,IAAI,CAAC;QAEZ,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,qBAAqB,EAAE,WAAW,IAAI,CAAC,MAAM,aAAa,CAAC,EAAE,GAAG,IAAI;QACrF,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B;IAEA,MAAM,eAAe,UAAkB,EAAoB;QACzD,MAAM,SAAS,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,gEAAgE,GAAG,CAChG,WACA,IAAI,OAAO,WAAW,IACtB;QAEF,OAAO,QAAQ,OAAO,CAAC,OAAO,OAAO,GAAG;IAC1C;IAEA,gFAAgF;IAChF,WAAW;IACX,gFAAgF;IAEhF,MAAM,cAAc,OAA2C,EAAoB;QACjF,MAAM,KAAK,CAAC,IAAI,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,IAAI;QAC5E,MAAM,aAAa,IAAI,OAAO,WAAW;QAEzC,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;;;;;IAKjB,CAAC,EAAE,GAAG,CACJ,IACA,QAAQ,UAAU,EAClB,QAAQ,MAAM,EACd,QAAQ,WAAW,EACnB,QAAQ,SAAS,EACjB,QAAQ,MAAM,EACd,QAAQ,YAAY,EACpB,QAAQ,OAAO,EACf,YACA,QAAQ,SAAS,IAAI,MACrB,QAAQ,UAAU,IAAI,MACtB,QAAQ,WAAW;QAGrB,OAAO,QAAQ,OAAO,CAAC;YACrB,GAAG,OAAO;YACV;YACA;QACF;IACF;IAEA,MAAM,WAAW,SAAiB,EAA2B;QAC3D,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,uCAAuC,GAAG,CAAC;QACvE,IAAI,CAAC,KAAK,OAAO,QAAQ,OAAO,CAAC;QACjC,OAAO,QAAQ,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC;IAC9C;IAEA,MAAM,mBAAmB,MAAc,EAA2B;QAChE,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,4CAA4C,GAAG,CAAC;QAC5E,IAAI,CAAC,KAAK,OAAO,QAAQ,OAAO,CAAC;QACjC,OAAO,QAAQ,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC;IAC9C;IAEA,MAAM,aAAa,OAAuD,EAAsB;QAC9F,IAAI,QAAQ;QACZ,MAAM,SAAgB,EAAE;QAExB,IAAI,SAAS,YAAY;YACvB,SAAS;YACT,OAAO,IAAI,CAAC,QAAQ,UAAU;QAChC;QAEA,IAAI,SAAS,aAAa;YACxB,SAAS;YACT,OAAO,IAAI,CAAC,QAAQ,WAAW;QACjC;QAEA,SAAS;QAET,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI;QAC3C,OAAO,QAAQ,OAAO,CAAC,KAAK,GAAG,CAAC,CAAA,MAAO,IAAI,CAAC,eAAe,CAAC;IAC9D;IAEA,MAAM,uBAAuB,UAAkB,EAAE,QAAgB,GAAG,EAAsB;QACxF,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,OAAO,CAC1B,kFACA,GAAG,CAAC,YAAY;QAClB,OAAO,QAAQ,OAAO,CAAC,KAAK,GAAG,CAAC,CAAA,MAAO,IAAI,CAAC,eAAe,CAAC;IAC9D;IAEA,gFAAgF;IAChF,aAAa;IACb,gFAAgF;IAEhF,MAAM,eAAe,GAAuC,EAAqB;QAC/E,MAAM,KAAK,CAAC,IAAI,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,IAAI;QAC5E,MAAM,YAAY,IAAI,OAAO,WAAW;QAExC,8DAA8D;QAC9D,IAAI;YACF,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;;;;;MAKd,CAAC;QACH,EAAE,OAAO,GAAQ;YACf,0CAA0C;YAC1C,IAAI,CAAC,EAAE,OAAO,EAAE,SAAS,qBAAqB;gBAC5C,QAAQ,IAAI,CAAC,+BAA+B,EAAE,OAAO;YACvD;QACF;QAEA,IAAI;YACF,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;;;;;;MAMjB,CAAC,EAAE,GAAG,CACJ,IACA,IAAI,UAAU,EACd,IAAI,SAAS,IAAI,MACjB,WACA,IAAI,MAAM,EACV,IAAI,IAAI,EACR,IAAI,UAAU,EACd,IAAI,YAAY,EAChB,IAAI,KAAK,EACT,IAAI,SAAS,IAAI,MACjB,IAAI,SAAS,IAAI,MACjB,IAAI,cAAc,IAAI,MACtB,IAAI,OAAO,IAAI,MACf,IAAI,UAAU,IAAI,MAClB,IAAI,WAAW,IAAI;QAEvB,EAAE,OAAO,SAAc;YACrB,uCAAuC;YACvC,MAAM,YAAY;gBAChB,SAAS,QAAQ,OAAO,IAAI,OAAO;gBACnC,MAAM,QAAQ,IAAI,IAAI;gBACtB,OAAO,QAAQ,KAAK;gBACpB,KAAK,QAAQ,GAAG;gBAChB,YAAY,IAAI,UAAU;gBAC1B,OAAO;YACT;YAEA,QAAQ,KAAK,CAAC,kCAAkC,KAAK,SAAS,CAAC,WAAW,MAAM;YAEhF,6BAA6B;YAC7B,MAAM,IAAI,MACR,CAAC,sBAAsB,EAAE,QAAQ,OAAO,IAAI,OAAO,SAAS,EAAE,CAAC,GAC/D,CAAC,+BAA+B,EAAE,IAAI,UAAU,CAAC,EAAE,CAAC,GACpD,CAAC,YAAY,EAAE,QAAQ,IAAI,IAAI,UAAU,EAAE,CAAC,GAC5C,CAAC,KAAK,EAAE,QAAQ,GAAG,IAAI,OAAO;QAElC;QAEA,OAAO,QAAQ,OAAO,CAAC;YACrB,GAAG,GAAG;YACN;YACA;QACF;IACF;IAEA,MAAM,cAAc,OAAqD,EAAuB;QAC9F,IAAI,QAAQ;QACZ,MAAM,SAAgB,EAAE;QAExB,IAAI,SAAS,YAAY;YACvB,SAAS;YACT,OAAO,IAAI,CAAC,QAAQ,UAAU;QAChC;QAEA,IAAI,SAAS,WAAW;YACtB,SAAS;YACT,OAAO,IAAI,CAAC,QAAQ,SAAS;QAC/B;QAEA,SAAS;QAET,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI;QAC3C,OAAO,QAAQ,OAAO,CAAC,KAAK,GAAG,CAAC,CAAA,MAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/D;IAEA,MAAM,cAAc,UAAkB,EAAE,SAAkB,EAAE,OAAgB,EAKzE;QACD,IAAI,QAAQ,CAAC;;;;;;;;;IASb,CAAC;QACD,MAAM,SAAgB;YAAC;SAAW;QAElC,IAAI,WAAW;YACb,SAAS;YACT,OAAO,IAAI,CAAC;QACd;QAEA,IAAI,SAAS;YACX,SAAS;YACT,OAAO,IAAI,CAAC;QACd;QAEA,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI;QAE1C,OAAO,QAAQ,OAAO,CAAC;YACrB,eAAe,IAAI,cAAc,IAAI;YACrC,eAAe,IAAI,cAAc,IAAI;YACrC,cAAc,IAAI,aAAa,EAAE,cAAc;YAC/C,qBAAqB,IAAI,iBAAiB,IAAI;QAChD;IACF;IAEA,gFAAgF;IAChF,UAAU;IACV,gFAAgF;IAExE,iBAAiB,GAAQ,EAAmB;QAClD,OAAO;YACL,IAAI,IAAI,EAAE;YACV,MAAM,IAAI,IAAI;YACd,aAAa,IAAI,WAAW;YAC5B,aAAa,IAAI,YAAY;YAC7B,OAAO,IAAI,KAAK;YAChB,SAAS,IAAI,OAAO;YACpB,cAAc,IAAI,aAAa;YAC/B,aAAa,IAAI,YAAY;YAC7B,SAAS,IAAI,QAAQ;YACrB,kBAAkB,IAAI,iBAAiB;YACvC,QAAQ,IAAI,MAAM;YAClB,WAAW,IAAI,UAAU;YACzB,WAAW,IAAI,UAAU;YACzB,WAAW,IAAI,UAAU;QAC3B;IACF;IAEQ,gBAAgB,GAAQ,EAAW;QACzC,OAAO;YACL,IAAI,IAAI,EAAE;YACV,YAAY,IAAI,WAAW;YAC3B,QAAQ,IAAI,OAAO;YACnB,aAAa,IAAI,YAAY;YAC7B,WAAW,IAAI,UAAU;YACzB,QAAQ,IAAI,MAAM;YAClB,cAAc,IAAI,aAAa;YAC/B,SAAS,IAAI,OAAO;YACpB,YAAY,IAAI,WAAW;YAC3B,WAAW,IAAI,UAAU;YACzB,YAAY,IAAI,WAAW;YAC3B,aAAa,IAAI,WAAW;QAC9B;IACF;IAEQ,iBAAiB,GAAQ,EAAY;QAC3C,OAAO;YACL,IAAI,IAAI,EAAE;YACV,YAAY,IAAI,WAAW;YAC3B,WAAW,IAAI,UAAU;YACzB,WAAW,IAAI,SAAS;YACxB,QAAQ,IAAI,MAAM;YAClB,MAAM,IAAI,IAAI;YACd,YAAY,IAAI,WAAW;YAC3B,cAAc,IAAI,aAAa;YAC/B,OAAO,IAAI,KAAK;YAChB,WAAW,IAAI,UAAU;YACzB,WAAW,IAAI,UAAU;YACzB,gBAAgB,IAAI,eAAe;YACnC,SAAS,IAAI,QAAQ;YACrB,YAAY,IAAI,YAAY;YAC5B,aAAa,IAAI,YAAY;QAC/B;IACF;IAEA,gFAAgF;IAChF,WAAW;IACX,gFAAgF;IAEhF,MAAM,aAAa,MAAiK,EAA+M;QACjY,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,CAAC;qDAC8C,CAAC,EAChD,GAAG,CACH,OAAO,EAAE,EAAE,OAAO,OAAO,EAAE,OAAO,IAAI,EAAE,OAAO,IAAI,EAAE,OAAO,MAAM,IAAI,MACtE,OAAO,SAAS,EAAE,OAAO,SAAS,IAAI,MACtC,OAAO,iBAAiB,IAAI,GAAG,OAAO,kBAAkB,IAAI,KAC5D,OAAO,kBAAkB,IAAI,KAAK,OAAO,mBAAmB,IAAI,WAChE,OAAO,SAAS,EAAE,OAAO,SAAS;QAEpC,OAAO,IAAI,CAAC,gBAAgB,CAAC,OAAO,OAAO;IAC7C;IAEA,MAAM,iBAAiB,OAAe,EAAsN;QAC1P,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,OAAO,CACzB,CAAC,gEAAgE,CAAC,EAClE,GAAG,CAAC;QACN,IAAI,CAAC,KAAK,OAAO;QACjB,OAAO;YACL,IAAI,IAAI,EAAE;YACV,SAAS,IAAI,QAAQ;YACrB,MAAM,IAAI,IAAI;YACd,MAAM,IAAI,IAAI;YACd,QAAQ,IAAI,OAAO;YACnB,WAAW,IAAI,UAAU;YACzB,YAAY,IAAI,YAAY;YAC5B,YAAY,IAAI,YAAY;YAC5B,WAAW,IAAI,UAAU;YACzB,mBAAmB,IAAI,oBAAoB,IAAI;YAC/C,oBAAoB,IAAI,qBAAqB,IAAI;YACjD,oBAAoB,IAAI,qBAAqB,IAAI;YACjD,qBAAqB,IAAI,sBAAsB,IAAI;YACnD,WAAW,IAAI,UAAU;YACzB,WAAW,IAAI,UAAU;YACzB,WAAW,IAAI,UAAU;QAC3B;IACF;IAEA,MAAM,qBAAqB,KAAa,EAAE,SAAkB,EAAiB;QAC3E,MAAM,MAAM,IAAI,OAAO,WAAW;QAClC,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,CAAC,mFAAmF,CAAC,EACrF,GAAG,CAAC,KAAK,aAAa,MAAM,KAAK;IACrC;IAEA,MAAM,8BAA8B,KAAa,EAAE,SAAiB,EAAE,UAAkB,EAAiB;QACvG,MAAM,MAAM,IAAI,OAAO,WAAW;QAClC,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,CAAC,oGAAoG,CAAC,EACtG,GAAG,CAAC,WAAW,YAAY,KAAK;IACpC;IAEA,MAAM,2BAA2B,KAAa,EAAE,UAAmB,EAAE,WAAoB,EAAiB;QACxG,MAAM,MAAM,IAAI,OAAO,WAAW;QAClC,IAAI,eAAe,aAAa,gBAAgB,WAAW;YACzD,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,CAAC,sGAAsG,CAAC,EACxG,GAAG,CAAC,YAAY,aAAa,KAAK;QACtC,OAAO,IAAI,eAAe,WAAW;YACnC,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,CAAC,0EAA0E,CAAC,EAC5E,GAAG,CAAC,YAAY,KAAK;QACzB,OAAO,IAAI,gBAAgB,WAAW;YACpC,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,CAAC,2EAA2E,CAAC,EAC7E,GAAG,CAAC,aAAa,KAAK;QAC1B;IACF;IAEA,MAAM,aAAa,KAAa,EAAoB;QAClD,MAAM,MAAM,IAAI,OAAO,WAAW;QAClC,MAAM,SAAS,IAAI,CAAC,EAAE,CAAC,OAAO,CAC5B,CAAC,sFAAsF,CAAC,EACxF,GAAG,CAAC,KAAK,KAAK;QAChB,OAAO,OAAO,OAAO,GAAG;IAC1B;IAEA,MAAM,YAAY,MAAe,EAAiN;QAChP,IAAI,QAAQ,CAAC,+CAA+C,CAAC;QAC7D,MAAM,SAAgB,EAAE;QACxB,IAAI,QAAQ;YACV,SAAS,CAAC,gBAAgB,CAAC;YAC3B,OAAO,IAAI,CAAC;QACd;QACA,SAAS,CAAC,yBAAyB,CAAC;QACpC,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI;QAC3C,OAAO,QAAQ,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC,MAAQ,CAAC;gBACxC,IAAI,IAAI,EAAE;gBACV,SAAS,IAAI,QAAQ;gBACrB,MAAM,IAAI,IAAI;gBACd,MAAM,IAAI,IAAI;gBACd,QAAQ,IAAI,OAAO;gBACnB,WAAW,IAAI,UAAU;gBACzB,YAAY,IAAI,YAAY;gBAC5B,YAAY,IAAI,YAAY;gBAC5B,WAAW,IAAI,UAAU;gBACzB,mBAAmB,IAAI,oBAAoB,IAAI;gBAC/C,oBAAoB,IAAI,qBAAqB,IAAI;gBACjD,oBAAoB,IAAI,qBAAqB,IAAI;gBACjD,qBAAqB,IAAI,sBAAsB,IAAI;gBACnD,WAAW,IAAI,UAAU;gBACzB,WAAW,IAAI,UAAU;gBACzB,WAAW,IAAI,UAAU;YAC3B,CAAC;IACH;IAEA,QAAc;QACZ,IAAI,CAAC,EAAE,CAAC,KAAK;IACf;AACF"}},
    {"offset": {"line": 5721, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/adapters/postgres-adapter.ts"],"sourcesContent":["// =============================================================================\r\n// POSTGRESQL ADAPTER\r\n// =============================================================================\r\n// PostgreSQL implementation of DatabaseAdapter\r\n// Uses pg (node-postgres) with connection pooling\r\n\r\nimport { Pool, QueryResult } from 'pg';\r\nimport type { DatabaseAdapter } from './base-adapter';\r\nimport type { MeteredEndpoint, Payment, UsageLog } from '../metered-endpoints';\r\n\r\nexport class PostgresAdapter implements DatabaseAdapter {\r\n  private pool: Pool;\r\n\r\n  constructor(connectionString: string) {\r\n    this.pool = new Pool({\r\n      connectionString,\r\n      max: 20, // Maximum pool size\r\n      idleTimeoutMillis: 30000,\r\n      connectionTimeoutMillis: 2000,\r\n    });\r\n\r\n    // Handle pool errors\r\n    this.pool.on('error', (err) => {\r\n      console.error('[PostgresAdapter] Unexpected pool error:', err);\r\n    });\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    try {\r\n      const result = await this.pool.query('SELECT 1');\r\n      return result.rows.length > 0;\r\n    } catch (error) {\r\n      console.error('[PostgresAdapter] Health check failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // =============================================================================\r\n  // ENDPOINTS\r\n  // =============================================================================\r\n\r\n  async createEndpoint(endpoint: Omit<MeteredEndpoint, 'id' | 'createdAt' | 'updatedAt'> & { id?: string }): Promise<MeteredEndpoint> {\r\n    const id = endpoint.id || `ep_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const now = new Date().toISOString();\r\n\r\n    const result = await this.pool.query(\r\n      `INSERT INTO endpoints (\r\n        id, name, description, upstream_url, price, network, token_address,\r\n        token_symbol, chain_id, recipient_address, status, created_at, updated_at, created_by\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        endpoint.name,\r\n        endpoint.description || null,\r\n        endpoint.upstreamUrl,\r\n        endpoint.price,\r\n        endpoint.network,\r\n        endpoint.tokenAddress,\r\n        endpoint.tokenSymbol,\r\n        endpoint.chainId,\r\n        endpoint.recipientAddress,\r\n        endpoint.status,\r\n        now,\r\n        now,\r\n        endpoint.createdBy || null,\r\n      ]\r\n    );\r\n\r\n    return this.mapRowToEndpoint(result.rows[0]);\r\n  }\r\n\r\n  async getEndpoint(endpointId: string): Promise<MeteredEndpoint | null> {\r\n    const result = await this.pool.query(\r\n      'SELECT * FROM endpoints WHERE id = $1 AND status != $2',\r\n      [endpointId, 'deleted']\r\n    );\r\n\r\n    if (result.rows.length === 0) return null;\r\n    return this.mapRowToEndpoint(result.rows[0]);\r\n  }\r\n\r\n  async listEndpoints(filters?: { status?: string; createdBy?: string }): Promise<MeteredEndpoint[]> {\r\n    let query = 'SELECT * FROM endpoints WHERE status != $1';\r\n    const params: any[] = ['deleted'];\r\n    let paramIndex = 2;\r\n\r\n    if (filters?.status) {\r\n      query += ` AND status = $${paramIndex}`;\r\n      params.push(filters.status);\r\n      paramIndex++;\r\n    }\r\n\r\n    if (filters?.createdBy) {\r\n      query += ` AND created_by = $${paramIndex}`;\r\n      params.push(filters.createdBy);\r\n      paramIndex++;\r\n    }\r\n\r\n    query += ' ORDER BY created_at DESC';\r\n\r\n    try {\r\n      const result = await this.pool.query(query, params);\r\n      return result.rows.map(row => this.mapRowToEndpoint(row));\r\n    } catch (error) {\r\n      console.error('[PostgresAdapter] listEndpoints error:', error);\r\n      console.error('[PostgresAdapter] Query:', query);\r\n      console.error('[PostgresAdapter] Params:', params);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async updateEndpoint(endpointId: string, updates: Partial<MeteredEndpoint>): Promise<MeteredEndpoint | null> {\r\n    const allowedFields = [\r\n      'name', 'description', 'upstreamUrl', 'price', 'network',\r\n      'tokenAddress', 'tokenSymbol', 'chainId', 'recipientAddress', 'status'\r\n    ];\r\n\r\n    const setClauses: string[] = [];\r\n    const values: any[] = [];\r\n    let paramIndex = 1;\r\n\r\n    for (const [key, value] of Object.entries(updates)) {\r\n      if (allowedFields.includes(key) && value !== undefined) {\r\n        const dbKey = key === 'upstreamUrl' ? 'upstream_url' :\r\n                     key === 'tokenAddress' ? 'token_address' :\r\n                     key === 'tokenSymbol' ? 'token_symbol' :\r\n                     key === 'chainId' ? 'chain_id' :\r\n                     key === 'recipientAddress' ? 'recipient_address' :\r\n                     key === 'createdAt' ? 'created_at' :\r\n                     key === 'updatedAt' ? 'updated_at' :\r\n                     key === 'createdBy' ? 'created_by' : key;\r\n        setClauses.push(`${dbKey} = $${paramIndex}`);\r\n        values.push(value);\r\n        paramIndex++;\r\n      }\r\n    }\r\n\r\n    if (setClauses.length === 0) {\r\n      return this.getEndpoint(endpointId);\r\n    }\r\n\r\n    setClauses.push(`updated_at = $${paramIndex}`);\r\n    values.push(new Date().toISOString());\r\n    paramIndex++;\r\n\r\n    values.push(endpointId);\r\n\r\n    const result = await this.pool.query(\r\n      `UPDATE endpoints SET ${setClauses.join(', ')} WHERE id = $${paramIndex} RETURNING *`,\r\n      values\r\n    );\r\n\r\n    if (result.rows.length === 0) return null;\r\n    return this.mapRowToEndpoint(result.rows[0]);\r\n  }\r\n\r\n  async deleteEndpoint(endpointId: string): Promise<boolean> {\r\n    const result = await this.pool.query(\r\n      'UPDATE endpoints SET status = $1, updated_at = $2 WHERE id = $3',\r\n      ['deleted', new Date().toISOString(), endpointId]\r\n    );\r\n    return result.rowCount !== null && result.rowCount > 0;\r\n  }\r\n\r\n  // =============================================================================\r\n  // PAYMENTS\r\n  // =============================================================================\r\n\r\n  async createPayment(payment: Omit<Payment, 'id' | 'verifiedAt'>): Promise<Payment> {\r\n    const id = `pay_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const now = new Date().toISOString();\r\n    const verifiedAt = now;\r\n    // Generate invoice_id if not provided (required by schema)\r\n    const invoiceId = `inv_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n\r\n    // Determine currency and token symbol from token address or default to USDC\r\n    // For USDC on Base: 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\r\n    const currency = payment.tokenAddress === '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' ? 'USDC' : 'USDC';\r\n    const token = payment.tokenAddress; // token column stores the token address\r\n\r\n    // Set default status for verified payments\r\n    const status = 'verified'; // Payment is verified and completed\r\n\r\n    const result = await this.pool.query(\r\n      `INSERT INTO payments (\r\n        id, endpoint_id, invoice_id, tx_hash, from_address, to_address, amount,\r\n        currency, token, token_address, network, status, created_at, verified_at, kyt_status, ofac_status, facilitator\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        payment.endpointId,\r\n        invoiceId,\r\n        payment.txHash,\r\n        payment.fromAddress,\r\n        payment.toAddress,\r\n        payment.amount,\r\n        currency,\r\n        token,\r\n        payment.tokenAddress,\r\n        payment.network,\r\n        status,\r\n        now, // created_at\r\n        verifiedAt,\r\n        payment.kytStatus || null,\r\n        payment.ofacStatus || null,\r\n        payment.facilitator,\r\n      ]\r\n    );\r\n\r\n    return this.mapRowToPayment(result.rows[0]);\r\n  }\r\n\r\n  async getPayment(paymentId: string): Promise<Payment | null> {\r\n    const result = await this.pool.query('SELECT * FROM payments WHERE id = $1', [paymentId]);\r\n    if (result.rows.length === 0) return null;\r\n    return this.mapRowToPayment(result.rows[0]);\r\n  }\r\n\r\n  async getPaymentByTxHash(txHash: string): Promise<Payment | null> {\r\n    const result = await this.pool.query('SELECT * FROM payments WHERE tx_hash = $1', [txHash]);\r\n    if (result.rows.length === 0) return null;\r\n    return this.mapRowToPayment(result.rows[0]);\r\n  }\r\n\r\n  async listPayments(filters?: { endpointId?: string; fromAddress?: string }): Promise<Payment[]> {\r\n    let query = 'SELECT * FROM payments WHERE 1=1';\r\n    const params: any[] = [];\r\n    let paramIndex = 1;\r\n\r\n    if (filters?.endpointId) {\r\n      query += ` AND endpoint_id = $${paramIndex}`;\r\n      params.push(filters.endpointId);\r\n      paramIndex++;\r\n    }\r\n\r\n    if (filters?.fromAddress) {\r\n      query += ` AND from_address = $${paramIndex}`;\r\n      params.push(filters.fromAddress);\r\n      paramIndex++;\r\n    }\r\n\r\n    query += ' ORDER BY verified_at DESC';\r\n\r\n    const result = await this.pool.query(query, params);\r\n    return result.rows.map(row => this.mapRowToPayment(row));\r\n  }\r\n\r\n  async getPaymentsForEndpoint(endpointId: string, limit: number = 100): Promise<Payment[]> {\r\n    const result = await this.pool.query(\r\n      'SELECT * FROM payments WHERE endpoint_id = $1 ORDER BY verified_at DESC LIMIT $2',\r\n      [endpointId, limit]\r\n    );\r\n    return result.rows.map(row => this.mapRowToPayment(row));\r\n  }\r\n\r\n  // =============================================================================\r\n  // USAGE LOGS\r\n  // =============================================================================\r\n\r\n  async createUsageLog(log: Omit<UsageLog, 'id' | 'timestamp'>): Promise<UsageLog> {\r\n    const id = `log_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n    const timestamp = new Date().toISOString();\r\n\r\n    const result = await this.pool.query(\r\n      `INSERT INTO usage_logs (\r\n        id, endpoint_id, payment_id, timestamp, method, path,\r\n        status_code, response_time, units, ip_address, user_agent,\r\n        conversation_id, agent_id, x402_tx_hash, failure_code\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        log.endpointId,\r\n        log.paymentId || null,\r\n        timestamp,\r\n        log.method,\r\n        log.path,\r\n        log.statusCode,\r\n        log.responseTime,\r\n        log.units,\r\n        log.ipAddress || null,\r\n        log.userAgent || null,\r\n        log.conversationId || null,\r\n        log.agentId || null,\r\n        log.x402TxHash || null,\r\n        log.failureCode || null,\r\n      ]\r\n    );\r\n\r\n    return this.mapRowToUsageLog(result.rows[0]);\r\n  }\r\n\r\n  async listUsageLogs(filters?: { endpointId?: string; paymentId?: string }): Promise<UsageLog[]> {\r\n    let query = 'SELECT * FROM usage_logs WHERE 1=1';\r\n    const params: any[] = [];\r\n    let paramIndex = 1;\r\n\r\n    if (filters?.endpointId) {\r\n      query += ` AND endpoint_id = $${paramIndex}`;\r\n      params.push(filters.endpointId);\r\n      paramIndex++;\r\n    }\r\n\r\n    if (filters?.paymentId) {\r\n      query += ` AND payment_id = $${paramIndex}`;\r\n      params.push(filters.paymentId);\r\n      paramIndex++;\r\n    }\r\n\r\n    query += ' ORDER BY timestamp DESC LIMIT 1000';\r\n\r\n    const result = await this.pool.query(query, params);\r\n    return result.rows.map(row => this.mapRowToUsageLog(row));\r\n  }\r\n\r\n  async getUsageStats(endpointId: string, startDate?: string, endDate?: string): Promise<{\r\n    totalRequests: number;\r\n    totalPayments: number;\r\n    totalRevenue: string;\r\n    averageResponseTime: number;\r\n  }> {\r\n    let query = `\r\n      SELECT\r\n        COUNT(*) as total_requests,\r\n        COUNT(DISTINCT payment_id) as total_payments,\r\n        COALESCE(SUM(p.amount), '0') as total_revenue,\r\n        COALESCE(AVG(response_time), 0) as avg_response_time\r\n      FROM usage_logs ul\r\n      LEFT JOIN payments p ON ul.payment_id = p.id\r\n      WHERE ul.endpoint_id = $1\r\n    `;\r\n    const params: any[] = [endpointId];\r\n    let paramIndex = 2;\r\n\r\n    if (startDate) {\r\n      query += ` AND ul.timestamp >= $${paramIndex}`;\r\n      params.push(startDate);\r\n      paramIndex++;\r\n    }\r\n\r\n    if (endDate) {\r\n      query += ` AND ul.timestamp <= $${paramIndex}`;\r\n      params.push(endDate);\r\n      paramIndex++;\r\n    }\r\n\r\n    const result = await this.pool.query(query, params);\r\n    const row = result.rows[0];\r\n\r\n    return {\r\n      totalRequests: parseInt(row.total_requests) || 0,\r\n      totalPayments: parseInt(row.total_payments) || 0,\r\n      totalRevenue: row.total_revenue || '0',\r\n      averageResponseTime: parseFloat(row.avg_response_time) || 0,\r\n    };\r\n  }\r\n\r\n  // =============================================================================\r\n  // HELPERS\r\n  // =============================================================================\r\n\r\n  private mapRowToEndpoint(row: any): MeteredEndpoint {\r\n    return {\r\n      id: row.id,\r\n      name: row.name,\r\n      description: row.description,\r\n      upstreamUrl: row.upstream_url,\r\n      price: row.price,\r\n      network: row.network,\r\n      tokenAddress: row.token_address,\r\n      tokenSymbol: row.token_symbol,\r\n      chainId: row.chain_id,\r\n      recipientAddress: row.recipient_address,\r\n      status: row.status,\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      createdBy: row.created_by,\r\n    };\r\n  }\r\n\r\n  private mapRowToPayment(row: any): Payment {\r\n    return {\r\n      id: row.id,\r\n      endpointId: row.endpoint_id,\r\n      txHash: row.tx_hash,\r\n      fromAddress: row.from_address,\r\n      toAddress: row.to_address,\r\n      amount: row.amount,\r\n      tokenAddress: row.token_address,\r\n      network: row.network,\r\n      verifiedAt: row.verified_at,\r\n      kytStatus: row.kyt_status,\r\n      ofacStatus: row.ofac_status,\r\n      facilitator: row.facilitator,\r\n    };\r\n  }\r\n\r\n  private mapRowToUsageLog(row: any): UsageLog {\r\n    return {\r\n      id: row.id,\r\n      endpointId: row.endpoint_id,\r\n      paymentId: row.payment_id,\r\n      timestamp: row.timestamp,\r\n      method: row.method,\r\n      path: row.path,\r\n      statusCode: row.status_code,\r\n      responseTime: row.response_time,\r\n      units: row.units,\r\n      ipAddress: row.ip_address,\r\n      userAgent: row.user_agent,\r\n      conversationId: row.conversation_id,\r\n      agentId: row.agent_id,\r\n      x402TxHash: row.x402_tx_hash,\r\n      failureCode: row.failure_code,\r\n    };\r\n  }\r\n\r\n  // =============================================================================\r\n  // API KEYS\r\n  // =============================================================================\r\n\r\n  async createApiKey(apiKey: { id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; expiresAt?: string; createdAt: string; updatedAt: string }): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }> {\r\n    await this.pool.query(\r\n      `INSERT INTO api_keys (id, key_hash, name, role, user_id, rate_limit, expires_at, created_at, updated_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,\r\n      [\r\n        apiKey.id, apiKey.keyHash, apiKey.name, apiKey.role, apiKey.userId || null,\r\n        apiKey.rateLimit, apiKey.expiresAt || null, apiKey.createdAt, apiKey.updatedAt,\r\n      ]\r\n    );\r\n    return this.findApiKeyByHash(apiKey.keyHash) as Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }>;\r\n  }\r\n\r\n  async findApiKeyByHash(keyHash: string): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string } | null> {\r\n    const result = await this.pool.query(\r\n      `SELECT * FROM api_keys WHERE key_hash = $1 AND revoked_at IS NULL`,\r\n      [keyHash]\r\n    );\r\n    if (result.rows.length === 0) return null;\r\n    const row = result.rows[0];\r\n    return {\r\n      id: row.id,\r\n      keyHash: row.key_hash,\r\n      name: row.name,\r\n      role: row.role,\r\n      userId: row.user_id,\r\n      rateLimit: row.rate_limit,\r\n      lastUsedAt: row.last_used_at,\r\n      lastUsedIp: row.last_used_ip,\r\n      expiresAt: row.expires_at,\r\n      x402DemoCallsUsed: row.x402_demo_calls_used || 0,\r\n      x402DemoCallsLimit: row.x402_demo_calls_limit || 200,\r\n      x402DemoAmountUsed: row.x402_demo_amount_used || '0',\r\n      x402DemoAmountLimit: row.x402_demo_amount_limit || '1000000',\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      revokedAt: row.revoked_at,\r\n    };\r\n  }\r\n\r\n  async updateApiKeyLastUsed(keyId: string, ipAddress?: string): Promise<void> {\r\n    await this.pool.query(\r\n      `UPDATE api_keys SET last_used_at = NOW(), last_used_ip = $2, updated_at = NOW() WHERE id = $1`,\r\n      [keyId, ipAddress || null]\r\n    );\r\n  }\r\n\r\n  async updateApiKeyX402DemoAllowance(keyId: string, callsUsed: number, amountUsed: string): Promise<void> {\r\n    await this.pool.query(\r\n      `UPDATE api_keys SET x402_demo_calls_used = $2, x402_demo_amount_used = $3, updated_at = NOW() WHERE id = $1`,\r\n      [keyId, callsUsed, amountUsed]\r\n    );\r\n  }\r\n\r\n  async updateApiKeyX402DemoLimits(keyId: string, callsLimit?: number, amountLimit?: string): Promise<void> {\r\n    if (callsLimit !== undefined && amountLimit !== undefined) {\r\n      await this.pool.query(\r\n        `UPDATE api_keys SET x402_demo_calls_limit = $2, x402_demo_amount_limit = $3, updated_at = NOW() WHERE id = $1`,\r\n        [keyId, callsLimit, amountLimit]\r\n      );\r\n    } else if (callsLimit !== undefined) {\r\n      await this.pool.query(\r\n        `UPDATE api_keys SET x402_demo_calls_limit = $2, updated_at = NOW() WHERE id = $1`,\r\n        [keyId, callsLimit]\r\n      );\r\n    } else if (amountLimit !== undefined) {\r\n      await this.pool.query(\r\n        `UPDATE api_keys SET x402_demo_amount_limit = $2, updated_at = NOW() WHERE id = $1`,\r\n        [keyId, amountLimit]\r\n      );\r\n    }\r\n  }\r\n\r\n  async revokeApiKey(keyId: string): Promise<boolean> {\r\n    const result = await this.pool.query(\r\n      `UPDATE api_keys SET revoked_at = NOW(), updated_at = NOW() WHERE id = $1 AND revoked_at IS NULL`,\r\n      [keyId]\r\n    );\r\n    return result.rowCount > 0;\r\n  }\r\n\r\n  async listApiKeys(userId?: string): Promise<{ id: string; keyHash: string; name: string; role: string; userId?: string; rateLimit: number; lastUsedAt?: string; expiresAt?: string; createdAt: string; updatedAt: string; revokedAt?: string }[]> {\r\n    let query = `SELECT * FROM api_keys WHERE revoked_at IS NULL`;\r\n    const params: any[] = [];\r\n    if (userId) {\r\n      query += ` AND user_id = $1`;\r\n      params.push(userId);\r\n    }\r\n    query += ` ORDER BY created_at DESC`;\r\n    const result = await this.pool.query(query, params);\r\n    return result.rows.map((row) => ({\r\n      id: row.id,\r\n      keyHash: row.key_hash,\r\n      name: row.name,\r\n      role: row.role,\r\n      userId: row.user_id,\r\n      rateLimit: row.rate_limit,\r\n      lastUsedAt: row.last_used_at,\r\n      lastUsedIp: row.last_used_ip,\r\n      expiresAt: row.expires_at,\r\n      x402DemoCallsUsed: row.x402_demo_calls_used || 0,\r\n      x402DemoCallsLimit: row.x402_demo_calls_limit || 200,\r\n      x402DemoAmountUsed: row.x402_demo_amount_used || '0',\r\n      x402DemoAmountLimit: row.x402_demo_amount_limit || '1000000',\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      revokedAt: row.revoked_at,\r\n    }));\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    await this.pool.end();\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6202, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/client.ts"],"sourcesContent":["// =============================================================================\r\n// DATABASE CLIENT FACTORY\r\n// =============================================================================\r\n// Automatically selects SQLite (dev) or PostgreSQL (prod) based on environment\r\n\r\nimport type { DatabaseAdapter } from './adapters/base-adapter';\r\nimport { SqliteAdapter } from './adapters/sqlite-adapter';\r\nimport { PostgresAdapter } from './adapters/postgres-adapter';\r\n\r\nlet dbAdapter: DatabaseAdapter | null = null;\r\n\r\n/**\r\n * Get the database adapter instance\r\n * Uses PostgreSQL if DATABASE_URL is set, otherwise falls back to SQLite\r\n */\r\nexport function getDb(): DatabaseAdapter {\r\n  if (dbAdapter) {\r\n    return dbAdapter;\r\n  }\r\n\r\n  const databaseUrl = process.env.DATABASE_URL;\r\n\r\n  if (databaseUrl && databaseUrl.startsWith('postgresql://')) {\r\n    // Production: Use PostgreSQL\r\n    console.log('[db] Using PostgreSQL adapter');\r\n    dbAdapter = new PostgresAdapter(databaseUrl);\r\n  } else {\r\n    // Development: Use SQLite\r\n    console.log('[db] Using SQLite adapter (development mode)');\r\n    dbAdapter = new SqliteAdapter();\r\n  }\r\n\r\n  return dbAdapter;\r\n}\r\n\r\n/**\r\n * Close database connections (useful for cleanup in tests)\r\n */\r\nexport async function closeDb(): Promise<void> {\r\n  if (dbAdapter) {\r\n    if ('close' in dbAdapter && typeof dbAdapter.close === 'function') {\r\n      await dbAdapter.close();\r\n    }\r\n    dbAdapter = null;\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;AAC1B,gFAAgF;AAChF,+EAA+E;;;;;;;AAG/E;AACA;;;;;;;AAEA,IAAI,YAAoC;AAMjC,SAAS;IACd,IAAI,WAAW;QACb,OAAO;IACT;IAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY;IAE5C,IAAI,eAAe,YAAY,UAAU,CAAC,kBAAkB;QAC1D,6BAA6B;QAC7B,QAAQ,GAAG,CAAC;QACZ,YAAY,IAAI,iKAAe,CAAC;IAClC,OAAO;QACL,0BAA0B;QAC1B,QAAQ,GAAG,CAAC;QACZ,YAAY,IAAI,6JAAa;IAC/B;IAEA,OAAO;AACT;AAKO,eAAe;IACpB,IAAI,WAAW;QACb,IAAI,WAAW,aAAa,OAAO,UAAU,KAAK,KAAK,YAAY;YACjE,MAAM,UAAU,KAAK;QACvB;QACA,YAAY;IACd;AACF"}},
    {"offset": {"line": 6252, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/smf.ts"],"sourcesContent":["// =============================================================================\r\n// SMF DATABASE OPERATIONS\r\n// =============================================================================\r\n// Database operations for Smart Meta-Facilitator routing, attempts, and health\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'SMFDatabase' });\r\n\r\nexport interface Facilitator {\r\n  id: string;\r\n  name: string;\r\n  status: 'active' | 'disabled' | 'testing';\r\n  base_url: string;\r\n  priority: number;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface FacilitatorCapability {\r\n  id: string;\r\n  facilitator_id: string;\r\n  network: string;\r\n  token: string;\r\n  min_amount: string;\r\n  max_amount: string | null;\r\n  fee_bps: number;\r\n  regions: string[] | null;\r\n  supports_deferred: boolean;\r\n  supports_subscriptions: boolean;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface Route {\r\n  id: string;\r\n  request_id: string | null;\r\n  correlation_id: string | null;\r\n  client_id: string | null;\r\n  agent_id: string | null;\r\n  network: string;\r\n  token: string;\r\n  amount: string;\r\n  selected_facilitator_id: string;\r\n  status: 'planned' | 'verifying' | 'settling' | 'settled' | 'failed';\r\n  created_at: string;\r\n  updated_at: string;\r\n  completed_at: string | null;\r\n}\r\n\r\nexport interface RouteAttempt {\r\n  id: string;\r\n  route_id: string;\r\n  facilitator_id: string;\r\n  phase: 'verify' | 'settle';\r\n  result: 'success' | 'failure' | 'timeout' | 'rate_limited' | 'insufficient_liquidity' | 'invalid_request' | 'network_error';\r\n  latency_ms: number;\r\n  error_code: string | null;\r\n  raw_status: number | null;\r\n  is_probe: boolean;\r\n  created_at: string;\r\n}\r\n\r\nexport interface FacilitatorHealthSnapshot {\r\n  id: string;\r\n  facilitator_id: string;\r\n  network: string;\r\n  token: string;\r\n  window_start: string;\r\n  window_end: string;\r\n  success_rate: number;\r\n  p50_latency_ms: number | null;\r\n  p95_latency_ms: number | null;\r\n  p99_latency_ms: number | null;\r\n  error_rate: number;\r\n  last_error_type: string | null;\r\n  status: 'healthy' | 'degraded' | 'down';\r\n  created_at: string;\r\n}\r\n\r\n/**\r\n * Create a route record\r\n */\r\nexport async function createRoute(route: Omit<Route, 'id' | 'created_at' | 'updated_at' | 'completed_at'>): Promise<Route> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO routes (\r\n        id, request_id, correlation_id, client_id, agent_id, network, token, amount,\r\n        selected_facilitator_id, status, created_at, updated_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        route.request_id,\r\n        route.correlation_id,\r\n        route.client_id,\r\n        route.agent_id,\r\n        route.network,\r\n        route.token,\r\n        route.amount,\r\n        route.selected_facilitator_id,\r\n        route.status,\r\n        now,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO routes (\r\n        id, request_id, correlation_id, client_id, agent_id, network, token, amount,\r\n        selected_facilitator_id, status, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      route.request_id,\r\n      route.correlation_id,\r\n      route.client_id,\r\n      route.agent_id,\r\n      route.network,\r\n      route.token,\r\n      route.amount,\r\n      route.selected_facilitator_id,\r\n      route.status,\r\n      now,\r\n      now\r\n    );\r\n    return {\r\n      id,\r\n      ...route,\r\n      created_at: now,\r\n      updated_at: now,\r\n      completed_at: null,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update route status\r\n */\r\nexport async function updateRouteStatus(\r\n  routeId: string,\r\n  status: Route['status'],\r\n  completedAt?: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE routes SET status = $1, updated_at = $2, completed_at = $3 WHERE id = $4`,\r\n      [status, now, completedAt || null, routeId]\r\n    );\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(\r\n      `UPDATE routes SET status = ?, updated_at = ?, completed_at = ? WHERE id = ?`\r\n    );\r\n    stmt.run(status, now, completedAt || null, routeId);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a route attempt record\r\n */\r\nexport async function createRouteAttempt(\r\n  attempt: Omit<RouteAttempt, 'id' | 'created_at'>\r\n): Promise<RouteAttempt> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO route_attempts (\r\n        id, route_id, facilitator_id, phase, result, latency_ms, error_code, raw_status, is_probe, created_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        attempt.route_id,\r\n        attempt.facilitator_id,\r\n        attempt.phase,\r\n        attempt.result,\r\n        attempt.latency_ms,\r\n        attempt.error_code,\r\n        attempt.raw_status,\r\n        attempt.is_probe ?? false,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO route_attempts (\r\n        id, route_id, facilitator_id, phase, result, latency_ms, error_code, raw_status, is_probe, created_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      attempt.route_id,\r\n      attempt.facilitator_id,\r\n      attempt.phase,\r\n      attempt.result,\r\n      attempt.latency_ms,\r\n      attempt.error_code,\r\n      attempt.raw_status,\r\n      attempt.is_probe ?? false,\r\n      now\r\n    );\r\n    return {\r\n      id,\r\n      ...attempt,\r\n      created_at: now,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get facilitator capabilities\r\n */\r\nexport async function getFacilitatorCapabilities(\r\n  facilitatorId?: string,\r\n  network?: string,\r\n  token?: string\r\n): Promise<FacilitatorCapability[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let query = 'SELECT * FROM facilitator_capabilities WHERE 1=1';\r\n  const params: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (facilitatorId) {\r\n    if (isPostgres) {\r\n      query += ` AND facilitator_id = $${paramIndex++}`;\r\n      params.push(facilitatorId);\r\n    } else {\r\n      query += ` AND facilitator_id = ?`;\r\n      params.push(facilitatorId);\r\n    }\r\n  }\r\n\r\n  if (network) {\r\n    if (isPostgres) {\r\n      query += ` AND network = $${paramIndex++}`;\r\n      params.push(network);\r\n    } else {\r\n      query += ` AND network = ?`;\r\n      params.push(network);\r\n    }\r\n  }\r\n\r\n  if (token) {\r\n    if (isPostgres) {\r\n      query += ` AND token = $${paramIndex++}`;\r\n      params.push(token);\r\n    } else {\r\n      query += ` AND token = ?`;\r\n      params.push(token);\r\n    }\r\n  }\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, params);\r\n    return result.rows;\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(query);\r\n    const rows = stmt.all(...params);\r\n    return rows;\r\n  }\r\n}\r\n\r\n/**\r\n * Get latest health snapshot for a facilitator/network/token\r\n */\r\nexport async function getLatestHealthSnapshot(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string\r\n): Promise<FacilitatorHealthSnapshot | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_health_snapshots\r\n       WHERE facilitator_id = $1 AND network = $2 AND token = $3\r\n       ORDER BY window_end DESC\r\n       LIMIT 1`,\r\n      [facilitatorId, network, token]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(\r\n      `SELECT * FROM facilitator_health_snapshots\r\n       WHERE facilitator_id = ? AND network = ? AND token = ?\r\n       ORDER BY window_end DESC\r\n       LIMIT 1`\r\n    );\r\n    const row = stmt.get(facilitatorId, network, token);\r\n    return row || null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get route attempts for health aggregation\r\n */\r\nexport async function getRouteAttemptsForHealth(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowStart: string,\r\n  windowEnd: string,\r\n  includeProbes: boolean = true\r\n): Promise<RouteAttempt[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  // Build probe route_id pattern for matching\r\n  const probePattern = `probe-${facilitatorId}-${network}-${token}%`;\r\n\r\n  if (isPostgres) {\r\n    // For probes, route_id starts with \"probe-{facilitatorId}-{network}-{token}\"\r\n    // For real routes, we join with routes table\r\n    const result = await (db as any).pool.query(\r\n      `SELECT ra.* FROM route_attempts ra\r\n       LEFT JOIN routes r ON (ra.route_id = r.id AND ra.is_probe = false)\r\n       WHERE ra.facilitator_id = $1\r\n         AND (\r\n           (ra.is_probe = true AND ra.route_id LIKE $2)\r\n           OR (ra.is_probe = false AND r.network = $3 AND r.token = $4)\r\n         )\r\n         AND ra.created_at >= $5\r\n         AND ra.created_at < $6\r\n       ORDER BY ra.created_at`,\r\n      [facilitatorId, probePattern, network, token, windowStart, windowEnd]\r\n    );\r\n    return result.rows;\r\n  } else {\r\n    // SQLite - similar logic\r\n    const stmt = (db as any).prepare(\r\n      `SELECT ra.* FROM route_attempts ra\r\n       LEFT JOIN routes r ON (ra.route_id = r.id AND ra.is_probe = 0)\r\n       WHERE ra.facilitator_id = ?\r\n         AND (\r\n           (ra.is_probe = 1 AND ra.route_id LIKE ?)\r\n           OR (ra.is_probe = 0 AND r.network = ? AND r.token = ?)\r\n         )\r\n         AND ra.created_at >= ?\r\n         AND ra.created_at < ?\r\n       ORDER BY ra.created_at`\r\n    );\r\n    const rows = stmt.all(facilitatorId, probePattern, network, token, windowStart, windowEnd);\r\n    return rows;\r\n  }\r\n}\r\n\r\n/**\r\n * Create or update health snapshot\r\n */\r\nexport async function upsertHealthSnapshot(\r\n  snapshot: Omit<FacilitatorHealthSnapshot, 'id' | 'created_at'>\r\n): Promise<FacilitatorHealthSnapshot> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    // Use ON CONFLICT for upsert\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO facilitator_health_snapshots (\r\n        id, facilitator_id, network, token, window_start, window_end,\r\n        success_rate, p50_latency_ms, p95_latency_ms, p99_latency_ms,\r\n        error_rate, last_error_type, status, created_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\r\n      ON CONFLICT (facilitator_id, network, token, window_end)\r\n      DO UPDATE SET\r\n        success_rate = EXCLUDED.success_rate,\r\n        p50_latency_ms = EXCLUDED.p50_latency_ms,\r\n        p95_latency_ms = EXCLUDED.p95_latency_ms,\r\n        p99_latency_ms = EXCLUDED.p99_latency_ms,\r\n        error_rate = EXCLUDED.error_rate,\r\n        last_error_type = EXCLUDED.last_error_type,\r\n        status = EXCLUDED.status\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        snapshot.facilitator_id,\r\n        snapshot.network,\r\n        snapshot.token,\r\n        snapshot.window_start,\r\n        snapshot.window_end,\r\n        snapshot.success_rate,\r\n        snapshot.p50_latency_ms,\r\n        snapshot.p95_latency_ms,\r\n        snapshot.p99_latency_ms,\r\n        snapshot.error_rate,\r\n        snapshot.last_error_type,\r\n        snapshot.status,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite - simple insert (no upsert for now)\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO facilitator_health_snapshots (\r\n        id, facilitator_id, network, token, window_start, window_end,\r\n        success_rate, p50_latency_ms, p95_latency_ms, p99_latency_ms,\r\n        error_rate, last_error_type, status, created_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      snapshot.facilitator_id,\r\n      snapshot.network,\r\n      snapshot.token,\r\n      snapshot.window_start,\r\n      snapshot.window_end,\r\n      snapshot.success_rate,\r\n      snapshot.p50_latency_ms,\r\n      snapshot.p95_latency_ms,\r\n      snapshot.p99_latency_ms,\r\n      snapshot.error_rate,\r\n      snapshot.last_error_type,\r\n      snapshot.status,\r\n      now\r\n    );\r\n    return {\r\n      id,\r\n      ...snapshot,\r\n      created_at: now,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Record facilitator probe event arguments\r\n */\r\nexport interface RecordFacilitatorProbeEventArgs {\r\n  probe_config_id: string;\r\n  facilitator_id: string;\r\n  network: string;\r\n  token: string;\r\n  result: 'success' | 'failure';\r\n  error_code: string | null;\r\n  facilitator_status: number | null;\r\n  facilitator_error_code: string | null;\r\n  latency_ms: number;\r\n}\r\n\r\n/**\r\n * Record a facilitator probe event for analytics\r\n */\r\nexport async function recordFacilitatorProbeEvent(event: RecordFacilitatorProbeEventArgs): Promise<void> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `INSERT INTO facilitator_probe_events (\r\n        probe_config_id, facilitator_id, network, token, result,\r\n        error_code, facilitator_status, facilitator_error_code, latency_ms\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,\r\n      [\r\n        event.probe_config_id,\r\n        event.facilitator_id,\r\n        event.network,\r\n        event.token,\r\n        event.result,\r\n        event.error_code,\r\n        event.facilitator_status,\r\n        event.facilitator_error_code,\r\n        event.latency_ms,\r\n      ]\r\n    );\r\n  } else {\r\n    // SQLite - table might not exist, skip silently\r\n    logger.warn('facilitator_probe_events table not available in SQLite');\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6575, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/health-aggregator.ts"],"sourcesContent":["// =============================================================================\r\n// HEALTH AGGREGATOR\r\n// =============================================================================\r\n// Aggregates health metrics from route attempts for scoring and monitoring\r\n\r\nimport { getRouteAttemptsForHealth, upsertHealthSnapshot, getLatestHealthSnapshot, type RouteAttempt, type FacilitatorHealthSnapshot } from '@/db/smf';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'HealthAggregator' });\r\n\r\n/**\r\n * Calculate percentile from sorted array\r\n */\r\nfunction percentile(sortedValues: number[], p: number): number {\r\n  if (sortedValues.length === 0) return 0;\r\n  const index = Math.ceil((p / 100) * sortedValues.length) - 1;\r\n  return sortedValues[Math.max(0, index)];\r\n}\r\n\r\n/**\r\n * Aggregate health metrics from route attempts\r\n */\r\nexport async function aggregateHealthMetrics(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowStart: Date,\r\n  windowEnd: Date\r\n): Promise<FacilitatorHealthSnapshot | null> {\r\n  try {\r\n    const attempts = await getRouteAttemptsForHealth(\r\n      facilitatorId,\r\n      network,\r\n      token,\r\n      windowStart.toISOString(),\r\n      windowEnd.toISOString()\r\n    );\r\n\r\n    if (attempts.length === 0) {\r\n      logger.debug({ facilitatorId, network, token }, 'No attempts found for health aggregation');\r\n      return null;\r\n    }\r\n\r\n    // Calculate success rate\r\n    const successful = attempts.filter((a) => a.result === 'success').length;\r\n    const successRate = successful / attempts.length;\r\n\r\n    // Calculate latency percentiles\r\n    const latencies = attempts\r\n      .map((a) => a.latency_ms)\r\n      .filter((l) => l > 0)\r\n      .sort((a, b) => a - b);\r\n\r\n    const p50 = latencies.length > 0 ? percentile(latencies, 50) : null;\r\n    const p95 = latencies.length > 0 ? percentile(latencies, 95) : null;\r\n    const p99 = latencies.length > 0 ? percentile(latencies, 99) : null;\r\n\r\n    // Calculate error rate\r\n    const errors = attempts.filter((a) => a.result !== 'success').length;\r\n    const errorRate = errors / attempts.length;\r\n\r\n    // Get last error type\r\n    const failedAttempts = attempts.filter((a) => a.result !== 'success');\r\n    const lastErrorType = failedAttempts.length > 0 ? failedAttempts[failedAttempts.length - 1].result : null;\r\n\r\n    // Determine status\r\n    let status: 'healthy' | 'degraded' | 'down' = 'healthy';\r\n    if (successRate < 0.5) {\r\n      status = 'down';\r\n    } else if (successRate < 0.9 || (p95 && p95 > 5000)) {\r\n      status = 'degraded';\r\n    }\r\n\r\n    const snapshot: Omit<FacilitatorHealthSnapshot, 'id' | 'created_at'> = {\r\n      facilitator_id: facilitatorId,\r\n      network,\r\n      token,\r\n      window_start: windowStart.toISOString(),\r\n      window_end: windowEnd.toISOString(),\r\n      success_rate: successRate,\r\n      p50_latency_ms: p50,\r\n      p95_latency_ms: p95,\r\n      p99_latency_ms: p99,\r\n      error_rate: errorRate,\r\n      last_error_type: lastErrorType,\r\n      status,\r\n    };\r\n\r\n    const saved = await upsertHealthSnapshot(snapshot);\r\n    logger.info(\r\n      {\r\n        facilitatorId,\r\n        network,\r\n        token,\r\n        successRate,\r\n        p95Latency: p95,\r\n        status,\r\n        attempts: attempts.length,\r\n      },\r\n      'Health snapshot created'\r\n    );\r\n\r\n    return saved;\r\n  } catch (error) {\r\n    logger.error({ error, facilitatorId, network, token }, 'Failed to aggregate health metrics');\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get current health for a facilitator/network/token\r\n * Returns latest snapshot or calculates from recent attempts\r\n */\r\nexport async function getCurrentHealth(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowMinutes: number = 15\r\n): Promise<{\r\n  successRate: number;\r\n  p50LatencyMs: number | null;\r\n  p95LatencyMs: number | null;\r\n  p99LatencyMs: number | null;\r\n  errorRate: number;\r\n  lastErrorType: string | null;\r\n  status: 'healthy' | 'degraded' | 'down';\r\n}> {\r\n  // Try to get latest snapshot first\r\n  const snapshot = await getLatestHealthSnapshot(facilitatorId, network, token);\r\n\r\n  if (snapshot) {\r\n    const snapshotAge = Date.now() - new Date(snapshot.window_end).getTime();\r\n    const maxAge = windowMinutes * 60 * 1000;\r\n\r\n    // If snapshot is recent enough, use it\r\n    if (snapshotAge < maxAge) {\r\n      return {\r\n        successRate: Number(snapshot.success_rate),\r\n        p50LatencyMs: snapshot.p50_latency_ms,\r\n        p95LatencyMs: snapshot.p95_latency_ms,\r\n        p99LatencyMs: snapshot.p99_latency_ms,\r\n        errorRate: Number(snapshot.error_rate),\r\n        lastErrorType: snapshot.last_error_type,\r\n        status: snapshot.status,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Otherwise, calculate from recent attempts\r\n  const windowEnd = new Date();\r\n  const windowStart = new Date(windowEnd.getTime() - windowMinutes * 60 * 1000);\r\n\r\n  const aggregated = await aggregateHealthMetrics(facilitatorId, network, token, windowStart, windowEnd);\r\n\r\n  if (aggregated) {\r\n    return {\r\n      successRate: Number(aggregated.success_rate),\r\n      p50LatencyMs: aggregated.p50_latency_ms,\r\n      p95LatencyMs: aggregated.p95_latency_ms,\r\n      p99LatencyMs: aggregated.p99_latency_ms,\r\n      errorRate: Number(aggregated.error_rate),\r\n      lastErrorType: aggregated.last_error_type,\r\n      status: aggregated.status,\r\n    };\r\n  }\r\n\r\n  // Default values if no data\r\n  return {\r\n    successRate: 1.0,\r\n    p50LatencyMs: null,\r\n    p95LatencyMs: null,\r\n    p99LatencyMs: null,\r\n    errorRate: 0.0,\r\n    lastErrorType: null,\r\n    status: 'healthy',\r\n  };\r\n}\r\n\r\n/**\r\n * Periodic job to update health snapshots\r\n * Should be called every 5-15 minutes\r\n */\r\nexport async function updateHealthSnapshots(windowMinutes: number = 15): Promise<void> {\r\n  logger.info({ windowMinutes }, 'Starting health snapshot update');\r\n\r\n  // Get all unique facilitator/network/token combinations from recent routes\r\n  // For now, we'll focus on CDP/Base/USDC - can be expanded later\r\n  const combinations = [\r\n    { facilitatorId: 'cdp', network: 'base', token: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' },\r\n  ];\r\n\r\n  const windowEnd = new Date();\r\n  const windowStart = new Date(windowEnd.getTime() - windowMinutes * 60 * 1000);\r\n\r\n  await Promise.all(\r\n    combinations.map(async (combo) => {\r\n      try {\r\n        await aggregateHealthMetrics(combo.facilitatorId, combo.network, combo.token, windowStart, windowEnd);\r\n      } catch (error) {\r\n        logger.error({ error, ...combo }, 'Failed to update health snapshot');\r\n      }\r\n    })\r\n  );\r\n\r\n  logger.info('Health snapshot update complete');\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6749, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/dummy-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// DUMMY FACILITATOR (FOR TESTING)\r\n// =============================================================================\r\n// Test facilitator that wraps CDP or provides mock behavior\r\n// Used to test routing logic, priority ties, failover, etc.\r\n\r\nimport { BaseFacilitator, type IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorHealth, type FacilitatorConfig } from './base-facilitator';\r\nimport { getCDPFacilitatorAdapter } from './cdp-facilitator-adapter';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'DummyFacilitator' });\r\n\r\n/**\r\n * Dummy Facilitator\r\n * \r\n * Can be configured to:\r\n * - Wrap CDP (for testing routing with same backend)\r\n * - Provide mock behavior (for testing without real payments)\r\n * - Simulate failures (for testing failover)\r\n */\r\nexport class DummyFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id: string;\r\n  readonly name: string;\r\n  readonly config: FacilitatorConfig;\r\n  \r\n  private wrapCDP: boolean;\r\n  private mockBehavior?: 'success' | 'failure' | 'timeout';\r\n  private cdpAdapter?: ReturnType<typeof getCDPFacilitatorAdapter>;\r\n\r\n  constructor(\r\n    id: string = 'dummy',\r\n    name: string = 'Dummy Facilitator',\r\n    config: Partial<FacilitatorConfig> = {},\r\n    options: {\r\n      wrapCDP?: boolean; // If true, wraps CDP adapter\r\n      mockBehavior?: 'success' | 'failure' | 'timeout'; // Mock behavior if not wrapping CDP\r\n    } = {}\r\n  ) {\r\n    super();\r\n    this.id = id;\r\n    this.name = name;\r\n    this.wrapCDP = options.wrapCDP ?? false;\r\n    this.mockBehavior = options.mockBehavior;\r\n\r\n    // Default config (can be overridden)\r\n    this.config = {\r\n      id: this.id,\r\n      name: this.name,\r\n      enabled: true,\r\n      priority: 2, // Lower priority than CDP (for testing priority-based routing)\r\n      networks: ['base'],\r\n      networksCAIP: ['eip155:8453'], // CAIP-2: Base mainnet\r\n      assets: ['0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // USDC on Base\r\n      assetsCAIP: ['eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // CAIP-19: USDC on Base\r\n      schemes: ['exact', 'x402'],\r\n      settlementModes: ['immediate'], // Default to immediate settlement\r\n      ...config,\r\n    };\r\n\r\n    if (this.wrapCDP) {\r\n      this.cdpAdapter = getCDPFacilitatorAdapter();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify payment\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    // If wrapping CDP, delegate to CDP\r\n    if (this.wrapCDP && this.cdpAdapter) {\r\n      logger.info({ payment: payment.substring(0, 20) + '...' }, 'Dummy facilitator delegating to CDP');\r\n      return await this.cdpAdapter.verify(payment, requirements);\r\n    }\r\n\r\n    // Mock behavior for testing\r\n    if (this.mockBehavior === 'failure') {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: 'Mock failure for testing',\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    if (this.mockBehavior === 'timeout') {\r\n      await new Promise((resolve) => setTimeout(resolve, 10000)); // 10 second delay\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: 'Mock timeout for testing',\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    // Mock success\r\n    return {\r\n      success: true,\r\n      valid: true,\r\n      transactionHash: `0x${Math.random().toString(16).substring(2, 66)}`,\r\n      kytStatus: 'passed',\r\n      ofacStatus: 'passed',\r\n      facilitatorId: this.id,\r\n      verifiedAt: new Date().toISOString(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get health status\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    // If wrapping CDP, delegate to CDP\r\n    if (this.wrapCDP && this.cdpAdapter) {\r\n      return await this.cdpAdapter.getHealth();\r\n    }\r\n\r\n    // Mock health (always healthy for testing)\r\n    return {\r\n      healthy: true,\r\n      latency: 50, // Mock low latency\r\n      lastChecked: new Date().toISOString(),\r\n      capabilities: {\r\n        networks: this.config.networks,\r\n        assets: this.config.assets,\r\n        schemes: this.config.schemes,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: string): boolean {\r\n    return super.supports(network, asset, scheme, settlementMode as any);\r\n  }\r\n\r\n  /**\r\n   * Get pricing (mock)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    if (this.wrapCDP && this.cdpAdapter) {\r\n      return await this.cdpAdapter.getPricing(network, asset);\r\n    }\r\n\r\n    // Mock pricing (slightly higher than CDP to test cost optimization)\r\n    if (network === 'base' && asset === '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913') {\r\n      return {\r\n        network: 'base',\r\n        asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n        baseFee: '1000', // Slightly higher than CDP\r\n        percentageFee: 0.001, // 0.1%\r\n        estimatedGas: '21000',\r\n        currency: 'USDC',\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Create a dummy facilitator for testing\r\n */\r\nexport function createDummyFacilitator(\r\n  id: string = 'dummy',\r\n  options?: {\r\n    wrapCDP?: boolean;\r\n    mockBehavior?: 'success' | 'failure' | 'timeout';\r\n    priority?: number;\r\n  }\r\n): DummyFacilitator {\r\n  return new DummyFacilitator(\r\n    id,\r\n    `Dummy Facilitator (${id})`,\r\n    {\r\n      priority: options?.priority ?? 2,\r\n    },\r\n    {\r\n      wrapCDP: options?.wrapCDP ?? false,\r\n      mockBehavior: options?.mockBehavior,\r\n    }\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,kCAAkC;AAClC,gFAAgF;AAChF,4DAA4D;AAC5D,4DAA4D;;;;;;;AAE5D;AACA;AACA;;;;AAEA,MAAM,SAAS,IAAA,sIAAY,EAAC;IAAE,WAAW;AAAmB;AAUrD,MAAM,yBAAyB,uLAAe;IAC1C,GAAW;IACX,KAAa;IACb,OAA0B;IAE3B,QAAiB;IACjB,aAAiD;IACjD,WAAyD;IAEjE,YACE,KAAa,OAAO,EACpB,OAAe,mBAAmB,EAClC,SAAqC,CAAC,CAAC,EACvC,UAGI,CAAC,CAAC,CACN;QACA,KAAK;QACL,IAAI,CAAC,EAAE,GAAG;QACV,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,OAAO,GAAG,QAAQ,OAAO,IAAI;QAClC,IAAI,CAAC,YAAY,GAAG,QAAQ,YAAY;QAExC,qCAAqC;QACrC,IAAI,CAAC,MAAM,GAAG;YACZ,IAAI,IAAI,CAAC,EAAE;YACX,MAAM,IAAI,CAAC,IAAI;YACf,SAAS;YACT,UAAU;YACV,UAAU;gBAAC;aAAO;YAClB,cAAc;gBAAC;aAAc;YAC7B,QAAQ;gBAAC;aAA6C;YACtD,YAAY;gBAAC;aAA+D;YAC5E,SAAS;gBAAC;gBAAS;aAAO;YAC1B,iBAAiB;gBAAC;aAAY;YAC9B,GAAG,MAAM;QACX;QAEA,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,IAAI,CAAC,UAAU,GAAG,IAAA,0MAAwB;QAC5C;IACF;IAEA;;GAEC,GACD,MAAM,OACJ,OAAe,EACf,YAAiC,EACJ;QAC7B,wBAAwB;QACxB,MAAM,aAAa,IAAI,CAAC,oBAAoB,CAAC;QAC7C,IAAI,CAAC,WAAW,KAAK,EAAE;YACrB,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,OAAO,WAAW,KAAK;gBACvB,eAAe,IAAI,CAAC,EAAE;gBACtB,YAAY,IAAI,OAAO,WAAW;YACpC;QACF;QAEA,mCAAmC;QACnC,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,UAAU,EAAE;YACnC,OAAO,IAAI,CAAC;gBAAE,SAAS,QAAQ,SAAS,CAAC,GAAG,MAAM;YAAM,GAAG;YAC3D,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,SAAS;QAC/C;QAEA,4BAA4B;QAC5B,IAAI,IAAI,CAAC,YAAY,KAAK,WAAW;YACnC,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,OAAO;gBACP,eAAe,IAAI,CAAC,EAAE;gBACtB,YAAY,IAAI,OAAO,WAAW;YACpC;QACF;QAEA,IAAI,IAAI,CAAC,YAAY,KAAK,WAAW;YACnC,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS,SAAS,kBAAkB;YAC9E,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,OAAO;gBACP,eAAe,IAAI,CAAC,EAAE;gBACtB,YAAY,IAAI,OAAO,WAAW;YACpC;QACF;QAEA,eAAe;QACf,OAAO;YACL,SAAS;YACT,OAAO;YACP,iBAAiB,CAAC,EAAE,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,KAAK;YACnE,WAAW;YACX,YAAY;YACZ,eAAe,IAAI,CAAC,EAAE;YACtB,YAAY,IAAI,OAAO,WAAW;QACpC;IACF;IAEA;;GAEC,GACD,MAAM,YAAwC;QAC5C,mCAAmC;QACnC,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,UAAU,EAAE;YACnC,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,SAAS;QACxC;QAEA,2CAA2C;QAC3C,OAAO;YACL,SAAS;YACT,SAAS;YACT,aAAa,IAAI,OAAO,WAAW;YACnC,cAAc;gBACZ,UAAU,IAAI,CAAC,MAAM,CAAC,QAAQ;gBAC9B,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM;gBAC1B,SAAS,IAAI,CAAC,MAAM,CAAC,OAAO;YAC9B;QACF;IACF;IAEA;;GAEC,GACD,SAAS,OAAe,EAAE,KAAa,EAAE,MAAc,EAAE,cAAuB,EAAW;QACzF,OAAO,KAAK,CAAC,SAAS,SAAS,OAAO,QAAQ;IAChD;IAEA;;GAEC,GACD,MAAM,WAAW,OAAe,EAAE,KAAa,EAAE;QAC/C,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,UAAU,EAAE;YACnC,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,SAAS;QACnD;QAEA,oEAAoE;QACpE,IAAI,YAAY,UAAU,UAAU,8CAA8C;YAChF,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,SAAS;gBACT,eAAe;gBACf,cAAc;gBACd,UAAU;YACZ;QACF;QACA,OAAO;IACT;AACF;AAKO,SAAS,uBACd,KAAa,OAAO,EACpB,OAIC;IAED,OAAO,IAAI,iBACT,IACA,CAAC,mBAAmB,EAAE,GAAG,CAAC,CAAC,EAC3B;QACE,UAAU,SAAS,YAAY;IACjC,GACA;QACE,SAAS,SAAS,WAAW;QAC7B,cAAc,SAAS;IACzB;AAEJ"}},
    {"offset": {"line": 6923, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/facilitator-router.ts"],"sourcesContent":["// =============================================================================\r\n// FACILITATOR ROUTER\r\n// =============================================================================\r\n// Smart routing logic for selecting the best facilitator based on policy\r\n// Implements \"meta-facilitator\" pattern: SDK expresses preferences, SMF owns policy\r\n\r\nimport { IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorConfig, type CAIPNetworkId, type CAIPAssetId, type SettlementMode } from './base-facilitator';\r\nimport { getCDPFacilitatorAdapter } from './cdp-facilitator-adapter';\r\nimport { getPayAIFacilitator } from './payai-facilitator';\r\nimport { getX402rsFacilitator } from './x402rs-facilitator';\r\nimport { getDexterFacilitator } from './dexter-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { getCurrentHealth } from './health-aggregator';\r\nimport { getFacilitatorCapabilities } from '@/db/smf';\r\nimport type { FacilitatorId } from './facilitator-registry';\r\nimport {\r\n  getFacilitatorScore,\r\n  getFacilitatorExplainer,\r\n  type FacilitatorScore,\r\n  type FacilitatorExplanation,\r\n} from '@/services/facilitator-metrics-reader';\r\nimport type { FacilitatorPathMetricsTimeframe } from '@/infra/x402scan/types';\r\nimport {\r\n  getScatteringMetricsForFacilitator,\r\n  computeActivityScore,\r\n} from '@/services/facilitator-volume-service';\r\nimport type { ScatteringFacilitatorMetrics } from '@/infra/scattering/types';\r\n\r\nconst logger = createLogger({ component: 'FacilitatorRouter' });\r\n\r\n// =============================================================================\r\n// X402SCAN METRICS INTEGRATION CONFIG\r\n// =============================================================================\r\n\r\n/**\r\n * Configuration for trusting x402scan metrics in routing decisions\r\n * Metrics are only used if they meet these freshness/confidence thresholds\r\n */\r\nexport interface X402ScanMetricsTrustConfig {\r\n  /** Maximum age of data to trust (hours) */\r\n  maxDataAgeHours: number;\r\n  /** Minimum invocations required for high confidence */\r\n  minInvocationsHighConfidence: number;\r\n  /** Minimum invocations required for medium confidence */\r\n  minInvocationsMediumConfidence: number;\r\n  /** Weight applied to x402scan score in overall routing (0-1) */\r\n  x402scanScoreWeight: number;\r\n  /** Timeframe to use for metrics */\r\n  timeframe: FacilitatorPathMetricsTimeframe;\r\n  /** Whether to log detailed explanations */\r\n  logExplanations: boolean;\r\n}\r\n\r\n/**\r\n * Default x402scan metrics trust configuration\r\n * Can be overridden via environment variables\r\n */\r\nconst DEFAULT_X402SCAN_TRUST_CONFIG: X402ScanMetricsTrustConfig = {\r\n  maxDataAgeHours: parseFloat(process.env.X402SCAN_MAX_DATA_AGE_HOURS ?? '4'),\r\n  minInvocationsHighConfidence: parseInt(process.env.X402SCAN_MIN_INVOCATIONS_HIGH ?? '1000', 10),\r\n  minInvocationsMediumConfidence: parseInt(process.env.X402SCAN_MIN_INVOCATIONS_MEDIUM ?? '100', 10),\r\n  x402scanScoreWeight: parseFloat(process.env.X402SCAN_SCORE_WEIGHT ?? '0.3'), // 30% weight\r\n  timeframe: (process.env.X402SCAN_TIMEFRAME ?? '1d') as FacilitatorPathMetricsTimeframe,\r\n  logExplanations: process.env.X402SCAN_LOG_EXPLANATIONS !== 'false',\r\n};\r\n\r\n// =============================================================================\r\n// SCATTERING / DUNE METRICS INTEGRATION CONFIG\r\n// =============================================================================\r\n\r\n/**\r\n * Configuration for Scattering/Dune activity metrics in routing decisions\r\n */\r\nexport interface ScatteringMetricsTrustConfig {\r\n  /** Weight applied to Scattering score in overall routing (0-1) */\r\n  scatteringScoreWeight: number;\r\n  /** Minimum 3-day transaction count to trust metrics */\r\n  minTxCount3d: number;\r\n  /** Maximum age of data to trust (hours) */\r\n  maxDataAgeHours: number;\r\n  /** Whether to log Scattering metrics */\r\n  logScatteringMetrics: boolean;\r\n}\r\n\r\n/**\r\n * Default Scattering metrics configuration\r\n */\r\nconst DEFAULT_SCATTERING_CONFIG: ScatteringMetricsTrustConfig = {\r\n  scatteringScoreWeight: parseFloat(process.env.SCATTERING_SCORE_WEIGHT ?? '0.2'), // 20% weight\r\n  minTxCount3d: parseInt(process.env.SCATTERING_MIN_TX_3D ?? '100', 10),\r\n  maxDataAgeHours: parseFloat(process.env.SCATTERING_MAX_DATA_AGE_HOURS ?? '24'),\r\n  logScatteringMetrics: process.env.SCATTERING_LOG_METRICS !== 'false',\r\n};\r\n\r\n/**\r\n * Check if Scattering metrics should be trusted based on freshness and activity\r\n */\r\nfunction shouldTrustScatteringMetrics(\r\n  metrics: ScatteringFacilitatorMetrics | null,\r\n  config: ScatteringMetricsTrustConfig = DEFAULT_SCATTERING_CONFIG\r\n): { trust: boolean; reason: string } {\r\n  if (!metrics) {\r\n    return { trust: false, reason: 'no-scattering-data' };\r\n  }\r\n\r\n  // Check data freshness\r\n  const dataAgeHours = (Date.now() - new Date(metrics.fetchedAt).getTime()) / (1000 * 60 * 60);\r\n  if (dataAgeHours > config.maxDataAgeHours) {\r\n    return { trust: false, reason: `data-too-old:${dataAgeHours.toFixed(1)}h` };\r\n  }\r\n\r\n  // Check minimum activity\r\n  if (metrics.txCount3d < config.minTxCount3d) {\r\n    return { trust: false, reason: `low-activity:${metrics.txCount3d}-txns` };\r\n  }\r\n\r\n  return { trust: true, reason: 'active' };\r\n}\r\n\r\n/**\r\n * Check if x402scan metrics should be trusted based on freshness/confidence\r\n */\r\nfunction shouldTrustX402ScanMetrics(\r\n  score: FacilitatorScore | null,\r\n  config: X402ScanMetricsTrustConfig = DEFAULT_X402SCAN_TRUST_CONFIG\r\n): { trust: boolean; reason: string } {\r\n  if (!score) {\r\n    return { trust: false, reason: 'no-x402scan-data' };\r\n  }\r\n\r\n  // Check data freshness\r\n  if (score.dataFreshness > config.maxDataAgeHours) {\r\n    return { trust: false, reason: `data-too-old:${score.dataFreshness.toFixed(1)}h` };\r\n  }\r\n\r\n  // Check minimum invocations for medium confidence\r\n  if (score.totalInvocations < config.minInvocationsMediumConfidence) {\r\n    return { trust: false, reason: `insufficient-data:${score.totalInvocations}-invocations` };\r\n  }\r\n\r\n  // Trust with appropriate confidence level\r\n  if (score.totalInvocations >= config.minInvocationsHighConfidence) {\r\n    return { trust: true, reason: 'high-confidence' };\r\n  }\r\n\r\n  return { trust: true, reason: 'medium-confidence' };\r\n}\r\n\r\n/**\r\n * Facilitator strategy for routing decisions\r\n * \r\n * - \"auto\": SMF chooses optimal facilitator based on health, cost, and policy\r\n * - \"cdp\": Force routing through Coinbase Developer Platform\r\n * - \"payai\": Force routing through PayAI facilitator\r\n * - \"x402rs\": Force routing through X402rs (Rust community facilitator)\r\n * - \"dexter\": Force routing through Dexter (Solana-native facilitator)\r\n */\r\nexport type FacilitatorStrategy = 'auto' | 'cdp' | 'payai' | 'x402rs' | 'dexter';\r\n\r\n/**\r\n * Routing preferences (from SDK/agent)\r\n * SDK expresses preferences, SMF owns policy\r\n */\r\nexport interface RoutingPreferences {\r\n  preferredNetworks?: string[]; // Legacy: e.g., ['solana', 'base']\r\n  preferredNetworksCAIP?: CAIPNetworkId[]; // CAIP-2 network identifiers\r\n  preferredAssets?: string[]; // Legacy: e.g., ['USDC']\r\n  preferredAssetsCAIP?: CAIPAssetId[]; // CAIP-19 asset identifiers\r\n  avoidNetworks?: string[]; // Legacy: e.g., ['ethereum'] (mainnet too expensive)\r\n  avoidNetworksCAIP?: CAIPNetworkId[]; // CAIP-2 networks to avoid\r\n  maxCost?: number; // Maximum cost in USD\r\n  requireCompliance?: boolean; // Require KYT/OFAC\r\n  priority?: 'cost' | 'speed' | 'reliability' | 'compliance';\r\n  jurisdiction?: string; // ISO country code (e.g., 'US', 'GB')\r\n  settlementMode?: SettlementMode; // Preferred settlement mode\r\n  /** Facilitator strategy - explicit facilitator selection or auto */\r\n  facilitatorStrategy?: FacilitatorStrategy;\r\n}\r\n\r\n/**\r\n * Routing policy (SMF business logic)\r\n * SMF owns higher-level policy above raw settlement\r\n */\r\nexport interface RoutingPolicy {\r\n  // Risk rules\r\n  riskThreshold?: number; // Max risk score (0-100)\r\n  requireKYC?: boolean; // Require KYC for certain amounts\r\n  \r\n  // Cost optimization\r\n  preferCheapest?: boolean; // Prefer cheapest facilitator\r\n  maxCostMultiplier?: number; // Max cost vs cheapest (1.5 = 50% premium)\r\n  \r\n  // Compliance rules\r\n  jurisdictionRules?: JurisdictionRule[];\r\n  \r\n  // Reliability\r\n  requireHealthCheck?: boolean; // Only route to healthy facilitators\r\n  minUptime?: number; // Minimum uptime percentage (0-1)\r\n  \r\n  // Custom rules\r\n  customRules?: (facilitator: IFacilitator, requirements: PaymentRequirements) => boolean;\r\n}\r\n\r\n/**\r\n * Jurisdiction-based routing rules\r\n */\r\nexport interface JurisdictionRule {\r\n  country?: string; // ISO country code\r\n  region?: string; // Region name\r\n  allowedNetworks?: string[];\r\n  requiredKYC?: boolean;\r\n  maxAmount?: string; // Max amount in smallest units\r\n  blockedFacilitators?: string[]; // Facilitator IDs to avoid\r\n}\r\n\r\n/**\r\n * Facilitator router\r\n * Implements smart routing based on preferences and policy\r\n */\r\nexport class FacilitatorRouter {\r\n  private facilitators: Map<string, IFacilitator> = new Map();\r\n  private facilitatorHealth: Map<string, { healthy: boolean; lastChecked: number }> = new Map();\r\n  private healthCheckInterval: NodeJS.Timeout | null = null;\r\n\r\n  constructor() {\r\n    // Register default facilitators\r\n    this.registerFacilitator(getCDPFacilitatorAdapter());\r\n    \r\n    // Register PayAI facilitator (multi-chain support)\r\n    this.registerFacilitator(getPayAIFacilitator());\r\n    \r\n    // Register X402rs facilitator (Rust-based community facilitator)\r\n    // Supports: Base Sepolia, Base mainnet, XDC mainnet\r\n    if (process.env.X402RS_ENABLED !== 'false') {\r\n      this.registerFacilitator(getX402rsFacilitator());\r\n      logger.info({ facilitatorId: 'x402rs', url: 'https://facilitator.x402.rs' }, 'X402rs facilitator registered');\r\n    }\r\n    \r\n    // Register Dexter facilitator (Solana-native x402 facilitator)\r\n    // Supports: Solana mainnet, Solana devnet\r\n    if (process.env.DEXTER_ENABLED !== 'false') {\r\n      this.registerFacilitator(getDexterFacilitator());\r\n      logger.info({ facilitatorId: 'dexter', url: 'https://facilitator.dexter.cash' }, 'Dexter facilitator registered');\r\n    }\r\n    \r\n    // Register dummy facilitator for testing (wraps CDP, different priority)\r\n    // This allows testing routing logic, priority ties, failover, etc.\r\n    if (process.env.ENABLE_DUMMY_FACILITATOR === 'true') {\r\n      const { createDummyFacilitator } = require('./dummy-facilitator');\r\n      const dummy = createDummyFacilitator('dummy', {\r\n        wrapCDP: true, // Wrap CDP for realistic testing\r\n        priority: 2, // Lower priority than CDP\r\n      });\r\n      this.registerFacilitator(dummy);\r\n    }\r\n    \r\n    // Start health check interval (every 5 minutes)\r\n    this.startHealthChecks();\r\n  }\r\n\r\n  /**\r\n   * Register a facilitator\r\n   */\r\n  registerFacilitator(facilitator: IFacilitator): void {\r\n    this.facilitators.set(facilitator.id, facilitator);\r\n    logger.info({ facilitatorId: facilitator.id, name: facilitator.name }, 'Facilitator registered');\r\n  }\r\n\r\n  /**\r\n   * Unregister a facilitator\r\n   */\r\n  unregisterFacilitator(facilitatorId: string): void {\r\n    this.facilitators.delete(facilitatorId);\r\n    this.facilitatorHealth.delete(facilitatorId);\r\n    logger.info({ facilitatorId }, 'Facilitator unregistered');\r\n  }\r\n\r\n  /**\r\n   * Get all registered facilitators\r\n   */\r\n  getFacilitators(): IFacilitator[] {\r\n    return Array.from(this.facilitators.values());\r\n  }\r\n\r\n  /**\r\n   * Route payment to best facilitator\r\n   * \r\n   * @param requirements - Payment requirements\r\n   * @param preferences - SDK/agent preferences\r\n   * @param policy - SMF business logic policy\r\n   */\r\n  async routePayment(\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): Promise<IFacilitator> {\r\n    // ==========================================================================\r\n    // Handle explicit facilitator strategy (non-auto)\r\n    // ==========================================================================\r\n    if (preferences?.facilitatorStrategy && preferences.facilitatorStrategy !== 'auto') {\r\n      const explicitFacilitator = this.facilitators.get(preferences.facilitatorStrategy);\r\n      \r\n      if (explicitFacilitator && explicitFacilitator.config.enabled) {\r\n        // Check if explicit facilitator supports the requested network/asset\r\n        if (explicitFacilitator.supports(requirements.network, requirements.asset, requirements.scheme, requirements.settlementMode)) {\r\n          logger.info({\r\n            facilitatorId: explicitFacilitator.id,\r\n            facilitatorUrl: explicitFacilitator.config.healthCheckUrl,\r\n            strategy: preferences.facilitatorStrategy,\r\n            network: requirements.network,\r\n            asset: requirements.asset,\r\n            mode: 'explicit',\r\n            msg: 'Facilitator selected via explicit strategy',\r\n          });\r\n          return explicitFacilitator;\r\n        } else {\r\n          logger.warn({\r\n            facilitatorId: preferences.facilitatorStrategy,\r\n            network: requirements.network,\r\n            asset: requirements.asset,\r\n            msg: 'Explicit facilitator does not support requested network/asset, falling back to auto',\r\n          });\r\n          // Fall through to auto selection\r\n        }\r\n      } else {\r\n        logger.warn({\r\n          facilitatorId: preferences.facilitatorStrategy,\r\n          enabled: explicitFacilitator?.config.enabled,\r\n          msg: 'Explicit facilitator not found or disabled, falling back to auto',\r\n        });\r\n        // Fall through to auto selection\r\n      }\r\n    }\r\n\r\n    // ==========================================================================\r\n    // Auto selection: Get eligible facilitators\r\n    // ==========================================================================\r\n    const eligible = this.getEligibleFacilitators(requirements, preferences, policy);\r\n\r\n    if (eligible.length === 0) {\r\n      throw new Error(\r\n        `No eligible facilitator found for ${requirements.network}/${requirements.asset}/${requirements.scheme}`\r\n      );\r\n    }\r\n\r\n    // Score and rank facilitators\r\n    const scored = await this.scoreFacilitators(eligible, requirements, preferences, policy);\r\n\r\n    // Select best facilitator\r\n    const best = scored[0].facilitator;\r\n    const bestExplanation = scored[0].x402scanExplanation;\r\n    \r\n    // =======================================================================\r\n    // Log x402scan explanation for the selected facilitator (if available)\r\n    // =======================================================================\r\n    if (bestExplanation && DEFAULT_X402SCAN_TRUST_CONFIG.logExplanations) {\r\n      logger.info({\r\n        facilitatorId: best.id,\r\n        x402scan: {\r\n          selected: true,\r\n          score: bestExplanation.score,\r\n          confidence: bestExplanation.confidence,\r\n          shortReason: bestExplanation.shortReason,\r\n          metrics: bestExplanation.metrics,\r\n        },\r\n        msg: 'x402scan routing explanation',\r\n      });\r\n    }\r\n\r\n    // Log alternatives with their x402scan data (for debugging/ML)\r\n    if (scored.length > 1 && DEFAULT_X402SCAN_TRUST_CONFIG.logExplanations) {\r\n      const alternatives = scored.slice(1, 4).map((s) => ({\r\n        id: s.facilitator.id,\r\n        score: s.score,\r\n        x402scan: s.x402scanExplanation ? {\r\n          score: s.x402scanExplanation.score,\r\n          confidence: s.x402scanExplanation.confidence,\r\n          shortReason: s.x402scanExplanation.shortReason,\r\n        } : null,\r\n      }));\r\n      logger.debug({ alternatives, msg: 'Alternative facilitators considered' });\r\n    }\r\n    \r\n    // Log decision trace (compact format for explainer/debugger UI)\r\n    // Include facilitatorUrl for per-facilitator logging\r\n    logger.info({\r\n      facilitatorId: best.id,\r\n      facilitatorUrl: best.config.healthCheckUrl,\r\n      score: scored[0].score,\r\n      x402scanScore: bestExplanation?.score,\r\n      x402scanConfidence: bestExplanation?.confidence,\r\n      alternatives: scored.length - 1,\r\n      reasons: scored[0].reasons,\r\n      strategy: preferences?.facilitatorStrategy || 'auto',\r\n      mode: 'auto',\r\n      constraints: {\r\n        preferences: preferences ? {\r\n          priority: preferences.priority,\r\n          preferredNetworks: preferences.preferredNetworks,\r\n          preferredAssets: preferences.preferredAssets,\r\n          facilitatorStrategy: preferences.facilitatorStrategy,\r\n        } : undefined,\r\n        settlementMode: requirements.settlementMode,\r\n      },\r\n      candidates: scored.map((s) => ({\r\n        id: s.facilitator.id,\r\n        url: s.facilitator.config.healthCheckUrl,\r\n        score: s.score,\r\n        reasons: s.reasons,\r\n      })),\r\n      msg: 'Facilitator selected',\r\n    });\r\n\r\n    return best;\r\n  }\r\n\r\n  /**\r\n   * Get eligible facilitators based on requirements, preferences, and policy\r\n   * Extended to support CAIP identifiers and settlement modes\r\n   */\r\n  private getEligibleFacilitators(\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): IFacilitator[] {\r\n    const facilitators = Array.from(this.facilitators.values());\r\n\r\n    return facilitators.filter((facilitator) => {\r\n      // 1. Check basic support (legacy or CAIP)\r\n      let supportsNetwork = false;\r\n      let supportsAsset = false;\r\n\r\n      // Check network support\r\n      if (requirements.networks && requirements.networks.length > 0) {\r\n        // CAIP networks\r\n        supportsNetwork = requirements.networks.some((n) =>\r\n          facilitator.supportsCAIPNetwork(n)\r\n        );\r\n      } else {\r\n        // Legacy network\r\n        supportsNetwork = facilitator.config.networks.includes(requirements.network);\r\n      }\r\n\r\n      // Check asset support\r\n      if (requirements.assets && requirements.assets.length > 0) {\r\n        // CAIP assets\r\n        supportsAsset = requirements.assets.some((a) =>\r\n          facilitator.supportsCAIPAsset(a)\r\n        );\r\n      } else {\r\n        // Legacy asset\r\n        supportsAsset = facilitator.config.assets.includes(requirements.asset);\r\n      }\r\n\r\n      if (\r\n        !supportsNetwork ||\r\n        !supportsAsset ||\r\n        !facilitator.supports(\r\n          requirements.network,\r\n          requirements.asset,\r\n          requirements.scheme,\r\n          requirements.settlementMode\r\n        )\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      // 2. Check if enabled\r\n      if (!facilitator.config.enabled) {\r\n        return false;\r\n      }\r\n\r\n      // 3. Check preferences (SDK preferences) - support both legacy and CAIP\r\n      const preferredNetworks = [\r\n        ...(preferences?.preferredNetworks || []),\r\n        ...(preferences?.preferredNetworksCAIP || []),\r\n      ];\r\n      if (preferredNetworks.length > 0) {\r\n        const facilitatorNetworks = [\r\n          ...facilitator.config.networks,\r\n          ...(facilitator.config.networksCAIP || []),\r\n        ];\r\n        if (!preferredNetworks.some((p) => facilitatorNetworks.some((n) => n.includes(p) || p.includes(n)))) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      const avoidedNetworks = [\r\n        ...(preferences?.avoidNetworks || []),\r\n        ...(preferences?.avoidNetworksCAIP || []),\r\n      ];\r\n      if (avoidedNetworks.length > 0) {\r\n        const facilitatorNetworks = [\r\n          ...facilitator.config.networks,\r\n          ...(facilitator.config.networksCAIP || []),\r\n        ];\r\n        if (avoidedNetworks.some((a) => facilitatorNetworks.some((n) => n.includes(a) || a.includes(n)))) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      const preferredAssets = [\r\n        ...(preferences?.preferredAssets || []),\r\n        ...(preferences?.preferredAssetsCAIP || []),\r\n      ];\r\n      if (preferredAssets.length > 0) {\r\n        const facilitatorAssets = [\r\n          ...facilitator.config.assets,\r\n          ...(facilitator.config.assetsCAIP || []),\r\n        ];\r\n        if (!preferredAssets.some((p) => facilitatorAssets.some((a) => a.includes(p) || p.includes(a)))) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // 3b. Check jurisdiction (if specified)\r\n      if (preferences?.jurisdiction) {\r\n        // This would integrate with jurisdiction rules\r\n        // For now, pass through (can be enhanced later)\r\n      }\r\n\r\n      // 3c. Check settlement mode preference\r\n      if (preferences?.settlementMode) {\r\n        if (facilitator.config.settlementModes && !facilitator.config.settlementModes.includes(preferences.settlementMode)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // 4. Check policy (SMF business logic)\r\n      if (policy?.requireHealthCheck) {\r\n        const health = this.facilitatorHealth.get(facilitator.id);\r\n        if (!health || !health.healthy) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Note: Database health snapshot check is done in scoreFacilitators (async)\r\n      // to avoid blocking the synchronous filter operation\r\n\r\n      if (policy?.customRules) {\r\n        if (!policy.customRules(facilitator, requirements)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // 5. Check compliance requirements\r\n      if (preferences?.requireCompliance || policy?.requireKYC) {\r\n        // Check if facilitator supports compliance\r\n        const metadata = facilitator.config.metadata;\r\n        if (!metadata?.kytEnabled && !metadata?.ofacEnabled) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Score facilitators based on preferences and policy\r\n   * Uses real health metrics from database AND x402scan ecosystem data for accurate scoring\r\n   * Handles priority ties with randomization\r\n   * Exposed for decision trace building\r\n   */\r\n  public async scoreFacilitators(\r\n    facilitators: IFacilitator[],\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): Promise<Array<{ facilitator: IFacilitator; score: number; reasons: string[]; x402scanExplanation?: FacilitatorExplanation }>> {\r\n    const x402scanConfig = DEFAULT_X402SCAN_TRUST_CONFIG;\r\n    \r\n    const scored = await Promise.all(\r\n      facilitators.map(async (facilitator) => {\r\n        let score = 100; // Start with base score\r\n        const reasons: string[] = [];\r\n        let x402scanExplanation: FacilitatorExplanation | undefined;\r\n\r\n        // 1. Base priority (lower priority number = higher priority)\r\n        const basePriority = facilitator.config.priority;\r\n        score += basePriority * 10;\r\n        reasons.push(`priority:${basePriority}`);\r\n\r\n        // 2. Get real health metrics from database\r\n        const network = requirements.network;\r\n        const token = requirements.asset;\r\n        let healthMetrics;\r\n        try {\r\n          healthMetrics = await getCurrentHealth(facilitator.id, network, token, 15);\r\n        } catch (error) {\r\n          logger.warn({ error, facilitatorId: facilitator.id, network, token }, 'Failed to get health metrics, using defaults');\r\n          healthMetrics = {\r\n            successRate: 1.0,\r\n            p95LatencyMs: null,\r\n            errorRate: 0.0,\r\n            status: 'healthy' as const,\r\n          };\r\n        }\r\n\r\n        // =======================================================================\r\n        // 2b. Get x402scan ecosystem metrics (if available and trusted)\r\n        // =======================================================================\r\n        let x402scanScore: FacilitatorScore | null = null;\r\n        let x402scanTrust = { trust: false, reason: 'not-fetched' };\r\n        \r\n        try {\r\n          x402scanScore = await getFacilitatorScore({\r\n            facilitatorId: facilitator.id,\r\n            timeframe: x402scanConfig.timeframe,\r\n          });\r\n          x402scanTrust = shouldTrustX402ScanMetrics(x402scanScore, x402scanConfig);\r\n          \r\n          // Get detailed explanation for logging\r\n          if (x402scanConfig.logExplanations) {\r\n            x402scanExplanation = await getFacilitatorExplainer(facilitator.id, {\r\n              timeframe: x402scanConfig.timeframe,\r\n            });\r\n          }\r\n        } catch (error) {\r\n          logger.debug({ error, facilitatorId: facilitator.id }, 'Failed to get x402scan metrics');\r\n          x402scanTrust = { trust: false, reason: 'fetch-error' };\r\n        }\r\n\r\n        // 3. Success rate scoring (w1 * successRate)\r\n        const w1 = 50; // Weight for success rate\r\n        const successRateScore = healthMetrics.successRate * w1;\r\n        score += successRateScore;\r\n        reasons.push(`success-rate:${(healthMetrics.successRate * 100).toFixed(1)}%`);\r\n\r\n        // 4. Latency scoring (w2 * p95LatencyMs) - lower is better\r\n        const w2 = 0.1; // Weight for latency penalty\r\n        if (healthMetrics.p95LatencyMs !== null) {\r\n          const latencyPenalty = healthMetrics.p95LatencyMs * w2;\r\n          score -= latencyPenalty;\r\n          reasons.push(`p95-latency:${healthMetrics.p95LatencyMs}ms`);\r\n        }\r\n\r\n        // 5. Fee scoring (w3 * feeBps) - get from capabilities\r\n        const w3 = 0.5; // Weight for fee penalty\r\n        try {\r\n          const capabilities = await getFacilitatorCapabilities(facilitator.id, network, token);\r\n          const capability = capabilities[0];\r\n          if (capability) {\r\n            const feePenalty = capability.fee_bps * w3;\r\n            score -= feePenalty;\r\n            reasons.push(`fee:${capability.fee_bps}bps`);\r\n          }\r\n        } catch (error) {\r\n          logger.debug({ error, facilitatorId: facilitator.id }, 'Failed to get capabilities for fee scoring');\r\n        }\r\n\r\n        // 6. Risk penalty (w4 * riskPenalty) - based on error rate and status\r\n        const w4 = 30; // Weight for risk penalty\r\n        const riskPenalty = healthMetrics.errorRate * w4;\r\n        score -= riskPenalty;\r\n        if (healthMetrics.status === 'down') {\r\n          // Refuse routing to down facilitators (set score to very low value)\r\n          score = -1000; // Effectively prevents routing\r\n          reasons.push('status:down');\r\n          logger.warn(\r\n            { facilitatorId: facilitator.id, network: requirements.network, token: requirements.asset },\r\n            'Refusing to route - facilitator is down'\r\n          );\r\n        } else if (healthMetrics.status === 'degraded') {\r\n          score -= 25; // Moderate penalty for degraded\r\n          reasons.push('status:degraded');\r\n          logger.warn(\r\n            { facilitatorId: facilitator.id, network: requirements.network, token: requirements.asset },\r\n            'Facilitator is degraded - routing with caution'\r\n          );\r\n        }\r\n\r\n        // 7. Health status check (cached)\r\n        const health = this.facilitatorHealth.get(facilitator.id);\r\n        if (health && !health.healthy) {\r\n          score -= 30; // Additional penalty for unhealthy in cache\r\n          reasons.push('cache-unhealthy');\r\n        }\r\n\r\n        // =======================================================================\r\n        // 8. X402SCAN ECOSYSTEM METRICS INTEGRATION\r\n        // =======================================================================\r\n        if (x402scanTrust.trust && x402scanScore) {\r\n          // Apply x402scan score as weighted bonus/penalty\r\n          // x402scan score is 0-100, normalize to contribute proportionally\r\n          const x402scanNormalized = (x402scanScore.score - 50) / 50; // -1 to +1\r\n          const x402scanBonus = x402scanNormalized * 30 * x402scanConfig.x402scanScoreWeight;\r\n          score += x402scanBonus;\r\n          reasons.push(`x402scan:${x402scanScore.score}/${x402scanTrust.reason}`);\r\n\r\n          // Extra bonus for high success rate in ecosystem data\r\n          if (x402scanScore.successRate >= 0.99) {\r\n            score += 10 * x402scanConfig.x402scanScoreWeight;\r\n            reasons.push('x402scan-excellent');\r\n          } else if (x402scanScore.successRate < 0.90) {\r\n            score -= 15 * x402scanConfig.x402scanScoreWeight;\r\n            reasons.push('x402scan-degraded');\r\n          }\r\n\r\n          // Latency bonus/penalty from ecosystem data\r\n          if (x402scanScore.p95LatencyMs !== undefined) {\r\n            if (x402scanScore.p95LatencyMs < 200) {\r\n              score += 5 * x402scanConfig.x402scanScoreWeight;\r\n              reasons.push(`x402scan-fast:${x402scanScore.p95LatencyMs.toFixed(0)}ms`);\r\n            } else if (x402scanScore.p95LatencyMs > 1000) {\r\n              score -= 10 * x402scanConfig.x402scanScoreWeight;\r\n              reasons.push(`x402scan-slow:${x402scanScore.p95LatencyMs.toFixed(0)}ms`);\r\n            }\r\n          }\r\n        } else {\r\n          // Log why x402scan data wasn't trusted\r\n          reasons.push(`x402scan-skipped:${x402scanTrust.reason}`);\r\n        }\r\n\r\n        // =======================================================================\r\n        // 8b. SCATTERING / DUNE ACTIVITY METRICS INTEGRATION\r\n        // =======================================================================\r\n        const scatteringConfig = DEFAULT_SCATTERING_CONFIG;\r\n        let scatteringMetrics: ScatteringFacilitatorMetrics | null = null;\r\n        let scatteringTrust = { trust: false, reason: 'not-fetched' };\r\n\r\n        try {\r\n          scatteringMetrics = await getScatteringMetricsForFacilitator(facilitator.id);\r\n          scatteringTrust = shouldTrustScatteringMetrics(scatteringMetrics, scatteringConfig);\r\n        } catch (error) {\r\n          logger.debug({ error, facilitatorId: facilitator.id }, 'Failed to get Scattering metrics');\r\n          scatteringTrust = { trust: false, reason: 'fetch-error' };\r\n        }\r\n\r\n        if (scatteringTrust.trust && scatteringMetrics) {\r\n          // Compute activity score (0-1)\r\n          const activityScore = computeActivityScore(scatteringMetrics);\r\n          \r\n          // Apply as weighted bonus (activity score 0.5+ is good, higher is better)\r\n          const activityBonus = (activityScore - 0.3) * 100 * scatteringConfig.scatteringScoreWeight;\r\n          score += activityBonus;\r\n          reasons.push(`scattering-activity:${(activityScore * 100).toFixed(1)}%`);\r\n\r\n          // Volume bonus for high-volume facilitators\r\n          if (scatteringMetrics.volumeUsd3d >= 100_000) {\r\n            score += 10 * scatteringConfig.scatteringScoreWeight;\r\n            reasons.push(`scattering-high-volume:$${(scatteringMetrics.volumeUsd3d / 1000).toFixed(1)}K`);\r\n          }\r\n\r\n          // User diversity bonus (more unique buyers = more trusted)\r\n          if (scatteringMetrics.uniqueBuyers3d >= 1000) {\r\n            score += 5 * scatteringConfig.scatteringScoreWeight;\r\n            reasons.push(`scattering-high-adoption:${scatteringMetrics.uniqueBuyers3d}-buyers`);\r\n          }\r\n\r\n          // Growth bonus/penalty\r\n          if (scatteringMetrics.volumeChangeRate !== undefined) {\r\n            if (scatteringMetrics.volumeChangeRate > 20) {\r\n              // Growing facilitator\r\n              score += 5 * scatteringConfig.scatteringScoreWeight;\r\n              reasons.push(`scattering-growing:+${scatteringMetrics.volumeChangeRate.toFixed(0)}%`);\r\n            } else if (scatteringMetrics.volumeChangeRate < -50) {\r\n              // Declining significantly\r\n              score -= 10 * scatteringConfig.scatteringScoreWeight;\r\n              reasons.push(`scattering-declining:${scatteringMetrics.volumeChangeRate.toFixed(0)}%`);\r\n            }\r\n          }\r\n\r\n          // Log Scattering metrics if enabled\r\n          if (scatteringConfig.logScatteringMetrics) {\r\n            logger.debug({\r\n              facilitatorId: facilitator.id,\r\n              scattering: {\r\n                volumeUsd3d: scatteringMetrics.volumeUsd3d,\r\n                txCount3d: scatteringMetrics.txCount3d,\r\n                uniqueBuyers3d: scatteringMetrics.uniqueBuyers3d,\r\n                activityScore: activityScore.toFixed(3),\r\n                volumeChangeRate: scatteringMetrics.volumeChangeRate,\r\n              },\r\n              msg: 'Scattering metrics applied',\r\n            });\r\n          }\r\n        } else {\r\n          reasons.push(`scattering-skipped:${scatteringTrust.reason}`);\r\n        }\r\n\r\n        // 9. Cost optimization (if policy requires)\r\n        if (policy?.preferCheapest || preferences?.priority === 'cost') {\r\n          const pricing = await facilitator.getPricing(requirements.network, requirements.asset);\r\n          if (pricing) {\r\n            // Lower cost = higher score (normalize)\r\n            score += 20; // Bonus for having pricing info\r\n            reasons.push('has-pricing');\r\n          }\r\n        }\r\n\r\n        // 10. Speed optimization (if preference)\r\n        if (preferences?.priority === 'speed') {\r\n          if (healthMetrics.p95LatencyMs !== null) {\r\n            // Lower latency = higher score\r\n            const latencyBonus = Math.max(0, 30 - healthMetrics.p95LatencyMs / 10);\r\n            score += latencyBonus;\r\n            reasons.push(`speed-optimized:${healthMetrics.p95LatencyMs}ms`);\r\n          }\r\n          // Also factor in x402scan latency for speed priority\r\n          if (x402scanTrust.trust && x402scanScore?.p95LatencyMs !== undefined) {\r\n            const x402LatencyBonus = Math.max(0, 20 - x402scanScore.p95LatencyMs / 25);\r\n            score += x402LatencyBonus * x402scanConfig.x402scanScoreWeight;\r\n          }\r\n        }\r\n\r\n        // 11. Compliance optimization\r\n        if (preferences?.priority === 'compliance' || policy?.requireKYC) {\r\n          const metadata = facilitator.config.metadata;\r\n          if (metadata?.kytEnabled && metadata?.ofacEnabled) {\r\n            score += 30; // Bonus for compliance\r\n            reasons.push('compliance-enabled');\r\n          }\r\n        }\r\n\r\n        // 12. Reliability optimization - strongly weight x402scan for reliability priority\r\n        if (preferences?.priority === 'reliability') {\r\n          if (healthMetrics.status === 'healthy' && healthMetrics.successRate > 0.95) {\r\n            score += 25;\r\n            reasons.push('high-reliability');\r\n          }\r\n          // Double weight x402scan for reliability priority\r\n          if (x402scanTrust.trust && x402scanScore) {\r\n            if (x402scanScore.successRate >= 0.98 && x402scanScore.confidence === 'high') {\r\n              score += 20; // Strong bonus for proven reliability\r\n              reasons.push('x402scan-proven-reliable');\r\n            }\r\n          }\r\n        }\r\n\r\n        // 13. Settlement mode optimization\r\n        if (requirements.settlementMode) {\r\n          if (facilitator.config.settlementModes?.includes(requirements.settlementMode)) {\r\n            score += 15; // Bonus for supporting requested settlement mode\r\n            reasons.push(`settlement:${requirements.settlementMode}`);\r\n          }\r\n        }\r\n\r\n        return { facilitator, score, reasons, x402scanExplanation };\r\n      })\r\n    );\r\n\r\n    // Sort by score (highest first)\r\n    const sorted = scored.sort((a, b) => b.score - a.score);\r\n\r\n    // Handle priority ties with randomization\r\n    // If top scores are within 5 points, randomize order\r\n    if (sorted.length > 1) {\r\n      const topScore = sorted[0].score;\r\n      const tied = sorted.filter((s) => Math.abs(s.score - topScore) <= 5);\r\n      \r\n      if (tied.length > 1) {\r\n        // Shuffle tied facilitators\r\n        for (let i = tied.length - 1; i > 0; i--) {\r\n          const j = Math.floor(Math.random() * (i + 1));\r\n          [tied[i], tied[j]] = [tied[j], tied[i]];\r\n        }\r\n        // Rebuild sorted array with shuffled ties\r\n        const rest = sorted.filter((s) => Math.abs(s.score - topScore) > 5);\r\n        return [...tied, ...rest];\r\n      }\r\n    }\r\n\r\n    return sorted;\r\n  }\r\n\r\n  /**\r\n   * Start periodic health checks\r\n   */\r\n  private startHealthChecks(): void {\r\n    this.healthCheckInterval = setInterval(async () => {\r\n      await this.checkAllFacilitators();\r\n    }, 5 * 60 * 1000); // Every 5 minutes\r\n\r\n    // Initial health check\r\n    this.checkAllFacilitators();\r\n  }\r\n\r\n  /**\r\n   * Check health of all facilitators\r\n   */\r\n  private async checkAllFacilitators(): Promise<void> {\r\n    const facilitators = Array.from(this.facilitators.values());\r\n    \r\n    await Promise.all(\r\n      facilitators.map(async (facilitator) => {\r\n        try {\r\n          const health = await facilitator.getHealth();\r\n          this.facilitatorHealth.set(facilitator.id, {\r\n            healthy: health.healthy,\r\n            lastChecked: Date.now(),\r\n          });\r\n        } catch (error) {\r\n          logger.error({ facilitatorId: facilitator.id, error }, 'Health check failed');\r\n          this.facilitatorHealth.set(facilitator.id, {\r\n            healthy: false,\r\n            lastChecked: Date.now(),\r\n          });\r\n        }\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get facilitator by ID\r\n   */\r\n  getFacilitator(id: string): IFacilitator | undefined {\r\n    return this.facilitators.get(id);\r\n  }\r\n\r\n  /**\r\n   * Get facilitator health status\r\n   */\r\n  getFacilitatorHealth(id: string): { healthy: boolean; lastChecked: number } | undefined {\r\n    return this.facilitatorHealth.get(id);\r\n  }\r\n\r\n  /**\r\n   * Cleanup\r\n   */\r\n  destroy(): void {\r\n    if (this.healthCheckInterval) {\r\n      clearInterval(this.healthCheckInterval);\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet router: FacilitatorRouter | null = null;\r\n\r\n/**\r\n * Get facilitator router instance\r\n */\r\nexport function getFacilitatorRouter(): FacilitatorRouter {\r\n  if (!router) {\r\n    router = new FacilitatorRouter();\r\n  }\r\n  return router;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7703, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/route-context.ts"],"sourcesContent":["// =============================================================================\r\n// ROUTE CONTEXT\r\n// =============================================================================\r\n// Normalized request context for SMF routing\r\n// Ensures all facilitators receive consistent, x402-spec-compliant requests\r\n\r\nimport type { PaymentRequirements } from './base-facilitator';\r\n\r\n/**\r\n * RouteContext - Normalized request context for SMF routing\r\n * \r\n * This type ensures all facilitators receive consistent, x402-spec-compliant\r\n * requests regardless of how the request originated (API, SDK, etc.)\r\n */\r\nexport interface RouteContext {\r\n  // Payment details (x402 spec compliant)\r\n  network: string; // Legacy network identifier (e.g., 'base', 'ethereum')\r\n  token: string; // Token address (e.g., '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913')\r\n  amount: string; // Amount in atomic units (string to avoid precision loss)\r\n  \r\n  // CAIP identifiers (preferred for multi-chain)\r\n  networkCAIP?: string; // CAIP-2 network identifier (e.g., 'eip155:8453')\r\n  tokenCAIP?: string; // CAIP-19 asset identifier (e.g., 'eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913')\r\n  \r\n  // x402 version\r\n  x402Version: number; // x402 protocol version (currently 1 or 2)\r\n  \r\n  // Caller identification\r\n  callerId?: string; // Agent/merchant identifier\r\n  clientId?: string; // Client application identifier\r\n  \r\n  // Optional routing preferences\r\n  region?: string; // Geographic region (e.g., 'us-east', 'eu-west')\r\n  riskLevel?: 'low' | 'medium' | 'high'; // Risk assessment level\r\n  watchLevel?: 'normal' | 'enhanced' | 'strict'; // Compliance watch level\r\n  \r\n  // Additional context\r\n  preferences?: {\r\n    priority?: 'cost' | 'speed' | 'reliability' | 'compliance';\r\n    requireKYC?: boolean;\r\n    requireOFAC?: boolean;\r\n    maxLatencyMs?: number;\r\n    maxFeeBps?: number;\r\n  };\r\n  \r\n  // Original payment requirements (for compatibility)\r\n  requirements: PaymentRequirements;\r\n}\r\n\r\n/**\r\n * Convert RouteContext to facilitator request format\r\n * \r\n * This ensures all facilitators receive x402-spec-compliant requests\r\n */\r\nexport function routeContextToFacilitatorRequest(\r\n  context: RouteContext\r\n): {\r\n  version: number;\r\n  amount: string;\r\n  network: string;\r\n  token: string;\r\n  networkCAIP?: string;\r\n  tokenCAIP?: string;\r\n} {\r\n  return {\r\n    version: context.x402Version,\r\n    amount: context.amount,\r\n    network: context.network,\r\n    token: context.token,\r\n    networkCAIP: context.networkCAIP,\r\n    tokenCAIP: context.tokenCAIP,\r\n  };\r\n}\r\n\r\n/**\r\n * Create RouteContext from PaymentRequirements\r\n * \r\n * Normalizes various input formats into consistent RouteContext\r\n */\r\nexport function createRouteContext(\r\n  requirements: PaymentRequirements,\r\n  options?: {\r\n    callerId?: string;\r\n    clientId?: string;\r\n    region?: string;\r\n    riskLevel?: 'low' | 'medium' | 'high';\r\n    watchLevel?: 'normal' | 'enhanced' | 'strict';\r\n    x402Version?: number;\r\n  }\r\n): RouteContext {\r\n  // Extract network (legacy or CAIP)\r\n  const network = requirements.network || requirements.networks?.[0] || '';\r\n  const networkCAIP = requirements.networks?.[0]?.startsWith('eip155:') \r\n    ? requirements.networks[0] \r\n    : undefined;\r\n  \r\n  // Extract token/asset (legacy or CAIP)\r\n  const token = requirements.asset || requirements.assets?.[0] || '';\r\n  const tokenCAIP = requirements.assets?.[0]?.includes('/') \r\n    ? requirements.assets[0] \r\n    : undefined;\r\n  \r\n  return {\r\n    network,\r\n    token,\r\n    amount: requirements.maxAmountRequired || '0',\r\n    networkCAIP,\r\n    tokenCAIP,\r\n    x402Version: options?.x402Version || 1, // Default to v1, upgrade to v2 when ready\r\n    callerId: options?.callerId,\r\n    clientId: options?.clientId,\r\n    region: options?.region,\r\n    riskLevel: options?.riskLevel,\r\n    watchLevel: options?.watchLevel,\r\n    requirements,\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,gBAAgB;AAChB,gFAAgF;AAChF,6CAA6C;AAC7C,4EAA4E;;;;;;;AAkDrE,SAAS,iCACd,OAAqB;IASrB,OAAO;QACL,SAAS,QAAQ,WAAW;QAC5B,QAAQ,QAAQ,MAAM;QACtB,SAAS,QAAQ,OAAO;QACxB,OAAO,QAAQ,KAAK;QACpB,aAAa,QAAQ,WAAW;QAChC,WAAW,QAAQ,SAAS;IAC9B;AACF;AAOO,SAAS,mBACd,YAAiC,EACjC,OAOC;IAED,mCAAmC;IACnC,MAAM,UAAU,aAAa,OAAO,IAAI,aAAa,QAAQ,EAAE,CAAC,EAAE,IAAI;IACtE,MAAM,cAAc,aAAa,QAAQ,EAAE,CAAC,EAAE,EAAE,WAAW,aACvD,aAAa,QAAQ,CAAC,EAAE,GACxB;IAEJ,uCAAuC;IACvC,MAAM,QAAQ,aAAa,KAAK,IAAI,aAAa,MAAM,EAAE,CAAC,EAAE,IAAI;IAChE,MAAM,YAAY,aAAa,MAAM,EAAE,CAAC,EAAE,EAAE,SAAS,OACjD,aAAa,MAAM,CAAC,EAAE,GACtB;IAEJ,OAAO;QACL;QACA;QACA,QAAQ,aAAa,iBAAiB,IAAI;QAC1C;QACA;QACA,aAAa,SAAS,eAAe;QACrC,UAAU,SAAS;QACnB,UAAU,SAAS;QACnB,QAAQ,SAAS;QACjB,WAAW,SAAS;QACpB,YAAY,SAAS;QACrB;IACF;AACF"}},
    {"offset": {"line": 7752, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/orchestrator/meta-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// META-FACILITATOR ORCHESTRATION ENGINE\r\n// =============================================================================\r\n// High-level orchestration layer that sits above individual facilitators\r\n// Owns business logic, routing policy, and risk management\r\n\r\nimport { getFacilitatorRouter, type RoutingPreferences, type RoutingPolicy } from '../facilitators/facilitator-router';\r\nimport { type PaymentRequirements, type VerificationResult, type IFacilitator } from '../facilitators/base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { createRoute, updateRouteStatus, createRouteAttempt } from '@/db/smf';\r\nimport { createRouteContext } from '../facilitators/route-context';\r\n\r\n// Re-export for convenience\r\nexport { getFacilitatorRouter };\r\n\r\nconst logger = createLogger({ component: 'MetaFacilitator' });\r\n\r\n/**\r\n * Meta-facilitator orchestration result\r\n */\r\n/**\r\n * Decision trace for routing decisions\r\n * Enables explainer/debugger UI in NexFlow\r\n */\r\nexport interface DecisionTrace {\r\n  timestamp: string;\r\n  reason: string;\r\n  constraints: {\r\n    preferences?: RoutingPreferences;\r\n    policy?: Partial<RoutingPolicy>;\r\n    requirements: PaymentRequirements;\r\n  };\r\n  candidates: Array<{\r\n    facilitatorId: string;\r\n    facilitatorName: string;\r\n    score: number;\r\n    eligible: boolean;\r\n    reasons: string[];\r\n  }>;\r\n  selected: {\r\n    facilitatorId: string;\r\n    score: number;\r\n    alternativesConsidered: number;\r\n  };\r\n}\r\n\r\nexport interface OrchestrationResult extends VerificationResult {\r\n  facilitatorUsed: string;\r\n  routingReason: string;\r\n  alternativesConsidered: number;\r\n  decisionTrace?: DecisionTrace; // Compact decision trace for debugging\r\n  orchestrationMetadata?: {\r\n    cost?: number;\r\n    latency?: number;\r\n    complianceScore?: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Meta-Facilitator\r\n * Orchestrates multiple facilitators with business logic above raw settlement\r\n */\r\nexport class MetaFacilitator {\r\n  private router = getFacilitatorRouter();\r\n\r\n  /**\r\n   * Verify payment with orchestration\r\n   * \r\n   * This is the main entry point for payment verification.\r\n   * It handles:\r\n   * 1. Facilitator selection based on policy\r\n   * 2. Payment routing\r\n   * 3. Failover handling\r\n   * 4. Result aggregation\r\n   * 5. Business logic application\r\n   */\r\n  async verifyPayment(\r\n    payment: string,\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy,\r\n    context?: {\r\n      requestId?: string;\r\n      correlationId?: string;\r\n      clientId?: string;\r\n      agentId?: string;\r\n    }\r\n  ): Promise<OrchestrationResult> {\r\n    const startTime = Date.now();\r\n    let routeId: string | null = null;\r\n\r\n    try {\r\n      // 1. Create route context and route record\r\n      const routeContext = createRouteContext(requirements, {\r\n        callerId: context?.clientId || context?.agentId,\r\n        clientId: context?.clientId,\r\n        x402Version: 1, // Default to v1, can be upgraded\r\n      });\r\n\r\n      // 2. Select best facilitator based on policy\r\n      const facilitator = await this.router.routePayment(requirements, preferences, policy);\r\n\r\n      // 3. Create route record with selected facilitator\r\n      const route = await createRoute({\r\n        request_id: context?.requestId || null,\r\n        correlation_id: context?.correlationId || null,\r\n        client_id: context?.clientId || null,\r\n        agent_id: context?.agentId || null,\r\n        network: routeContext.network,\r\n        token: routeContext.token,\r\n        amount: routeContext.amount,\r\n        selected_facilitator_id: facilitator.id,\r\n        status: 'verifying',\r\n      });\r\n      routeId = route.id;\r\n\r\n      // Log decision trace (compact format)\r\n      logger.info({\r\n        routeId,\r\n        facilitatorId: facilitator.id,\r\n        network: requirements.network,\r\n        asset: requirements.asset,\r\n        settlementMode: requirements.settlementMode,\r\n        preferences: preferences ? {\r\n          priority: preferences.priority,\r\n          jurisdiction: preferences.jurisdiction,\r\n        } : undefined,\r\n      }, 'Routing payment to facilitator');\r\n\r\n      // 3. Verify payment with selected facilitator\r\n      const verifyStartTime = Date.now();\r\n      let result: VerificationResult;\r\n      let attemptResult: 'success' | 'failure' | 'timeout' | 'rate_limited' | 'insufficient_liquidity' | 'invalid_request' | 'network_error' = 'success';\r\n      let errorCode: string | null = null;\r\n      let rawStatus: number | null = null;\r\n\r\n      try {\r\n        result = await facilitator.verify(payment, requirements);\r\n        const verifyLatency = Date.now() - verifyStartTime;\r\n\r\n        // Determine attempt result\r\n        if (!result.success || !result.valid) {\r\n          attemptResult = 'failure';\r\n          errorCode = result.error || 'verification_failed';\r\n        }\r\n\r\n        // Log route attempt\r\n        await createRouteAttempt({\r\n          route_id: routeId,\r\n          facilitator_id: facilitator.id,\r\n          phase: 'verify',\r\n          result: attemptResult,\r\n          latency_ms: verifyLatency,\r\n          error_code: errorCode,\r\n          raw_status: rawStatus,\r\n          is_probe: false,\r\n        });\r\n      } catch (error) {\r\n        const verifyLatency = Date.now() - verifyStartTime;\r\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n\r\n        // Determine error type\r\n        if (errorMessage.includes('timeout') || errorMessage.includes('TIMEOUT')) {\r\n          attemptResult = 'timeout';\r\n        } else if (errorMessage.includes('rate') || errorMessage.includes('429')) {\r\n          attemptResult = 'rate_limited';\r\n          rawStatus = 429;\r\n        } else if (errorMessage.includes('network') || errorMessage.includes('ECONNREFUSED')) {\r\n          attemptResult = 'network_error';\r\n        } else {\r\n          attemptResult = 'failure';\r\n        }\r\n\r\n        errorCode = errorMessage;\r\n\r\n        // Log failed attempt\r\n        await createRouteAttempt({\r\n          route_id: routeId,\r\n          facilitator_id: facilitator.id,\r\n          phase: 'verify',\r\n          result: attemptResult,\r\n          latency_ms: verifyLatency,\r\n          error_code: errorCode,\r\n          raw_status: rawStatus,\r\n          is_probe: false,\r\n        });\r\n\r\n        // Create failure result\r\n        result = {\r\n          success: false,\r\n          valid: false,\r\n          error: errorMessage,\r\n          facilitatorId: facilitator.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // 4. Apply business logic (risk rules, compliance, etc.)\r\n      const orchestrated = this.applyBusinessLogic(result, requirements, policy);\r\n\r\n      // 5. Update route status\r\n      if (orchestrated.success && orchestrated.valid) {\r\n        await updateRouteStatus(routeId, 'settled', new Date().toISOString());\r\n      } else {\r\n        await updateRouteStatus(routeId, 'failed', new Date().toISOString());\r\n      }\r\n\r\n      // 6. Calculate orchestration metadata\r\n      const latency = Date.now() - startTime;\r\n      const metadata = {\r\n        latency,\r\n        complianceScore: this.calculateComplianceScore(result),\r\n      };\r\n\r\n      // 7. Build decision trace (for explainer/debugger UI)\r\n      const eligible = this.router.getFacilitators().filter((f) =>\r\n        f.supports(requirements.network, requirements.asset, requirements.scheme, requirements.settlementMode) && f.config.enabled\r\n      );\r\n      const decisionTrace = await this.buildDecisionTrace(\r\n        facilitator,\r\n        eligible,\r\n        requirements,\r\n        preferences,\r\n        policy\r\n      );\r\n\r\n      return {\r\n        ...orchestrated,\r\n        facilitatorUsed: facilitator.id,\r\n        routingReason: this.getRoutingReason(facilitator, preferences, policy),\r\n        alternativesConsidered: eligible.length - 1,\r\n        decisionTrace,\r\n        orchestrationMetadata: metadata,\r\n      };\r\n    } catch (error) {\r\n      logger.error({ error, requirements, routeId }, 'Orchestration error');\r\n\r\n      // Update route status to failed\r\n      if (routeId) {\r\n        await updateRouteStatus(routeId, 'failed', new Date().toISOString());\r\n      }\r\n\r\n      // Try failover if available\r\n      if (policy?.requireHealthCheck !== false) {\r\n        return await this.handleFailover(payment, requirements, preferences, policy, error, routeId);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply business logic to verification result\r\n   * SMF owns higher-level policy above raw settlement\r\n   */\r\n  private applyBusinessLogic(\r\n    result: VerificationResult,\r\n    requirements: PaymentRequirements,\r\n    policy?: RoutingPolicy\r\n  ): VerificationResult {\r\n    // 1. Risk rules\r\n    if (policy?.riskThreshold !== undefined) {\r\n      const riskScore = this.calculateRiskScore(result);\r\n      if (riskScore > policy.riskThreshold) {\r\n        return {\r\n          ...result,\r\n          valid: false,\r\n          error: `Risk score ${riskScore} exceeds threshold ${policy.riskThreshold}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // 2. Compliance rules\r\n    if (policy?.requireKYC) {\r\n      // Check if KYC is required for this amount\r\n      const amount = BigInt(requirements.maxAmountRequired);\r\n      const kycThreshold = BigInt('1000000000'); // 1000 USDC in smallest units\r\n      \r\n      if (amount > kycThreshold && result.kytStatus !== 'passed') {\r\n        return {\r\n          ...result,\r\n          valid: false,\r\n          error: 'KYC required for this amount',\r\n        };\r\n      }\r\n    }\r\n\r\n    // 3. Jurisdiction rules\r\n    if (policy?.jurisdictionRules) {\r\n      // Apply jurisdiction-specific rules\r\n      // This would integrate with geo-detection\r\n      // For now, pass through\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Calculate risk score (0-100)\r\n   */\r\n  private calculateRiskScore(result: VerificationResult): number {\r\n    let score = 0;\r\n\r\n    // KYT status\r\n    if (result.kytStatus === 'blocked') score += 50;\r\n    else if (result.kytStatus === 'flagged') score += 25;\r\n\r\n    // OFAC status\r\n    if (result.ofacStatus === 'blocked') score += 50;\r\n    else if (result.ofacStatus === 'flagged') score += 25;\r\n\r\n    // Error status\r\n    if (!result.success || !result.valid) score += 30;\r\n\r\n    return Math.min(100, score);\r\n  }\r\n\r\n  /**\r\n   * Calculate compliance score (0-100)\r\n   */\r\n  private calculateComplianceScore(result: VerificationResult): number {\r\n    let score = 100;\r\n\r\n    // Deduct for compliance issues\r\n    if (result.kytStatus === 'blocked') score -= 50;\r\n    else if (result.kytStatus === 'flagged') score -= 25;\r\n\r\n    if (result.ofacStatus === 'blocked') score -= 50;\r\n    else if (result.ofacStatus === 'flagged') score -= 25;\r\n\r\n    return Math.max(0, score);\r\n  }\r\n\r\n  /**\r\n   * Build decision trace for explainer/debugger UI\r\n   * Compact format for logging and future UI display\r\n   */\r\n  private async buildDecisionTrace(\r\n    selected: IFacilitator,\r\n    eligible: IFacilitator[],\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): Promise<DecisionTrace> {\r\n    // Score candidates to get detailed info\r\n    const router = getFacilitatorRouter();\r\n    const scored = await router.scoreFacilitators(\r\n      eligible,\r\n      requirements,\r\n      preferences,\r\n      policy\r\n    );\r\n\r\n    const candidates = eligible.map((f) => {\r\n      const scoredEntry = scored.find((s: any) => s.facilitator.id === f.id);\r\n      const score = scoredEntry?.score || 0;\r\n      const reasons = scoredEntry?.reasons || [];\r\n\r\n      return {\r\n        facilitatorId: f.id,\r\n        facilitatorName: f.name,\r\n        score,\r\n        eligible: true,\r\n        reasons,\r\n      };\r\n    });\r\n\r\n    return {\r\n      timestamp: new Date().toISOString(),\r\n      reason: this.getRoutingReason(selected, preferences, policy),\r\n      constraints: {\r\n        preferences,\r\n        policy: policy ? {\r\n          requireHealthCheck: policy.requireHealthCheck,\r\n          preferCheapest: policy.preferCheapest,\r\n          requireKYC: policy.requireKYC,\r\n        } : undefined,\r\n        requirements,\r\n      },\r\n      candidates,\r\n      selected: {\r\n        facilitatorId: selected.id,\r\n        score: scored.find((s: any) => s.facilitator.id === selected.id)?.score || 100,\r\n        alternativesConsidered: eligible.length - 1,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get routing reason for logging/analytics\r\n   */\r\n  private getRoutingReason(\r\n    facilitator: any,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): string {\r\n    const reasons: string[] = [];\r\n\r\n    if (preferences?.priority === 'cost') reasons.push('cost-optimized');\r\n    if (preferences?.priority === 'speed') reasons.push('speed-optimized');\r\n    if (preferences?.priority === 'compliance') reasons.push('compliance-optimized');\r\n    if (preferences?.priority === 'reliability') reasons.push('reliability-optimized');\r\n    if (preferences?.preferredNetworks) reasons.push('network-preference');\r\n    if (policy?.preferCheapest) reasons.push('cheapest-selected');\r\n    if (facilitator.config.priority === 1) reasons.push('primary-facilitator');\r\n\r\n    return reasons.join(', ') || 'default-routing';\r\n  }\r\n\r\n  /**\r\n   * Handle failover to alternative facilitator\r\n   */\r\n  private async handleFailover(\r\n    payment: string,\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy,\r\n    originalError?: any,\r\n    routeId?: string | null\r\n  ): Promise<OrchestrationResult> {\r\n    logger.warn({ originalError, requirements }, 'Attempting failover');\r\n\r\n    // Get all facilitators\r\n    const facilitators = this.router.getFacilitators();\r\n    const eligible = facilitators.filter((f) =>\r\n      f.supports(requirements.network, requirements.asset, requirements.scheme, requirements.settlementMode) && f.config.enabled\r\n    );\r\n\r\n    // Try each facilitator in order of priority\r\n    for (const facilitator of eligible.sort((a, b) => a.config.priority - b.config.priority)) {\r\n      const attemptStartTime = Date.now();\r\n      try {\r\n        const result = await facilitator.verify(payment, requirements);\r\n        const attemptLatency = Date.now() - attemptStartTime;\r\n        \r\n        // Log failover attempt\r\n        if (routeId) {\r\n          await createRouteAttempt({\r\n            route_id: routeId,\r\n            facilitator_id: facilitator.id,\r\n            phase: 'verify',\r\n            result: result.success && result.valid ? 'success' : 'failure',\r\n            latency_ms: attemptLatency,\r\n            is_probe: false,\r\n            error_code: result.error || null,\r\n            raw_status: null,\r\n          });\r\n        }\r\n        \r\n        if (result.success && result.valid) {\r\n          logger.info({ facilitatorId: facilitator.id, routeId }, 'Failover successful');\r\n          \r\n          // Update route with successful facilitator\r\n          if (routeId) {\r\n            await updateRouteStatus(routeId, 'settled', new Date().toISOString());\r\n          }\r\n          \r\n          return {\r\n            ...result,\r\n            facilitatorUsed: facilitator.id,\r\n            routingReason: 'failover',\r\n            alternativesConsidered: eligible.length - 1,\r\n          };\r\n        }\r\n      } catch (error) {\r\n        const attemptLatency = Date.now() - attemptStartTime;\r\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n        \r\n        // Log failed failover attempt\r\n        if (routeId) {\r\n          let attemptResult: 'timeout' | 'rate_limited' | 'network_error' | 'failure' = 'failure';\r\n          if (errorMessage.includes('timeout')) {\r\n            attemptResult = 'timeout';\r\n          } else if (errorMessage.includes('rate') || errorMessage.includes('429')) {\r\n            attemptResult = 'rate_limited';\r\n          } else if (errorMessage.includes('network') || errorMessage.includes('ECONNREFUSED')) {\r\n            attemptResult = 'network_error';\r\n          }\r\n          \r\n          await createRouteAttempt({\r\n            route_id: routeId,\r\n            facilitator_id: facilitator.id,\r\n            phase: 'verify',\r\n            result: attemptResult,\r\n            latency_ms: attemptLatency,\r\n            is_probe: false,\r\n            error_code: errorMessage,\r\n            raw_status: null,\r\n          });\r\n        }\r\n        \r\n        logger.warn({ facilitatorId: facilitator.id, error, routeId }, 'Failover attempt failed');\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // All facilitators failed\r\n    throw new Error(\r\n      `All facilitators failed. Original error: ${originalError instanceof Error ? originalError.message : 'Unknown error'}`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get orchestrator status\r\n   * Fixed: Aligns health semantics with facilitator health checks\r\n   */\r\n  async getStatus(): Promise<{\r\n    facilitators: number;\r\n    healthy: number;\r\n    networks: string[];\r\n    assets: string[];\r\n    facilitatorDetails: Array<{\r\n      id: string;\r\n      name: string;\r\n      healthy: boolean;\r\n      lastChecked?: string;\r\n    }>;\r\n  }> {\r\n    const facilitators = this.router.getFacilitators();\r\n    \r\n    // Check health of all facilitators (use actual health checks, not cached)\r\n    const healthChecks = await Promise.all(\r\n      facilitators.map(async (f) => {\r\n        try {\r\n          const health = await f.getHealth();\r\n          return {\r\n            id: f.id,\r\n            name: f.name,\r\n            healthy: health.healthy,\r\n            lastChecked: health.lastChecked,\r\n          };\r\n        } catch (error) {\r\n          return {\r\n            id: f.id,\r\n            name: f.name,\r\n            healthy: false,\r\n            lastChecked: new Date().toISOString(),\r\n          };\r\n        }\r\n      })\r\n    );\r\n\r\n    const healthy = healthChecks.filter((h) => h.healthy);\r\n\r\n    const networks = new Set<string>();\r\n    const assets = new Set<string>();\r\n\r\n    facilitators.forEach((f) => {\r\n      f.config.networks.forEach((n) => networks.add(n));\r\n      f.config.assets.forEach((a) => assets.add(a));\r\n    });\r\n\r\n    return {\r\n      facilitators: facilitators.length,\r\n      healthy: healthy.length,\r\n      networks: Array.from(networks),\r\n      assets: Array.from(assets),\r\n      facilitatorDetails: healthChecks,\r\n    };\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet metaFacilitator: MetaFacilitator | null = null;\r\n\r\n/**\r\n * Get meta-facilitator instance\r\n */\r\nexport function getMetaFacilitator(): MetaFacilitator {\r\n  if (!metaFacilitator) {\r\n    metaFacilitator = new MetaFacilitator();\r\n  }\r\n  return metaFacilitator;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8179, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/x402-watchlist.ts"],"sourcesContent":["// =============================================================================\n// x402 WATCHLIST DATABASE OPERATIONS\n// =============================================================================\n// Database operations for x402 ecosystem watchlist tracking\n\nimport { getDb } from './client';\nimport { createLogger } from '@/lib/logger';\n\nconst logger = createLogger({ component: 'X402WatchlistDB' });\n\n// Shared type for x402 watchlist items\nexport type X402WatchCategory = \n  | 'spec' \n  | 'index' \n  | 'facilitator_docs' \n  | 'gateway_docs' \n  | 'example_api' \n  | 'ecosystem_blog'\n  | 'bazaar_discovery'\n  | 'facilitator_discovery';\nexport type X402WatchStatus = 'active' | 'paused';\n\nexport interface X402WatchItem {\n  id: string;\n  root_domain: string;\n  path_prefix: string | null;\n  category: X402WatchCategory;\n  priority: number;\n  status: X402WatchStatus;\n  last_checked_at: string | null;\n  last_change_at: string | null;\n  last_etag: string | null;\n  last_http_status: number | null;\n  notes: string | null;\n  created_at: string;\n  updated_at: string;\n}\n\nexport type X402WatchItemInsert = Omit<X402WatchItem, 'id' | 'created_at' | 'updated_at' | 'last_checked_at' | 'last_change_at' | 'last_etag' | 'last_http_status'>;\n\n/**\n * Get all active watchlist items, optionally filtered by minimum priority\n */\nexport async function getActiveWatchlistItems(minPriority?: number): Promise<X402WatchItem[]> {\n  const db = getDb();\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\n\n  let query = `SELECT * FROM x402_watchlist WHERE status = 'active'`;\n  const params: any[] = [];\n\n  if (minPriority !== undefined) {\n    if (isPostgres) {\n      query += ` AND priority >= $1`;\n      params.push(minPriority);\n    } else {\n      query += ` AND priority >= ?`;\n      params.push(minPriority);\n    }\n  }\n\n  query += ` ORDER BY priority DESC, last_checked_at ASC NULLS FIRST`;\n\n  if (isPostgres) {\n    const result = await (db as any).pool.query(query, params);\n    return result.rows;\n  } else {\n    // SQLite\n    const stmt = (db as any).prepare(query);\n    return params.length > 0 ? stmt.all(...params) : stmt.all();\n  }\n}\n\n/**\n * Upsert a watchlist item (by root_domain + path_prefix)\n */\nexport async function upsertWatchlistItem(item: X402WatchItemInsert): Promise<X402WatchItem> {\n  const db = getDb();\n  const id = crypto.randomUUID();\n  const now = new Date().toISOString();\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\n\n  if (isPostgres) {\n    const result = await (db as any).pool.query(\n      `INSERT INTO x402_watchlist (\n        id, root_domain, path_prefix, category, priority, status, notes, created_at, updated_at\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n      ON CONFLICT (root_domain, path_prefix)\n      DO UPDATE SET\n        category = EXCLUDED.category,\n        priority = EXCLUDED.priority,\n        status = EXCLUDED.status,\n        notes = EXCLUDED.notes,\n        updated_at = EXCLUDED.updated_at\n      RETURNING *`,\n      [\n        id,\n        item.root_domain,\n        item.path_prefix,\n        item.category,\n        item.priority,\n        item.status,\n        item.notes,\n        now,\n        now,\n      ]\n    );\n    return result.rows[0];\n  } else {\n    // SQLite - use INSERT OR REPLACE\n    const stmt = (db as any).prepare(`\n      INSERT OR REPLACE INTO x402_watchlist (\n        id, root_domain, path_prefix, category, priority, status, notes, created_at, updated_at\n      ) VALUES (\n        COALESCE((SELECT id FROM x402_watchlist WHERE root_domain = ? AND (path_prefix = ? OR (path_prefix IS NULL AND ? IS NULL))), ?),\n        ?, ?, ?, ?, ?, ?,\n        COALESCE((SELECT created_at FROM x402_watchlist WHERE root_domain = ? AND (path_prefix = ? OR (path_prefix IS NULL AND ? IS NULL))), ?),\n        ?\n      )\n    `);\n    stmt.run(\n      item.root_domain, item.path_prefix, item.path_prefix, id,\n      item.root_domain, item.path_prefix, item.category, item.priority, item.status, item.notes,\n      item.root_domain, item.path_prefix, item.path_prefix, now,\n      now\n    );\n\n    // Fetch the inserted/updated row\n    const selectStmt = (db as any).prepare(\n      `SELECT * FROM x402_watchlist WHERE root_domain = ? AND (path_prefix = ? OR (path_prefix IS NULL AND ? IS NULL))`\n    );\n    return selectStmt.get(item.root_domain, item.path_prefix, item.path_prefix);\n  }\n}\n\n/**\n * Update watchlist item after a crawl check\n */\nexport async function updateWatchlistItemAfterCheck(\n  id: string,\n  httpStatus: number,\n  etag: string | null,\n  changed: boolean\n): Promise<void> {\n  const db = getDb();\n  const now = new Date().toISOString();\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\n\n  if (isPostgres) {\n    if (changed) {\n      await (db as any).pool.query(\n        `UPDATE x402_watchlist \n         SET last_checked_at = $1, last_http_status = $2, last_etag = $3, last_change_at = $4, updated_at = $5\n         WHERE id = $6`,\n        [now, httpStatus, etag, now, now, id]\n      );\n    } else {\n      await (db as any).pool.query(\n        `UPDATE x402_watchlist \n         SET last_checked_at = $1, last_http_status = $2, last_etag = $3, updated_at = $4\n         WHERE id = $5`,\n        [now, httpStatus, etag, now, id]\n      );\n    }\n  } else {\n    // SQLite\n    if (changed) {\n      const stmt = (db as any).prepare(\n        `UPDATE x402_watchlist \n         SET last_checked_at = ?, last_http_status = ?, last_etag = ?, last_change_at = ?, updated_at = ?\n         WHERE id = ?`\n      );\n      stmt.run(now, httpStatus, etag, now, now, id);\n    } else {\n      const stmt = (db as any).prepare(\n        `UPDATE x402_watchlist \n         SET last_checked_at = ?, last_http_status = ?, last_etag = ?, updated_at = ?\n         WHERE id = ?`\n      );\n      stmt.run(now, httpStatus, etag, now, id);\n    }\n  }\n}\n\n/**\n * Get watchlist item by ID\n */\nexport async function getWatchlistItemById(id: string): Promise<X402WatchItem | null> {\n  const db = getDb();\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\n\n  if (isPostgres) {\n    const result = await (db as any).pool.query(\n      `SELECT * FROM x402_watchlist WHERE id = $1`,\n      [id]\n    );\n    return result.rows[0] || null;\n  } else {\n    const stmt = (db as any).prepare(`SELECT * FROM x402_watchlist WHERE id = ?`);\n    return stmt.get(id) || null;\n  }\n}\n\n/**\n * Get all watchlist items (for admin/debugging)\n */\nexport async function getAllWatchlistItems(): Promise<X402WatchItem[]> {\n  const db = getDb();\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\n\n  if (isPostgres) {\n    const result = await (db as any).pool.query(\n      `SELECT * FROM x402_watchlist ORDER BY priority DESC, root_domain`\n    );\n    return result.rows;\n  } else {\n    const stmt = (db as any).prepare(\n      `SELECT * FROM x402_watchlist ORDER BY priority DESC, root_domain`\n    );\n    return stmt.all();\n  }\n}\n\n/**\n * Map root domain to facilitator identifier\n */\nfunction deriveFacilitator(rootDomain: string): 'cdp' | 'payai' | 'cronos' | 'altlayer' | 'unknown' {\n  if (rootDomain.includes('cdp.coinbase.com') || rootDomain.includes('coinbase.com')) {\n    return 'cdp';\n  }\n  if (rootDomain.includes('payai.network')) {\n    return 'payai';\n  }\n  if (rootDomain.includes('cronos') || rootDomain.includes('cronoslabs.org')) {\n    return 'cronos';\n  }\n  if (rootDomain.includes('altlayer.io')) {\n    return 'altlayer';\n  }\n  return 'unknown';\n}\n\n/**\n * Map category to kind\n */\nfunction categoryToKind(category: X402WatchCategory): 'bazaar' | 'facilitator' | 'gateway_docs' | 'spec' | 'index' {\n  if (category === 'bazaar_discovery') {\n    return 'bazaar';\n  }\n  if (category === 'facilitator_discovery') {\n    return 'facilitator';\n  }\n  if (category === 'gateway_docs') {\n    return 'gateway_docs';\n  }\n  if (category === 'spec') {\n    return 'spec';\n  }\n  return 'index';\n}\n\n/**\n * Discovery resource for SMF routing logic\n */\nexport type X402DiscoveryResource = {\n  facilitator: 'cdp' | 'payai' | 'cronos' | 'altlayer' | 'unknown';\n  kind: 'bazaar' | 'facilitator' | 'gateway_docs' | 'spec' | 'index';\n  url: string;\n  lastHttpStatus: number | null;\n  lastSeenAt: string | null;\n  category: X402WatchCategory;\n  priority: number;\n};\n\n/**\n * Get x402 discovery resources for SMF\n * Returns normalized discovery endpoints that can be used by SMF routing logic\n */\nexport async function getX402DiscoveryResources(): Promise<X402DiscoveryResource[]> {\n  const items = await getAllWatchlistItems();\n  \n  return items\n    .filter(item => item.status === 'active')\n    .map(item => {\n      const url = `https://${item.root_domain}${item.path_prefix || ''}`;\n      return {\n        facilitator: deriveFacilitator(item.root_domain),\n        kind: categoryToKind(item.category),\n        url,\n        lastHttpStatus: item.last_http_status,\n        lastSeenAt: item.last_checked_at,\n        category: item.category,\n        priority: item.priority,\n      };\n    })\n    .sort((a, b) => {\n      // Sort by priority (desc) then by facilitator\n      if (b.priority !== a.priority) {\n        return b.priority - a.priority;\n      }\n      return a.facilitator.localeCompare(b.facilitator);\n    });\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8406, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/agent-recommendations.ts"],"sourcesContent":["// =============================================================================\r\n// AGENT RECOMMENDATIONS DATABASE\r\n// =============================================================================\r\n// Persistence layer for agent recommendations\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  AgentRecommendation,\r\n  AgentRecommendationType,\r\n  AgentId,\r\n  RecommendationStatus,\r\n} from '@/agents/types';\r\n\r\nconst logger = createLogger({ component: 'AgentRecommendationsDB' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface RecommendationFilter {\r\n  agent?: AgentId;\r\n  type?: AgentRecommendationType;\r\n  status?: RecommendationStatus;\r\n  facilitatorId?: string;\r\n  priority?: 'low' | 'medium' | 'high' | 'critical';\r\n  since?: Date;\r\n  limit?: number;\r\n}\r\n\r\nexport interface CreateRecommendationInput {\r\n  agent: AgentId;\r\n  type: AgentRecommendationType;\r\n  facilitatorId?: string;\r\n  resourceId?: string;\r\n  priority: 'low' | 'medium' | 'high' | 'critical';\r\n  confidence: number;\r\n  details: Record<string, unknown>;\r\n  reasoning: string;\r\n  expiresAt?: Date;\r\n}\r\n\r\n// =============================================================================\r\n// DATABASE OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Create a new recommendation\r\n */\r\nexport async function createRecommendation(\r\n  input: CreateRecommendationInput\r\n): Promise<AgentRecommendation> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  const recommendation: AgentRecommendation = {\r\n    id,\r\n    createdAt: now,\r\n    agent: input.agent,\r\n    type: input.type,\r\n    facilitatorId: input.facilitatorId,\r\n    resourceId: input.resourceId,\r\n    priority: input.priority,\r\n    confidence: input.confidence,\r\n    details: input.details,\r\n    reasoning: input.reasoning,\r\n    status: 'PENDING',\r\n    expiresAt: input.expiresAt,\r\n  };\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `INSERT INTO agent_recommendations (\r\n        id, created_at, agent, type, facilitator_id, resource_id,\r\n        priority, confidence, details, reasoning, status, expires_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`,\r\n      [\r\n        id,\r\n        now.toISOString(),\r\n        input.agent,\r\n        input.type,\r\n        input.facilitatorId || null,\r\n        input.resourceId || null,\r\n        input.priority,\r\n        input.confidence,\r\n        JSON.stringify(input.details),\r\n        input.reasoning,\r\n        'PENDING',\r\n        input.expiresAt?.toISOString() || null,\r\n      ]\r\n    );\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO agent_recommendations (\r\n        id, created_at, agent, type, facilitator_id, resource_id,\r\n        priority, confidence, details, reasoning, status, expires_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      now.toISOString(),\r\n      input.agent,\r\n      input.type,\r\n      input.facilitatorId || null,\r\n      input.resourceId || null,\r\n      input.priority,\r\n      input.confidence,\r\n      JSON.stringify(input.details),\r\n      input.reasoning,\r\n      'PENDING',\r\n      input.expiresAt?.toISOString() || null\r\n    );\r\n  }\r\n\r\n  logger.info({\r\n    recommendationId: id,\r\n    agent: input.agent,\r\n    type: input.type,\r\n    priority: input.priority,\r\n    msg: 'Created agent recommendation',\r\n  });\r\n\r\n  return recommendation;\r\n}\r\n\r\n/**\r\n * Create multiple recommendations in batch\r\n */\r\nexport async function createRecommendations(\r\n  inputs: CreateRecommendationInput[]\r\n): Promise<AgentRecommendation[]> {\r\n  const results: AgentRecommendation[] = [];\r\n  for (const input of inputs) {\r\n    const rec = await createRecommendation(input);\r\n    results.push(rec);\r\n  }\r\n  return results;\r\n}\r\n\r\n/**\r\n * List recommendations with optional filters\r\n */\r\nexport async function listRecommendations(\r\n  filter: RecommendationFilter = {}\r\n): Promise<AgentRecommendation[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let query = 'SELECT * FROM agent_recommendations WHERE 1=1';\r\n  const params: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (filter.agent) {\r\n    query += isPostgres ? ` AND agent = $${paramIndex++}` : ' AND agent = ?';\r\n    params.push(filter.agent);\r\n  }\r\n\r\n  if (filter.type) {\r\n    query += isPostgres ? ` AND type = $${paramIndex++}` : ' AND type = ?';\r\n    params.push(filter.type);\r\n  }\r\n\r\n  if (filter.status) {\r\n    query += isPostgres ? ` AND status = $${paramIndex++}` : ' AND status = ?';\r\n    params.push(filter.status);\r\n  }\r\n\r\n  if (filter.facilitatorId) {\r\n    query += isPostgres ? ` AND facilitator_id = $${paramIndex++}` : ' AND facilitator_id = ?';\r\n    params.push(filter.facilitatorId);\r\n  }\r\n\r\n  if (filter.priority) {\r\n    query += isPostgres ? ` AND priority = $${paramIndex++}` : ' AND priority = ?';\r\n    params.push(filter.priority);\r\n  }\r\n\r\n  if (filter.since) {\r\n    query += isPostgres ? ` AND created_at >= $${paramIndex++}` : ' AND created_at >= ?';\r\n    params.push(filter.since.toISOString());\r\n  }\r\n\r\n  query += ' ORDER BY created_at DESC';\r\n\r\n  if (filter.limit) {\r\n    query += isPostgres ? ` LIMIT $${paramIndex++}` : ' LIMIT ?';\r\n    params.push(filter.limit);\r\n  }\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, params);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all(...params);\r\n  }\r\n\r\n  return rows.map(rowToRecommendation);\r\n}\r\n\r\n/**\r\n * Get a single recommendation by ID\r\n */\r\nexport async function getRecommendation(id: string): Promise<AgentRecommendation | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let row: any;\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      'SELECT * FROM agent_recommendations WHERE id = $1',\r\n      [id]\r\n    );\r\n    row = result.rows[0];\r\n  } else {\r\n    const stmt = (db as any).prepare('SELECT * FROM agent_recommendations WHERE id = ?');\r\n    row = stmt.get(id);\r\n  }\r\n\r\n  return row ? rowToRecommendation(row) : null;\r\n}\r\n\r\n/**\r\n * Mark a recommendation as applied\r\n */\r\nexport async function markRecommendationApplied(\r\n  id: string,\r\n  reviewedBy: string,\r\n  metadata?: Record<string, unknown>\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE agent_recommendations\r\n       SET status = 'APPLIED', reviewed_by = $1, reviewed_at = $2,\r\n           details = details || $3\r\n       WHERE id = $4`,\r\n      [reviewedBy, now, JSON.stringify(metadata || {}), id]\r\n    );\r\n  } else {\r\n    // SQLite - simpler update\r\n    const stmt = (db as any).prepare(`\r\n      UPDATE agent_recommendations\r\n      SET status = 'APPLIED', reviewed_by = ?, reviewed_at = ?\r\n      WHERE id = ?\r\n    `);\r\n    stmt.run(reviewedBy, now, id);\r\n  }\r\n\r\n  logger.info({ recommendationId: id, reviewedBy, msg: 'Recommendation applied' });\r\n}\r\n\r\n/**\r\n * Mark a recommendation as rejected\r\n */\r\nexport async function markRecommendationRejected(\r\n  id: string,\r\n  reviewedBy: string,\r\n  reason: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE agent_recommendations\r\n       SET status = 'REJECTED', reviewed_by = $1, reviewed_at = $2,\r\n           details = details || $3\r\n       WHERE id = $4`,\r\n      [reviewedBy, now, JSON.stringify({ rejectionReason: reason }), id]\r\n    );\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      UPDATE agent_recommendations\r\n      SET status = 'REJECTED', reviewed_by = ?, reviewed_at = ?\r\n      WHERE id = ?\r\n    `);\r\n    stmt.run(reviewedBy, now, id);\r\n  }\r\n\r\n  logger.info({ recommendationId: id, reviewedBy, reason, msg: 'Recommendation rejected' });\r\n}\r\n\r\n/**\r\n * Expire old pending recommendations\r\n */\r\nexport async function expirePendingRecommendations(): Promise<number> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `UPDATE agent_recommendations\r\n       SET status = 'EXPIRED'\r\n       WHERE status = 'PENDING' AND expires_at IS NOT NULL AND expires_at < $1`,\r\n      [now]\r\n    );\r\n    return result.rowCount || 0;\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      UPDATE agent_recommendations\r\n      SET status = 'EXPIRED'\r\n      WHERE status = 'PENDING' AND expires_at IS NOT NULL AND expires_at < ?\r\n    `);\r\n    const info = stmt.run(now);\r\n    return info.changes || 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Get pending recommendations count by agent\r\n */\r\nexport async function getPendingCountByAgent(): Promise<Record<AgentId, number>> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  const query = `\r\n    SELECT agent, COUNT(*) as count\r\n    FROM agent_recommendations\r\n    WHERE status = 'PENDING'\r\n    GROUP BY agent\r\n  `;\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all();\r\n  }\r\n\r\n  const counts: Record<string, number> = {};\r\n  for (const row of rows) {\r\n    counts[row.agent] = parseInt(row.count, 10);\r\n  }\r\n  return counts as Record<AgentId, number>;\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\nfunction rowToRecommendation(row: any): AgentRecommendation {\r\n  return {\r\n    id: row.id,\r\n    createdAt: new Date(row.created_at),\r\n    agent: row.agent,\r\n    type: row.type,\r\n    facilitatorId: row.facilitator_id || undefined,\r\n    resourceId: row.resource_id || undefined,\r\n    priority: row.priority,\r\n    confidence: parseFloat(row.confidence),\r\n    details: typeof row.details === 'string' ? JSON.parse(row.details) : row.details,\r\n    reasoning: row.reasoning,\r\n    status: row.status,\r\n    reviewedBy: row.reviewed_by || undefined,\r\n    reviewedAt: row.reviewed_at ? new Date(row.reviewed_at) : undefined,\r\n    expiresAt: row.expires_at ? new Date(row.expires_at) : undefined,\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8693, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/agents/routing-tuner.ts"],"sourcesContent":["// =============================================================================\r\n// ROUTING TUNER AGENT\r\n// =============================================================================\r\n// Analyzes facilitator performance and proposes routing changes\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  WorldState,\r\n  FacilitatorState,\r\n  AgentRecommendation,\r\n  RoutingTunerOutput,\r\n} from './types';\r\n\r\nconst logger = createLogger({ component: 'RoutingTuner' });\r\n\r\n// =============================================================================\r\n// CONFIGURATION (can be overridden via env vars)\r\n// =============================================================================\r\n\r\nexport const ROUTING_TUNER_CONFIG = {\r\n  // Thresholds for deprioritization\r\n  deprioritizeSuccessRateThreshold: parseFloat(\r\n    process.env.ROUTING_TUNER_DEPRIORITIZE_SUCCESS_RATE || '0.85'\r\n  ),\r\n  deprioritizeLatencyThresholdMs: parseInt(\r\n    process.env.ROUTING_TUNER_DEPRIORITIZE_LATENCY_MS || '3000', 10\r\n  ),\r\n  \r\n  // Thresholds for promotion\r\n  promoteSuccessRateThreshold: parseFloat(\r\n    process.env.ROUTING_TUNER_PROMOTE_SUCCESS_RATE || '0.98'\r\n  ),\r\n  promoteLatencyThresholdMs: parseInt(\r\n    process.env.ROUTING_TUNER_PROMOTE_LATENCY_MS || '500', 10\r\n  ),\r\n  \r\n  // Minimum data requirements\r\n  minInvocationsForDecision: parseInt(\r\n    process.env.ROUTING_TUNER_MIN_INVOCATIONS || '100', 10\r\n  ),\r\n  \r\n  // Confidence thresholds\r\n  highConfidenceThreshold: parseFloat(\r\n    process.env.ROUTING_TUNER_HIGH_CONFIDENCE || '0.8'\r\n  ),\r\n  mediumConfidenceThreshold: parseFloat(\r\n    process.env.ROUTING_TUNER_MEDIUM_CONFIDENCE || '0.5'\r\n  ),\r\n  \r\n  // How many top performers to track\r\n  topPerformersCount: parseInt(\r\n    process.env.ROUTING_TUNER_TOP_PERFORMERS || '3', 10\r\n  ),\r\n};\r\n\r\n// =============================================================================\r\n// ROUTING TUNER\r\n// =============================================================================\r\n\r\n/**\r\n * Run the routing tuner to analyze facilitator performance\r\n */\r\nexport async function runRoutingTuner(worldState: WorldState): Promise<RoutingTunerOutput> {\r\n  const recommendations: AgentRecommendation[] = [];\r\n  const now = new Date();\r\n\r\n  logger.info({ facilitatorCount: worldState.facilitators.length, msg: 'Running routing tuner' });\r\n\r\n  // 1. Identify top performers\r\n  const sortedByScore = [...worldState.facilitators]\r\n    .filter((f) => f.totalInvocations >= ROUTING_TUNER_CONFIG.minInvocationsForDecision)\r\n    .sort((a, b) => b.score - a.score);\r\n\r\n  const topPerformers = sortedByScore\r\n    .slice(0, ROUTING_TUNER_CONFIG.topPerformersCount)\r\n    .map((f) => f.id);\r\n\r\n  // 2. Identify underperformers (low success rate or high latency)\r\n  const underperformers: string[] = [];\r\n  const newContenders: string[] = [];\r\n\r\n  for (const facilitator of worldState.facilitators) {\r\n    const analysis = analyzeFacilitator(facilitator);\r\n\r\n    // Check if facilitator should be deprioritized\r\n    if (analysis.shouldDeprioritize) {\r\n      underperformers.push(facilitator.id);\r\n      \r\n      recommendations.push(createDeprioritizeRecommendation(\r\n        facilitator,\r\n        analysis.deprioritizeReasons,\r\n        analysis.confidence,\r\n        now\r\n      ));\r\n    }\r\n\r\n    // Check if facilitator should be promoted\r\n    if (analysis.shouldPromote && !topPerformers.includes(facilitator.id)) {\r\n      newContenders.push(facilitator.id);\r\n      \r\n      recommendations.push(createPromoteRecommendation(\r\n        facilitator,\r\n        analysis.promoteReasons,\r\n        analysis.confidence,\r\n        now\r\n      ));\r\n    }\r\n  }\r\n\r\n  // 3. Check for risk anomalies that need routing changes\r\n  for (const anomaly of worldState.riskAnomalies) {\r\n    if (anomaly.severity === 'critical' && anomaly.facilitatorId) {\r\n      // Check if we already have a recommendation for this facilitator\r\n      const existingRec = recommendations.find(\r\n        (r) => r.facilitatorId === anomaly.facilitatorId && r.type === 'FACILITATOR_DEPRIORITIZE'\r\n      );\r\n\r\n      if (!existingRec) {\r\n        recommendations.push({\r\n          id: crypto.randomUUID(),\r\n          createdAt: now,\r\n          agent: 'routing_tuner',\r\n          type: 'FACILITATOR_DEPRIORITIZE',\r\n          facilitatorId: anomaly.facilitatorId,\r\n          priority: 'critical',\r\n          confidence: 0.9,\r\n          details: {\r\n            anomalyId: anomaly.id,\r\n            anomalyType: anomaly.type,\r\n            metrics: anomaly.metrics,\r\n          },\r\n          reasoning: `Critical risk anomaly detected: ${anomaly.description}`,\r\n          status: 'PENDING',\r\n          expiresAt: new Date(now.getTime() + 24 * 60 * 60 * 1000), // Expires in 24h\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  const output: RoutingTunerOutput = {\r\n    recommendations,\r\n    analysis: {\r\n      topPerformers,\r\n      underperformers,\r\n      newContenders,\r\n    },\r\n  };\r\n\r\n  logger.info({\r\n    topPerformers,\r\n    underperformers,\r\n    newContenders,\r\n    recommendationCount: recommendations.length,\r\n    msg: 'Routing tuner completed',\r\n  });\r\n\r\n  return output;\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\ninterface FacilitatorAnalysis {\r\n  shouldDeprioritize: boolean;\r\n  deprioritizeReasons: string[];\r\n  shouldPromote: boolean;\r\n  promoteReasons: string[];\r\n  confidence: number;\r\n}\r\n\r\n/**\r\n * Analyze a single facilitator\r\n */\r\nfunction analyzeFacilitator(facilitator: FacilitatorState): FacilitatorAnalysis {\r\n  const deprioritizeReasons: string[] = [];\r\n  const promoteReasons: string[] = [];\r\n\r\n  // Determine confidence based on data\r\n  let confidence = 0;\r\n  if (facilitator.confidence === 'high') {\r\n    confidence = ROUTING_TUNER_CONFIG.highConfidenceThreshold + 0.1;\r\n  } else if (facilitator.confidence === 'medium') {\r\n    confidence = ROUTING_TUNER_CONFIG.mediumConfidenceThreshold + 0.2;\r\n  } else if (facilitator.confidence === 'low') {\r\n    confidence = ROUTING_TUNER_CONFIG.mediumConfidenceThreshold;\r\n  } else {\r\n    confidence = 0.3; // Low confidence for no data\r\n  }\r\n\r\n  // Not enough data to make decisions\r\n  if (facilitator.totalInvocations < ROUTING_TUNER_CONFIG.minInvocationsForDecision) {\r\n    return {\r\n      shouldDeprioritize: false,\r\n      deprioritizeReasons: [],\r\n      shouldPromote: false,\r\n      promoteReasons: [],\r\n      confidence: 0.2,\r\n    };\r\n  }\r\n\r\n  // Check for deprioritization\r\n  if (facilitator.successRate < ROUTING_TUNER_CONFIG.deprioritizeSuccessRateThreshold) {\r\n    deprioritizeReasons.push(\r\n      `Success rate ${(facilitator.successRate * 100).toFixed(1)}% below threshold ${ROUTING_TUNER_CONFIG.deprioritizeSuccessRateThreshold * 100}%`\r\n    );\r\n  }\r\n\r\n  if (facilitator.avgLatencyMs > ROUTING_TUNER_CONFIG.deprioritizeLatencyThresholdMs) {\r\n    deprioritizeReasons.push(\r\n      `Average latency ${facilitator.avgLatencyMs}ms exceeds threshold ${ROUTING_TUNER_CONFIG.deprioritizeLatencyThresholdMs}ms`\r\n    );\r\n  }\r\n\r\n  if (facilitator.status === 'down' || facilitator.status === 'degraded') {\r\n    deprioritizeReasons.push(`Facilitator status is ${facilitator.status}`);\r\n  }\r\n\r\n  // Check for promotion\r\n  if (\r\n    facilitator.successRate >= ROUTING_TUNER_CONFIG.promoteSuccessRateThreshold &&\r\n    facilitator.avgLatencyMs <= ROUTING_TUNER_CONFIG.promoteLatencyThresholdMs\r\n  ) {\r\n    promoteReasons.push(\r\n      `Excellent performance: ${(facilitator.successRate * 100).toFixed(1)}% success, ${facilitator.avgLatencyMs}ms latency`\r\n    );\r\n  }\r\n\r\n  if (facilitator.score >= 90) {\r\n    promoteReasons.push(`High composite score: ${facilitator.score.toFixed(1)}`);\r\n  }\r\n\r\n  return {\r\n    shouldDeprioritize: deprioritizeReasons.length > 0,\r\n    deprioritizeReasons,\r\n    shouldPromote: promoteReasons.length > 0 && deprioritizeReasons.length === 0,\r\n    promoteReasons,\r\n    confidence,\r\n  };\r\n}\r\n\r\n/**\r\n * Create a deprioritize recommendation\r\n */\r\nfunction createDeprioritizeRecommendation(\r\n  facilitator: FacilitatorState,\r\n  reasons: string[],\r\n  confidence: number,\r\n  now: Date\r\n): AgentRecommendation {\r\n  // Determine priority based on severity\r\n  let priority: 'low' | 'medium' | 'high' | 'critical' = 'medium';\r\n  if (facilitator.successRate < 0.5 || facilitator.status === 'down') {\r\n    priority = 'critical';\r\n  } else if (facilitator.successRate < 0.7) {\r\n    priority = 'high';\r\n  }\r\n\r\n  return {\r\n    id: crypto.randomUUID(),\r\n    createdAt: now,\r\n    agent: 'routing_tuner',\r\n    type: 'FACILITATOR_DEPRIORITIZE',\r\n    facilitatorId: facilitator.id,\r\n    priority,\r\n    confidence,\r\n    details: {\r\n      // Metrics snapshot at decision time\r\n      metricsSnapshot: {\r\n        timestamp: now.toISOString(),\r\n        score: facilitator.score,\r\n        successRate: facilitator.successRate,\r\n        avgLatencyMs: facilitator.avgLatencyMs,\r\n        p95LatencyMs: facilitator.p95LatencyMs,\r\n        totalInvocations: facilitator.totalInvocations,\r\n        trustTier: facilitator.trustTier,\r\n        status: facilitator.status,\r\n        confidence: facilitator.confidence,\r\n      },\r\n      // Thresholds used for decision\r\n      thresholdsUsed: {\r\n        deprioritizeSuccessRate: ROUTING_TUNER_CONFIG.deprioritizeSuccessRateThreshold,\r\n        deprioritizeLatencyMs: ROUTING_TUNER_CONFIG.deprioritizeLatencyThresholdMs,\r\n        minInvocations: ROUTING_TUNER_CONFIG.minInvocationsForDecision,\r\n      },\r\n      // Conditions that triggered this recommendation\r\n      triggeredConditions: reasons,\r\n      // Whether facilitator is currently routable\r\n      isCurrentlyRoutable: facilitator.status !== 'down' && facilitator.status !== 'degraded',\r\n    },\r\n    reasoning: `Recommend deprioritizing ${facilitator.id}: ${reasons.join('; ')}`,\r\n    status: 'PENDING',\r\n    expiresAt: new Date(now.getTime() + 24 * 60 * 60 * 1000), // Expires in 24h\r\n  };\r\n}\r\n\r\n/**\r\n * Create a promote recommendation\r\n */\r\nfunction createPromoteRecommendation(\r\n  facilitator: FacilitatorState,\r\n  reasons: string[],\r\n  confidence: number,\r\n  now: Date\r\n): AgentRecommendation {\r\n  return {\r\n    id: crypto.randomUUID(),\r\n    createdAt: now,\r\n    agent: 'routing_tuner',\r\n    type: 'FACILITATOR_PROMOTE',\r\n    facilitatorId: facilitator.id,\r\n    priority: 'low',\r\n    confidence,\r\n    details: {\r\n      // Metrics snapshot at decision time\r\n      metricsSnapshot: {\r\n        timestamp: now.toISOString(),\r\n        score: facilitator.score,\r\n        successRate: facilitator.successRate,\r\n        avgLatencyMs: facilitator.avgLatencyMs,\r\n        p95LatencyMs: facilitator.p95LatencyMs,\r\n        totalInvocations: facilitator.totalInvocations,\r\n        trustTier: facilitator.trustTier,\r\n        status: facilitator.status,\r\n        confidence: facilitator.confidence,\r\n      },\r\n      // Thresholds used for decision\r\n      thresholdsUsed: {\r\n        promoteSuccessRate: ROUTING_TUNER_CONFIG.promoteSuccessRateThreshold,\r\n        promoteLatencyMs: ROUTING_TUNER_CONFIG.promoteLatencyThresholdMs,\r\n        minInvocations: ROUTING_TUNER_CONFIG.minInvocationsForDecision,\r\n      },\r\n      // Conditions that triggered this recommendation\r\n      triggeredConditions: reasons,\r\n    },\r\n    reasoning: `Recommend promoting ${facilitator.id}: ${reasons.join('; ')}`,\r\n    status: 'PENDING',\r\n    expiresAt: new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000), // Expires in 7 days\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8934, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/agents/pricing-tuner.ts"],"sourcesContent":["// =============================================================================\r\n// PRICING TUNER AGENT (STUB)\r\n// =============================================================================\r\n// Analyzes resource pricing and proposes adjustments\r\n// \r\n// TODO: This is a stub implementation. Future enhancements:\r\n// - Integrate with metered endpoints to get pricing data\r\n// - Analyze cost vs. usage patterns\r\n// - Propose price changes based on market conditions\r\n// - Factor in facilitator fees\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  WorldState,\r\n  AgentRecommendation,\r\n  PricingTunerOutput,\r\n} from './types';\r\n\r\nconst logger = createLogger({ component: 'PricingTuner' });\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nconst PRICING_TUNER_CONFIG = {\r\n  // Minimum margin to maintain over facilitator fees\r\n  minMarginBps: 50, // 0.5%\r\n  \r\n  // Maximum price increase per adjustment\r\n  maxPriceIncreasePct: 20,\r\n  \r\n  // Minimum usage to consider for price changes\r\n  minUsageForPricing: 100,\r\n};\r\n\r\n// =============================================================================\r\n// PRICING TUNER\r\n// =============================================================================\r\n\r\n/**\r\n * Run the pricing tuner to analyze resource pricing\r\n * \r\n * NOTE: This is a stub implementation. Currently returns no recommendations.\r\n * \r\n * Future implementation should:\r\n * 1. Query metered endpoints to get current pricing\r\n * 2. Analyze usage patterns and revenue\r\n * 3. Compare against facilitator fees\r\n * 4. Propose price adjustments to optimize for usage or revenue\r\n */\r\nexport async function runPricingTuner(worldState: WorldState): Promise<PricingTunerOutput> {\r\n  const recommendations: AgentRecommendation[] = [];\r\n\r\n  logger.info({ msg: 'Running pricing tuner (stub)' });\r\n\r\n  // TODO: Implement actual pricing analysis\r\n  // For now, just log that this is a stub\r\n  \r\n  // Example of what future implementation might look like:\r\n  /*\r\n  const endpoints = await getMeteredEndpoints();\r\n  \r\n  for (const endpoint of endpoints) {\r\n    const usage = await getEndpointUsage(endpoint.id, '7d');\r\n    const facilitatorCost = calculateFacilitatorCost(endpoint, worldState.facilitators);\r\n    const currentMargin = endpoint.priceUsd - facilitatorCost;\r\n    \r\n    if (currentMargin < PRICING_TUNER_CONFIG.minMarginBps / 100) {\r\n      recommendations.push({\r\n        id: crypto.randomUUID(),\r\n        createdAt: new Date(),\r\n        agent: 'pricing_tuner',\r\n        type: 'PRICING_CHANGE',\r\n        resourceId: endpoint.id,\r\n        priority: 'medium',\r\n        confidence: 0.7,\r\n        details: {\r\n          currentPrice: endpoint.priceUsd,\r\n          suggestedPrice: facilitatorCost * 1.1, // 10% margin\r\n          facilitatorCost,\r\n          usage7d: usage.totalCalls,\r\n        },\r\n        reasoning: `Margin below minimum threshold. Suggest price increase.`,\r\n        status: 'PENDING',\r\n      });\r\n    }\r\n  }\r\n  */\r\n\r\n  const output: PricingTunerOutput = {\r\n    recommendations,\r\n    analysis: {\r\n      resourcesReviewed: 0, // TODO: Count actual resources reviewed\r\n      priceChangesProposed: recommendations.length,\r\n    },\r\n  };\r\n\r\n  logger.info({\r\n    recommendationCount: recommendations.length,\r\n    msg: 'Pricing tuner completed (stub)',\r\n  });\r\n\r\n  return output;\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,6BAA6B;AAC7B,gFAAgF;AAChF,qDAAqD;AACrD,GAAG;AACH,4DAA4D;AAC5D,yDAAyD;AACzD,oCAAoC;AACpC,qDAAqD;AACrD,+BAA+B;;;;;AAE/B;;AAOA,MAAM,SAAS,IAAA,sIAAY,EAAC;IAAE,WAAW;AAAe;AAExD,gFAAgF;AAChF,gBAAgB;AAChB,gFAAgF;AAEhF,6DAA6D;AAC7D,MAAM,uBAAuB;IAC3B,mDAAmD;IACnD,cAAc;IAEd,wCAAwC;IACxC,qBAAqB;IAErB,8CAA8C;IAC9C,oBAAoB;AACtB;AAiBO,eAAe,gBAAgB,UAAsB;IAC1D,MAAM,kBAAyC,EAAE;IAEjD,OAAO,IAAI,CAAC;QAAE,KAAK;IAA+B;IAElD,0CAA0C;IAC1C,wCAAwC;IAExC,yDAAyD;IACzD;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4BA,GAEA,MAAM,SAA6B;QACjC;QACA,UAAU;YACR,mBAAmB;YACnB,sBAAsB,gBAAgB,MAAM;QAC9C;IACF;IAEA,OAAO,IAAI,CAAC;QACV,qBAAqB,gBAAgB,MAAM;QAC3C,KAAK;IACP;IAEA,OAAO;AACT"}},
    {"offset": {"line": 9018, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/agents/scout-tuner.ts"],"sourcesContent":["// =============================================================================\r\n// SCOUT TUNER AGENT\r\n// =============================================================================\r\n// Evaluates newly discovered facilitators and proposes onboarding\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  WorldState,\r\n  PendingFacilitator,\r\n  AgentRecommendation,\r\n  ScoutTunerOutput,\r\n} from './types';\r\n\r\nconst logger = createLogger({ component: 'ScoutTuner' });\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\nconst SCOUT_TUNER_CONFIG = {\r\n  // Minimum external score to consider onboarding\r\n  minExternalScoreForOnboarding: 60,\r\n  \r\n  // Maximum pending duration before requiring evaluation\r\n  maxPendingDurationDays: 7,\r\n  \r\n  // Required networks for onboarding (must support at least one)\r\n  requiredNetworks: ['eip155:8453'], // Base mainnet\r\n  \r\n  // Required assets for onboarding (must support at least one)\r\n  requiredAssets: ['USDC'],\r\n};\r\n\r\n// =============================================================================\r\n// SCOUT TUNER\r\n// =============================================================================\r\n\r\n/**\r\n * Run the scout tuner to evaluate pending facilitators\r\n */\r\nexport async function runScoutTuner(worldState: WorldState): Promise<ScoutTunerOutput> {\r\n  const recommendations: AgentRecommendation[] = [];\r\n  const now = new Date();\r\n\r\n  const readyForOnboarding: string[] = [];\r\n  const rejected: string[] = [];\r\n\r\n  logger.info({\r\n    pendingCount: worldState.pendingFacilitators.length,\r\n    msg: 'Running scout tuner',\r\n  });\r\n\r\n  for (const pending of worldState.pendingFacilitators) {\r\n    const evaluation = evaluatePendingFacilitator(pending, worldState, now);\r\n\r\n    if (evaluation.readyForOnboarding) {\r\n      readyForOnboarding.push(pending.id);\r\n      \r\n      recommendations.push({\r\n        id: crypto.randomUUID(),\r\n        createdAt: now,\r\n        agent: 'scout_tuner',\r\n        type: 'FACILITATOR_ONBOARD',\r\n        facilitatorId: pending.id,\r\n        priority: evaluation.priority,\r\n        confidence: evaluation.confidence,\r\n        details: {\r\n          name: pending.name,\r\n          source: pending.source,\r\n          discoveredAt: pending.discoveredAt.toISOString(),\r\n          externalScore: pending.externalScore,\r\n          networks: pending.networks,\r\n          assets: pending.assets,\r\n          evaluationReasons: evaluation.reasons,\r\n        },\r\n        reasoning: `Recommend onboarding ${pending.name}: ${evaluation.reasons.join('; ')}`,\r\n        status: 'PENDING',\r\n        expiresAt: new Date(now.getTime() + 14 * 24 * 60 * 60 * 1000), // Expires in 14 days\r\n      });\r\n    } else if (evaluation.shouldReject) {\r\n      rejected.push(pending.id);\r\n      \r\n      // We don't create a formal recommendation for rejections,\r\n      // but we could log or track them\r\n      logger.info({\r\n        facilitatorId: pending.id,\r\n        reasons: evaluation.rejectionReasons,\r\n        msg: 'Pending facilitator rejected',\r\n      });\r\n    }\r\n    // Otherwise, leave in pending state for more data\r\n  }\r\n\r\n  // Check for stale pending facilitators that need attention\r\n  const stalePending = worldState.pendingFacilitators.filter((p) => {\r\n    const daysPending = (now.getTime() - p.discoveredAt.getTime()) / (24 * 60 * 60 * 1000);\r\n    return daysPending > SCOUT_TUNER_CONFIG.maxPendingDurationDays;\r\n  });\r\n\r\n  if (stalePending.length > 0) {\r\n    recommendations.push({\r\n      id: crypto.randomUUID(),\r\n      createdAt: now,\r\n      agent: 'scout_tuner',\r\n      type: 'RISK_ALERT',\r\n      priority: 'low',\r\n      confidence: 0.8,\r\n      details: {\r\n        staleFacilitatorIds: stalePending.map((p) => p.id),\r\n        staleFacilitatorNames: stalePending.map((p) => p.name),\r\n        maxAgeDays: Math.max(\r\n          ...stalePending.map(\r\n            (p) => (now.getTime() - p.discoveredAt.getTime()) / (24 * 60 * 60 * 1000)\r\n          )\r\n        ),\r\n      },\r\n      reasoning: `${stalePending.length} facilitator(s) have been pending evaluation for more than ${SCOUT_TUNER_CONFIG.maxPendingDurationDays} days`,\r\n      status: 'PENDING',\r\n    });\r\n  }\r\n\r\n  const output: ScoutTunerOutput = {\r\n    recommendations,\r\n    analysis: {\r\n      pendingEvaluated: worldState.pendingFacilitators.length,\r\n      readyForOnboarding,\r\n      rejected,\r\n    },\r\n  };\r\n\r\n  logger.info({\r\n    pendingEvaluated: worldState.pendingFacilitators.length,\r\n    readyForOnboarding,\r\n    rejected,\r\n    recommendationCount: recommendations.length,\r\n    msg: 'Scout tuner completed',\r\n  });\r\n\r\n  return output;\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\ninterface PendingEvaluation {\r\n  readyForOnboarding: boolean;\r\n  shouldReject: boolean;\r\n  priority: 'low' | 'medium' | 'high' | 'critical';\r\n  confidence: number;\r\n  reasons: string[];\r\n  rejectionReasons: string[];\r\n}\r\n\r\n/**\r\n * Evaluate a pending facilitator for onboarding\r\n */\r\nfunction evaluatePendingFacilitator(\r\n  pending: PendingFacilitator,\r\n  worldState: WorldState,\r\n  now: Date\r\n): PendingEvaluation {\r\n  const reasons: string[] = [];\r\n  const rejectionReasons: string[] = [];\r\n  let confidence = 0.5;\r\n  let readyForOnboarding = false;\r\n  let shouldReject = false;\r\n  let priority: 'low' | 'medium' | 'high' | 'critical' = 'low';\r\n\r\n  // Check external score\r\n  if (pending.externalScore !== undefined) {\r\n    if (pending.externalScore >= SCOUT_TUNER_CONFIG.minExternalScoreForOnboarding) {\r\n      reasons.push(`External score ${pending.externalScore} meets threshold`);\r\n      confidence += 0.2;\r\n    } else {\r\n      rejectionReasons.push(\r\n        `External score ${pending.externalScore} below threshold ${SCOUT_TUNER_CONFIG.minExternalScoreForOnboarding}`\r\n      );\r\n    }\r\n  } else {\r\n    // No external score - lower confidence\r\n    reasons.push('No external score available - manual review recommended');\r\n    confidence -= 0.1;\r\n  }\r\n\r\n  // Check network support\r\n  const hasRequiredNetwork = pending.networks.length === 0 || // Unknown = might support\r\n    pending.networks.some((n) => SCOUT_TUNER_CONFIG.requiredNetworks.includes(n));\r\n  \r\n  if (hasRequiredNetwork) {\r\n    if (pending.networks.length > 0) {\r\n      reasons.push(`Supports required network(s): ${pending.networks.join(', ')}`);\r\n      confidence += 0.1;\r\n    }\r\n  } else {\r\n    rejectionReasons.push(\r\n      `Does not support required networks. Has: ${pending.networks.join(', ')}`\r\n    );\r\n  }\r\n\r\n  // Check asset support\r\n  const hasRequiredAsset = pending.assets.length === 0 || // Unknown = might support\r\n    pending.assets.some((a) => SCOUT_TUNER_CONFIG.requiredAssets.includes(a));\r\n  \r\n  if (hasRequiredAsset) {\r\n    if (pending.assets.length > 0) {\r\n      reasons.push(`Supports required asset(s): ${pending.assets.join(', ')}`);\r\n      confidence += 0.1;\r\n    }\r\n  } else {\r\n    rejectionReasons.push(\r\n      `Does not support required assets. Has: ${pending.assets.join(', ')}`\r\n    );\r\n  }\r\n\r\n  // Check if from trusted source\r\n  if (pending.source === 'bazaar') {\r\n    reasons.push('Discovered from Bazaar marketplace');\r\n    confidence += 0.1;\r\n    priority = 'medium';\r\n  }\r\n\r\n  // Check how long it's been pending\r\n  const daysPending = (now.getTime() - pending.discoveredAt.getTime()) / (24 * 60 * 60 * 1000);\r\n  if (daysPending > 30) {\r\n    rejectionReasons.push(`Stale: pending for ${Math.round(daysPending)} days without progress`);\r\n  }\r\n\r\n  // Check for existing similar facilitators\r\n  // If we already have many high-performing facilitators, lower priority\r\n  const highPerformers = worldState.facilitators.filter((f) => f.score >= 80);\r\n  if (highPerformers.length >= 3) {\r\n    reasons.push('Multiple high-performing facilitators already available');\r\n    priority = 'low';\r\n    confidence -= 0.1;\r\n  } else {\r\n    reasons.push('Could fill gap in facilitator coverage');\r\n    priority = 'medium';\r\n    confidence += 0.1;\r\n  }\r\n\r\n  // Determine final decision\r\n  confidence = Math.max(0.1, Math.min(0.95, confidence)); // Clamp to [0.1, 0.95]\r\n\r\n  if (rejectionReasons.length > 0 && reasons.length === 0) {\r\n    shouldReject = true;\r\n  } else if (reasons.length > 0 && rejectionReasons.length === 0 && confidence >= 0.5) {\r\n    readyForOnboarding = true;\r\n  }\r\n  // Otherwise, leave in pending state\r\n\r\n  return {\r\n    readyForOnboarding,\r\n    shouldReject,\r\n    priority,\r\n    confidence,\r\n    reasons,\r\n    rejectionReasons,\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9223, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/agents/coordinator.ts"],"sourcesContent":["// =============================================================================\r\n// COORDINATOR / SUPER-AGENT\r\n// =============================================================================\r\n// Main orchestration agent that coordinates sub-agents and builds world state\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport { rankFacilitators, getFacilitatorScore } from '@/services/facilitator-metrics-reader';\r\nimport { getMetaFacilitator } from '@/integrations/x402/orchestrator/meta-facilitator';\r\nimport { getActiveWatchlistItems } from '@/db/x402-watchlist';\r\nimport { createRecommendations } from '@/db/agent-recommendations';\r\nimport { runRoutingTuner } from './routing-tuner';\r\nimport { runPricingTuner } from './pricing-tuner';\r\nimport { runScoutTuner } from './scout-tuner';\r\nimport type {\r\n  WorldState,\r\n  FacilitatorState,\r\n  PendingFacilitator,\r\n  RiskAnomaly,\r\n  CoordinatorOutput,\r\n  AgentRecommendation,\r\n} from './types';\r\n\r\nconst logger = createLogger({ component: 'Coordinator' });\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\nconst COORDINATOR_CONFIG = {\r\n  // Thresholds for anomaly detection\r\n  successRateWarningThreshold: 0.9, // Below this triggers warning\r\n  successRateCriticalThreshold: 0.7, // Below this triggers critical\r\n  latencyWarningThresholdMs: 2000,\r\n  latencyCriticalThresholdMs: 5000,\r\n  \r\n  // Default facilitator IDs to monitor (from registry)\r\n  defaultFacilitatorIds: ['cdp', 'payai', 'x402rs', 'dexter'],\r\n};\r\n\r\n// =============================================================================\r\n// WORLD STATE BUILDER\r\n// =============================================================================\r\n\r\n/**\r\n * Build the current world state by reading from metrics and services\r\n */\r\nexport async function buildWorldState(): Promise<WorldState> {\r\n  const timestamp = new Date();\r\n  \r\n  logger.info({ msg: 'Building world state for coordinator' });\r\n\r\n  // 1. Get facilitator rankings and scores\r\n  const rankings = await rankFacilitators(\r\n    COORDINATOR_CONFIG.defaultFacilitatorIds,\r\n    '1d'\r\n  );\r\n\r\n  // 2. Get meta-facilitator status for health info\r\n  const metaFacilitator = getMetaFacilitator();\r\n  const status = await metaFacilitator.getStatus();\r\n\r\n  // 3. Build facilitator states\r\n  const facilitators: FacilitatorState[] = [];\r\n  \r\n  for (const ranking of rankings.rankings) {\r\n    const healthDetail = status.facilitatorDetails.find(\r\n      (d) => d.id === ranking.facilitatorId\r\n    );\r\n\r\n    // Determine if facilitator is currently routable\r\n    const isHealthy = healthDetail?.healthy ?? false;\r\n    const hasData = ranking.confidence !== 'none';\r\n    const notBlocked = ranking.successRate > 0.1; // Not completely failing\r\n    const isRoutable = isHealthy && hasData && notBlocked;\r\n    \r\n    let nonRoutableReason: string | undefined;\r\n    if (!isRoutable) {\r\n      const reasons: string[] = [];\r\n      if (!isHealthy) reasons.push('failing health check');\r\n      if (!hasData) reasons.push('no performance data');\r\n      if (!notBlocked) reasons.push('success rate critically low');\r\n      nonRoutableReason = reasons.join(', ');\r\n    }\r\n\r\n    facilitators.push({\r\n      id: ranking.facilitatorId,\r\n      name: healthDetail?.name || ranking.facilitatorId,\r\n      score: ranking.score,\r\n      successRate: ranking.successRate,\r\n      avgLatencyMs: ranking.avgLatencyMs || 0,\r\n      p95LatencyMs: ranking.p95LatencyMs,\r\n      totalInvocations: ranking.totalInvocations,\r\n      confidence: ranking.confidence,\r\n      trustTier: mapConfidenceToTier(ranking.confidence),\r\n      status: healthDetail?.healthy ? 'healthy' : 'unknown',\r\n      networks: status.networks,\r\n      assets: status.assets,\r\n      feeBps: 0, // TODO: Get from capabilities table\r\n      // TODO: Compute deltas from historical data\r\n      scoreDelta24h: undefined,\r\n      successRateDelta24h: undefined,\r\n      // Routing eligibility\r\n      isRoutable,\r\n      nonRoutableReason,\r\n    });\r\n  }\r\n\r\n  // 4. Get pending facilitators from watchlist\r\n  const pendingFacilitators = await getPendingFacilitators();\r\n\r\n  // 5. Detect risk anomalies\r\n  const riskAnomalies = detectRiskAnomalies(facilitators);\r\n\r\n  // 6. Build aggregates\r\n  const aggregates = computeAggregates(facilitators);\r\n\r\n  // 7. Build recent decisions summary\r\n  const recentDecisions = facilitators.map((f) => ({\r\n    facilitatorId: f.id,\r\n    routeCount: f.totalInvocations,\r\n    successCount: Math.round(f.totalInvocations * f.successRate),\r\n    avgLatencyMs: f.avgLatencyMs,\r\n  }));\r\n\r\n  const worldState: WorldState = {\r\n    timestamp,\r\n    facilitators,\r\n    pendingFacilitators,\r\n    riskAnomalies,\r\n    aggregates,\r\n    recentDecisions,\r\n  };\r\n\r\n  logger.info({\r\n    facilitatorCount: facilitators.length,\r\n    pendingCount: pendingFacilitators.length,\r\n    anomalyCount: riskAnomalies.length,\r\n    msg: 'World state built',\r\n  });\r\n\r\n  return worldState;\r\n}\r\n\r\n// =============================================================================\r\n// COORDINATOR TICK\r\n// =============================================================================\r\n\r\n/**\r\n * Run a single coordinator tick\r\n * This is the main entry point called by the cron\r\n */\r\nexport async function runCoordinatorTick(): Promise<CoordinatorOutput> {\r\n  const runId = crypto.randomUUID();\r\n  const startedAt = new Date();\r\n  const errors: string[] = [];\r\n\r\n  logger.info({ runId, msg: 'Starting coordinator tick' });\r\n\r\n  // 1. Build world state\r\n  let worldState: WorldState;\r\n  try {\r\n    worldState = await buildWorldState();\r\n  } catch (error) {\r\n    const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n    errors.push(`World state build failed: ${errorMsg}`);\r\n    logger.error({ runId, error: errorMsg, msg: 'World state build failed' });\r\n    \r\n    // Return early with error\r\n    return {\r\n      runId,\r\n      startedAt,\r\n      completedAt: new Date(),\r\n      worldState: createEmptyWorldState(),\r\n      routingTuner: { recommendations: [], analysis: { topPerformers: [], underperformers: [], newContenders: [] } },\r\n      pricingTuner: { recommendations: [], analysis: { resourcesReviewed: 0, priceChangesProposed: 0 } },\r\n      scoutTuner: { recommendations: [], analysis: { pendingEvaluated: 0, readyForOnboarding: [], rejected: [] } },\r\n      totalRecommendations: 0,\r\n      errors,\r\n    };\r\n  }\r\n\r\n  // 2. Run routing tuner\r\n  let routingTunerOutput;\r\n  try {\r\n    routingTunerOutput = await runRoutingTuner(worldState);\r\n    logger.info({\r\n      runId,\r\n      recommendations: routingTunerOutput.recommendations.length,\r\n      msg: 'Routing tuner completed',\r\n    });\r\n  } catch (error) {\r\n    const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n    errors.push(`Routing tuner failed: ${errorMsg}`);\r\n    logger.error({ runId, error: errorMsg, msg: 'Routing tuner failed' });\r\n    routingTunerOutput = {\r\n      recommendations: [],\r\n      analysis: { topPerformers: [], underperformers: [], newContenders: [] },\r\n    };\r\n  }\r\n\r\n  // 3. Run pricing tuner\r\n  let pricingTunerOutput;\r\n  try {\r\n    pricingTunerOutput = await runPricingTuner(worldState);\r\n    logger.info({\r\n      runId,\r\n      recommendations: pricingTunerOutput.recommendations.length,\r\n      msg: 'Pricing tuner completed',\r\n    });\r\n  } catch (error) {\r\n    const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n    errors.push(`Pricing tuner failed: ${errorMsg}`);\r\n    logger.error({ runId, error: errorMsg, msg: 'Pricing tuner failed' });\r\n    pricingTunerOutput = {\r\n      recommendations: [],\r\n      analysis: { resourcesReviewed: 0, priceChangesProposed: 0 },\r\n    };\r\n  }\r\n\r\n  // 4. Run scout tuner\r\n  let scoutTunerOutput;\r\n  try {\r\n    scoutTunerOutput = await runScoutTuner(worldState);\r\n    logger.info({\r\n      runId,\r\n      recommendations: scoutTunerOutput.recommendations.length,\r\n      msg: 'Scout tuner completed',\r\n    });\r\n  } catch (error) {\r\n    const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n    errors.push(`Scout tuner failed: ${errorMsg}`);\r\n    logger.error({ runId, error: errorMsg, msg: 'Scout tuner failed' });\r\n    scoutTunerOutput = {\r\n      recommendations: [],\r\n      analysis: { pendingEvaluated: 0, readyForOnboarding: [], rejected: [] },\r\n    };\r\n  }\r\n\r\n  // 5. Aggregate all recommendations\r\n  const allRecommendations: AgentRecommendation[] = [\r\n    ...routingTunerOutput.recommendations,\r\n    ...pricingTunerOutput.recommendations,\r\n    ...scoutTunerOutput.recommendations,\r\n  ];\r\n\r\n  // 6. Persist recommendations\r\n  if (allRecommendations.length > 0) {\r\n    try {\r\n      await createRecommendations(\r\n        allRecommendations.map((rec) => ({\r\n          agent: rec.agent,\r\n          type: rec.type,\r\n          facilitatorId: rec.facilitatorId,\r\n          resourceId: rec.resourceId,\r\n          priority: rec.priority,\r\n          confidence: rec.confidence,\r\n          details: rec.details,\r\n          reasoning: rec.reasoning,\r\n          expiresAt: rec.expiresAt,\r\n        }))\r\n      );\r\n      logger.info({\r\n        runId,\r\n        count: allRecommendations.length,\r\n        msg: 'Recommendations persisted',\r\n      });\r\n    } catch (error) {\r\n      const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n      errors.push(`Failed to persist recommendations: ${errorMsg}`);\r\n      logger.error({ runId, error: errorMsg, msg: 'Failed to persist recommendations' });\r\n    }\r\n  }\r\n\r\n  const completedAt = new Date();\r\n\r\n  const output: CoordinatorOutput = {\r\n    runId,\r\n    startedAt,\r\n    completedAt,\r\n    worldState,\r\n    routingTuner: routingTunerOutput,\r\n    pricingTuner: pricingTunerOutput,\r\n    scoutTuner: scoutTunerOutput,\r\n    totalRecommendations: allRecommendations.length,\r\n    errors,\r\n  };\r\n\r\n  logger.info({\r\n    runId,\r\n    durationMs: completedAt.getTime() - startedAt.getTime(),\r\n    totalRecommendations: allRecommendations.length,\r\n    errorCount: errors.length,\r\n    msg: 'Coordinator tick completed',\r\n  });\r\n\r\n  return output;\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Get pending facilitators from watchlist\r\n */\r\nasync function getPendingFacilitators(): Promise<PendingFacilitator[]> {\r\n  try {\r\n    const watchlist = await getActiveWatchlistItems();\r\n    \r\n    // Filter for facilitator discovery items that haven't been fully onboarded\r\n    const facilitatorItems = watchlist.filter(\r\n      (item) => item.category === 'facilitator_discovery' || item.category === 'bazaar_discovery'\r\n    );\r\n\r\n    // Map to PendingFacilitator format\r\n    // TODO: Cross-reference with facilitator registry to find truly new ones\r\n    return facilitatorItems.map((item) => ({\r\n      id: `watchlist-${item.id}`,\r\n      name: item.root_domain,\r\n      discoveredAt: new Date(item.created_at),\r\n      source: item.category === 'bazaar_discovery' ? 'bazaar' : 'watchlist',\r\n      networks: [], // TODO: Parse from watchlist metadata\r\n      assets: [],\r\n      status: 'pending_evaluation',\r\n    }));\r\n  } catch (error) {\r\n    logger.warn({ error, msg: 'Failed to get pending facilitators from watchlist' });\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Detect risk anomalies from facilitator states\r\n */\r\nfunction detectRiskAnomalies(facilitators: FacilitatorState[]): RiskAnomaly[] {\r\n  const anomalies: RiskAnomaly[] = [];\r\n\r\n  for (const f of facilitators) {\r\n    // Check success rate\r\n    if (f.successRate < COORDINATOR_CONFIG.successRateCriticalThreshold) {\r\n      anomalies.push({\r\n        id: `anomaly-${f.id}-success-critical`,\r\n        detectedAt: new Date(),\r\n        type: 'high_error_rate',\r\n        facilitatorId: f.id,\r\n        severity: 'critical',\r\n        description: `Facilitator ${f.id} has critical error rate: ${((1 - f.successRate) * 100).toFixed(1)}%`,\r\n        metrics: { successRate: f.successRate, threshold: COORDINATOR_CONFIG.successRateCriticalThreshold },\r\n        resolved: false,\r\n      });\r\n    } else if (f.successRate < COORDINATOR_CONFIG.successRateWarningThreshold) {\r\n      anomalies.push({\r\n        id: `anomaly-${f.id}-success-warning`,\r\n        detectedAt: new Date(),\r\n        type: 'high_error_rate',\r\n        facilitatorId: f.id,\r\n        severity: 'medium',\r\n        description: `Facilitator ${f.id} has elevated error rate: ${((1 - f.successRate) * 100).toFixed(1)}%`,\r\n        metrics: { successRate: f.successRate, threshold: COORDINATOR_CONFIG.successRateWarningThreshold },\r\n        resolved: false,\r\n      });\r\n    }\r\n\r\n    // Check latency\r\n    if (f.avgLatencyMs > COORDINATOR_CONFIG.latencyCriticalThresholdMs) {\r\n      anomalies.push({\r\n        id: `anomaly-${f.id}-latency-critical`,\r\n        detectedAt: new Date(),\r\n        type: 'latency_spike',\r\n        facilitatorId: f.id,\r\n        severity: 'high',\r\n        description: `Facilitator ${f.id} has critical latency: ${f.avgLatencyMs}ms`,\r\n        metrics: { avgLatencyMs: f.avgLatencyMs, threshold: COORDINATOR_CONFIG.latencyCriticalThresholdMs },\r\n        resolved: false,\r\n      });\r\n    } else if (f.avgLatencyMs > COORDINATOR_CONFIG.latencyWarningThresholdMs) {\r\n      anomalies.push({\r\n        id: `anomaly-${f.id}-latency-warning`,\r\n        detectedAt: new Date(),\r\n        type: 'latency_spike',\r\n        facilitatorId: f.id,\r\n        severity: 'medium',\r\n        description: `Facilitator ${f.id} has elevated latency: ${f.avgLatencyMs}ms`,\r\n        metrics: { avgLatencyMs: f.avgLatencyMs, threshold: COORDINATOR_CONFIG.latencyWarningThresholdMs },\r\n        resolved: false,\r\n      });\r\n    }\r\n  }\r\n\r\n  return anomalies;\r\n}\r\n\r\n/**\r\n * Compute aggregate metrics\r\n */\r\nfunction computeAggregates(facilitators: FacilitatorState[]): WorldState['aggregates'] {\r\n  const totalRoutes = facilitators.reduce((sum, f) => sum + f.totalInvocations, 0);\r\n  \r\n  const weightedSuccessSum = facilitators.reduce(\r\n    (sum, f) => sum + f.successRate * f.totalInvocations,\r\n    0\r\n  );\r\n  const avgSuccessRate = totalRoutes > 0 ? weightedSuccessSum / totalRoutes : 0;\r\n\r\n  const weightedLatencySum = facilitators.reduce(\r\n    (sum, f) => sum + f.avgLatencyMs * f.totalInvocations,\r\n    0\r\n  );\r\n  const avgLatency = totalRoutes > 0 ? weightedLatencySum / totalRoutes : 0;\r\n\r\n  return {\r\n    totalRoutesLast24h: totalRoutes,\r\n    successRateLast24h: avgSuccessRate,\r\n    avgLatencyLast24h: avgLatency,\r\n    totalVolumeLast24h: undefined, // TODO: Get from volume service\r\n  };\r\n}\r\n\r\n/**\r\n * Map confidence to trust tier\r\n */\r\nfunction mapConfidenceToTier(confidence: 'high' | 'medium' | 'low' | 'none'): 'high' | 'medium' | 'low' | 'unknown' {\r\n  switch (confidence) {\r\n    case 'high':\r\n      return 'high';\r\n    case 'medium':\r\n      return 'medium';\r\n    case 'low':\r\n      return 'low';\r\n    case 'none':\r\n      return 'unknown';\r\n  }\r\n}\r\n\r\n/**\r\n * Create empty world state for error cases\r\n */\r\nfunction createEmptyWorldState(): WorldState {\r\n  return {\r\n    timestamp: new Date(),\r\n    facilitators: [],\r\n    pendingFacilitators: [],\r\n    riskAnomalies: [],\r\n    aggregates: {\r\n      totalRoutesLast24h: 0,\r\n      successRateLast24h: 0,\r\n      avgLatencyLast24h: 0,\r\n    },\r\n    recentDecisions: [],\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9689, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/db/routing-experiments.ts"],"sourcesContent":["// =============================================================================\r\n// ROUTING EXPERIMENTS DATABASE\r\n// =============================================================================\r\n// Persistence layer for bandit shadow routing experiments\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  RoutingExperiment,\r\n  BanditContext,\r\n  BanditReward,\r\n  BanditArmState,\r\n} from '@/agents/types';\r\n\r\nconst logger = createLogger({ component: 'RoutingExperimentsDB' });\r\n\r\n// =============================================================================\r\n// EXPERIMENT OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Check if an experiment already exists for a route+algorithm+version\r\n * Used for idempotency\r\n */\r\nexport async function checkExperimentExists(\r\n  routeId: string,\r\n  algorithm: string,\r\n  algorithmVersion: string\r\n): Promise<boolean> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  const query = isPostgres\r\n    ? `SELECT 1 FROM routing_experiments \r\n       WHERE route_id = $1 AND algorithm = $2 AND algorithm_version = $3 \r\n       LIMIT 1`\r\n    : `SELECT 1 FROM routing_experiments \r\n       WHERE route_id = ? AND algorithm = ? AND algorithm_version = ? \r\n       LIMIT 1`;\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, [routeId, algorithm, algorithmVersion]);\r\n    return result.rows.length > 0;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    const row = stmt.get(routeId, algorithm, algorithmVersion);\r\n    return !!row;\r\n  }\r\n}\r\n\r\n/**\r\n * Create a routing experiment record\r\n */\r\nexport async function createRoutingExperiment(\r\n  experiment: Omit<RoutingExperiment, 'id'>\r\n): Promise<RoutingExperiment> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  const record: RoutingExperiment = { id, ...experiment };\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `INSERT INTO routing_experiments (\r\n        id, route_id, timestamp, context, context_hash, available_facilitators,\r\n        actual_facilitator, actual_reward,\r\n        bandit_chosen_facilitator, bandit_estimated_reward, is_counterfactual,\r\n        algorithm, algorithm_version, algorithm_state\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\r\n      ON CONFLICT (route_id, algorithm, algorithm_version) DO NOTHING`,\r\n      [\r\n        id,\r\n        experiment.routeId || null,\r\n        experiment.timestamp.toISOString(),\r\n        JSON.stringify(experiment.context),\r\n        experiment.contextHash,\r\n        JSON.stringify(experiment.availableFacilitators),\r\n        experiment.actualFacilitator,\r\n        JSON.stringify(experiment.actualReward),\r\n        experiment.banditChosenFacilitator,\r\n        experiment.banditEstimatedReward,\r\n        experiment.isCounterfactual || false,\r\n        experiment.algorithm,\r\n        experiment.algorithmVersion,\r\n        experiment.algorithmState ? JSON.stringify(experiment.algorithmState) : null,\r\n      ]\r\n    );\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      INSERT OR IGNORE INTO routing_experiments (\r\n        id, route_id, timestamp, context, context_hash, available_facilitators,\r\n        actual_facilitator, actual_reward,\r\n        bandit_chosen_facilitator, bandit_estimated_reward, is_counterfactual,\r\n        algorithm, algorithm_version, algorithm_state\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      experiment.routeId || null,\r\n      experiment.timestamp.toISOString(),\r\n      JSON.stringify(experiment.context),\r\n      experiment.contextHash,\r\n      JSON.stringify(experiment.availableFacilitators),\r\n      experiment.actualFacilitator,\r\n      JSON.stringify(experiment.actualReward),\r\n      experiment.banditChosenFacilitator,\r\n      experiment.banditEstimatedReward,\r\n      experiment.isCounterfactual ? 1 : 0,\r\n      experiment.algorithm,\r\n      experiment.algorithmVersion,\r\n      experiment.algorithmState ? JSON.stringify(experiment.algorithmState) : null\r\n    );\r\n  }\r\n\r\n  return record;\r\n}\r\n\r\n/**\r\n * Create multiple experiments in batch\r\n */\r\nexport async function createRoutingExperiments(\r\n  experiments: Omit<RoutingExperiment, 'id'>[]\r\n): Promise<number> {\r\n  let count = 0;\r\n  for (const exp of experiments) {\r\n    await createRoutingExperiment(exp);\r\n    count++;\r\n  }\r\n  return count;\r\n}\r\n\r\n/**\r\n * Get experiments for analysis\r\n */\r\nexport async function getRoutingExperiments(params: {\r\n  algorithm?: string;\r\n  algorithmVersion?: string;\r\n  fromTimestamp?: Date;\r\n  toTimestamp?: Date;\r\n  limit?: number;\r\n}): Promise<RoutingExperiment[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let query = 'SELECT * FROM routing_experiments WHERE 1=1';\r\n  const queryParams: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (params.algorithm) {\r\n    query += isPostgres ? ` AND algorithm = $${paramIndex++}` : ' AND algorithm = ?';\r\n    queryParams.push(params.algorithm);\r\n  }\r\n\r\n  if (params.algorithmVersion) {\r\n    query += isPostgres ? ` AND algorithm_version = $${paramIndex++}` : ' AND algorithm_version = ?';\r\n    queryParams.push(params.algorithmVersion);\r\n  }\r\n\r\n  if (params.fromTimestamp) {\r\n    query += isPostgres ? ` AND timestamp >= $${paramIndex++}` : ' AND timestamp >= ?';\r\n    queryParams.push(params.fromTimestamp.toISOString());\r\n  }\r\n\r\n  if (params.toTimestamp) {\r\n    query += isPostgres ? ` AND timestamp < $${paramIndex++}` : ' AND timestamp < ?';\r\n    queryParams.push(params.toTimestamp.toISOString());\r\n  }\r\n\r\n  query += ' ORDER BY timestamp DESC';\r\n\r\n  if (params.limit) {\r\n    query += isPostgres ? ` LIMIT $${paramIndex++}` : ' LIMIT ?';\r\n    queryParams.push(params.limit);\r\n  }\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, queryParams);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all(...queryParams);\r\n  }\r\n\r\n  return rows.map(rowToExperiment);\r\n}\r\n\r\n/**\r\n * Prune old experiments\r\n */\r\nexport async function pruneOldExperiments(cutoffDate: Date): Promise<number> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `DELETE FROM routing_experiments WHERE created_at < $1`,\r\n      [cutoffDate.toISOString()]\r\n    );\r\n    return result.rowCount || 0;\r\n  } else {\r\n    const stmt = (db as any).prepare('DELETE FROM routing_experiments WHERE created_at < ?');\r\n    const info = stmt.run(cutoffDate.toISOString());\r\n    return info.changes || 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Get bandit performance summary\r\n */\r\nexport async function getBanditPerformanceSummary(params: {\r\n  algorithm: string;\r\n  algorithmVersion: string;\r\n  fromTimestamp: Date;\r\n  toTimestamp: Date;\r\n}): Promise<{\r\n  totalExperiments: number;\r\n  banditMatchedRate: number;\r\n  counterfactualRate: number;\r\n  avgActualReward: number;\r\n  avgBanditEstimatedReward: number;\r\n  facilitatorStats: Array<{\r\n    facilitatorId: string;\r\n    actualPicks: number;\r\n    banditPicks: number;\r\n    avgActualReward: number;\r\n  }>;\r\n}> {\r\n  // Get all experiments in window\r\n  const experiments = await getRoutingExperiments({\r\n    algorithm: params.algorithm,\r\n    algorithmVersion: params.algorithmVersion,\r\n    fromTimestamp: params.fromTimestamp,\r\n    toTimestamp: params.toTimestamp,\r\n  });\r\n\r\n  if (experiments.length === 0) {\r\n    return {\r\n      totalExperiments: 0,\r\n      banditMatchedRate: 0,\r\n      counterfactualRate: 0,\r\n      avgActualReward: 0,\r\n      avgBanditEstimatedReward: 0,\r\n      facilitatorStats: [],\r\n    };\r\n  }\r\n\r\n  // Compute stats\r\n  let matchedCount = 0;\r\n  let counterfactualCount = 0;\r\n  let totalActualReward = 0;\r\n  let totalEstimatedReward = 0;\r\n  let estimatedCount = 0;\r\n  \r\n  const facilitatorMap = new Map<string, {\r\n    actualPicks: number;\r\n    banditPicks: number;\r\n    totalReward: number;\r\n  }>();\r\n\r\n  for (const exp of experiments) {\r\n    if (exp.isCounterfactual) {\r\n      counterfactualCount++;\r\n    } else {\r\n      matchedCount++;\r\n    }\r\n\r\n    totalActualReward += exp.actualReward.combined;\r\n    if (exp.banditEstimatedReward !== null) {\r\n      totalEstimatedReward += exp.banditEstimatedReward;\r\n      estimatedCount++;\r\n    }\r\n\r\n    // Actual facilitator stats\r\n    const actualStats = facilitatorMap.get(exp.actualFacilitator) || {\r\n      actualPicks: 0,\r\n      banditPicks: 0,\r\n      totalReward: 0,\r\n    };\r\n    actualStats.actualPicks++;\r\n    actualStats.totalReward += exp.actualReward.combined;\r\n    facilitatorMap.set(exp.actualFacilitator, actualStats);\r\n\r\n    // Bandit pick stats\r\n    const banditStats = facilitatorMap.get(exp.banditChosenFacilitator) || {\r\n      actualPicks: 0,\r\n      banditPicks: 0,\r\n      totalReward: 0,\r\n    };\r\n    banditStats.banditPicks++;\r\n    facilitatorMap.set(exp.banditChosenFacilitator, banditStats);\r\n  }\r\n\r\n  const facilitatorStats = Array.from(facilitatorMap.entries()).map(([id, stats]) => ({\r\n    facilitatorId: id,\r\n    actualPicks: stats.actualPicks,\r\n    banditPicks: stats.banditPicks,\r\n    avgActualReward: stats.actualPicks > 0 ? stats.totalReward / stats.actualPicks : 0,\r\n  }));\r\n\r\n  return {\r\n    totalExperiments: experiments.length,\r\n    banditMatchedRate: matchedCount / experiments.length,\r\n    counterfactualRate: counterfactualCount / experiments.length,\r\n    avgActualReward: totalActualReward / experiments.length,\r\n    avgBanditEstimatedReward: estimatedCount > 0 ? totalEstimatedReward / estimatedCount : 0,\r\n    facilitatorStats,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// BANDIT STATE PERSISTENCE\r\n// =============================================================================\r\n\r\n/**\r\n * Save bandit arm state (for resuming learner)\r\n */\r\nexport async function saveBanditArmState(\r\n  algorithm: string,\r\n  algorithmVersion: string,\r\n  contextHash: string,\r\n  arm: BanditArmState\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `INSERT INTO bandit_arm_states (\r\n        algorithm, algorithm_version, context_hash, facilitator_id,\r\n        pulls, total_reward, avg_reward, last_pulled, updated_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\r\n      ON CONFLICT (algorithm, algorithm_version, context_hash, facilitator_id)\r\n      DO UPDATE SET\r\n        pulls = EXCLUDED.pulls,\r\n        total_reward = EXCLUDED.total_reward,\r\n        avg_reward = EXCLUDED.avg_reward,\r\n        last_pulled = EXCLUDED.last_pulled,\r\n        updated_at = EXCLUDED.updated_at`,\r\n      [\r\n        algorithm,\r\n        algorithmVersion,\r\n        contextHash,\r\n        arm.facilitatorId,\r\n        arm.pulls,\r\n        arm.totalReward,\r\n        arm.avgReward,\r\n        arm.lastPulled?.toISOString() || null,\r\n        now,\r\n      ]\r\n    );\r\n  } else {\r\n    // SQLite - use INSERT OR REPLACE\r\n    const stmt = (db as any).prepare(`\r\n      INSERT OR REPLACE INTO bandit_arm_states (\r\n        algorithm, algorithm_version, context_hash, facilitator_id,\r\n        pulls, total_reward, avg_reward, last_pulled, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      algorithm,\r\n      algorithmVersion,\r\n      contextHash,\r\n      arm.facilitatorId,\r\n      arm.pulls,\r\n      arm.totalReward,\r\n      arm.avgReward,\r\n      arm.lastPulled?.toISOString() || null,\r\n      now\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Load bandit arm states for an algorithm\r\n */\r\nexport async function loadBanditArmStates(\r\n  algorithm: string,\r\n  algorithmVersion: string,\r\n  contextHash?: string\r\n): Promise<Map<string, BanditArmState>> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let query: string;\r\n  const params: any[] = [algorithm, algorithmVersion];\r\n\r\n  if (isPostgres) {\r\n    query = 'SELECT * FROM bandit_arm_states WHERE algorithm = $1 AND algorithm_version = $2';\r\n    if (contextHash) {\r\n      query += ' AND context_hash = $3';\r\n      params.push(contextHash);\r\n    }\r\n  } else {\r\n    query = 'SELECT * FROM bandit_arm_states WHERE algorithm = ? AND algorithm_version = ?';\r\n    if (contextHash) {\r\n      query += ' AND context_hash = ?';\r\n      params.push(contextHash);\r\n    }\r\n  }\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, params);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all(...params);\r\n  }\r\n\r\n  const arms = new Map<string, BanditArmState>();\r\n  for (const row of rows) {\r\n    const key = `${row.context_hash}-${row.facilitator_id}`;\r\n    arms.set(key, {\r\n      facilitatorId: row.facilitator_id,\r\n      pulls: row.pulls,\r\n      totalReward: parseFloat(row.total_reward),\r\n      avgReward: parseFloat(row.avg_reward),\r\n      lastPulled: row.last_pulled ? new Date(row.last_pulled) : undefined,\r\n    });\r\n  }\r\n\r\n  return arms;\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\nfunction rowToExperiment(row: any): RoutingExperiment {\r\n  return {\r\n    id: row.id,\r\n    routeId: row.route_id || undefined,\r\n    timestamp: new Date(row.timestamp),\r\n    context: typeof row.context === 'string' ? JSON.parse(row.context) : row.context,\r\n    contextHash: row.context_hash,\r\n    availableFacilitators:\r\n      typeof row.available_facilitators === 'string'\r\n        ? JSON.parse(row.available_facilitators)\r\n        : row.available_facilitators,\r\n    actualFacilitator: row.actual_facilitator,\r\n    actualReward:\r\n      typeof row.actual_reward === 'string'\r\n        ? JSON.parse(row.actual_reward)\r\n        : row.actual_reward,\r\n    banditChosenFacilitator: row.bandit_chosen_facilitator,\r\n    banditEstimatedReward: row.bandit_estimated_reward !== null\r\n      ? parseFloat(row.bandit_estimated_reward)\r\n      : null,\r\n    isCounterfactual: row.is_counterfactual === true || row.is_counterfactual === 1,\r\n    algorithm: row.algorithm,\r\n    algorithmVersion: row.algorithm_version,\r\n    algorithmState: row.algorithm_state\r\n      ? typeof row.algorithm_state === 'string'\r\n        ? JSON.parse(row.algorithm_state)\r\n        : row.algorithm_state\r\n      : undefined,\r\n  };\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 10022, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/agents/bandit-routing.ts"],"sourcesContent":["// =============================================================================\r\n// BANDIT SHADOW ROUTING\r\n// =============================================================================\r\n// Contextual bandit for shadow routing experiments\r\n// Does NOT affect live routing - only simulates and logs decisions\r\n//\r\n// Algorithms implemented:\r\n// - -greedy: Explore with probability , exploit otherwise\r\n// - UCB1: Upper Confidence Bound for exploration/exploitation balance\r\n//\r\n// IMPORTANT: This is an OFFLINE simulation. For each historical event:\r\n// 1. FIRST, compute what bandit would choose given current state\r\n// 2. THEN, update bandit state with observed outcome\r\n// This ensures proper offline policy evaluation semantics.\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport { getDb } from '@/db/client';\r\nimport {\r\n  createRoutingExperiment,\r\n  saveBanditArmState,\r\n  loadBanditArmStates,\r\n  checkExperimentExists,\r\n  pruneOldExperiments,\r\n} from '@/db/routing-experiments';\r\nimport type {\r\n  BanditContext,\r\n  BanditReward,\r\n  BanditArmState,\r\n  RoutingExperiment,\r\n} from './types';\r\n\r\nconst logger = createLogger({ component: 'BanditRouting' });\r\n\r\n// =============================================================================\r\n// CONFIGURATION (can be overridden via env vars)\r\n// =============================================================================\r\n\r\nexport const BANDIT_CONFIG = {\r\n  // -greedy parameters\r\n  epsilon: parseFloat(process.env.BANDIT_EPSILON || '0.1'), // 10% exploration rate\r\n  \r\n  // UCB1 parameters\r\n  explorationBonus: parseFloat(process.env.BANDIT_UCB_BONUS || '2.0'), // Exploration bonus coefficient\r\n  \r\n  // Reward computation weights\r\n  rewardWeights: {\r\n    success: parseFloat(process.env.BANDIT_WEIGHT_SUCCESS || '0.6'),\r\n    latency: parseFloat(process.env.BANDIT_WEIGHT_LATENCY || '0.3'),\r\n    cost: parseFloat(process.env.BANDIT_WEIGHT_COST || '0.1'),\r\n  },\r\n  \r\n  // Latency normalization\r\n  maxLatencyMs: parseInt(process.env.BANDIT_MAX_LATENCY_MS || '5000', 10),\r\n  \r\n  // Cost normalization\r\n  maxFeeBps: parseInt(process.env.BANDIT_MAX_FEE_BPS || '100', 10),\r\n  \r\n  // Safety limits\r\n  maxBanditHours: parseInt(process.env.BANDIT_MAX_HOURS || '24', 10), // Max replay window\r\n  \r\n  // Algorithm version (increment when changing algorithm behavior)\r\n  algorithmVersion: process.env.BANDIT_ALGORITHM_VERSION || 'v1',\r\n  \r\n  // Pruning settings\r\n  experimentRetentionDays: parseInt(process.env.BANDIT_RETENTION_DAYS || '30', 10),\r\n};\r\n\r\n// =============================================================================\r\n// CONTEXT HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Discretize amount into buckets\r\n * Handles both decimal strings (e.g., \"0.05\") and wei/smallest unit strings\r\n */\r\nfunction getAmountBucket(amountStr: string): BanditContext['amountBucket'] {\r\n  // Try parsing as a decimal first (e.g., \"0.05\", \"100.50\")\r\n  const amountFloat = parseFloat(amountStr);\r\n  \r\n  if (!isNaN(amountFloat)) {\r\n    // Interpret as USD value\r\n    if (amountFloat < 1) return 'micro';\r\n    if (amountFloat < 100) return 'small';\r\n    if (amountFloat < 10000) return 'medium';\r\n    return 'large';\r\n  }\r\n  \r\n  // Fallback: try as BigInt (smallest units like wei)\r\n  try {\r\n    const amount = BigInt(amountStr);\r\n    const oneDollar = BigInt('1000000'); // 1 USDC in 6 decimals\r\n    \r\n    if (amount < oneDollar) return 'micro';\r\n    if (amount < oneDollar * BigInt(100)) return 'small';\r\n    if (amount < oneDollar * BigInt(10000)) return 'medium';\r\n    return 'large';\r\n  } catch {\r\n    // If all else fails, default to small\r\n    return 'small';\r\n  }\r\n}\r\n\r\n/**\r\n * Get time of day bucket\r\n */\r\nfunction getTimeOfDay(timestamp: Date): BanditContext['timeOfDay'] {\r\n  const hour = timestamp.getUTCHours();\r\n  if (hour >= 5 && hour < 12) return 'morning';\r\n  if (hour >= 12 && hour < 17) return 'afternoon';\r\n  if (hour >= 17 && hour < 21) return 'evening';\r\n  return 'night';\r\n}\r\n\r\n/**\r\n * Get day of week bucket\r\n */\r\nfunction getDayOfWeek(timestamp: Date): BanditContext['dayOfWeek'] {\r\n  const day = timestamp.getUTCDay();\r\n  return day === 0 || day === 6 ? 'weekend' : 'weekday';\r\n}\r\n\r\n/**\r\n * Build context from route data\r\n */\r\nexport function buildContext(\r\n  network: string,\r\n  asset: string,\r\n  amount: string,\r\n  timestamp: Date\r\n): BanditContext {\r\n  return {\r\n    network,\r\n    asset,\r\n    amountBucket: getAmountBucket(amount),\r\n    timeOfDay: getTimeOfDay(timestamp),\r\n    dayOfWeek: getDayOfWeek(timestamp),\r\n  };\r\n}\r\n\r\n/**\r\n * Create a hash key for context (for arm state lookup)\r\n */\r\nexport function hashContext(context: BanditContext): string {\r\n  return `${context.network}|${context.asset}|${context.amountBucket}|${context.timeOfDay}|${context.dayOfWeek}`;\r\n}\r\n\r\n// =============================================================================\r\n// REWARD COMPUTATION\r\n// =============================================================================\r\n\r\n/**\r\n * Compute reward from outcome\r\n */\r\nexport function computeReward(\r\n  success: boolean,\r\n  latencyMs: number,\r\n  feeBps: number\r\n): BanditReward {\r\n  const successReward = success ? 1 : 0;\r\n  \r\n  // Latency penalty: 0 = instant, 1 = very slow\r\n  const latencyPenalty = Math.min(1, latencyMs / BANDIT_CONFIG.maxLatencyMs);\r\n  \r\n  // Cost penalty: 0 = free, 1 = expensive\r\n  const costPenalty = Math.min(1, feeBps / BANDIT_CONFIG.maxFeeBps);\r\n  \r\n  // Combined reward (higher is better)\r\n  const combined =\r\n    BANDIT_CONFIG.rewardWeights.success * successReward -\r\n    BANDIT_CONFIG.rewardWeights.latency * latencyPenalty -\r\n    BANDIT_CONFIG.rewardWeights.cost * costPenalty;\r\n\r\n  return {\r\n    success: successReward,\r\n    latencyPenalty,\r\n    costPenalty,\r\n    combined,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// BANDIT ALGORITHMS\r\n// =============================================================================\r\n\r\n/**\r\n * -greedy algorithm\r\n * - With probability , choose randomly (explore)\r\n * - Otherwise, choose the arm with highest average reward (exploit)\r\n */\r\nexport function epsilonGreedySelect(\r\n  contextHash: string,\r\n  availableFacilitators: string[],\r\n  arms: Map<string, BanditArmState>,\r\n  epsilon: number = BANDIT_CONFIG.epsilon\r\n): { chosen: string; estimated: number; isExplore: boolean } {\r\n  if (availableFacilitators.length === 0) {\r\n    throw new Error('No available facilitators');\r\n  }\r\n\r\n  // Explore with probability epsilon\r\n  if (Math.random() < epsilon) {\r\n    const randomIdx = Math.floor(Math.random() * availableFacilitators.length);\r\n    const chosen = availableFacilitators[randomIdx];\r\n    const armKey = `${contextHash}-${chosen}`;\r\n    const arm = arms.get(armKey);\r\n    return {\r\n      chosen,\r\n      estimated: arm?.avgReward || 0,\r\n      isExplore: true,\r\n    };\r\n  }\r\n\r\n  // Exploit: choose best arm\r\n  let bestFacilitator = availableFacilitators[0];\r\n  let bestAvgReward = -Infinity;\r\n\r\n  for (const facilitatorId of availableFacilitators) {\r\n    const armKey = `${contextHash}-${facilitatorId}`;\r\n    const arm = arms.get(armKey);\r\n    const avgReward = arm?.avgReward || 0;\r\n\r\n    if (avgReward > bestAvgReward) {\r\n      bestAvgReward = avgReward;\r\n      bestFacilitator = facilitatorId;\r\n    }\r\n  }\r\n\r\n  return {\r\n    chosen: bestFacilitator,\r\n    estimated: bestAvgReward === -Infinity ? 0 : bestAvgReward,\r\n    isExplore: false,\r\n  };\r\n}\r\n\r\n/**\r\n * UCB1 algorithm\r\n * Choose arm that maximizes: avgReward + c * sqrt(ln(totalPulls) / armPulls)\r\n * This balances exploitation (avgReward) with exploration (bonus for less-pulled arms)\r\n */\r\nexport function ucb1Select(\r\n  contextHash: string,\r\n  availableFacilitators: string[],\r\n  arms: Map<string, BanditArmState>,\r\n  totalPulls: number,\r\n  explorationBonus: number = BANDIT_CONFIG.explorationBonus\r\n): { chosen: string; estimated: number; ucbScore: number } {\r\n  if (availableFacilitators.length === 0) {\r\n    throw new Error('No available facilitators');\r\n  }\r\n\r\n  // If we haven't tried all arms, pick an untried one\r\n  for (const facilitatorId of availableFacilitators) {\r\n    const armKey = `${contextHash}-${facilitatorId}`;\r\n    const arm = arms.get(armKey);\r\n    if (!arm || arm.pulls === 0) {\r\n      return {\r\n        chosen: facilitatorId,\r\n        estimated: 0,\r\n        ucbScore: Infinity, // Always try untried arms first\r\n      };\r\n    }\r\n  }\r\n\r\n  // All arms have been tried at least once - use UCB formula\r\n  let bestFacilitator = availableFacilitators[0];\r\n  let bestUcbScore = -Infinity;\r\n  let bestEstimated = 0;\r\n\r\n  const logTotalPulls = Math.log(Math.max(1, totalPulls));\r\n\r\n  for (const facilitatorId of availableFacilitators) {\r\n    const armKey = `${contextHash}-${facilitatorId}`;\r\n    const arm = arms.get(armKey);\r\n    \r\n    if (!arm) continue;\r\n\r\n    const avgReward = arm.avgReward;\r\n    const explorationTerm = explorationBonus * Math.sqrt(logTotalPulls / arm.pulls);\r\n    const ucbScore = avgReward + explorationTerm;\r\n\r\n    if (ucbScore > bestUcbScore) {\r\n      bestUcbScore = ucbScore;\r\n      bestFacilitator = facilitatorId;\r\n      bestEstimated = avgReward;\r\n    }\r\n  }\r\n\r\n  return {\r\n    chosen: bestFacilitator,\r\n    estimated: bestEstimated,\r\n    ucbScore: bestUcbScore === -Infinity ? 0 : bestUcbScore,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// SHADOW SIMULATION\r\n// =============================================================================\r\n\r\n/**\r\n * Historical route data from route_attempts joined with routes\r\n */\r\ninterface HistoricalRoute {\r\n  routeId: string;\r\n  timestamp: Date;\r\n  network: string;\r\n  token: string;\r\n  amount: string;\r\n  facilitatorId: string;\r\n  result: 'success' | 'failure' | 'timeout' | 'rate_limited' | 'insufficient_liquidity' | 'invalid_request' | 'network_error';\r\n  latencyMs: number;\r\n  feeBps: number;\r\n}\r\n\r\n/**\r\n * Get historical routes for simulation\r\n */\r\nasync function getHistoricalRoutes(\r\n  fromTimestamp: Date,\r\n  toTimestamp: Date\r\n): Promise<HistoricalRoute[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  // Query routes with their attempts\r\n  // Only include non-probe attempts\r\n  const query = isPostgres\r\n    ? `\r\n      SELECT \r\n        r.id as route_id,\r\n        r.created_at as timestamp,\r\n        r.network,\r\n        r.token,\r\n        r.amount,\r\n        ra.facilitator_id,\r\n        ra.result,\r\n        ra.latency_ms\r\n      FROM routes r\r\n      JOIN route_attempts ra ON r.id = ra.route_id\r\n      WHERE r.created_at >= $1 \r\n        AND r.created_at < $2\r\n        AND ra.is_probe = false\r\n        AND ra.phase = 'verify'\r\n      ORDER BY r.created_at ASC\r\n    `\r\n    : `\r\n      SELECT \r\n        r.id as route_id,\r\n        r.created_at as timestamp,\r\n        r.network,\r\n        r.token,\r\n        r.amount,\r\n        ra.facilitator_id,\r\n        ra.result,\r\n        ra.latency_ms\r\n      FROM routes r\r\n      JOIN route_attempts ra ON r.id = ra.route_id\r\n      WHERE r.created_at >= ?\r\n        AND r.created_at < ?\r\n        AND ra.is_probe = 0\r\n        AND ra.phase = 'verify'\r\n      ORDER BY r.created_at ASC\r\n    `;\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, [\r\n      fromTimestamp.toISOString(),\r\n      toTimestamp.toISOString(),\r\n    ]);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all(fromTimestamp.toISOString(), toTimestamp.toISOString());\r\n  }\r\n\r\n  return rows.map((row) => ({\r\n    routeId: row.route_id,\r\n    timestamp: new Date(row.timestamp),\r\n    network: row.network,\r\n    token: row.token,\r\n    amount: row.amount,\r\n    facilitatorId: row.facilitator_id,\r\n    result: row.result,\r\n    latencyMs: row.latency_ms,\r\n    feeBps: 0, // TODO: Get from facilitator capabilities table\r\n  }));\r\n}\r\n\r\n/**\r\n * Get list of available facilitators for a network/token\r\n * TODO: Query facilitator registry/capabilities for actual available facilitators\r\n */\r\nfunction getAvailableFacilitators(network: string, token: string): string[] {\r\n  // For now, use hardcoded list\r\n  // In production, this should query the facilitator registry\r\n  return ['cdp', 'payai', 'x402rs', 'dexter'];\r\n}\r\n\r\n/**\r\n * Run bandit shadow simulation on historical data\r\n * \r\n * OFFLINE SIMULATION SEMANTICS:\r\n * For each historical route, we:\r\n * 1. FIRST compute what bandit would choose (before seeing this outcome)\r\n * 2. THEN update bandit state with the observed outcome\r\n * \r\n * This ensures proper offline policy evaluation.\r\n */\r\nexport async function runBanditShadowSimulation(params: {\r\n  fromTimestamp: Date;\r\n  toTimestamp: Date;\r\n  algorithm?: 'epsilon_greedy' | 'ucb1';\r\n}): Promise<{\r\n  experimentsCreated: number;\r\n  experimentsSkipped: number; // Duplicates\r\n  routesProcessed: number;\r\n  banditCorrectRate: number;\r\n  counterfactualCount: number;\r\n  durationMs: number;\r\n}> {\r\n  const startTime = Date.now();\r\n  const algorithm = params.algorithm || 'epsilon_greedy';\r\n  const algorithmVersion = BANDIT_CONFIG.algorithmVersion;\r\n\r\n  // Validate time window\r\n  const windowHours = (params.toTimestamp.getTime() - params.fromTimestamp.getTime()) / (1000 * 60 * 60);\r\n  if (windowHours > BANDIT_CONFIG.maxBanditHours) {\r\n    throw new Error(\r\n      `Bandit time window ${windowHours.toFixed(1)}h exceeds maximum ${BANDIT_CONFIG.maxBanditHours}h. ` +\r\n      `Use smaller windows or adjust BANDIT_MAX_HOURS env var.`\r\n    );\r\n  }\r\n\r\n  logger.info({\r\n    fromTimestamp: params.fromTimestamp.toISOString(),\r\n    toTimestamp: params.toTimestamp.toISOString(),\r\n    algorithm,\r\n    algorithmVersion,\r\n    windowHours: windowHours.toFixed(2),\r\n    msg: 'Starting bandit shadow simulation',\r\n  });\r\n\r\n  // 1. Load existing arm states\r\n  const arms = await loadBanditArmStates(algorithm, algorithmVersion);\r\n  let totalPulls = Array.from(arms.values()).reduce((sum, arm) => sum + arm.pulls, 0);\r\n\r\n  // 2. Get historical routes\r\n  const routes = await getHistoricalRoutes(params.fromTimestamp, params.toTimestamp);\r\n\r\n  if (routes.length === 0) {\r\n    logger.info({ msg: 'No historical routes found in time window' });\r\n    return {\r\n      experimentsCreated: 0,\r\n      experimentsSkipped: 0,\r\n      routesProcessed: 0,\r\n      banditCorrectRate: 0,\r\n      counterfactualCount: 0,\r\n      durationMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  // 3. Process each route\r\n  let experimentsCreated = 0;\r\n  let experimentsSkipped = 0;\r\n  let banditCorrectCount = 0;\r\n  let counterfactualCount = 0;\r\n  const armsToSave: Map<string, { contextHash: string; arm: BanditArmState }> = new Map();\r\n\r\n  for (const route of routes) {\r\n    // Check for duplicate (idempotency)\r\n    const exists = await checkExperimentExists(route.routeId, algorithm, algorithmVersion);\r\n    if (exists) {\r\n      experimentsSkipped++;\r\n      continue;\r\n    }\r\n\r\n    // Build context\r\n    const context = buildContext(\r\n      route.network,\r\n      route.token,\r\n      route.amount,\r\n      route.timestamp\r\n    );\r\n    const contextHash = hashContext(context);\r\n\r\n    // Get available facilitators\r\n    const availableFacilitators = getAvailableFacilitators(route.network, route.token);\r\n\r\n    // Skip if actual facilitator not in available list (edge case)\r\n    if (!availableFacilitators.includes(route.facilitatorId)) {\r\n      continue;\r\n    }\r\n\r\n    // =====================================================\r\n    // STEP 1: Compute what bandit would choose BEFORE update\r\n    // This is the key offline simulation semantic\r\n    // =====================================================\r\n    let banditChoice: { chosen: string; estimated: number };\r\n    if (algorithm === 'epsilon_greedy') {\r\n      banditChoice = epsilonGreedySelect(contextHash, availableFacilitators, arms);\r\n    } else {\r\n      banditChoice = ucb1Select(contextHash, availableFacilitators, arms, totalPulls);\r\n    }\r\n\r\n    // Check if bandit chose the same as actual\r\n    const isCounterfactual = banditChoice.chosen !== route.facilitatorId;\r\n    if (isCounterfactual) {\r\n      counterfactualCount++;\r\n    } else {\r\n      banditCorrectCount++;\r\n    }\r\n\r\n    // Compute actual reward from observed outcome\r\n    const success = route.result === 'success';\r\n    const actualReward = computeReward(success, route.latencyMs, route.feeBps);\r\n\r\n    // For counterfactual: we don't have observed reward for bandit's choice\r\n    // We can only estimate based on historical avg for that arm\r\n    const banditEstimatedReward = isCounterfactual\r\n      ? null // Explicitly null for counterfactual\r\n      : actualReward.combined; // Same as actual when matched\r\n\r\n    // Create experiment record\r\n    const experiment: Omit<RoutingExperiment, 'id'> = {\r\n      routeId: route.routeId,\r\n      timestamp: route.timestamp,\r\n      context,\r\n      contextHash,\r\n      availableFacilitators,\r\n      actualFacilitator: route.facilitatorId,\r\n      actualReward,\r\n      banditChosenFacilitator: banditChoice.chosen,\r\n      banditEstimatedReward,\r\n      isCounterfactual,\r\n      algorithm,\r\n      algorithmVersion,\r\n    };\r\n\r\n    await createRoutingExperiment(experiment);\r\n    experimentsCreated++;\r\n\r\n    // =====================================================\r\n    // STEP 2: Update arm state with actual observed outcome\r\n    // We update the arm that was ACTUALLY used, not bandit's choice\r\n    // =====================================================\r\n    const armKey = `${contextHash}-${route.facilitatorId}`;\r\n    const existingArm = arms.get(armKey);\r\n    \r\n    const updatedArm: BanditArmState = {\r\n      facilitatorId: route.facilitatorId,\r\n      pulls: (existingArm?.pulls || 0) + 1,\r\n      totalReward: (existingArm?.totalReward || 0) + actualReward.combined,\r\n      avgReward: 0, // Will be computed below\r\n      lastPulled: route.timestamp,\r\n    };\r\n    updatedArm.avgReward = updatedArm.totalReward / updatedArm.pulls;\r\n\r\n    arms.set(armKey, updatedArm);\r\n    totalPulls++;\r\n\r\n    // Queue arm for batch save\r\n    armsToSave.set(armKey, { contextHash, arm: updatedArm });\r\n\r\n    // Batch save every 100 records\r\n    if (armsToSave.size >= 100) {\r\n      await batchSaveArms(algorithm, algorithmVersion, armsToSave);\r\n      armsToSave.clear();\r\n    }\r\n  }\r\n\r\n  // 4. Final persist of remaining arm states\r\n  if (armsToSave.size > 0) {\r\n    await batchSaveArms(algorithm, algorithmVersion, armsToSave);\r\n  }\r\n\r\n  const durationMs = Date.now() - startTime;\r\n  const processedCount = routes.length - experimentsSkipped;\r\n  const banditCorrectRate = processedCount > 0 ? banditCorrectCount / processedCount : 0;\r\n\r\n  logger.info({\r\n    experimentsCreated,\r\n    experimentsSkipped,\r\n    routesProcessed: routes.length,\r\n    banditCorrectRate: banditCorrectRate.toFixed(4),\r\n    counterfactualCount,\r\n    durationMs,\r\n    msg: 'Bandit shadow simulation completed',\r\n  });\r\n\r\n  return {\r\n    experimentsCreated,\r\n    experimentsSkipped,\r\n    routesProcessed: routes.length,\r\n    banditCorrectRate,\r\n    counterfactualCount,\r\n    durationMs,\r\n  };\r\n}\r\n\r\n/**\r\n * Batch save arm states\r\n */\r\nasync function batchSaveArms(\r\n  algorithm: string,\r\n  algorithmVersion: string,\r\n  arms: Map<string, { contextHash: string; arm: BanditArmState }>\r\n): Promise<void> {\r\n  for (const [, { contextHash, arm }] of arms) {\r\n    await saveBanditArmState(algorithm, algorithmVersion, contextHash, arm);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// ANALYSIS & MAINTENANCE\r\n// =============================================================================\r\n\r\n/**\r\n * Get bandit arm statistics for a context\r\n */\r\nexport async function getBanditArmStats(\r\n  algorithm: string,\r\n  algorithmVersion?: string,\r\n  contextHash?: string\r\n): Promise<Map<string, BanditArmState>> {\r\n  return loadBanditArmStates(algorithm, algorithmVersion || BANDIT_CONFIG.algorithmVersion, contextHash);\r\n}\r\n\r\n/**\r\n * Compare bandit vs actual routing performance\r\n */\r\nexport async function compareBanditPerformance(params: {\r\n  algorithm: string;\r\n  algorithmVersion?: string;\r\n  fromTimestamp: Date;\r\n  toTimestamp: Date;\r\n}): Promise<{\r\n  totalRoutes: number;\r\n  banditMatched: number;\r\n  counterfactual: number;\r\n  avgActualReward: number;\r\n  avgBanditEstimatedReward: number;\r\n  facilitatorStats: Array<{\r\n    facilitatorId: string;\r\n    actualPicks: number;\r\n    banditPicks: number;\r\n    avgActualReward: number;\r\n  }>;\r\n}> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  const version = params.algorithmVersion || BANDIT_CONFIG.algorithmVersion;\r\n\r\n  const query = isPostgres\r\n    ? `\r\n      SELECT \r\n        actual_facilitator,\r\n        bandit_chosen_facilitator,\r\n        actual_reward,\r\n        bandit_estimated_reward,\r\n        is_counterfactual\r\n      FROM routing_experiments\r\n      WHERE algorithm = $1\r\n        AND algorithm_version = $2\r\n        AND timestamp >= $3\r\n        AND timestamp < $4\r\n    `\r\n    : `\r\n      SELECT \r\n        actual_facilitator,\r\n        bandit_chosen_facilitator,\r\n        actual_reward,\r\n        bandit_estimated_reward,\r\n        is_counterfactual\r\n      FROM routing_experiments\r\n      WHERE algorithm = ?\r\n        AND algorithm_version = ?\r\n        AND timestamp >= ?\r\n        AND timestamp < ?\r\n    `;\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, [\r\n      params.algorithm,\r\n      version,\r\n      params.fromTimestamp.toISOString(),\r\n      params.toTimestamp.toISOString(),\r\n    ]);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all(\r\n      params.algorithm,\r\n      version,\r\n      params.fromTimestamp.toISOString(),\r\n      params.toTimestamp.toISOString()\r\n    );\r\n  }\r\n\r\n  let matched = 0;\r\n  let counterfactual = 0;\r\n  let totalActualReward = 0;\r\n  let totalEstimatedReward = 0;\r\n  let estimatedCount = 0;\r\n  const facilitatorMap = new Map<string, {\r\n    actualPicks: number;\r\n    banditPicks: number;\r\n    totalReward: number;\r\n  }>();\r\n\r\n  for (const row of rows) {\r\n    const actualReward = typeof row.actual_reward === 'string'\r\n      ? JSON.parse(row.actual_reward).combined\r\n      : row.actual_reward.combined;\r\n    const estimatedReward = row.bandit_estimated_reward !== null\r\n      ? parseFloat(row.bandit_estimated_reward)\r\n      : null;\r\n\r\n    totalActualReward += actualReward;\r\n    if (estimatedReward !== null) {\r\n      totalEstimatedReward += estimatedReward;\r\n      estimatedCount++;\r\n    }\r\n\r\n    if (row.is_counterfactual) {\r\n      counterfactual++;\r\n    } else {\r\n      matched++;\r\n    }\r\n\r\n    // Actual facilitator stats\r\n    const actualStats = facilitatorMap.get(row.actual_facilitator) || {\r\n      actualPicks: 0,\r\n      banditPicks: 0,\r\n      totalReward: 0,\r\n    };\r\n    actualStats.actualPicks++;\r\n    actualStats.totalReward += actualReward;\r\n    facilitatorMap.set(row.actual_facilitator, actualStats);\r\n\r\n    // Bandit pick stats\r\n    if (row.bandit_chosen_facilitator !== row.actual_facilitator) {\r\n      const banditStats = facilitatorMap.get(row.bandit_chosen_facilitator) || {\r\n        actualPicks: 0,\r\n        banditPicks: 0,\r\n        totalReward: 0,\r\n      };\r\n      banditStats.banditPicks++;\r\n      facilitatorMap.set(row.bandit_chosen_facilitator, banditStats);\r\n    } else {\r\n      const stats = facilitatorMap.get(row.actual_facilitator)!;\r\n      stats.banditPicks++;\r\n    }\r\n  }\r\n\r\n  const facilitatorStats = Array.from(facilitatorMap.entries()).map(([id, stats]) => ({\r\n    facilitatorId: id,\r\n    actualPicks: stats.actualPicks,\r\n    banditPicks: stats.banditPicks,\r\n    avgActualReward: stats.actualPicks > 0 ? stats.totalReward / stats.actualPicks : 0,\r\n  }));\r\n\r\n  return {\r\n    totalRoutes: rows.length,\r\n    banditMatched: matched,\r\n    counterfactual,\r\n    avgActualReward: rows.length > 0 ? totalActualReward / rows.length : 0,\r\n    avgBanditEstimatedReward: estimatedCount > 0 ? totalEstimatedReward / estimatedCount : 0,\r\n    facilitatorStats,\r\n  };\r\n}\r\n\r\n/**\r\n * Prune old experiments to control table size\r\n * Should be called periodically (e.g., daily) via cron\r\n */\r\nexport async function pruneOldBanditData(retentionDays?: number): Promise<{\r\n  experimentsDeleted: number;\r\n  armStatesDeleted: number;\r\n}> {\r\n  const days = retentionDays || BANDIT_CONFIG.experimentRetentionDays;\r\n  const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);\r\n\r\n  logger.info({\r\n    retentionDays: days,\r\n    cutoffDate: cutoffDate.toISOString(),\r\n    msg: 'Pruning old bandit data',\r\n  });\r\n\r\n  const experimentsDeleted = await pruneOldExperiments(cutoffDate);\r\n\r\n  // Prune arm states that haven't been updated in retention period\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let armStatesDeleted = 0;\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `DELETE FROM bandit_arm_states WHERE updated_at < $1`,\r\n      [cutoffDate.toISOString()]\r\n    );\r\n    armStatesDeleted = result.rowCount || 0;\r\n  } else {\r\n    const stmt = (db as any).prepare('DELETE FROM bandit_arm_states WHERE updated_at < ?');\r\n    const info = stmt.run(cutoffDate.toISOString());\r\n    armStatesDeleted = info.changes || 0;\r\n  }\r\n\r\n  logger.info({\r\n    experimentsDeleted,\r\n    armStatesDeleted,\r\n    msg: 'Bandit data pruned',\r\n  });\r\n\r\n  return { experimentsDeleted, armStatesDeleted };\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 10616, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/app/api/cron/coord/route.ts"],"sourcesContent":["// =============================================================================\r\n// COORDINATOR CRON ENDPOINT\r\n// =============================================================================\r\n// GET /api/cron/coord\r\n//\r\n// Runs the coordinator tick which:\r\n// 1. Builds world state from metrics and services\r\n// 2. Runs routing tuner (proposes facilitator changes)\r\n// 3. Runs pricing tuner (proposes pricing adjustments)\r\n// 4. Runs scout tuner (evaluates new facilitators)\r\n// 5. Persists recommendations to database\r\n// 6. Optionally runs bandit shadow simulation\r\n//\r\n// Query params:\r\n// - bandit=true: Also run bandit shadow simulation\r\n// - banditHours=N: Hours to replay (default: 1, max: 24)\r\n// - banditAlgo=epsilon_greedy|ucb1: Algorithm to use\r\n// - prune=true: Also prune old experiment data\r\n//\r\n// Triggered by Vercel Cron or manual invocation\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { headers } from 'next/headers';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { runCoordinatorTick } from '@/agents/coordinator';\r\nimport { runBanditShadowSimulation, pruneOldBanditData, BANDIT_CONFIG } from '@/agents/bandit-routing';\r\nimport { expirePendingRecommendations } from '@/db/agent-recommendations';\r\n\r\nconst logger = createLogger({ component: 'CoordinatorCron' });\r\n\r\n// Cron secret for authorization (required in production)\r\nconst CRON_SECRET = process.env.CRON_SECRET || process.env.VERCEL_CRON_SECRET;\r\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production';\r\n\r\n// Rate limiting - track last run time\r\nlet lastRunTimestamp: number = 0;\r\nconst MIN_RUN_INTERVAL_MS = 60 * 1000; // 1 minute minimum between runs\r\n\r\n// =============================================================================\r\n// GET /api/cron/coord\r\n// =============================================================================\r\n\r\nexport async function GET(request: NextRequest): Promise<NextResponse> {\r\n  const startTime = Date.now();\r\n  const requestId = crypto.randomUUID();\r\n\r\n  // Get client info for logging\r\n  const headersList = await headers();\r\n  const clientIp = headersList.get('x-forwarded-for') || headersList.get('x-real-ip') || 'unknown';\r\n  const userAgent = headersList.get('user-agent') || 'unknown';\r\n\r\n  logger.info({\r\n    requestId,\r\n    clientIp,\r\n    userAgent,\r\n    msg: 'Coordinator cron request received',\r\n  });\r\n\r\n  // ==========================================================================\r\n  // 1. Authorization check\r\n  // ==========================================================================\r\n  const authHeader = request.headers.get('authorization');\r\n  \r\n  if (IS_PRODUCTION) {\r\n    if (!CRON_SECRET) {\r\n      logger.error({ requestId, msg: 'CRON_SECRET not configured in production' });\r\n      return NextResponse.json(\r\n        { error: 'Server configuration error', code: 'CONFIG_ERROR' },\r\n        { status: 500 }\r\n      );\r\n    }\r\n    \r\n    if (authHeader !== `Bearer ${CRON_SECRET}`) {\r\n      logger.warn({\r\n        requestId,\r\n        clientIp,\r\n        hasAuth: !!authHeader,\r\n        msg: 'Unauthorized coordinator cron request',\r\n      });\r\n      return NextResponse.json(\r\n        { error: 'Unauthorized', code: 'UNAUTHORIZED' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n  } else {\r\n    // In development, warn if no auth but allow\r\n    if (!authHeader) {\r\n      logger.warn({ requestId, msg: 'No authorization in dev mode - allowing for testing' });\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // 2. Rate limiting check\r\n  // ==========================================================================\r\n  const timeSinceLastRun = Date.now() - lastRunTimestamp;\r\n  if (timeSinceLastRun < MIN_RUN_INTERVAL_MS) {\r\n    const waitSeconds = Math.ceil((MIN_RUN_INTERVAL_MS - timeSinceLastRun) / 1000);\r\n    logger.warn({\r\n      requestId,\r\n      timeSinceLastRunMs: timeSinceLastRun,\r\n      waitSeconds,\r\n      msg: 'Rate limited - too soon since last run',\r\n    });\r\n    return NextResponse.json(\r\n      {\r\n        error: 'Rate limited',\r\n        code: 'RATE_LIMITED',\r\n        retryAfterSeconds: waitSeconds,\r\n      },\r\n      {\r\n        status: 429,\r\n        headers: { 'Retry-After': String(waitSeconds) },\r\n      }\r\n    );\r\n  }\r\n\r\n  // ==========================================================================\r\n  // 3. Parse and validate query parameters\r\n  // ==========================================================================\r\n  const { searchParams } = new URL(request.url);\r\n  const runBandit = searchParams.get('bandit') === 'true';\r\n  const runPrune = searchParams.get('prune') === 'true';\r\n  const banditHoursParam = parseInt(searchParams.get('banditHours') || '1', 10);\r\n  const banditAlgorithm = (searchParams.get('banditAlgo') || 'epsilon_greedy') as 'epsilon_greedy' | 'ucb1';\r\n\r\n  // Validate bandit hours with sanity limit\r\n  const maxBanditHours = BANDIT_CONFIG.maxBanditHours;\r\n  if (banditHoursParam < 1 || banditHoursParam > maxBanditHours) {\r\n    logger.warn({\r\n      requestId,\r\n      banditHoursParam,\r\n      maxBanditHours,\r\n      msg: 'Invalid banditHours parameter',\r\n    });\r\n    return NextResponse.json(\r\n      {\r\n        error: `banditHours must be between 1 and ${maxBanditHours}`,\r\n        code: 'INVALID_PARAM',\r\n      },\r\n      { status: 400 }\r\n    );\r\n  }\r\n\r\n  const banditHours = Math.min(banditHoursParam, maxBanditHours);\r\n\r\n  logger.info({\r\n    requestId,\r\n    runBandit,\r\n    runPrune,\r\n    banditHours,\r\n    banditAlgorithm,\r\n    msg: 'Starting coordinator cron',\r\n  });\r\n\r\n  // Update last run timestamp\r\n  lastRunTimestamp = Date.now();\r\n\r\n  try {\r\n    // ==========================================================================\r\n    // 4. Expire old pending recommendations\r\n    // ==========================================================================\r\n    const expiredCount = await expirePendingRecommendations();\r\n    if (expiredCount > 0) {\r\n      logger.info({ requestId, expiredCount, msg: 'Expired old recommendations' });\r\n    }\r\n\r\n    // ==========================================================================\r\n    // 5. Run coordinator tick\r\n    // ==========================================================================\r\n    const coordinatorResult = await runCoordinatorTick();\r\n\r\n    logger.info({\r\n      requestId,\r\n      runId: coordinatorResult.runId,\r\n      totalRecommendations: coordinatorResult.totalRecommendations,\r\n      routingTunerRecs: coordinatorResult.routingTuner.recommendations.length,\r\n      pricingTunerRecs: coordinatorResult.pricingTuner.recommendations.length,\r\n      scoutTunerRecs: coordinatorResult.scoutTuner.recommendations.length,\r\n      facilitatorCount: coordinatorResult.worldState.facilitators.length,\r\n      routableCount: coordinatorResult.worldState.facilitators.filter(f => f.isRoutable).length,\r\n      riskAnomalyCount: coordinatorResult.worldState.riskAnomalies.length,\r\n      errorCount: coordinatorResult.errors.length,\r\n      msg: 'Coordinator tick completed',\r\n    });\r\n\r\n    // ==========================================================================\r\n    // 6. Optionally run bandit shadow simulation\r\n    // ==========================================================================\r\n    let banditResult: {\r\n      experimentsCreated: number;\r\n      experimentsSkipped: number;\r\n      routesProcessed: number;\r\n      banditCorrectRate: number;\r\n      counterfactualCount: number;\r\n      durationMs: number;\r\n    } | null = null;\r\n\r\n    if (runBandit) {\r\n      const toTimestamp = new Date();\r\n      const fromTimestamp = new Date(toTimestamp.getTime() - banditHours * 60 * 60 * 1000);\r\n\r\n      try {\r\n        banditResult = await runBanditShadowSimulation({\r\n          fromTimestamp,\r\n          toTimestamp,\r\n          algorithm: banditAlgorithm,\r\n        });\r\n\r\n        logger.info({\r\n          requestId,\r\n          algorithm: banditAlgorithm,\r\n          timeWindowHours: banditHours,\r\n          routesProcessed: banditResult.routesProcessed,\r\n          experimentsCreated: banditResult.experimentsCreated,\r\n          experimentsSkipped: banditResult.experimentsSkipped,\r\n          banditCorrectRate: banditResult.banditCorrectRate.toFixed(4),\r\n          counterfactualCount: banditResult.counterfactualCount,\r\n          durationMs: banditResult.durationMs,\r\n          msg: 'Bandit simulation completed',\r\n        });\r\n      } catch (banditError) {\r\n        const errorMsg = banditError instanceof Error ? banditError.message : 'Unknown error';\r\n        logger.error({\r\n          requestId,\r\n          error: errorMsg,\r\n          msg: 'Bandit simulation failed',\r\n        });\r\n        // Don't fail the whole request, just log the error\r\n        coordinatorResult.errors.push(`Bandit simulation failed: ${errorMsg}`);\r\n      }\r\n    }\r\n\r\n    // ==========================================================================\r\n    // 7. Optionally prune old data\r\n    // ==========================================================================\r\n    let pruneResult: { experimentsDeleted: number; armStatesDeleted: number } | null = null;\r\n\r\n    if (runPrune) {\r\n      try {\r\n        pruneResult = await pruneOldBanditData();\r\n        logger.info({\r\n          requestId,\r\n          experimentsDeleted: pruneResult.experimentsDeleted,\r\n          armStatesDeleted: pruneResult.armStatesDeleted,\r\n          msg: 'Data pruning completed',\r\n        });\r\n      } catch (pruneError) {\r\n        const errorMsg = pruneError instanceof Error ? pruneError.message : 'Unknown error';\r\n        logger.error({ requestId, error: errorMsg, msg: 'Data pruning failed' });\r\n      }\r\n    }\r\n\r\n    // ==========================================================================\r\n    // 8. Build response\r\n    // ==========================================================================\r\n    const durationMs = Date.now() - startTime;\r\n\r\n    const response = {\r\n      success: coordinatorResult.errors.length === 0,\r\n      requestId,\r\n      runId: coordinatorResult.runId,\r\n      timestamp: coordinatorResult.completedAt.toISOString(),\r\n      durationMs,\r\n      \r\n      coordinator: {\r\n        totalRecommendations: coordinatorResult.totalRecommendations,\r\n        routingTuner: {\r\n          recommendations: coordinatorResult.routingTuner.recommendations.length,\r\n          topPerformers: coordinatorResult.routingTuner.analysis.topPerformers,\r\n          underperformers: coordinatorResult.routingTuner.analysis.underperformers,\r\n        },\r\n        pricingTuner: {\r\n          recommendations: coordinatorResult.pricingTuner.recommendations.length,\r\n          resourcesReviewed: coordinatorResult.pricingTuner.analysis.resourcesReviewed,\r\n        },\r\n        scoutTuner: {\r\n          recommendations: coordinatorResult.scoutTuner.recommendations.length,\r\n          pendingEvaluated: coordinatorResult.scoutTuner.analysis.pendingEvaluated,\r\n          readyForOnboarding: coordinatorResult.scoutTuner.analysis.readyForOnboarding,\r\n        },\r\n        errors: coordinatorResult.errors,\r\n      },\r\n\r\n      worldState: {\r\n        facilitatorCount: coordinatorResult.worldState.facilitators.length,\r\n        routableFacilitatorCount: coordinatorResult.worldState.facilitators.filter(f => f.isRoutable).length,\r\n        pendingFacilitatorCount: coordinatorResult.worldState.pendingFacilitators.length,\r\n        riskAnomalyCount: coordinatorResult.worldState.riskAnomalies.length,\r\n        aggregates: coordinatorResult.worldState.aggregates,\r\n      },\r\n\r\n      bandit: banditResult\r\n        ? {\r\n            algorithm: banditAlgorithm,\r\n            algorithmVersion: BANDIT_CONFIG.algorithmVersion,\r\n            timeWindowHours: banditHours,\r\n            routesProcessed: banditResult.routesProcessed,\r\n            experimentsCreated: banditResult.experimentsCreated,\r\n            experimentsSkipped: banditResult.experimentsSkipped,\r\n            banditCorrectRate: banditResult.banditCorrectRate,\r\n            counterfactualCount: banditResult.counterfactualCount,\r\n            durationMs: banditResult.durationMs,\r\n          }\r\n        : null,\r\n\r\n      prune: pruneResult\r\n        ? {\r\n            experimentsDeleted: pruneResult.experimentsDeleted,\r\n            armStatesDeleted: pruneResult.armStatesDeleted,\r\n          }\r\n        : null,\r\n\r\n      expiredRecommendations: expiredCount,\r\n    };\r\n\r\n    logger.info({\r\n      requestId,\r\n      runId: coordinatorResult.runId,\r\n      totalRecommendations: coordinatorResult.totalRecommendations,\r\n      banditRan: !!banditResult,\r\n      pruneRan: !!pruneResult,\r\n      durationMs,\r\n      msg: 'Coordinator cron completed successfully',\r\n    });\r\n\r\n    return NextResponse.json(response, { status: 200 });\r\n\r\n  } catch (error) {\r\n    const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n    const durationMs = Date.now() - startTime;\r\n\r\n    logger.error({\r\n      requestId,\r\n      error: errorMsg,\r\n      stack: error instanceof Error ? error.stack : undefined,\r\n      durationMs,\r\n      msg: 'Coordinator cron failed',\r\n    });\r\n\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        requestId,\r\n        error: errorMsg,\r\n        code: 'INTERNAL_ERROR',\r\n        durationMs,\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// POST /api/cron/coord\r\n// =============================================================================\r\n// Alternative POST endpoint for manual triggers with body params\r\n\r\nexport async function POST(request: NextRequest): Promise<NextResponse> {\r\n  // Reuse GET handler\r\n  return GET(request);\r\n}\r\n"],"names":[],"mappings":"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"}}]
}