{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/sentry.ts"],"sourcesContent":["// src/lib/sentry.ts\r\n\r\n// Temporary no-op Sentry shim to avoid module errors during dev\r\nconst Sentry = null as any;\r\n\r\nexport const sentry = {\r\n  captureException: (..._args: any[]) => {},\r\n  captureMessage: (..._args: any[]) => {},\r\n  withScope: (fn: (scope: any) => void) => fn({}),\r\n};\r\n\r\n// No-op functions for compatibility\r\nexport function initSentry() {}\r\nexport function setSentryUser(_userId?: string, _apiKeyId?: string) {}\r\nexport function setSentryContext(_context: any) {}\r\nexport function captureException(_error: Error, _context?: any) {}\r\nexport function captureMessage(_message: string, _level: any = 'info', _context?: any) {}\r\n"],"names":[],"mappings":"AAAA,oBAAoB;AAEpB,gEAAgE;;;;;;;;;;;;;;;AAChE,MAAM,SAAS;AAER,MAAM,SAAS;IACpB,kBAAkB,CAAC,GAAG,SAAkB;IACxC,gBAAgB,CAAC,GAAG,SAAkB;IACtC,WAAW,CAAC,KAA6B,GAAG,CAAC;AAC/C;AAGO,SAAS,cAAc;AACvB,SAAS,cAAc,OAAgB,EAAE,SAAkB,GAAG;AAC9D,SAAS,iBAAiB,QAAa,GAAG;AAC1C,SAAS,iBAAiB,MAAa,EAAE,QAAc,GAAG;AAC1D,SAAS,eAAe,QAAgB,EAAE,SAAc,MAAM,EAAE,QAAc,GAAG"}},
    {"offset": {"line": 155, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/lib/logger.ts"],"sourcesContent":["// =============================================================================\r\n// Structured Logging\r\n// =============================================================================\r\n// Uses Pino for fast, structured logging\r\n// Supports request ID tracking and different log levels\r\n// All logs include standard fields: timestamp, level, message, requestId, etc.\r\n\r\nimport pino from 'pino';\r\n\r\n// Determine log level from environment\r\nconst logLevel = process.env.LOG_LEVEL || (process.env.NODE_ENV === 'production' ? 'info' : 'debug');\r\n\r\n// Create logger instance with structured output\r\n// In Next.js dev mode, disable pino-pretty transport to avoid worker thread issues\r\n// Use simple JSON output instead (can be prettified by other tools)\r\nconst isNextDev = process.env.NODE_ENV === 'development' && process.env.NEXT_RUNTIME;\r\nconst usePrettyTransport = process.env.NODE_ENV !== 'production' && !isNextDev;\r\n\r\nconst logger = pino({\r\n  level: logLevel,\r\n  transport: usePrettyTransport ? {\r\n    target: 'pino-pretty',\r\n    options: {\r\n      colorize: true,\r\n      translateTime: 'SYS:standard',\r\n      ignore: 'pid,hostname',\r\n    },\r\n  } : undefined,\r\n  formatters: {\r\n    level: (label) => {\r\n      return { level: label.toUpperCase() };\r\n    },\r\n  },\r\n  base: {\r\n    env: process.env.NODE_ENV || 'development',\r\n    service: 'nexflow-api',\r\n  },\r\n  // Ensure timestamps are included\r\n  timestamp: pino.stdTimeFunctions.isoTime,\r\n});\r\n\r\nexport type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';\r\n\r\n/**\r\n * Standard log context fields\r\n */\r\nexport interface LogContext {\r\n  // Request tracking\r\n  requestId?: string;\r\n  apiKeyId?: string;\r\n  endpoint?: string;\r\n  method?: string;\r\n  statusCode?: number;\r\n  durationMs?: number;\r\n  ip?: string;\r\n  \r\n  // Error context\r\n  errorCode?: string;\r\n  error?: Error | any;\r\n  stack?: string;\r\n  \r\n  // CDP/x402 context\r\n  cdpStatus?: string;\r\n  cdpErrorId?: string;\r\n  paymentIntentId?: string;\r\n  x402HeaderId?: string;\r\n  \r\n  // Rate limiting\r\n  rateLimitKey?: string;\r\n  rateLimitRemaining?: number;\r\n  \r\n  // Additional context\r\n  [key: string]: any;\r\n}\r\n\r\n/**\r\n * Create a child logger with additional context\r\n * Useful for request-scoped logging with request IDs\r\n */\r\nexport function createLogger(context?: LogContext | Record<string, any>) {\r\n  return context ? logger.child(context) : logger;\r\n}\r\n\r\n/**\r\n * Get the default logger instance\r\n */\r\nexport function getLogger() {\r\n  return logger;\r\n}\r\n\r\n/**\r\n * Sanitize sensitive data from log context\r\n * Removes API keys, tokens, payment headers, and PII\r\n */\r\nfunction sanitizeContext(context: LogContext): LogContext {\r\n  const sanitized = { ...context };\r\n  \r\n  // Remove sensitive fields\r\n  const sensitiveKeys = [\r\n    'apiKey', 'token', 'authorization', 'x-payment', 'paymentHeader',\r\n    'cardNumber', 'cvv', 'ssn', 'password', 'secret',\r\n  ];\r\n  \r\n  sensitiveKeys.forEach(key => {\r\n    if (key in sanitized) {\r\n      delete sanitized[key];\r\n    }\r\n  });\r\n  \r\n  // Truncate long strings that might contain sensitive data\r\n  Object.keys(sanitized).forEach(key => {\r\n    const value = sanitized[key];\r\n    if (typeof value === 'string' && value.length > 200) {\r\n      sanitized[key] = value.substring(0, 200) + '... [truncated]';\r\n    }\r\n  });\r\n  \r\n  return sanitized;\r\n}\r\n\r\n/**\r\n * Log levels with structured context\r\n */\r\nexport const log = {\r\n  trace: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.trace(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  debug: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.debug(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  info: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.info(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  warn: (msg: string, context?: LogContext, ...args: any[]) => {\r\n    logger.warn(sanitizeContext(context || {}), msg, ...args);\r\n  },\r\n  error: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.error(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry if error object exists\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'UNKNOWN_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n  fatal: (msg: string, context?: LogContext | Error, ...args: any[]) => {\r\n    let logContext: LogContext = {};\r\n    let errorObj: Error | undefined;\r\n    \r\n    if (context instanceof Error) {\r\n      errorObj = context;\r\n      logContext = {\r\n        error: context,\r\n        errorCode: (context as any).code || 'UNKNOWN_ERROR',\r\n        stack: context.stack,\r\n      };\r\n    } else if (context && typeof context === 'object') {\r\n      logContext = context as LogContext;\r\n      if (logContext.error instanceof Error) {\r\n        errorObj = logContext.error;\r\n        logContext.stack = logContext.error.stack;\r\n      }\r\n    }\r\n    \r\n    const sanitizedContext = sanitizeContext(logContext);\r\n    logger.fatal(sanitizedContext, msg, ...args);\r\n    \r\n    // Automatically capture to Sentry for fatal errors\r\n    if (errorObj) {\r\n      try {\r\n        const { captureException } = require('./sentry');\r\n        captureException(errorObj, {\r\n          requestId: logContext.requestId,\r\n          apiKeyId: logContext.apiKeyId,\r\n          endpoint: logContext.endpoint,\r\n          endpointId: (logContext as any).endpointId,\r\n          method: logContext.method,\r\n          statusCode: logContext.statusCode,\r\n          ip: logContext.ip,\r\n          userAgent: (logContext as any).userAgent,\r\n          tags: {\r\n            errorCode: logContext.errorCode || 'FATAL_ERROR',\r\n            component: (logContext as any).component || 'unknown',\r\n            severity: 'fatal',\r\n          },\r\n          extra: {\r\n            ...sanitizedContext,\r\n          },\r\n        });\r\n      } catch (sentryError) {\r\n        // Silently fail if Sentry not available\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport default logger;\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 347, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/integrations/x402/facilitators/facilitator-registry.ts"],"sourcesContent":["// =============================================================================\r\n// FACILITATOR REGISTRY\r\n// =============================================================================\r\n// Central registry of facilitator configurations\r\n// This is the source of truth for facilitator metadata\r\n\r\nexport interface FacilitatorRegistryEntry {\r\n  id: string;\r\n  name: string;\r\n  baseUrl: string;\r\n  networks: string[]; // CAIP-2 network IDs\r\n  tokens: string[]; // Token symbols or addresses\r\n  feeBps: number;\r\n  priority: number;\r\n}\r\n\r\n/**\r\n * Facilitator ID type - all known facilitators\r\n * Use this union type for type-safe facilitator references\r\n */\r\nexport type FacilitatorId = 'cdp' | 'payai' | 'x402rs' | 'dexter' | 'dummy';\r\n\r\n/**\r\n * Facilitator registry\r\n * CDP is the primary facilitator for x402 payments\r\n */\r\nexport const FACILITATORS: Record<string, FacilitatorRegistryEntry> = {\r\n  cdp: {\r\n    id: 'cdp',\r\n    name: 'CDP x402 Facilitator',\r\n    baseUrl: process.env.CDP_FACILITATOR_URL || 'https://api.cdp.coinbase.com/platform/v2/x402',\r\n    networks: ['eip155:8453', 'solana:mainnet', 'eip155:84532', 'solana:devnet'], // Base mainnet, Solana mainnet, Base sepolia, Solana devnet\r\n    tokens: ['USDC'],\r\n    feeBps: 0,\r\n    priority: 100, // High priority (primary facilitator)\r\n  },\r\n  payai: {\r\n    id: 'payai',\r\n    name: 'PayAI Facilitator',\r\n    baseUrl: process.env.PAYAI_FACILITATOR_URL || 'https://facilitator.payai.network',\r\n    networks: ['eip155:1', 'eip155:8453', 'eip155:56', 'eip155:137', 'solana:mainnet'], // Multi-chain support\r\n    tokens: ['USDC'],\r\n    feeBps: 10, // Example: 0.1% fee (to be confirmed with PayAI)\r\n    priority: 200, // Lower priority than CDP\r\n  },\r\n  /**\r\n   * X402rs Facilitator\r\n   * \r\n   * Rust-based x402 facilitator operated by the x402 community.\r\n   * Supports Base (mainnet & testnet) and XDC networks.\r\n   * \r\n   * Source: https://x402.org/networks\r\n   */\r\n  x402rs: {\r\n    id: 'x402rs',\r\n    name: 'X402rs Facilitator',\r\n    baseUrl: process.env.X402RS_FACILITATOR_URL || 'https://facilitator.x402.rs',\r\n    networks: [\r\n      'eip155:84532',  // Base Sepolia (testnet)\r\n      'eip155:8453',   // Base mainnet\r\n      'xdc:50',        // XDC mainnet\r\n    ],\r\n    tokens: ['USDC'],\r\n    feeBps: 0, // Community facilitator - no fees (to be confirmed)\r\n    priority: 150, // Between CDP (100) and PayAI (200)\r\n  },\r\n  /**\r\n   * Dexter Facilitator\r\n   * \r\n   * Solana-native x402 facilitator operated by Dexter.\r\n   * Public facilitator URL: https://facilitator.dexter.cash\r\n   * Standard x402 endpoints: /verify and /settle\r\n   * \r\n   * Supports Solana mainnet and devnet networks.\r\n   */\r\n  dexter: {\r\n    id: 'dexter',\r\n    name: 'Dexter Facilitator',\r\n    baseUrl: process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash',\r\n    networks: [\r\n      'solana:101',    // Solana mainnet (CAIP-2)\r\n      'solana:mainnet', // Legacy alias\r\n      'solana:102',    // Solana devnet (CAIP-2)\r\n      'solana:devnet', // Legacy alias\r\n    ],\r\n    tokens: ['USDC'],\r\n    feeBps: 0, // To be confirmed with Dexter\r\n    priority: 120, // Between CDP (100) and X402rs (150) - strong Solana support\r\n  },\r\n} as const;\r\n\r\n/**\r\n * Get facilitator by ID\r\n */\r\nexport function getFacilitator(id: string): FacilitatorRegistryEntry | undefined {\r\n  return FACILITATORS[id];\r\n}\r\n\r\n/**\r\n * Get all facilitators\r\n */\r\nexport function getAllFacilitators(): FacilitatorRegistryEntry[] {\r\n  return Object.values(FACILITATORS);\r\n}\r\n\r\n/**\r\n * Get facilitators for a specific network\r\n */\r\nexport function getFacilitatorsForNetwork(network: string): FacilitatorRegistryEntry[] {\r\n  return Object.values(FACILITATORS).filter((f) => f.networks.includes(network));\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,uBAAuB;AACvB,gFAAgF;AAChF,iDAAiD;AACjD,uDAAuD;;;;;;;;;;;AAsBhD,MAAM,eAAyD;IACpE,KAAK;QACH,IAAI;QACJ,MAAM;QACN,SAAS,QAAQ,GAAG,CAAC,mBAAmB,IAAI;QAC5C,UAAU;YAAC;YAAe;YAAkB;YAAgB;SAAgB;QAC5E,QAAQ;YAAC;SAAO;QAChB,QAAQ;QACR,UAAU;IACZ;IACA,OAAO;QACL,IAAI;QACJ,MAAM;QACN,SAAS,QAAQ,GAAG,CAAC,qBAAqB,IAAI;QAC9C,UAAU;YAAC;YAAY;YAAe;YAAa;YAAc;SAAiB;QAClF,QAAQ;YAAC;SAAO;QAChB,QAAQ;QACR,UAAU;IACZ;IACA;;;;;;;GAOC,GACD,QAAQ;QACN,IAAI;QACJ,MAAM;QACN,SAAS,QAAQ,GAAG,CAAC,sBAAsB,IAAI;QAC/C,UAAU;YACR;YACA;YACA;SACD;QACD,QAAQ;YAAC;SAAO;QAChB,QAAQ;QACR,UAAU;IACZ;IACA;;;;;;;;GAQC,GACD,QAAQ;QACN,IAAI;QACJ,MAAM;QACN,SAAS,QAAQ,GAAG,CAAC,sBAAsB,IAAI;QAC/C,UAAU;YACR;YACA;YACA;YACA;SACD;QACD,QAAQ;YAAC;SAAO;QAChB,QAAQ;QACR,UAAU;IACZ;AACF;AAKO,SAAS,eAAe,EAAU;IACvC,OAAO,YAAY,CAAC,GAAG;AACzB;AAKO,SAAS;IACd,OAAO,OAAO,MAAM,CAAC;AACvB;AAKO,SAAS,0BAA0B,OAAe;IACvD,OAAO,OAAO,MAAM,CAAC,cAAc,MAAM,CAAC,CAAC,IAAM,EAAE,QAAQ,CAAC,QAAQ,CAAC;AACvE"}},
    {"offset": {"line": 462, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/services/facilitator-metrics-service.ts"],"sourcesContent":["// =============================================================================\r\n// FACILITATOR METRICS SERVICE\r\n// =============================================================================\r\n// Service for persisting and managing facilitator path metrics from x402scan\r\n// Uses JSON file storage for simplicity (can be migrated to DB later)\r\n//\r\n// =============================================================================\r\n// RETENTION & COMPACTION PLAN (TODO)\r\n// =============================================================================\r\n// 1. Raw buckets (bucketMinutes < 60):\r\n//    - Keep for 7 days\r\n//    - After 7 days, compact into hourly rollups\r\n//\r\n// 2. Hourly rollups (bucketMinutes = 60):\r\n//    - Keep for 30 days\r\n//    - After 30 days, compact into daily rollups\r\n//\r\n// 3. Daily rollups (bucketMinutes = 1440):\r\n//    - Keep for 90 days\r\n//    - After 90 days, archive or delete\r\n//\r\n// Compaction strategy:\r\n//    - Sum invocations, successCount, failureCount, status buckets\r\n//    - Weighted average for latency percentiles (weight by invocations)\r\n//    - Recalculate errorRate from compacted counts\r\n//\r\n// TODO: Implement compactMetrics() function for scheduled compaction job\r\n// TODO: Add database migration for PostgreSQL storage with proper indexes\r\n// =============================================================================\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport {\r\n  type FacilitatorPathMetrics,\r\n  type FacilitatorSummary,\r\n  type FacilitatorPathMetricsTimeframe,\r\n} from '@/infra/x402scan/types';\r\nimport * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\n\r\nconst logger = createLogger({ component: 'FacilitatorMetricsService' });\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\nconst DATA_DIR = process.env.FACILITATOR_METRICS_DATA_DIR ?? 'data';\r\nconst METRICS_FILE = 'facilitator-path-metrics.json';\r\nconst SUMMARIES_FILE = 'facilitator-summaries.json';\r\n\r\n// =============================================================================\r\n// FILE STORAGE HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Ensure data directory exists\r\n */\r\nasync function ensureDataDir(): Promise<string> {\r\n  const dataPath = path.resolve(process.cwd(), DATA_DIR);\r\n  try {\r\n    await fs.mkdir(dataPath, { recursive: true });\r\n  } catch {\r\n    // Directory may already exist\r\n  }\r\n  return dataPath;\r\n}\r\n\r\n/**\r\n * Read JSON file with fallback to empty object/array\r\n */\r\nasync function readJsonFile<T>(filePath: string, defaultValue: T): Promise<T> {\r\n  try {\r\n    const content = await fs.readFile(filePath, 'utf-8');\r\n    return JSON.parse(content) as T;\r\n  } catch {\r\n    return defaultValue;\r\n  }\r\n}\r\n\r\n/**\r\n * Write JSON file atomically\r\n */\r\nasync function writeJsonFile(filePath: string, data: unknown): Promise<void> {\r\n  const tempPath = `${filePath}.tmp`;\r\n  await fs.writeFile(tempPath, JSON.stringify(data, null, 2), 'utf-8');\r\n  await fs.rename(tempPath, filePath);\r\n}\r\n\r\n// =============================================================================\r\n// METRICS STORAGE TYPES\r\n// =============================================================================\r\n\r\ninterface MetricsStore {\r\n  version: string;\r\n  lastUpdated: string;\r\n  metrics: FacilitatorPathMetrics[];\r\n}\r\n\r\ninterface SummariesStore {\r\n  version: string;\r\n  lastUpdated: string;\r\n  summaries: Record<string, FacilitatorSummary>; // keyed by `${facilitatorId}:${timeframe}`\r\n}\r\n\r\n// =============================================================================\r\n// METRICS PERSISTENCE\r\n// =============================================================================\r\n\r\n/**\r\n * Get the full path to the metrics file\r\n */\r\nasync function getMetricsFilePath(): Promise<string> {\r\n  const dataDir = await ensureDataDir();\r\n  return path.join(dataDir, METRICS_FILE);\r\n}\r\n\r\n/**\r\n * Get the full path to the summaries file\r\n */\r\nasync function getSummariesFilePath(): Promise<string> {\r\n  const dataDir = await ensureDataDir();\r\n  return path.join(dataDir, SUMMARIES_FILE);\r\n}\r\n\r\n/**\r\n * Load all stored metrics\r\n */\r\nexport async function loadAllMetrics(): Promise<FacilitatorPathMetrics[]> {\r\n  const filePath = await getMetricsFilePath();\r\n  const store = await readJsonFile<MetricsStore>(filePath, {\r\n    version: '1.0',\r\n    lastUpdated: new Date().toISOString(),\r\n    metrics: [],\r\n  });\r\n  return store.metrics;\r\n}\r\n\r\n/**\r\n * Upsert facilitator path metrics\r\n * Updates existing records or inserts new ones based on (facilitatorId, timeframe, timeBucketStart)\r\n */\r\nexport async function upsertFacilitatorPathMetrics(\r\n  metrics: FacilitatorPathMetrics[]\r\n): Promise<void> {\r\n  if (metrics.length === 0) {\r\n    logger.debug('No metrics to upsert');\r\n    return;\r\n  }\r\n\r\n  const filePath = await getMetricsFilePath();\r\n  const store = await readJsonFile<MetricsStore>(filePath, {\r\n    version: '1.0',\r\n    lastUpdated: new Date().toISOString(),\r\n    metrics: [],\r\n  });\r\n\r\n  // Build lookup key for deduplication\r\n  const buildKey = (m: FacilitatorPathMetrics) => \r\n    `${m.facilitatorId}:${m.timeframe}:${m.timeBucketStart}`;\r\n\r\n  // Create map of existing metrics\r\n  const existingMap = new Map<string, FacilitatorPathMetrics>();\r\n  for (const m of store.metrics) {\r\n    existingMap.set(buildKey(m), m);\r\n  }\r\n\r\n  // Upsert new metrics\r\n  let inserted = 0;\r\n  let updated = 0;\r\n  \r\n  for (const m of metrics) {\r\n    const key = buildKey(m);\r\n    if (existingMap.has(key)) {\r\n      updated++;\r\n    } else {\r\n      inserted++;\r\n    }\r\n    existingMap.set(key, m);\r\n  }\r\n\r\n  // Convert map back to array and sort by time\r\n  store.metrics = Array.from(existingMap.values()).sort((a, b) => \r\n    new Date(b.timeBucketStart).getTime() - new Date(a.timeBucketStart).getTime()\r\n  );\r\n\r\n  // Keep only last 30 days of data to prevent unbounded growth\r\n  const cutoffDate = new Date();\r\n  cutoffDate.setDate(cutoffDate.getDate() - 30);\r\n  store.metrics = store.metrics.filter((m) => \r\n    new Date(m.timeBucketStart) >= cutoffDate\r\n  );\r\n\r\n  store.lastUpdated = new Date().toISOString();\r\n\r\n  await writeJsonFile(filePath, store);\r\n\r\n  logger.info({\r\n    inserted,\r\n    updated,\r\n    total: store.metrics.length,\r\n    facilitatorId: metrics[0]?.facilitatorId,\r\n    timeframe: metrics[0]?.timeframe,\r\n    msg: 'Facilitator path metrics upserted',\r\n  });\r\n}\r\n\r\n/**\r\n * Load stored summaries\r\n */\r\nexport async function loadAllSummaries(): Promise<Record<string, FacilitatorSummary>> {\r\n  const filePath = await getSummariesFilePath();\r\n  const store = await readJsonFile<SummariesStore>(filePath, {\r\n    version: '1.0',\r\n    lastUpdated: new Date().toISOString(),\r\n    summaries: {},\r\n  });\r\n  return store.summaries;\r\n}\r\n\r\n/**\r\n * Upsert facilitator summary\r\n */\r\nexport async function upsertFacilitatorSummary(summary: FacilitatorSummary): Promise<void> {\r\n  const filePath = await getSummariesFilePath();\r\n  const store = await readJsonFile<SummariesStore>(filePath, {\r\n    version: '1.0',\r\n    lastUpdated: new Date().toISOString(),\r\n    summaries: {},\r\n  });\r\n\r\n  const key = `${summary.facilitatorId}:${summary.timeframe}`;\r\n  store.summaries[key] = summary;\r\n  store.lastUpdated = new Date().toISOString();\r\n\r\n  await writeJsonFile(filePath, store);\r\n\r\n  logger.info({\r\n    facilitatorId: summary.facilitatorId,\r\n    timeframe: summary.timeframe,\r\n    totalInvocations: summary.totalInvocations,\r\n    errorRate: summary.overallErrorRate,\r\n    msg: 'Facilitator summary upserted',\r\n  });\r\n}\r\n\r\n/**\r\n * Upsert multiple facilitator summaries\r\n */\r\nexport async function upsertFacilitatorSummaries(summaries: FacilitatorSummary[]): Promise<void> {\r\n  for (const summary of summaries) {\r\n    await upsertFacilitatorSummary(summary);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// QUERY FUNCTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Get metrics for a specific facilitator\r\n */\r\nexport async function getMetricsForFacilitator(\r\n  facilitatorId: string,\r\n  timeframe?: FacilitatorPathMetricsTimeframe\r\n): Promise<FacilitatorPathMetrics[]> {\r\n  const allMetrics = await loadAllMetrics();\r\n  \r\n  return allMetrics.filter((m) => {\r\n    if (m.facilitatorId !== facilitatorId) return false;\r\n    if (timeframe && m.timeframe !== timeframe) return false;\r\n    return true;\r\n  });\r\n}\r\n\r\n/**\r\n * Get summary for a specific facilitator and timeframe\r\n */\r\nexport async function getSummary(\r\n  facilitatorId: string,\r\n  timeframe: FacilitatorPathMetricsTimeframe\r\n): Promise<FacilitatorSummary | null> {\r\n  const summaries = await loadAllSummaries();\r\n  const key = `${facilitatorId}:${timeframe}`;\r\n  return summaries[key] ?? null;\r\n}\r\n\r\n/**\r\n * Get all summaries for a specific facilitator across all timeframes\r\n */\r\nexport async function getSummariesForFacilitator(\r\n  facilitatorId: string\r\n): Promise<FacilitatorSummary[]> {\r\n  const summaries = await loadAllSummaries();\r\n  \r\n  return Object.values(summaries).filter((s) => s.facilitatorId === facilitatorId);\r\n}\r\n\r\n/**\r\n * Get latest metrics across all facilitators\r\n */\r\nexport async function getLatestMetrics(\r\n  limit: number = 100\r\n): Promise<FacilitatorPathMetrics[]> {\r\n  const allMetrics = await loadAllMetrics();\r\n  return allMetrics.slice(0, limit);\r\n}\r\n\r\n/**\r\n * Get metrics comparison across facilitators for a timeframe\r\n */\r\nexport async function compareFacilitators(\r\n  facilitatorIds: string[],\r\n  timeframe: FacilitatorPathMetricsTimeframe\r\n): Promise<Map<string, FacilitatorSummary | null>> {\r\n  const summaries = await loadAllSummaries();\r\n  const result = new Map<string, FacilitatorSummary | null>();\r\n\r\n  for (const id of facilitatorIds) {\r\n    const key = `${id}:${timeframe}`;\r\n    result.set(id, summaries[key] ?? null);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// =============================================================================\r\n// CLEANUP\r\n// =============================================================================\r\n\r\n/**\r\n * Clean up old metrics data\r\n */\r\nexport async function cleanupOldMetrics(daysToKeep: number = 30): Promise<number> {\r\n  const filePath = await getMetricsFilePath();\r\n  const store = await readJsonFile<MetricsStore>(filePath, {\r\n    version: '1.0',\r\n    lastUpdated: new Date().toISOString(),\r\n    metrics: [],\r\n  });\r\n\r\n  const cutoffDate = new Date();\r\n  cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);\r\n\r\n  const originalCount = store.metrics.length;\r\n  store.metrics = store.metrics.filter((m) => \r\n    new Date(m.timeBucketStart) >= cutoffDate\r\n  );\r\n  const removed = originalCount - store.metrics.length;\r\n\r\n  if (removed > 0) {\r\n    store.lastUpdated = new Date().toISOString();\r\n    await writeJsonFile(filePath, store);\r\n    logger.info({ removed, daysToKeep, msg: 'Old metrics cleaned up' });\r\n  }\r\n\r\n  return removed;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 724, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/services/facilitator-metrics-reader.ts"],"sourcesContent":["// =============================================================================\r\n// FACILITATOR METRICS READER\r\n// =============================================================================\r\n// Read-side helper for SMF to access facilitator path metrics\r\n// Used by the SMF router to inform routing decisions\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport {\r\n  type FacilitatorPathMetrics,\r\n  type FacilitatorSummary,\r\n  type FacilitatorPathMetricsTimeframe,\r\n} from '@/infra/x402scan/types';\r\nimport {\r\n  loadAllMetrics,\r\n  loadAllSummaries,\r\n  getSummary,\r\n  getMetricsForFacilitator,\r\n} from './facilitator-metrics-service';\r\n\r\nconst logger = createLogger({ component: 'FacilitatorMetricsReader' });\r\n\r\n// =============================================================================\r\n// FRESHNESS & CONFIDENCE CONFIGURATION\r\n// =============================================================================\r\n\r\n/**\r\n * Configuration for determining when metrics are trustworthy\r\n * These thresholds prevent routing decisions based on stale or thin data\r\n */\r\nexport interface MetricsTrustConfig {\r\n  /** Maximum age of data to trust (hours) */\r\n  maxDataAgeHours: number;\r\n  /** Minimum invocations for high confidence scoring */\r\n  minInvocationsHighConfidence: number;\r\n  /** Minimum invocations to use data at all */\r\n  minInvocationsMinimum: number;\r\n  /** Penalty multiplier for low confidence data (0-1) */\r\n  lowConfidencePenalty: number;\r\n}\r\n\r\n/**\r\n * Default trust configuration\r\n * Can be overridden via environment variables\r\n */\r\nexport const DEFAULT_TRUST_CONFIG: MetricsTrustConfig = {\r\n  maxDataAgeHours: parseFloat(process.env.METRICS_MAX_AGE_HOURS ?? '4'),\r\n  minInvocationsHighConfidence: parseInt(process.env.METRICS_MIN_INVOCATIONS_HIGH ?? '1000', 10),\r\n  minInvocationsMinimum: parseInt(process.env.METRICS_MIN_INVOCATIONS ?? '100', 10),\r\n  lowConfidencePenalty: parseFloat(process.env.METRICS_LOW_CONFIDENCE_PENALTY ?? '0.5'),\r\n};\r\n\r\n/**\r\n * Check if metrics should be trusted for routing decisions\r\n */\r\nexport function shouldTrustMetrics(\r\n  dataAgeHours: number,\r\n  invocations: number,\r\n  config: MetricsTrustConfig = DEFAULT_TRUST_CONFIG\r\n): { trust: boolean; confidence: 'high' | 'medium' | 'low' | 'none'; reason: string } {\r\n  // Data too old\r\n  if (dataAgeHours > config.maxDataAgeHours) {\r\n    return {\r\n      trust: false,\r\n      confidence: 'none',\r\n      reason: `data-stale:${dataAgeHours.toFixed(1)}h-old`,\r\n    };\r\n  }\r\n\r\n  // Not enough data\r\n  if (invocations < config.minInvocationsMinimum) {\r\n    return {\r\n      trust: false,\r\n      confidence: 'none',\r\n      reason: `insufficient-data:${invocations}-invocations`,\r\n    };\r\n  }\r\n\r\n  // High confidence\r\n  if (invocations >= config.minInvocationsHighConfidence) {\r\n    return {\r\n      trust: true,\r\n      confidence: 'high',\r\n      reason: `high-confidence:${invocations}-invocations`,\r\n    };\r\n  }\r\n\r\n  // Medium confidence\r\n  return {\r\n    trust: true,\r\n    confidence: 'medium',\r\n    reason: `medium-confidence:${invocations}-invocations`,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface GetBestPathsParams {\r\n  /** Facilitator ID (NexFlow format, e.g., \"cdp\", \"payai\") */\r\n  facilitatorId: string;\r\n  \r\n  /** Network filter (optional) */\r\n  network?: string;\r\n  \r\n  /** Timeframe to consider (default: \"1d\") */\r\n  timeframe?: FacilitatorPathMetricsTimeframe;\r\n  \r\n  /** Maximum number of results */\r\n  limit?: number;\r\n}\r\n\r\nexport interface FacilitatorScoreParams {\r\n  /** Facilitator ID */\r\n  facilitatorId: string;\r\n  \r\n  /** Timeframe to consider */\r\n  timeframe?: FacilitatorPathMetricsTimeframe;\r\n}\r\n\r\nexport interface FacilitatorScore {\r\n  facilitatorId: string;\r\n  score: number;             // 0-100, higher is better\r\n  successRate: number;       // 0-1\r\n  avgLatencyMs?: number;\r\n  p95LatencyMs?: number;\r\n  totalInvocations: number;\r\n  dataFreshness: number;     // hours since last data\r\n  confidence: 'high' | 'medium' | 'low';  // based on data availability\r\n  reasons: string[];\r\n}\r\n\r\nexport interface FacilitatorRanking {\r\n  rankings: FacilitatorScore[];\r\n  timestamp: string;\r\n  timeframe: FacilitatorPathMetricsTimeframe;\r\n}\r\n\r\n// =============================================================================\r\n// SCORING WEIGHTS\r\n// =============================================================================\r\n\r\nconst SCORING_WEIGHTS = {\r\n  successRate: 50,     // 50% weight on success rate\r\n  latency: 30,         // 30% weight on latency\r\n  volume: 10,          // 10% weight on volume (more volume = more confidence)\r\n  freshness: 10,       // 10% weight on data freshness\r\n};\r\n\r\n// =============================================================================\r\n// QUERY FUNCTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Get best performing facilitator paths\r\n * Sorted by success rate, then by latency\r\n */\r\nexport async function getBestFacilitatorPaths(\r\n  params: GetBestPathsParams\r\n): Promise<FacilitatorPathMetrics[]> {\r\n  const timeframe = params.timeframe ?? '1d';\r\n  const limit = params.limit ?? 10;\r\n\r\n  try {\r\n    const metrics = await getMetricsForFacilitator(params.facilitatorId, timeframe);\r\n\r\n    if (metrics.length === 0) {\r\n      logger.debug({\r\n        facilitatorId: params.facilitatorId,\r\n        timeframe,\r\n        msg: 'No metrics found for facilitator',\r\n      });\r\n      return [];\r\n    }\r\n\r\n    // Sort by success rate (descending), then by latency (ascending)\r\n    const sorted = [...metrics].sort((a, b) => {\r\n      // Primary: higher success rate is better\r\n      const successRateDiff = (1 - b.errorRate) - (1 - a.errorRate);\r\n      if (Math.abs(successRateDiff) > 0.01) {\r\n        return successRateDiff > 0 ? 1 : -1;\r\n      }\r\n\r\n      // Secondary: lower latency is better\r\n      const aLatency = a.p95LatencyMs ?? a.avgLatencyMs ?? Infinity;\r\n      const bLatency = b.p95LatencyMs ?? b.avgLatencyMs ?? Infinity;\r\n      return aLatency - bLatency;\r\n    });\r\n\r\n    return sorted.slice(0, limit);\r\n  } catch (error) {\r\n    logger.error({\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n      facilitatorId: params.facilitatorId,\r\n      msg: 'Failed to get best facilitator paths',\r\n    });\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate a score for a facilitator based on x402scan metrics\r\n * Score is 0-100, higher is better\r\n */\r\nexport async function getFacilitatorScore(\r\n  params: FacilitatorScoreParams\r\n): Promise<FacilitatorScore | null> {\r\n  const timeframe = params.timeframe ?? '1d';\r\n  const reasons: string[] = [];\r\n\r\n  try {\r\n    const summary = await getSummary(params.facilitatorId, timeframe);\r\n\r\n    if (!summary) {\r\n      return {\r\n        facilitatorId: params.facilitatorId,\r\n        score: 50, // Default neutral score\r\n        successRate: 0,\r\n        totalInvocations: 0,\r\n        dataFreshness: Infinity,\r\n        confidence: 'low',\r\n        reasons: ['No x402scan data available'],\r\n      };\r\n    }\r\n\r\n    // Calculate success rate score (0-50)\r\n    const successRate = 1 - summary.overallErrorRate;\r\n    const successRateScore = successRate * SCORING_WEIGHTS.successRate;\r\n    reasons.push(`success-rate:${(successRate * 100).toFixed(1)}%`);\r\n\r\n    // Calculate latency score (0-30)\r\n    // Assume 500ms is \"good\", 2000ms is \"bad\"\r\n    let latencyScore = SCORING_WEIGHTS.latency;\r\n    const p95 = summary.avgP90LatencyMs ?? summary.avgP99LatencyMs;\r\n    if (p95 !== undefined) {\r\n      const normalizedLatency = Math.min(p95, 2000) / 2000; // 0-1, lower is better\r\n      latencyScore = (1 - normalizedLatency) * SCORING_WEIGHTS.latency;\r\n      reasons.push(`p95-latency:${p95.toFixed(0)}ms`);\r\n    } else {\r\n      latencyScore = SCORING_WEIGHTS.latency * 0.5; // Neutral if unknown\r\n      reasons.push('latency:unknown');\r\n    }\r\n\r\n    // Calculate volume score (0-10)\r\n    // More volume = more confidence in the data\r\n    const volumeThreshold = 1000; // 1000 invocations is \"high confidence\"\r\n    const volumeRatio = Math.min(summary.totalInvocations / volumeThreshold, 1);\r\n    const volumeScore = volumeRatio * SCORING_WEIGHTS.volume;\r\n    reasons.push(`invocations:${summary.totalInvocations}`);\r\n\r\n    // Calculate freshness score (0-10)\r\n    const fetchedAt = new Date(summary.fetchedAt);\r\n    const hoursOld = (Date.now() - fetchedAt.getTime()) / (1000 * 60 * 60);\r\n    const freshnessRatio = Math.max(0, 1 - hoursOld / 24); // Decays over 24 hours\r\n    const freshnessScore = freshnessRatio * SCORING_WEIGHTS.freshness;\r\n    reasons.push(`data-age:${hoursOld.toFixed(1)}h`);\r\n\r\n    // Total score\r\n    const score = successRateScore + latencyScore + volumeScore + freshnessScore;\r\n\r\n    // Determine confidence level\r\n    let confidence: 'high' | 'medium' | 'low' = 'low';\r\n    if (summary.totalInvocations >= 1000 && hoursOld < 6) {\r\n      confidence = 'high';\r\n    } else if (summary.totalInvocations >= 100 && hoursOld < 24) {\r\n      confidence = 'medium';\r\n    }\r\n\r\n    return {\r\n      facilitatorId: params.facilitatorId,\r\n      score: Math.round(score),\r\n      successRate,\r\n      avgLatencyMs: summary.avgP50LatencyMs,\r\n      p95LatencyMs: summary.avgP90LatencyMs,\r\n      totalInvocations: summary.totalInvocations,\r\n      dataFreshness: hoursOld,\r\n      confidence,\r\n      reasons,\r\n    };\r\n  } catch (error) {\r\n    logger.error({\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n      facilitatorId: params.facilitatorId,\r\n      msg: 'Failed to get facilitator score',\r\n    });\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Rank multiple facilitators by their x402scan-derived score\r\n * Enforces freshness and confidence thresholds - only returns trusted scores\r\n * \r\n * @param facilitatorIds - List of facilitator IDs to rank\r\n * @param timeframe - Timeframe for metrics (default: '1d')\r\n * @param config - Trust configuration (default: DEFAULT_TRUST_CONFIG)\r\n */\r\nexport async function rankFacilitators(\r\n  facilitatorIds: string[],\r\n  timeframe: FacilitatorPathMetricsTimeframe = '1d',\r\n  config: MetricsTrustConfig = DEFAULT_TRUST_CONFIG\r\n): Promise<FacilitatorRanking> {\r\n  const scores: FacilitatorScore[] = [];\r\n  const untrusted: Array<{ id: string; reason: string }> = [];\r\n\r\n  for (const id of facilitatorIds) {\r\n    const score = await getFacilitatorScore({ facilitatorId: id, timeframe });\r\n    \r\n    if (!score) {\r\n      untrusted.push({ id, reason: 'no-data' });\r\n      continue;\r\n    }\r\n\r\n    // Check if metrics meet trust thresholds\r\n    const trustCheck = shouldTrustMetrics(\r\n      score.dataFreshness,\r\n      score.totalInvocations,\r\n      config\r\n    );\r\n\r\n    if (!trustCheck.trust) {\r\n      untrusted.push({ id, reason: trustCheck.reason });\r\n      // Still include in rankings but with penalized score\r\n      scores.push({\r\n        ...score,\r\n        score: score.score * config.lowConfidencePenalty, // Heavy penalty\r\n        confidence: 'low',\r\n        reasons: [...score.reasons, `untrusted:${trustCheck.reason}`],\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // Apply confidence-based adjustments\r\n    if (trustCheck.confidence === 'medium') {\r\n      // Slight penalty for medium confidence\r\n      scores.push({\r\n        ...score,\r\n        score: score.score * 0.9, // 10% penalty\r\n        confidence: 'medium',\r\n        reasons: [...score.reasons, trustCheck.reason],\r\n      });\r\n    } else {\r\n      // High confidence - use score as-is\r\n      scores.push({\r\n        ...score,\r\n        reasons: [...score.reasons, trustCheck.reason],\r\n      });\r\n    }\r\n  }\r\n\r\n  // Log untrusted facilitators for visibility\r\n  if (untrusted.length > 0) {\r\n    logger.debug({\r\n      untrusted,\r\n      trusted: scores.filter((s) => s.confidence !== 'low').map((s) => s.facilitatorId),\r\n      msg: 'Facilitator metrics trust check results',\r\n    });\r\n  }\r\n\r\n  // Sort by score descending\r\n  scores.sort((a, b) => b.score - a.score);\r\n\r\n  return {\r\n    rankings: scores,\r\n    timestamp: new Date().toISOString(),\r\n    timeframe,\r\n  };\r\n}\r\n\r\n/**\r\n * Get recommended facilitator for a given context\r\n * Uses x402scan data to inform the recommendation\r\n * Falls back to default candidate when metrics are stale/missing\r\n */\r\nexport async function getRecommendedFacilitator(\r\n  candidateIds: string[],\r\n  options?: {\r\n    network?: string;\r\n    timeframe?: FacilitatorPathMetricsTimeframe;\r\n    prioritize?: 'latency' | 'reliability' | 'balanced';\r\n    trustConfig?: MetricsTrustConfig;\r\n  }\r\n): Promise<{\r\n  recommended: string | null;\r\n  ranking: FacilitatorRanking;\r\n  reason: string;\r\n  usedFallback: boolean;\r\n}> {\r\n  const timeframe = options?.timeframe ?? '1d';\r\n  const trustConfig = options?.trustConfig ?? DEFAULT_TRUST_CONFIG;\r\n  const ranking = await rankFacilitators(candidateIds, timeframe, trustConfig);\r\n\r\n  // Check if we have any trusted rankings\r\n  const trustedRankings = ranking.rankings.filter((r) => r.confidence !== 'low');\r\n\r\n  if (trustedRankings.length === 0) {\r\n    // No trusted data - fall back to first candidate\r\n    logger.warn({\r\n      candidates: candidateIds,\r\n      rankings: ranking.rankings.map((r) => ({\r\n        id: r.facilitatorId,\r\n        confidence: r.confidence,\r\n        reasons: r.reasons,\r\n      })),\r\n      msg: 'No trusted x402scan data available, using fallback',\r\n    });\r\n\r\n    return {\r\n      recommended: candidateIds[0] ?? null,\r\n      ranking,\r\n      reason: 'No trusted x402scan data (stale or insufficient), using default order',\r\n      usedFallback: true,\r\n    };\r\n  }\r\n\r\n  const prioritize = options?.prioritize ?? 'balanced';\r\n  let recommended: FacilitatorScore;\r\n\r\n  switch (prioritize) {\r\n    case 'latency':\r\n      // Sort by latency (ascending), filter out unknown latency, only trusted\r\n      const byLatency = trustedRankings\r\n        .filter((r) => r.p95LatencyMs !== undefined)\r\n        .sort((a, b) => (a.p95LatencyMs ?? Infinity) - (b.p95LatencyMs ?? Infinity));\r\n      recommended = byLatency[0] ?? trustedRankings[0];\r\n      break;\r\n\r\n    case 'reliability':\r\n      // Sort by success rate (descending), only trusted\r\n      const byReliability = [...trustedRankings].sort((a, b) => b.successRate - a.successRate);\r\n      recommended = byReliability[0];\r\n      break;\r\n\r\n    case 'balanced':\r\n    default:\r\n      // Use overall score from trusted rankings\r\n      recommended = trustedRankings[0];\r\n      break;\r\n  }\r\n\r\n  return {\r\n    recommended: recommended.facilitatorId,\r\n    ranking,\r\n    reason: `Selected ${recommended.facilitatorId} with score ${recommended.score} ` +\r\n      `(${recommended.confidence} confidence, ${recommended.reasons.slice(0, 3).join(', ')})`,\r\n    usedFallback: false,\r\n  };\r\n}\r\n\r\n/**\r\n * Check if a facilitator should be avoided based on recent performance\r\n */\r\nexport async function shouldAvoidFacilitator(\r\n  facilitatorId: string,\r\n  threshold: {\r\n    maxErrorRate?: number;    // Default: 0.2 (20%)\r\n    minInvocations?: number;  // Default: 10\r\n  } = {}\r\n): Promise<{\r\n  avoid: boolean;\r\n  reason?: string;\r\n}> {\r\n  const maxErrorRate = threshold.maxErrorRate ?? 0.2;\r\n  const minInvocations = threshold.minInvocations ?? 10;\r\n\r\n  try {\r\n    const score = await getFacilitatorScore({ facilitatorId, timeframe: '1d' });\r\n\r\n    if (!score) {\r\n      return { avoid: false, reason: 'No data available' };\r\n    }\r\n\r\n    // Not enough data to make a decision\r\n    if (score.totalInvocations < minInvocations) {\r\n      return { avoid: false, reason: `Insufficient data (${score.totalInvocations} invocations)` };\r\n    }\r\n\r\n    // Check error rate\r\n    const errorRate = 1 - score.successRate;\r\n    if (errorRate > maxErrorRate) {\r\n      return {\r\n        avoid: true,\r\n        reason: `Error rate ${(errorRate * 100).toFixed(1)}% exceeds threshold ${(maxErrorRate * 100).toFixed(1)}%`,\r\n      };\r\n    }\r\n\r\n    return { avoid: false };\r\n  } catch (error) {\r\n    logger.error({\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n      facilitatorId,\r\n      msg: 'Failed to check if facilitator should be avoided',\r\n    });\r\n    return { avoid: false, reason: 'Error checking metrics' };\r\n  }\r\n}\r\n\r\n/**\r\n * Get all available facilitator summaries\r\n * Useful for dashboard/monitoring\r\n */\r\nexport async function getAllFacilitatorSummaries(): Promise<Record<string, FacilitatorSummary>> {\r\n  return loadAllSummaries();\r\n}\r\n\r\n// =============================================================================\r\n// SMF EXPLAINER\r\n// =============================================================================\r\n\r\n/**\r\n * Structured explanation for SMF routing decisions\r\n */\r\nexport interface FacilitatorExplanation {\r\n  facilitatorId: string;\r\n  selected: boolean;\r\n  score: number;\r\n  confidence: 'high' | 'medium' | 'low';\r\n  shortReason: string;      // One-line summary\r\n  detailedReasons: string[];\r\n  metrics: {\r\n    successRate?: number;\r\n    errorRate?: number;\r\n    p95LatencyMs?: number;\r\n    invocations?: number;\r\n    dataAgeHours?: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Get a structured explanation for why a facilitator was/wasn't selected\r\n * Used by SMF to provide transparent routing decisions\r\n * \r\n * @example\r\n * const explanation = await getFacilitatorExplainer('cdp', { timeframe: '1d' });\r\n * console.log(explanation.shortReason);\r\n * // \"cdp: 98.5% success, 185ms p95, high confidence (12K invocations)\"\r\n */\r\nexport async function getFacilitatorExplainer(\r\n  facilitatorId: string,\r\n  options?: {\r\n    timeframe?: FacilitatorPathMetricsTimeframe;\r\n    wasSelected?: boolean;\r\n  }\r\n): Promise<FacilitatorExplanation> {\r\n  const timeframe = options?.timeframe ?? '1d';\r\n  const wasSelected = options?.wasSelected ?? false;\r\n\r\n  const score = await getFacilitatorScore({ facilitatorId, timeframe });\r\n\r\n  if (!score) {\r\n    return {\r\n      facilitatorId,\r\n      selected: wasSelected,\r\n      score: 50,\r\n      confidence: 'low',\r\n      shortReason: `${facilitatorId}: no x402scan data available`,\r\n      detailedReasons: ['No observability data from x402scan'],\r\n      metrics: {},\r\n    };\r\n  }\r\n\r\n  // Build short reason string\r\n  const successPct = (score.successRate * 100).toFixed(1);\r\n  const latencyStr = score.p95LatencyMs ? `${score.p95LatencyMs.toFixed(0)}ms p95` : 'latency unknown';\r\n  const volumeStr = score.totalInvocations >= 1000 \r\n    ? `${(score.totalInvocations / 1000).toFixed(1)}K invocations`\r\n    : `${score.totalInvocations} invocations`;\r\n\r\n  const shortReason = `${facilitatorId}: ${successPct}% success, ${latencyStr}, ${score.confidence} confidence (${volumeStr})`;\r\n\r\n  // Build detailed reasons\r\n  const detailedReasons: string[] = [];\r\n  \r\n  if (score.successRate >= 0.99) {\r\n    detailedReasons.push(`Excellent success rate: ${successPct}%`);\r\n  } else if (score.successRate >= 0.95) {\r\n    detailedReasons.push(`Good success rate: ${successPct}%`);\r\n  } else if (score.successRate >= 0.90) {\r\n    detailedReasons.push(`Acceptable success rate: ${successPct}%`);\r\n  } else {\r\n    detailedReasons.push(` Low success rate: ${successPct}%`);\r\n  }\r\n\r\n  if (score.p95LatencyMs !== undefined) {\r\n    if (score.p95LatencyMs < 200) {\r\n      detailedReasons.push(`Fast response times: ${score.p95LatencyMs.toFixed(0)}ms p95`);\r\n    } else if (score.p95LatencyMs < 500) {\r\n      detailedReasons.push(`Moderate latency: ${score.p95LatencyMs.toFixed(0)}ms p95`);\r\n    } else {\r\n      detailedReasons.push(` High latency: ${score.p95LatencyMs.toFixed(0)}ms p95`);\r\n    }\r\n  }\r\n\r\n  if (score.confidence === 'high') {\r\n    detailedReasons.push(`High confidence: ${volumeStr}, data ${score.dataFreshness.toFixed(1)}h old`);\r\n  } else if (score.confidence === 'medium') {\r\n    detailedReasons.push(`Medium confidence: ${volumeStr}`);\r\n  } else {\r\n    detailedReasons.push(`Low confidence: limited data (${volumeStr})`);\r\n  }\r\n\r\n  if (score.dataFreshness > 12) {\r\n    detailedReasons.push(` Data is ${score.dataFreshness.toFixed(1)} hours old`);\r\n  }\r\n\r\n  return {\r\n    facilitatorId,\r\n    selected: wasSelected,\r\n    score: score.score,\r\n    confidence: score.confidence,\r\n    shortReason,\r\n    detailedReasons,\r\n    metrics: {\r\n      successRate: score.successRate,\r\n      errorRate: 1 - score.successRate,\r\n      p95LatencyMs: score.p95LatencyMs,\r\n      invocations: score.totalInvocations,\r\n      dataAgeHours: score.dataFreshness,\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Get explanations for multiple facilitators (for comparison)\r\n */\r\nexport async function getMultipleFacilitatorExplanations(\r\n  facilitatorIds: string[],\r\n  options?: {\r\n    timeframe?: FacilitatorPathMetricsTimeframe;\r\n    selectedId?: string;\r\n  }\r\n): Promise<FacilitatorExplanation[]> {\r\n  const explanations: FacilitatorExplanation[] = [];\r\n\r\n  for (const id of facilitatorIds) {\r\n    const explanation = await getFacilitatorExplainer(id, {\r\n      timeframe: options?.timeframe,\r\n      wasSelected: id === options?.selectedId,\r\n    });\r\n    explanations.push(explanation);\r\n  }\r\n\r\n  // Sort by score descending\r\n  return explanations.sort((a, b) => b.score - a.score);\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1176, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/meaux/CascadeProjects/my%20second%20project/CascadeProjects/windsurf-project/nexflow-deploy/src/app/api/debug/smf-facilitators/route.ts"],"sourcesContent":["// =============================================================================\r\n// DEBUG API: SMF FACILITATOR RANKINGS\r\n// =============================================================================\r\n// Exposes x402scan metrics and SMF ranking information for debugging\r\n// GET /api/debug/smf-facilitators?network=eip155:8453&timeframe=1d\r\n\r\nimport { NextResponse } from 'next/server';\r\nimport { createLogger } from '@/lib/logger';\r\nimport {\r\n  getAllFacilitators,\r\n  getFacilitatorsForNetwork,\r\n  type FacilitatorRegistryEntry,\r\n} from '@/integrations/x402/facilitators/facilitator-registry';\r\nimport {\r\n  rankFacilitators,\r\n  getRecommendedFacilitator,\r\n  getFacilitatorExplainer,\r\n  type FacilitatorExplanation,\r\n} from '@/services/facilitator-metrics-reader';\r\nimport type { FacilitatorPathMetricsTimeframe } from '@/infra/x402scan/types';\r\n\r\nconst logger = createLogger({ component: 'DebugSMFFacilitators' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\ninterface FacilitatorDebugInfo {\r\n  id: string;\r\n  name: string;\r\n  baseUrl: string;\r\n  networks: string[];\r\n  score: number;\r\n  rank: number;\r\n  selected: boolean;\r\n  x402scanScore?: number;\r\n  confidence?: 'high' | 'medium' | 'low' | 'none';\r\n  shortReason?: string;\r\n  metrics?: {\r\n    successRate: number;\r\n    errorRate: number;\r\n    p95LatencyMs?: number;\r\n    invocations: number;\r\n    dataAgeHours: number;\r\n  };\r\n  reasons?: string[];\r\n}\r\n\r\ninterface DebugResponse {\r\n  ok: true;\r\n  network: string | null;\r\n  timeframe: FacilitatorPathMetricsTimeframe;\r\n  usedFallback: boolean;\r\n  recommended: string | null;\r\n  recommendationReason: string;\r\n  facilitators: FacilitatorDebugInfo[];\r\n  timestamp: string;\r\n}\r\n\r\ninterface ErrorResponse {\r\n  ok: false;\r\n  error: string;\r\n}\r\n\r\n// =============================================================================\r\n// ROUTE HANDLER\r\n// =============================================================================\r\n\r\nexport async function GET(request: Request): Promise<NextResponse<DebugResponse | ErrorResponse>> {\r\n  try {\r\n    const { searchParams } = new URL(request.url);\r\n    const network = searchParams.get('network') || null;\r\n    const timeframe = (searchParams.get('timeframe') || '1d') as FacilitatorPathMetricsTimeframe;\r\n\r\n    // Validate timeframe\r\n    if (!['1d', '7d', '30d'].includes(timeframe)) {\r\n      return NextResponse.json(\r\n        { ok: false, error: `Invalid timeframe: ${timeframe}. Must be 1d, 7d, or 30d.` },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Get facilitators (filtered by network if provided)\r\n    let facilitators: FacilitatorRegistryEntry[];\r\n    if (network) {\r\n      facilitators = getFacilitatorsForNetwork(network);\r\n      if (facilitators.length === 0) {\r\n        return NextResponse.json({\r\n          ok: true,\r\n          network,\r\n          timeframe,\r\n          usedFallback: true,\r\n          recommended: null,\r\n          recommendationReason: `No facilitators support network: ${network}`,\r\n          facilitators: [],\r\n          timestamp: new Date().toISOString(),\r\n        });\r\n      }\r\n    } else {\r\n      facilitators = getAllFacilitators();\r\n    }\r\n\r\n    const facilitatorIds = facilitators.map((f) => f.id);\r\n\r\n    // Get recommendation and rankings\r\n    const recommendation = await getRecommendedFacilitator(facilitatorIds, {\r\n      network: network ?? undefined,\r\n      timeframe,\r\n      prioritize: 'balanced',\r\n    });\r\n\r\n    // Get detailed explanations for each facilitator\r\n    const facilitatorDebugInfo: FacilitatorDebugInfo[] = [];\r\n\r\n    for (let i = 0; i < recommendation.ranking.rankings.length; i++) {\r\n      const ranking = recommendation.ranking.rankings[i];\r\n      const registryEntry = facilitators.find((f) => f.id === ranking.facilitatorId);\r\n      \r\n      // Get detailed explanation\r\n      let explanation: FacilitatorExplanation | null = null;\r\n      try {\r\n        explanation = await getFacilitatorExplainer(ranking.facilitatorId, {\r\n          timeframe,\r\n          wasSelected: ranking.facilitatorId === recommendation.recommended,\r\n        });\r\n      } catch (error) {\r\n        logger.debug({ error, facilitatorId: ranking.facilitatorId }, 'Failed to get explanation');\r\n      }\r\n\r\n      const debugInfo: FacilitatorDebugInfo = {\r\n        id: ranking.facilitatorId,\r\n        name: registryEntry?.name ?? ranking.facilitatorId,\r\n        baseUrl: registryEntry?.baseUrl ?? 'unknown',\r\n        networks: registryEntry?.networks ?? [],\r\n        score: Math.round(ranking.score * 10) / 10,\r\n        rank: i + 1,\r\n        selected: ranking.facilitatorId === recommendation.recommended,\r\n        x402scanScore: explanation?.score ?? ranking.score,\r\n        confidence: ranking.confidence,\r\n        shortReason: explanation?.shortReason,\r\n        metrics: explanation?.metrics ? {\r\n          successRate: explanation.metrics.successRate,\r\n          errorRate: explanation.metrics.errorRate,\r\n          p95LatencyMs: explanation.metrics.p95LatencyMs,\r\n          invocations: explanation.metrics.invocations,\r\n          dataAgeHours: Math.round(explanation.metrics.dataAgeHours * 10) / 10,\r\n        } : undefined,\r\n        reasons: ranking.reasons,\r\n      };\r\n\r\n      facilitatorDebugInfo.push(debugInfo);\r\n    }\r\n\r\n    // Add facilitators with no ranking data\r\n    for (const facilitator of facilitators) {\r\n      if (!facilitatorDebugInfo.some((f) => f.id === facilitator.id)) {\r\n        facilitatorDebugInfo.push({\r\n          id: facilitator.id,\r\n          name: facilitator.name,\r\n          baseUrl: facilitator.baseUrl,\r\n          networks: facilitator.networks,\r\n          score: 0,\r\n          rank: facilitatorDebugInfo.length + 1,\r\n          selected: false,\r\n          confidence: 'none',\r\n          shortReason: 'No x402scan data available',\r\n          reasons: ['no-x402scan-data'],\r\n        });\r\n      }\r\n    }\r\n\r\n    // Log the debug request\r\n    logger.info({\r\n      network,\r\n      timeframe,\r\n      usedFallback: recommendation.usedFallback,\r\n      recommended: recommendation.recommended,\r\n      facilitatorCount: facilitatorDebugInfo.length,\r\n      topFacilitator: facilitatorDebugInfo[0] ? {\r\n        id: facilitatorDebugInfo[0].id,\r\n        score: facilitatorDebugInfo[0].score,\r\n        confidence: facilitatorDebugInfo[0].confidence,\r\n      } : null,\r\n      msg: 'SMF facilitator debug request',\r\n    });\r\n\r\n    const response: DebugResponse = {\r\n      ok: true,\r\n      network,\r\n      timeframe,\r\n      usedFallback: recommendation.usedFallback,\r\n      recommended: recommendation.recommended,\r\n      recommendationReason: recommendation.reason,\r\n      facilitators: facilitatorDebugInfo,\r\n      timestamp: new Date().toISOString(),\r\n    };\r\n\r\n    return NextResponse.json(response);\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n    \r\n    logger.error({\r\n      error: errorMessage,\r\n      stack: error instanceof Error ? error.stack : undefined,\r\n      msg: 'SMF facilitator debug route error',\r\n    });\r\n\r\n    return NextResponse.json(\r\n      { ok: false, error: errorMessage },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// OPTIONS (CORS)\r\n// =============================================================================\r\n\r\nexport async function OPTIONS(): Promise<NextResponse> {\r\n  return new NextResponse(null, {\r\n    status: 204,\r\n    headers: {\r\n      'Access-Control-Allow-Origin': '*',\r\n      'Access-Control-Allow-Methods': 'GET, OPTIONS',\r\n      'Access-Control-Allow-Headers': 'Content-Type',\r\n    },\r\n  });\r\n}\r\n\r\n"],"names":[],"mappings":"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"}}]
}