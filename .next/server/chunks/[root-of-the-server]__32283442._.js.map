{"version":3,"sources":["turbopack:///[project]/node_modules/thread-stream/package.json","../../../src/lib/auth/validate-api-key.ts","../../../src/types/smf-api.ts","../../../src/app/api/v1/smf/verify/route.ts","../../../node_modules/next/src/build/templates/app-route.ts"],"sourcesContent":["{\"name\":\"thread-stream\",\"version\":\"3.1.0\",\"description\":\"A streaming way to send data to a Node.js Worker Thread\",\"main\":\"index.js\",\"types\":\"index.d.ts\",\"dependencies\":{\"real-require\":\"^0.2.0\"},\"devDependencies\":{\"@types/node\":\"^20.1.0\",\"@types/tap\":\"^15.0.0\",\"@yao-pkg/pkg\":\"^5.11.5\",\"desm\":\"^1.3.0\",\"fastbench\":\"^1.0.1\",\"husky\":\"^9.0.6\",\"pino-elasticsearch\":\"^8.0.0\",\"sonic-boom\":\"^4.0.1\",\"standard\":\"^17.0.0\",\"tap\":\"^16.2.0\",\"ts-node\":\"^10.8.0\",\"typescript\":\"^5.3.2\",\"why-is-node-running\":\"^2.2.2\"},\"scripts\":{\"build\":\"tsc --noEmit\",\"test\":\"standard && npm run build && npm run transpile && tap \\\"test/**/*.test.*js\\\" && tap --ts test/*.test.*ts\",\"test:ci\":\"standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts\",\"test:ci:js\":\"tap --no-check-coverage --timeout=120 --coverage-report=lcovonly \\\"test/**/*.test.*js\\\"\",\"test:ci:ts\":\"tap --ts --no-check-coverage --coverage-report=lcovonly \\\"test/**/*.test.*ts\\\"\",\"test:yarn\":\"npm run transpile && tap \\\"test/**/*.test.js\\\" --no-check-coverage\",\"transpile\":\"sh ./test/ts/transpile.sh\",\"prepare\":\"husky install\"},\"standard\":{\"ignore\":[\"test/ts/**/*\",\"test/syntax-error.mjs\"]},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/mcollina/thread-stream.git\"},\"keywords\":[\"worker\",\"thread\",\"threads\",\"stream\"],\"author\":\"Matteo Collina <hello@matteocollina.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/mcollina/thread-stream/issues\"},\"homepage\":\"https://github.com/mcollina/thread-stream#readme\"}","// =============================================================================\r\n// API Key Validation\r\n// =============================================================================\r\n// Validates NexFlow API keys for authentication\r\n// Supports both live (nf_live_*) and test (nf_test_*) keys\r\n\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'ValidateApiKey' });\r\n\r\n/**\r\n * Validated API key result\r\n */\r\nexport interface ValidatedApiKey {\r\n  /** Unique identifier for the API key (first 20 chars or hash) */\r\n  id: string;\r\n  /** Account ID associated with this key (if known) */\r\n  accountId?: string;\r\n  /** Whether this is a live or test key */\r\n  isLive: boolean;\r\n  /** Whether the key is valid */\r\n  valid: boolean;\r\n}\r\n\r\n/**\r\n * API key prefix patterns\r\n */\r\nconst API_KEY_PREFIXES = {\r\n  LIVE: 'nf_live_',\r\n  TEST: 'nf_test_',\r\n} as const;\r\n\r\n/**\r\n * Validate an API key and return key metadata\r\n * \r\n * @param apiKey - The API key to validate\r\n * @returns Validated key info or null if invalid\r\n * \r\n * @example\r\n * ```ts\r\n * const key = await validateApiKey('nf_live_abc123xyz...');\r\n * if (key) {\r\n *   console.log(`Key ${key.id} is valid`);\r\n * }\r\n * ```\r\n */\r\nexport async function validateApiKey(apiKey: string): Promise<ValidatedApiKey | null> {\r\n  if (!apiKey || typeof apiKey !== 'string') {\r\n    logger.debug({ reason: 'empty' }, 'API key validation failed');\r\n    return null;\r\n  }\r\n\r\n  // Check for valid prefix\r\n  const isLive = apiKey.startsWith(API_KEY_PREFIXES.LIVE);\r\n  const isTest = apiKey.startsWith(API_KEY_PREFIXES.TEST);\r\n\r\n  if (!isLive && !isTest) {\r\n    logger.debug({ reason: 'invalid_prefix' }, 'API key validation failed');\r\n    return null;\r\n  }\r\n\r\n  // Extract key body (after prefix)\r\n  const prefix = isLive ? API_KEY_PREFIXES.LIVE : API_KEY_PREFIXES.TEST;\r\n  const keyBody = apiKey.slice(prefix.length);\r\n\r\n  // Basic validation: key body should be at least 16 characters\r\n  if (keyBody.length < 16) {\r\n    logger.debug({ reason: 'too_short' }, 'API key validation failed');\r\n    return null;\r\n  }\r\n\r\n  // Generate a stable ID from the key (first 20 chars of full key)\r\n  const id = apiKey.substring(0, 20);\r\n\r\n  // In a production system, you would:\r\n  // 1. Hash the key and look it up in the database\r\n  // 2. Check expiration, rate limits, permissions\r\n  // 3. Return associated account info\r\n  \r\n  // For now, we accept any well-formed key\r\n  // Real validation should be added when accounts system is integrated\r\n  \r\n  logger.debug({ id, isLive }, 'API key validated');\r\n\r\n  return {\r\n    id,\r\n    isLive,\r\n    valid: true,\r\n  };\r\n}\r\n\r\n/**\r\n * Check if an API key format is valid (without database lookup)\r\n * \r\n * @param apiKey - The API key to check\r\n * @returns true if format is valid\r\n */\r\nexport function isValidApiKeyFormat(apiKey: string): boolean {\r\n  if (!apiKey || typeof apiKey !== 'string') return false;\r\n  \r\n  const isLive = apiKey.startsWith(API_KEY_PREFIXES.LIVE);\r\n  const isTest = apiKey.startsWith(API_KEY_PREFIXES.TEST);\r\n  \r\n  if (!isLive && !isTest) return false;\r\n  \r\n  const prefix = isLive ? API_KEY_PREFIXES.LIVE : API_KEY_PREFIXES.TEST;\r\n  const keyBody = apiKey.slice(prefix.length);\r\n  \r\n  return keyBody.length >= 16;\r\n}\r\n\r\n/**\r\n * Extract key type from API key\r\n */\r\nexport function getApiKeyType(apiKey: string): 'live' | 'test' | 'unknown' {\r\n  if (apiKey?.startsWith(API_KEY_PREFIXES.LIVE)) return 'live';\r\n  if (apiKey?.startsWith(API_KEY_PREFIXES.TEST)) return 'test';\r\n  return 'unknown';\r\n}\r\n\r\n","// =============================================================================\r\n// SMF API TYPES\r\n// =============================================================================\r\n// Shared request/response types for SMF API endpoints\r\n// Used by both server-side API handlers and client SDK\r\n\r\n// =============================================================================\r\n// PROTECTED PAYMENTS - Anomaly Detection Metadata\r\n// =============================================================================\r\n\r\n/**\r\n * Payment protection status from NexFlow's anomaly detection system.\r\n * Every payment routed through SMF is automatically protected.\r\n */\r\nexport interface PaymentProtection {\r\n  /** Protection level - always 'automatic' for SMF */\r\n  level: 'automatic';\r\n  /** Circuit breaker state for the selected facilitator */\r\n  circuit_breaker_state: 'CLOSED' | 'OPEN' | 'HALF_OPEN';\r\n  /** Current health classification based on recent metrics */\r\n  facilitator_health: 'normal' | 'suspect' | 'anomalous';\r\n  /** 7-day rolling success rate (0-1) */\r\n  success_rate_7d: number;\r\n  /** Whether anomaly detection is actively monitoring */\r\n  anomaly_detection_active: boolean;\r\n}\r\n\r\n/**\r\n * Fee breakdown for settlement.\r\n * Single platform fee (0.25%) - no insurance split.\r\n */\r\nexport interface SettlementFeeBreakdown {\r\n  /** Platform fee in wei (0.25% of amount) */\r\n  platform_fee_wei: string;\r\n  /** Total fee in wei (same as platform_fee) */\r\n  total_fee_wei: string;\r\n}\r\n\r\n// =============================================================================\r\n// ROUTE ENDPOINT\r\n// =============================================================================\r\n\r\n/**\r\n * Request body for POST /api/v1/smf/route\r\n * Routes a payment to the best available facilitator\r\n */\r\nexport interface SMFRouteRequest {\r\n  /** Payment amount in wei (e.g., \"1000000\") */\r\n  amount_wei: string;\r\n  /** Token contract address (e.g., \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\") */\r\n  token_address: string;\r\n  /** Chain ID in CAIP-2 format (e.g., \"eip155:8453\") */\r\n  chain_id: string;\r\n  /** Optional recipient address for routing optimization */\r\n  recipient?: string;\r\n  /** Optional idempotency key / correlation ID */\r\n  payment_id?: string;\r\n  /** Optional metadata for routing decisions */\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Response body for POST /api/v1/smf/route\r\n */\r\nexport interface SMFRouteResponse {\r\n  /** Selected facilitator ID (e.g., \"cdp\", \"payai\", \"x402rs\") */\r\n  facilitator_id: string;\r\n  /** Routing decision path (e.g., \"direct\", \"batched\", \"fallback\") */\r\n  path: string;\r\n  /** Expected platform fee in wei (0.25% default) */\r\n  expected_fee_wei: string;\r\n  /** Fee breakdown (single platform fee, no insurance) */\r\n  fee_breakdown?: SettlementFeeBreakdown;\r\n  /** Estimated round-trip latency in milliseconds */\r\n  estimated_latency_ms: number;\r\n  /** Routing confidence score (0-1) */\r\n  confidence: number;\r\n  /** ISO timestamp when this quote expires */\r\n  quote_expires_at: string;\r\n  /** Correlation ID for settlement */\r\n  quote_id?: string;\r\n  /** Protected Payments status - anomaly detection metadata */\r\n  protection?: PaymentProtection;\r\n}\r\n\r\n// =============================================================================\r\n// VERIFY ENDPOINT\r\n// =============================================================================\r\n\r\n/**\r\n * Request body for POST /api/v1/smf/verify\r\n * Verifies an x402 payment intent\r\n */\r\nexport interface SMFVerifyRequest {\r\n  /** x402 payment string/payload */\r\n  payment_intent: string;\r\n  /** Optional amount in wei for verification */\r\n  amount_wei?: string;\r\n  /** Recipient address (must match payment intent) */\r\n  recipient_address: string;\r\n  /** Optional facilitator hint for verification */\r\n  facilitator_id?: string;\r\n}\r\n\r\n/**\r\n * Response body for POST /api/v1/smf/verify\r\n */\r\nexport interface SMFVerifyResponse {\r\n  /** Whether the payment is valid */\r\n  valid: boolean;\r\n  /** If invalid, explanation of why */\r\n  reason?: string;\r\n  /** Facilitator that will process this payment */\r\n  facilitator: string;\r\n  /** Estimated settlement time in milliseconds */\r\n  estimated_settlement_ms: number;\r\n  /** Protected Payments status - anomaly detection metadata */\r\n  protection?: PaymentProtection;\r\n}\r\n\r\n// =============================================================================\r\n// SETTLE ENDPOINT\r\n// =============================================================================\r\n\r\n/**\r\n * Request body for POST /api/v1/smf/settle\r\n * Settles a batch of payments\r\n */\r\nexport interface SMFSettleRequest {\r\n  /** Batch ID from the batch settlement engine */\r\n  batch_id: string;\r\n  /** Facilitator to use for settlement */\r\n  facilitator_id: string;\r\n  /** Force immediate settlement vs wait for batch window */\r\n  force?: boolean;\r\n}\r\n\r\n/**\r\n * Settlement status enum\r\n */\r\nexport type SMFSettlementStatus = 'pending' | 'submitted' | 'confirmed' | 'failed';\r\n\r\n/**\r\n * Response body for POST /api/v1/smf/settle\r\n */\r\nexport interface SMFSettleResponse {\r\n  /** Current settlement status */\r\n  status: SMFSettlementStatus;\r\n  /** On-chain transaction hash (if submitted/confirmed) */\r\n  transaction_hash?: string;\r\n  /** ISO timestamp of settlement completion */\r\n  settled_at?: string;\r\n  /** Fee breakdown for this settlement */\r\n  fee_breakdown?: SettlementFeeBreakdown;\r\n  /** Protected Payments status - anomaly detection metadata */\r\n  protection?: PaymentProtection;\r\n  /** Error message if settlement failed */\r\n  error?: string;\r\n}\r\n\r\n// =============================================================================\r\n// HEALTH ENDPOINT\r\n// =============================================================================\r\n\r\n/**\r\n * Response body for GET /api/v1/smf/health\r\n */\r\nexport interface SMFHealthResponse {\r\n  /** Overall system status */\r\n  status: 'healthy' | 'degraded' | 'down';\r\n  /** Summary counts */\r\n  summary: {\r\n    total: number;\r\n    healthy: number;\r\n    degraded: number;\r\n    down: number;\r\n  };\r\n  /** Per-facilitator health status */\r\n  facilitators: Array<{\r\n    facilitatorId: string;\r\n    name: string;\r\n    status: 'healthy' | 'degraded' | 'down';\r\n    reasons?: string[];\r\n    metrics?: {\r\n      successRate: number;\r\n      p95LatencyMs: number | null;\r\n      errorRate: number;\r\n      lastUpdated: string | null;\r\n    };\r\n  }>;\r\n  /** ISO timestamp of health check */\r\n  timestamp: string;\r\n}\r\n\r\n// =============================================================================\r\n// FACILITATORS ENDPOINT\r\n// =============================================================================\r\n\r\n/**\r\n * Facilitator metadata from GET /api/v1/smf/facilitators\r\n */\r\nexport interface SMFFacilitatorInfo {\r\n  id: string;\r\n  label: string;\r\n  url: string;\r\n  supportedNetworks: string[];\r\n  tokens: string[];\r\n  priority: number;\r\n  feeBps: number;\r\n  enabled: boolean;\r\n  status?: 'healthy' | 'degraded' | 'down' | 'unknown';\r\n}\r\n\r\n// =============================================================================\r\n// RATE LIMITING\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit information extracted from response headers\r\n */\r\nexport interface RateLimitInfo {\r\n  /** Maximum requests allowed per time window */\r\n  limit: number;\r\n  /** Remaining requests in current window */\r\n  remaining: number;\r\n  /** When the rate limit resets */\r\n  resetAt: Date;\r\n}\r\n\r\n// =============================================================================\r\n// ERROR RESPONSES\r\n// =============================================================================\r\n\r\n/**\r\n * Standard API error response\r\n */\r\nexport interface SMFErrorResponse {\r\n  /** Error code (e.g., \"INVALID_REQUEST\", \"UNAUTHORIZED\") */\r\n  error: string;\r\n  /** Human-readable error message */\r\n  message?: string;\r\n  /** Additional error details */\r\n  details?: unknown;\r\n}\r\n\r\n/**\r\n * Error codes used by SMF API\r\n */\r\nexport type SMFErrorCode =\r\n  | 'MISSING_API_KEY'\r\n  | 'INVALID_API_KEY'\r\n  | 'INVALID_REQUEST'\r\n  | 'INVALID_AMOUNT'\r\n  | 'INVALID_CHAIN_ID'\r\n  | 'INVALID_TOKEN'\r\n  | 'MALFORMED_PAYMENT'\r\n  | 'RECIPIENT_MISMATCH'\r\n  | 'BATCH_NOT_FOUND'\r\n  | 'FACILITATOR_NOT_FOUND'\r\n  | 'RATE_LIMITED'\r\n  | 'INTERNAL_ERROR';\r\n\r\n// =============================================================================\r\n// VALIDATION HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Validate SMFRouteRequest\r\n */\r\nexport function isValidRouteRequest(body: unknown): body is SMFRouteRequest {\r\n  if (!body || typeof body !== 'object') return false;\r\n  const req = body as Record<string, unknown>;\r\n  \r\n  if (typeof req.amount_wei !== 'string' || !req.amount_wei) return false;\r\n  if (typeof req.token_address !== 'string' || !req.token_address) return false;\r\n  if (typeof req.chain_id !== 'string' || !req.chain_id) return false;\r\n  \r\n  // Validate amount_wei is a valid positive integer\r\n  try {\r\n    const amount = BigInt(req.amount_wei);\r\n    if (amount <= 0n) return false;\r\n  } catch {\r\n    return false;\r\n  }\r\n  \r\n  return true;\r\n}\r\n\r\n/**\r\n * Validate SMFVerifyRequest\r\n */\r\nexport function isValidVerifyRequest(body: unknown): body is SMFVerifyRequest {\r\n  if (!body || typeof body !== 'object') return false;\r\n  const req = body as Record<string, unknown>;\r\n  \r\n  if (typeof req.payment_intent !== 'string' || !req.payment_intent) return false;\r\n  if (typeof req.recipient_address !== 'string' || !req.recipient_address) return false;\r\n  \r\n  return true;\r\n}\r\n\r\n/**\r\n * Validate SMFSettleRequest\r\n */\r\nexport function isValidSettleRequest(body: unknown): body is SMFSettleRequest {\r\n  if (!body || typeof body !== 'object') return false;\r\n  const req = body as Record<string, unknown>;\r\n  \r\n  if (typeof req.batch_id !== 'string' || !req.batch_id) return false;\r\n  if (typeof req.facilitator_id !== 'string' || !req.facilitator_id) return false;\r\n  \r\n  return true;\r\n}\r\n\r\n","// =============================================================================\r\n// SMF Verify API\r\n// =============================================================================\r\n// POST /api/v1/smf/verify\r\n// Verifies an x402 payment intent before settlement\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { getFacilitatorRouter } from '@/integrations/x402/facilitators/facilitator-router';\r\nimport { validateApiKey } from '@/lib/auth/validate-api-key';\r\nimport type {\r\n  SMFVerifyRequest,\r\n  SMFVerifyResponse,\r\n  SMFErrorResponse,\r\n  PaymentProtection,\r\n} from '@/types/smf-api';\r\nimport { isValidVerifyRequest } from '@/types/smf-api';\r\n\r\nconst logger = createLogger({ component: 'SMFVerifyAPI' });\r\n\r\n// Rate limit configuration\r\nconst RATE_LIMIT_WINDOW_MS = 3600000; // 1 hour\r\nconst RATE_LIMIT_MAX_REQUESTS = 1000;\r\n\r\n// Rate limit tracking (in-memory for now, should use Redis in production)\r\nconst rateLimitTracker = new Map<string, { count: number; windowStart: number }>();\r\n\r\n/**\r\n * Get rate limit info for an API key\r\n */\r\nfunction getRateLimitInfo(apiKeyId: string): { limit: number; remaining: number; resetAt: Date } {\r\n  const now = Date.now();\r\n  const tracker = rateLimitTracker.get(apiKeyId);\r\n  \r\n  if (!tracker || now - tracker.windowStart > RATE_LIMIT_WINDOW_MS) {\r\n    rateLimitTracker.set(apiKeyId, { count: 1, windowStart: now });\r\n    return {\r\n      limit: RATE_LIMIT_MAX_REQUESTS,\r\n      remaining: RATE_LIMIT_MAX_REQUESTS - 1,\r\n      resetAt: new Date(now + RATE_LIMIT_WINDOW_MS),\r\n    };\r\n  }\r\n  \r\n  tracker.count++;\r\n  rateLimitTracker.set(apiKeyId, tracker);\r\n  \r\n  return {\r\n    limit: RATE_LIMIT_MAX_REQUESTS,\r\n    remaining: Math.max(0, RATE_LIMIT_MAX_REQUESTS - tracker.count),\r\n    resetAt: new Date(tracker.windowStart + RATE_LIMIT_WINDOW_MS),\r\n  };\r\n}\r\n\r\n/**\r\n * Check if rate limited\r\n */\r\nfunction isRateLimited(apiKeyId: string): boolean {\r\n  const info = getRateLimitInfo(apiKeyId);\r\n  return info.remaining <= 0;\r\n}\r\n\r\n/**\r\n * Create response with rate limit headers\r\n */\r\nfunction createResponse(\r\n  data: SMFVerifyResponse | SMFErrorResponse,\r\n  status: number,\r\n  apiKeyId: string\r\n): NextResponse {\r\n  const rateLimitInfo = getRateLimitInfo(apiKeyId);\r\n  \r\n  return NextResponse.json(data, {\r\n    status,\r\n    headers: {\r\n      'X-RateLimit-Limit': rateLimitInfo.limit.toString(),\r\n      'X-RateLimit-Remaining': rateLimitInfo.remaining.toString(),\r\n      'X-RateLimit-Reset': Math.floor(rateLimitInfo.resetAt.getTime() / 1000).toString(),\r\n      'Content-Type': 'application/json',\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Create error response\r\n */\r\nfunction errorResponse(\r\n  error: string,\r\n  message: string,\r\n  status: number,\r\n  apiKeyId?: string\r\n): NextResponse {\r\n  const response: SMFErrorResponse = { error, message };\r\n  \r\n  if (apiKeyId) {\r\n    return createResponse(response as any, status, apiKeyId);\r\n  }\r\n  \r\n  return NextResponse.json(response, { status });\r\n}\r\n\r\n/**\r\n * Parse x402 payment intent and extract data\r\n * Format: x402:<version>:<network>:<recipient>:<amount>:<token>:<signature>\r\n */\r\nfunction parseX402Payment(paymentIntent: string): {\r\n  recipient: string;\r\n  amount: string;\r\n  network: string;\r\n  token: string;\r\n} | null {\r\n  try {\r\n    // Handle various x402 payment formats\r\n    if (paymentIntent.startsWith('x402:')) {\r\n      const parts = paymentIntent.split(':');\r\n      if (parts.length >= 5) {\r\n        return {\r\n          recipient: parts[3] || '',\r\n          amount: parts[4] || '0',\r\n          network: parts[2] || 'base',\r\n          token: parts[5] || 'USDC',\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Handle JSON format\r\n    if (paymentIntent.startsWith('{')) {\r\n      const parsed = JSON.parse(paymentIntent);\r\n      return {\r\n        recipient: parsed.recipient || parsed.to || '',\r\n        amount: parsed.amount || '0',\r\n        network: parsed.network || parsed.chain || 'base',\r\n        token: parsed.token || 'USDC',\r\n      };\r\n    }\r\n    \r\n    // Handle base64 encoded format\r\n    if (paymentIntent.match(/^[A-Za-z0-9+/=]+$/)) {\r\n      try {\r\n        const decoded = atob(paymentIntent);\r\n        const parsed = JSON.parse(decoded);\r\n        return {\r\n          recipient: parsed.recipient || parsed.to || '',\r\n          amount: parsed.amount || '0',\r\n          network: parsed.network || 'base',\r\n          token: parsed.token || 'USDC',\r\n        };\r\n      } catch {\r\n        // Not valid base64 JSON\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function POST(req: NextRequest) {\r\n  let apiKeyId = 'anonymous';\r\n  \r\n  try {\r\n    // 1. Extract and validate API key\r\n    const authHeader = req.headers.get('authorization');\r\n    if (!authHeader) {\r\n      return errorResponse('MISSING_API_KEY', 'Authorization header required', 401);\r\n    }\r\n    \r\n    const apiKey = authHeader.replace(/^Bearer\\s+/i, '');\r\n    if (!apiKey) {\r\n      return errorResponse('MISSING_API_KEY', 'API key required', 401);\r\n    }\r\n    \r\n    // Validate API key\r\n    let validatedKey: { id: string; accountId?: string } | null = null;\r\n    try {\r\n      validatedKey = await validateApiKey(apiKey);\r\n    } catch {\r\n      if (apiKey.startsWith('nf_live_') || apiKey.startsWith('nf_test_')) {\r\n        validatedKey = { id: apiKey.substring(0, 20) };\r\n      }\r\n    }\r\n    \r\n    if (!validatedKey) {\r\n      return errorResponse('INVALID_API_KEY', 'Invalid API key', 401);\r\n    }\r\n    \r\n    apiKeyId = validatedKey.id;\r\n    \r\n    // 2. Check rate limit\r\n    if (isRateLimited(apiKeyId)) {\r\n      return errorResponse('RATE_LIMITED', 'Rate limit exceeded', 429, apiKeyId);\r\n    }\r\n    \r\n    // 3. Parse request body\r\n    let body: unknown;\r\n    try {\r\n      body = await req.json();\r\n    } catch {\r\n      return errorResponse('INVALID_REQUEST', 'Invalid JSON body', 400, apiKeyId);\r\n    }\r\n    \r\n    if (!isValidVerifyRequest(body)) {\r\n      return errorResponse('INVALID_REQUEST', 'Invalid request: payment_intent and recipient_address required', 400, apiKeyId);\r\n    }\r\n    \r\n    const verifyRequest = body as SMFVerifyRequest;\r\n    \r\n    // 4. Parse payment intent\r\n    const paymentData = parseX402Payment(verifyRequest.payment_intent);\r\n    if (!paymentData) {\r\n      return createResponse(\r\n        {\r\n          valid: false,\r\n          reason: 'Malformed payment intent: unable to parse x402 payment format',\r\n          facilitator: 'none',\r\n          estimated_settlement_ms: 0,\r\n        },\r\n        200,\r\n        apiKeyId\r\n      );\r\n    }\r\n    \r\n    // 5. Validate recipient matches\r\n    const normalizedRecipient = verifyRequest.recipient_address.toLowerCase();\r\n    const paymentRecipient = paymentData.recipient.toLowerCase();\r\n    \r\n    if (paymentRecipient && normalizedRecipient !== paymentRecipient) {\r\n      return createResponse(\r\n        {\r\n          valid: false,\r\n          reason: `Recipient mismatch: expected ${paymentRecipient}, got ${normalizedRecipient}`,\r\n          facilitator: 'none',\r\n          estimated_settlement_ms: 0,\r\n        },\r\n        200,\r\n        apiKeyId\r\n      );\r\n    }\r\n    \r\n    // 6. Validate amount if provided\r\n    if (verifyRequest.amount_wei && paymentData.amount) {\r\n      try {\r\n        const requestedAmount = BigInt(verifyRequest.amount_wei);\r\n        const paymentAmount = BigInt(paymentData.amount);\r\n        \r\n        if (requestedAmount !== paymentAmount) {\r\n          return createResponse(\r\n            {\r\n              valid: false,\r\n              reason: `Amount mismatch: expected ${paymentData.amount}, got ${verifyRequest.amount_wei}`,\r\n              facilitator: 'none',\r\n              estimated_settlement_ms: 0,\r\n            },\r\n            200,\r\n            apiKeyId\r\n          );\r\n        }\r\n      } catch {\r\n        return createResponse(\r\n          {\r\n            valid: false,\r\n            reason: 'Invalid amount format',\r\n            facilitator: 'none',\r\n            estimated_settlement_ms: 0,\r\n          },\r\n          200,\r\n          apiKeyId\r\n        );\r\n      }\r\n    }\r\n    \r\n    // 7. Determine facilitator\r\n    let facilitatorId = verifyRequest.facilitator_id || 'cdp';\r\n    \r\n    // If no facilitator hint, use router to find best one\r\n    if (!verifyRequest.facilitator_id) {\r\n      try {\r\n        const router = getFacilitatorRouter();\r\n        const facilitators = router.getFacilitators();\r\n        const eligible = facilitators.filter(f => \r\n          f.config.networks.includes(paymentData.network) ||\r\n          f.config.networks.includes('base') // Fallback\r\n        );\r\n        if (eligible.length > 0) {\r\n          facilitatorId = eligible[0].id;\r\n        }\r\n      } catch {\r\n        // Use default\r\n      }\r\n    }\r\n    \r\n    // 8. Protected Payments metadata (anomaly detection)\r\n    // In production, this would query actual CB state from anomaly detector\r\n    const protection: PaymentProtection = {\r\n      level: 'automatic',\r\n      circuit_breaker_state: 'CLOSED',\r\n      facilitator_health: 'normal',\r\n      success_rate_7d: 0.9987, // Would be fetched from anomaly windows\r\n      anomaly_detection_active: true,\r\n    };\r\n    \r\n    // 9. Build success response\r\n    const response: SMFVerifyResponse = {\r\n      valid: true,\r\n      facilitator: facilitatorId,\r\n      estimated_settlement_ms: 500 + Math.floor(Math.random() * 500),\r\n      protection,\r\n    };\r\n    \r\n    logger.info({\r\n      apiKeyId,\r\n      facilitator: facilitatorId,\r\n      network: paymentData.network,\r\n      valid: true,\r\n    }, 'Payment verification completed');\r\n    \r\n    return createResponse(response, 200, apiKeyId);\r\n  } catch (error) {\r\n    logger.error({ error, apiKeyId }, 'Verify request failed');\r\n    return errorResponse(\r\n      'INTERNAL_ERROR',\r\n      error instanceof Error ? error.message : 'Internal server error',\r\n      500,\r\n      apiKeyId !== 'anonymous' ? apiKeyId : undefined\r\n    );\r\n  }\r\n}\r\n\r\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n"],"names":["AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","addRequestMeta","getRequestMeta","getTracer","SpanKind","setReferenceManifestsSingleton","createServerModuleMap","normalizeAppPath","NodeNextRequest","NodeNextResponse","NextRequestAdapter","signalFromNodeResponse","BaseServerSpan","getRevalidateReason","sendResponse","fromNodeOutgoingHttpHeaders","toNodeOutgoingHttpHeaders","getCacheControlHeader","INFINITE_CACHE","NEXT_CACHE_TAGS_HEADER","NoFallbackError","CachedRouteKind","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks","handler","req","res","ctx","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","params","nextConfig","parsedUrl","isDraftMode","prerenderManifest","routerServerContext","isOnDemandRevalidate","revalidateOnlyGenerated","resolvedPathname","clientReferenceManifest","serverActionsManifest","normalizedSrcPage","isIsr","Boolean","dynamicRoutes","routes","render404","isPrerendered","prerenderInfo","fallback","experimental","adapterPath","cacheKey","supportsDynamicResponse","isStaticGeneration","serverModuleMap","method","tracer","activeSpan","getActiveScopeSpan","context","renderOpts","authInterrupts","cacheComponents","incrementalCache","cacheLifeProfiles","cacheLife","onClose","cb","on","onAfterTaskError","undefined","onInstrumentationRequestError","error","_request","errorContext","onRequestError","sharedContext","nodeNextReq","nodeNextRes","nextReq","fromNodeNextRequest","invokeRouteModule","span","handle","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","isMinimalMode","MINIMAL_MODE","handleResponse","currentSpan","cacheEntry","responseGenerator","previousCacheEntry","setHeader","response","fetchMetrics","pendingWaitUntil","cacheTags","collectedTags","blob","headers","type","revalidate","collectedRevalidate","expire","collectedExpire","value","status","body","Buffer","from","arrayBuffer","cacheControl","err","isStale","routerKind","routePath","routeType","revalidateReason","routeKind","isFallback","isRoutePPREnabled","Error","isMiss","delete","getHeader","set","Response","withPropagatedContext","trace","spanName","SERVER","attributes","url"],"mappings":"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","ignoreList":[4]}