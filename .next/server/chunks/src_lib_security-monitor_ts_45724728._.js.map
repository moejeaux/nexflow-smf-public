{"version":3,"sources":["../../../src/lib/security-monitor.ts"],"sourcesContent":["// =============================================================================\r\n// SECURITY MONITORING & THREAT DETECTION\r\n// =============================================================================\r\n// Real-time security monitoring and threat detection for all requests\r\n// Implements agent-based security scanning for all in/out traffic\r\n//\r\n// Configuration (environment variables):\r\n// - SECURITY_SHADOW_MODE: 'true' (default) = log-only, 'false' = enforce\r\n// - SECURITY_ENFORCE_SQL_INJECTION: 'true' = block SQL injection attempts\r\n// - SECURITY_ENFORCE_XSS: 'true' = block XSS attempts\r\n// - SECURITY_ENFORCE_PATH_TRAVERSAL: 'true' = block path traversal\r\n// - SECURITY_ENFORCE_COMMAND_INJECTION: 'true' = block command injection\r\n// - SECURITY_ENFORCE_AUTH_BYPASS: 'true' = block auth bypass attempts\r\n// - SECURITY_VIOLATION_THRESHOLD: Number of violations before auto-block (default: 10)\r\n// - SECURITY_VIOLATION_WINDOW_MS: Time window for violations (default: 300000 = 5min)\r\n// - SECURITY_MAX_BLOCKS_PER_HOUR: Safety cap (default: 100)\r\n// - SECURITY_MAX_BLOCKS_PER_DAY: Safety cap (default: 1000)\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'SecurityMonitor' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface SecurityEvent {\r\n  type: 'threat' | 'suspicious' | 'anomaly' | 'violation';\r\n  severity: 'critical' | 'high' | 'medium' | 'low';\r\n  category: string;\r\n  description: string;\r\n  requestId: string;\r\n  ip: string;\r\n  path: string;\r\n  method: string;\r\n  userAgent?: string;\r\n  details?: Record<string, any>;\r\n  timestamp: string;\r\n  // Correlation fields for full traceability\r\n  conversationId?: string;\r\n  agentId?: string;\r\n  x402TxHash?: string;\r\n  failureCode?: string;\r\n  // Shadow mode tracking\r\n  wouldHaveBlocked?: boolean;\r\n}\r\n\r\nexport interface SecurityScanResult {\r\n  safe: boolean;\r\n  threats: SecurityEvent[];\r\n  riskScore: number; // 0-100\r\n  recommendations: string[];\r\n  // Shadow mode info\r\n  shadowMode: boolean;\r\n  wouldBlock: boolean;\r\n}\r\n\r\nexport interface SecurityMetrics {\r\n  // Threat counts by category\r\n  threatsByCategory: Record<string, number>;\r\n  // Shadow mode metrics\r\n  shadowModeStats: {\r\n    enabled: boolean;\r\n    wouldHaveBlocked: number;\r\n    totalScanned: number;\r\n    blockedCategories: Record<string, number>;\r\n  };\r\n  // Enforcement stats\r\n  enforcementStats: {\r\n    blocked: number;\r\n    allowed: number;\r\n    byCategory: Record<string, { blocked: number; allowed: number }>;\r\n  };\r\n  // Violation rate limiting\r\n  violationRateLimiting: {\r\n    ipsRateLimited: number;\r\n    violationsInWindow: number;\r\n  };\r\n  // Time period\r\n  since: string;\r\n}\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\n// Global shadow mode (master switch)\r\nconst SHADOW_MODE_ENABLED = process.env.SECURITY_SHADOW_MODE !== 'false'; // Default to true for safety\r\n\r\n// Per-category enforcement flags (granular control)\r\nconst ENFORCEMENT_FLAGS = {\r\n  sql_injection: process.env.SECURITY_ENFORCE_SQL_INJECTION === 'true',\r\n  xss: process.env.SECURITY_ENFORCE_XSS === 'true',\r\n  path_traversal: process.env.SECURITY_ENFORCE_PATH_TRAVERSAL === 'true',\r\n  command_injection: process.env.SECURITY_ENFORCE_COMMAND_INJECTION === 'true',\r\n  auth_bypass: process.env.SECURITY_ENFORCE_AUTH_BYPASS === 'true',\r\n  suspicious_user_agent: process.env.SECURITY_ENFORCE_SUSPICIOUS_UA === 'true',\r\n  suspicious_path: process.env.SECURITY_ENFORCE_SUSPICIOUS_PATH === 'true',\r\n  missing_auth: false, // Always shadow mode - too many false positives\r\n};\r\n\r\n// Violation-based rate limiting\r\nconst VIOLATION_THRESHOLD = parseInt(process.env.SECURITY_VIOLATION_THRESHOLD || '10', 10);\r\nconst VIOLATION_WINDOW_MS = parseInt(process.env.SECURITY_VIOLATION_WINDOW_MS || '300000', 10); // 5 minutes\r\n\r\n// Safety caps to prevent mass blocking\r\nconst MAX_BLOCKS_PER_HOUR = parseInt(process.env.SECURITY_MAX_BLOCKS_PER_HOUR || '100', 10);\r\nconst MAX_BLOCKS_PER_DAY = parseInt(process.env.SECURITY_MAX_BLOCKS_PER_DAY || '1000', 10);\r\n\r\n// =============================================================================\r\n// IN-MEMORY STORES\r\n// =============================================================================\r\n\r\n// Threat store (upgrade to Redis in production)\r\nconst threatStore = new Map<string, {\r\n  count: number;\r\n  firstSeen: number;\r\n  lastSeen: number;\r\n  events: SecurityEvent[];\r\n}>();\r\n\r\n// Violation rate limiting store\r\nconst violationStore = new Map<string, {\r\n  violations: number;\r\n  windowStart: number;\r\n  blocked: boolean;\r\n}>();\r\n\r\n// Track blocks per time window\r\nconst blocksThisHour = new Map<string, number>();\r\nconst blocksThisDay = new Map<string, number>();\r\n\r\n// Shadow mode metrics\r\nconst shadowModeMetrics = {\r\n  startTime: Date.now(),\r\n  totalScanned: 0,\r\n  wouldHaveBlocked: 0,\r\n  blockedByCategory: new Map<string, number>(),\r\n  actuallyBlocked: 0,\r\n  actuallyAllowed: 0,\r\n  threatsByCategory: new Map<string, number>(),\r\n};\r\n\r\n// =============================================================================\r\n// CLEANUP INTERVALS\r\n// =============================================================================\r\n\r\n// Cleanup block counters every hour\r\nsetInterval(() => {\r\n  blocksThisHour.clear();\r\n}, 60 * 60 * 1000);\r\n\r\n// Cleanup daily block counters every day\r\nsetInterval(() => {\r\n  blocksThisDay.clear();\r\n}, 24 * 60 * 60 * 1000);\r\n\r\n// Cleanup old threats every 10 minutes\r\nsetInterval(() => {\r\n  const now = Date.now();\r\n  const maxAge = 24 * 60 * 60 * 1000; // 24 hours\r\n  const keysToDelete: string[] = [];\r\n  \r\n  threatStore.forEach((value, key) => {\r\n    if (now - value.lastSeen > maxAge) {\r\n      keysToDelete.push(key);\r\n    }\r\n  });\r\n  \r\n  keysToDelete.forEach(key => threatStore.delete(key));\r\n}, 10 * 60 * 1000);\r\n\r\n// Cleanup violation store every 10 minutes\r\nsetInterval(() => {\r\n  const now = Date.now();\r\n  const keysToDelete: string[] = [];\r\n  \r\n  violationStore.forEach((value, key) => {\r\n    if (now - value.windowStart > VIOLATION_WINDOW_MS * 2) {\r\n      keysToDelete.push(key);\r\n    }\r\n  });\r\n  \r\n  keysToDelete.forEach(key => violationStore.delete(key));\r\n}, 10 * 60 * 1000);\r\n\r\n/**\r\n * SQL Injection Detection Patterns\r\n */\r\nconst SQL_INJECTION_PATTERNS = [\r\n  /(\\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|EXECUTE|UNION|SCRIPT)\\b)/i,\r\n  /('|\\\\'|;|--|\\/\\*|\\*\\/|\\+|%)/i,\r\n  /(\\bOR\\b.*=.*)/i,\r\n  /(\\bAND\\b.*=.*)/i,\r\n  /(\\bUNION\\b.*SELECT)/i,\r\n];\r\n\r\n/**\r\n * XSS Detection Patterns\r\n */\r\nconst XSS_PATTERNS = [\r\n  /<script[^>]*>.*?<\\/script>/gi,\r\n  /javascript:/i,\r\n  /on\\w+\\s*=/i, // onclick=, onerror=, etc.\r\n  /<iframe[^>]*>/gi,\r\n  /<img[^>]*src[^>]*javascript:/i,\r\n  /<svg[^>]*onload/i,\r\n];\r\n\r\n/**\r\n * Path Traversal Patterns\r\n */\r\nconst PATH_TRAVERSAL_PATTERNS = [\r\n  /\\.\\.\\//g,\r\n  /\\.\\.\\\\/g,\r\n  /\\.\\.%2F/i,\r\n  /\\.\\.%5C/i,\r\n  /%2e%2e%2f/i,\r\n  /%2e%2e%5c/i,\r\n];\r\n\r\n/**\r\n * Command Injection Patterns\r\n */\r\nconst COMMAND_INJECTION_PATTERNS = [\r\n  /[;&|`$(){}[\\]]/,\r\n  /\\b(cat|ls|pwd|whoami|id|uname|ps|kill|rm|mv|cp)\\b/i,\r\n  /\\|\\s*(nc|netcat|wget|curl|bash|sh)/i,\r\n];\r\n\r\n/**\r\n * Suspicious User Agent Patterns\r\n */\r\nconst SUSPICIOUS_USER_AGENTS = [\r\n  /sqlmap/i,\r\n  /nikto/i,\r\n  /nmap/i,\r\n  /masscan/i,\r\n  /zap/i,\r\n  /burp/i,\r\n  /scanner/i,\r\n  /bot.*crawler/i,\r\n];\r\n\r\n/**\r\n * Rate Limit Violation Thresholds\r\n */\r\nconst RATE_LIMIT_THRESHOLDS = {\r\n  critical: 100, // requests per minute\r\n  high: 50,\r\n  medium: 20,\r\n};\r\n\r\n/**\r\n * Scan request for security threats\r\n * Extracts correlation fields (conversation_id, agent_id, x402_tx_hash) from headers\r\n */\r\nexport function scanRequest(request: NextRequest, requestId: string): SecurityScanResult {\r\n  const path = request.nextUrl.pathname;\r\n  \r\n  // Whitelist internal/system endpoints that should not be scanned\r\n  // These are trusted internal endpoints (Vercel cron, health checks, x402 endpoints)\r\n  // x402 endpoints are whitelisted because payment headers contain base64/JSON\r\n  // that triggers false positives for command injection patterns\r\n  const whitelistedPaths = [\r\n    // Vercel cron job endpoints (all internal)\r\n    '/api/cron/', // All cron endpoints (dogfood, scout, probes, pull-metrics, etc.)\r\n    \r\n    // x402 router and verification endpoints\r\n    '/api/x402/router/', // Router execute endpoint (used by agents)\r\n    '/api/x402/verify', // x402 verification endpoint\r\n    '/api/x402/health', // x402 health check\r\n    \r\n    // Health checks\r\n    '/api/health', // Health check endpoint\r\n    \r\n    // Metered and demo x402 endpoints\r\n    '/api/v1/metered/', // All metered x402 endpoints (url-enrich, etc.)\r\n    '/api/v1/x402/', // x402 demo endpoints\r\n    '/api/test/hello-world', // Test endpoint with x402\r\n    \r\n    // Debug endpoints (internal)\r\n    '/api/debug/', // Debug endpoints (smf-facilitators, etc.)\r\n  ];\r\n  \r\n  // Check if path matches any whitelisted path (exact match or prefix match)\r\n  const isWhitelisted = whitelistedPaths.some(whitelisted => \r\n    path === whitelisted || \r\n    path.startsWith(whitelisted) ||  // Handles /api/v1/metered/url-enrich matching /api/v1/metered/\r\n    (whitelisted.endsWith('/') ? path.startsWith(whitelisted) : path.startsWith(whitelisted + '/'))\r\n  );\r\n  \r\n  if (isWhitelisted) {\r\n    // Skip all security scanning for whitelisted paths\r\n    return {\r\n      safe: true,\r\n      threats: [],\r\n      riskScore: 0,\r\n      recommendations: [],\r\n    };\r\n  }\r\n  \r\n  const threats: SecurityEvent[] = [];\r\n  const ip = request.ip || request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';\r\n  const method = request.method;\r\n  const userAgent = request.headers.get('user-agent') || undefined;\r\n  const url = request.nextUrl.toString();\r\n  const queryParams = Object.fromEntries(request.nextUrl.searchParams);\r\n  \r\n  // Extract correlation fields for full traceability\r\n  const conversationId = request.headers.get('x-conversation-id') || \r\n                         request.headers.get('x-request-id') || \r\n                         undefined;\r\n  const agentId = request.headers.get('x-agent-id') || undefined;\r\n  const x402TxHash = request.headers.get('x-x402-tx-hash') || undefined;\r\n  \r\n  // Get request body if available (for POST/PUT/PATCH)\r\n  let bodyText = '';\r\n  try {\r\n    // Note: Body can only be read once, so this is a best-effort scan\r\n    // In production, consider cloning the request for scanning\r\n  } catch {\r\n    // Body not available for scanning\r\n  }\r\n\r\n  // 1. SQL Injection Detection\r\n  const sqlInjectionThreats = detectSQLInjection(url, queryParams, bodyText);\r\n  // Add correlation fields to all threats\r\n  sqlInjectionThreats.forEach(threat => {\r\n    threat.requestId = requestId;\r\n    threat.ip = ip;\r\n    threat.path = path;\r\n    threat.method = method;\r\n    threat.userAgent = userAgent;\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...sqlInjectionThreats);\r\n\r\n  // 2. XSS Detection\r\n  const xssThreats = detectXSS(url, queryParams, bodyText);\r\n  xssThreats.forEach(threat => {\r\n    threat.requestId = requestId;\r\n    threat.ip = ip;\r\n    threat.path = path;\r\n    threat.method = method;\r\n    threat.userAgent = userAgent;\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...xssThreats);\r\n\r\n  // 3. Path Traversal Detection\r\n  const pathTraversalThreats = detectPathTraversal(path, queryParams);\r\n  pathTraversalThreats.forEach(threat => {\r\n    threat.requestId = requestId;\r\n    threat.ip = ip;\r\n    threat.path = path;\r\n    threat.method = method;\r\n    threat.userAgent = userAgent;\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...pathTraversalThreats);\r\n\r\n  // 4. Command Injection Detection\r\n  const commandInjectionThreats = detectCommandInjection(url, queryParams, bodyText);\r\n  commandInjectionThreats.forEach(threat => {\r\n    threat.requestId = requestId;\r\n    threat.ip = ip;\r\n    threat.path = path;\r\n    threat.method = method;\r\n    threat.userAgent = userAgent;\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...commandInjectionThreats);\r\n\r\n  // 5. Suspicious User Agent Detection\r\n  if (userAgent && isSuspiciousUserAgent(userAgent)) {\r\n    threats.push({\r\n      type: 'suspicious',\r\n      severity: 'medium',\r\n      category: 'suspicious_user_agent',\r\n      description: `Suspicious user agent detected: ${userAgent.substring(0, 100)}`,\r\n      requestId,\r\n      ip,\r\n      path,\r\n      method,\r\n      userAgent,\r\n      conversationId,\r\n      agentId,\r\n      x402TxHash,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  }\r\n\r\n  // 6. Unusual Request Pattern Detection\r\n  const anomalyThreats = detectAnomalies(request, requestId);\r\n  anomalyThreats.forEach(threat => {\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...anomalyThreats);\r\n\r\n  // 7. Authentication Bypass Attempts\r\n  const authBypassThreats = detectAuthBypass(request, requestId);\r\n  authBypassThreats.forEach(threat => {\r\n    threat.conversationId = conversationId;\r\n    threat.agentId = agentId;\r\n    threat.x402TxHash = x402TxHash;\r\n  });\r\n  threats.push(...authBypassThreats);\r\n\r\n  // Calculate risk score\r\n  const riskScore = calculateRiskScore(threats);\r\n\r\n  // Generate recommendations\r\n  const recommendations = generateRecommendations(threats, riskScore);\r\n\r\n  // Update metrics\r\n  shadowModeMetrics.totalScanned++;\r\n  \r\n  // Track threats by category\r\n  for (const threat of threats) {\r\n    const currentCount = shadowModeMetrics.threatsByCategory.get(threat.category) || 0;\r\n    shadowModeMetrics.threatsByCategory.set(threat.category, currentCount + 1);\r\n  }\r\n\r\n  // Determine if we would block this request\r\n  const wouldBlock = shouldBlockRequest(threats, ip);\r\n  \r\n  // Track shadow mode \"would have blocked\" metrics\r\n  if (wouldBlock && SHADOW_MODE_ENABLED) {\r\n    shadowModeMetrics.wouldHaveBlocked++;\r\n    for (const threat of threats) {\r\n      const currentCount = shadowModeMetrics.blockedByCategory.get(threat.category) || 0;\r\n      shadowModeMetrics.blockedByCategory.set(threat.category, currentCount + 1);\r\n      threat.wouldHaveBlocked = true;\r\n    }\r\n  }\r\n\r\n  // Log threats\r\n  if (threats.length > 0) {\r\n    logger.warn({\r\n      requestId,\r\n      ip,\r\n      path,\r\n      method,\r\n      threatCount: threats.length,\r\n      riskScore,\r\n      wouldBlock,\r\n      shadowMode: SHADOW_MODE_ENABLED,\r\n      threats: threats.map(t => ({\r\n        type: t.type,\r\n        severity: t.severity,\r\n        category: t.category,\r\n        wouldHaveBlocked: t.wouldHaveBlocked,\r\n      })),\r\n    }, SHADOW_MODE_ENABLED && wouldBlock \r\n      ? 'Security threats detected (SHADOW MODE - would have blocked)' \r\n      : 'Security threats detected');\r\n  }\r\n\r\n  // Store threats for IP tracking\r\n  if (threats.length > 0) {\r\n    storeThreat(ip, threats);\r\n    \r\n    // Track violations for rate limiting\r\n    trackViolation(ip, threats.length);\r\n  }\r\n\r\n  // Track enforcement stats\r\n  if (!SHADOW_MODE_ENABLED && wouldBlock) {\r\n    shadowModeMetrics.actuallyBlocked++;\r\n  } else {\r\n    shadowModeMetrics.actuallyAllowed++;\r\n  }\r\n\r\n  return {\r\n    safe: threats.length === 0,\r\n    threats,\r\n    riskScore,\r\n    recommendations,\r\n    shadowMode: SHADOW_MODE_ENABLED,\r\n    wouldBlock,\r\n  };\r\n}\r\n\r\n/**\r\n * Detect SQL injection attempts\r\n */\r\nfunction detectSQLInjection(url: string, queryParams: Record<string, string>, body: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const textToScan = `${url} ${JSON.stringify(queryParams)} ${body}`;\r\n\r\n  for (const pattern of SQL_INJECTION_PATTERNS) {\r\n    if (pattern.test(textToScan)) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'critical',\r\n        category: 'sql_injection',\r\n        description: 'Potential SQL injection attempt detected',\r\n        requestId: '', // Will be set by caller\r\n        ip: '', // Will be set by caller\r\n        path: '', // Will be set by caller\r\n        method: '', // Will be set by caller\r\n        details: { pattern: pattern.toString(), matched: textToScan.substring(0, 200) },\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Detect XSS attempts\r\n */\r\nfunction detectXSS(url: string, queryParams: Record<string, string>, body: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const textToScan = `${url} ${JSON.stringify(queryParams)} ${body}`;\r\n\r\n  for (const pattern of XSS_PATTERNS) {\r\n    if (pattern.test(textToScan)) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'high',\r\n        category: 'xss',\r\n        description: 'Potential XSS attempt detected',\r\n        requestId: '', // Will be set by caller\r\n        ip: '', // Will be set by caller\r\n        path: '', // Will be set by caller\r\n        method: '', // Will be set by caller\r\n        details: { pattern: pattern.toString() },\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Detect path traversal attempts\r\n */\r\nfunction detectPathTraversal(path: string, queryParams: Record<string, string>): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const textToScan = `${path} ${JSON.stringify(queryParams)}`;\r\n\r\n  for (const pattern of PATH_TRAVERSAL_PATTERNS) {\r\n    if (pattern.test(textToScan)) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'high',\r\n        category: 'path_traversal',\r\n        description: 'Potential path traversal attempt detected',\r\n        requestId: '', // Will be set by caller\r\n        ip: '', // Will be set by caller\r\n        path: '', // Will be set by caller\r\n        method: '', // Will be set by caller\r\n        details: { pattern: pattern.toString() },\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Detect command injection attempts\r\n */\r\nfunction detectCommandInjection(url: string, queryParams: Record<string, string>, body: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const textToScan = `${url} ${JSON.stringify(queryParams)} ${body}`;\r\n\r\n  for (const pattern of COMMAND_INJECTION_PATTERNS) {\r\n    if (pattern.test(textToScan)) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'critical',\r\n        category: 'command_injection',\r\n        description: 'Potential command injection attempt detected',\r\n        requestId: '', // Will be set by caller\r\n        ip: '', // Will be set by caller\r\n        path: '', // Will be set by caller\r\n        method: '', // Will be set by caller\r\n        details: { pattern: pattern.toString() },\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Check if user agent is suspicious\r\n */\r\nfunction isSuspiciousUserAgent(userAgent: string): boolean {\r\n  return SUSPICIOUS_USER_AGENTS.some(pattern => pattern.test(userAgent));\r\n}\r\n\r\n/**\r\n * Detect anomalies in request patterns\r\n */\r\nfunction detectAnomalies(request: NextRequest, requestId: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const ip = request.ip || request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';\r\n  const path = request.nextUrl.pathname;\r\n\r\n  // Check for unusual path patterns\r\n  if (path.includes('admin') || path.includes('config') || path.includes('.env')) {\r\n    threats.push({\r\n      type: 'suspicious',\r\n      severity: 'medium',\r\n      category: 'suspicious_path',\r\n      description: `Suspicious path accessed: ${path}`,\r\n      requestId,\r\n      ip,\r\n      path,\r\n      method: request.method,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  }\r\n\r\n  // Check for missing required headers on sensitive endpoints\r\n  if (path.startsWith('/api/v1/') && !request.headers.get('authorization')) {\r\n    threats.push({\r\n      type: 'violation',\r\n      severity: 'medium',\r\n      category: 'missing_auth',\r\n      description: 'Unauthenticated request to protected endpoint',\r\n      requestId,\r\n      ip,\r\n      path,\r\n      method: request.method,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Detect authentication bypass attempts\r\n */\r\nfunction detectAuthBypass(request: NextRequest, requestId: string): SecurityEvent[] {\r\n  const threats: SecurityEvent[] = [];\r\n  const authHeader = request.headers.get('authorization');\r\n\r\n  // Check for common bypass attempts\r\n  if (authHeader) {\r\n    // Empty token\r\n    if (authHeader.trim() === 'Bearer' || authHeader.trim() === '') {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'high',\r\n        category: 'auth_bypass',\r\n        description: 'Empty authorization token detected',\r\n        requestId,\r\n        ip: request.ip || 'unknown',\r\n        path: request.nextUrl.pathname,\r\n        method: request.method,\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n\r\n    // Suspicious token patterns\r\n    if (authHeader.includes('null') || authHeader.includes('undefined') || authHeader.includes('true')) {\r\n      threats.push({\r\n        type: 'threat',\r\n        severity: 'medium',\r\n        category: 'auth_bypass',\r\n        description: 'Suspicious authorization token pattern',\r\n        requestId,\r\n        ip: request.ip || 'unknown',\r\n        path: request.nextUrl.pathname,\r\n        method: request.method,\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  }\r\n\r\n  return threats;\r\n}\r\n\r\n/**\r\n * Calculate risk score (0-100)\r\n */\r\nfunction calculateRiskScore(threats: SecurityEvent[]): number {\r\n  if (threats.length === 0) return 0;\r\n\r\n  const severityWeights = {\r\n    critical: 25,\r\n    high: 15,\r\n    medium: 8,\r\n    low: 3,\r\n  };\r\n\r\n  let score = 0;\r\n  for (const threat of threats) {\r\n    score += severityWeights[threat.severity];\r\n  }\r\n\r\n  // Cap at 100\r\n  return Math.min(100, score);\r\n}\r\n\r\n/**\r\n * Generate security recommendations\r\n */\r\nfunction generateRecommendations(threats: SecurityEvent[], riskScore: number): string[] {\r\n  const recommendations: string[] = [];\r\n\r\n  if (riskScore >= 50) {\r\n    recommendations.push('Consider blocking this IP address');\r\n    recommendations.push('Review security logs immediately');\r\n  }\r\n\r\n  if (threats.some(t => t.category === 'sql_injection')) {\r\n    recommendations.push('SQL injection attempt detected - ensure parameterized queries are used');\r\n  }\r\n\r\n  if (threats.some(t => t.category === 'xss')) {\r\n    recommendations.push('XSS attempt detected - ensure input sanitization is enabled');\r\n  }\r\n\r\n  if (threats.some(t => t.category === 'command_injection')) {\r\n    recommendations.push('Command injection attempt detected - review system commands');\r\n  }\r\n\r\n  if (threats.some(t => t.category === 'auth_bypass')) {\r\n    recommendations.push('Authentication bypass attempt - review auth middleware');\r\n  }\r\n\r\n  return recommendations;\r\n}\r\n\r\n/**\r\n * Store threat for IP tracking\r\n */\r\nfunction storeThreat(ip: string, threats: SecurityEvent[]): void {\r\n  const existing = threatStore.get(ip);\r\n  const now = Date.now();\r\n\r\n  if (existing) {\r\n    existing.count += threats.length;\r\n    existing.lastSeen = now;\r\n    existing.events.push(...threats);\r\n    // Keep last 100 events per IP\r\n    if (existing.events.length > 100) {\r\n      existing.events = existing.events.slice(-100);\r\n    }\r\n  } else {\r\n    threatStore.set(ip, {\r\n      count: threats.length,\r\n      firstSeen: now,\r\n      lastSeen: now,\r\n      events: [...threats],\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Determine if a request should be blocked based on threats and enforcement settings\r\n */\r\nfunction shouldBlockRequest(threats: SecurityEvent[], ip: string): boolean {\r\n  if (threats.length === 0) return false;\r\n  \r\n  // Check if IP is rate limited due to violations\r\n  if (isIpViolationRateLimited(ip)) {\r\n    return true;\r\n  }\r\n  \r\n  // Check global shadow mode\r\n  if (SHADOW_MODE_ENABLED) {\r\n    // In shadow mode, check if ANY category would have blocked\r\n    // This is for metrics - we won't actually block\r\n    for (const threat of threats) {\r\n      const categoryKey = threat.category as keyof typeof ENFORCEMENT_FLAGS;\r\n      if (ENFORCEMENT_FLAGS[categoryKey]) {\r\n        return true; // Would have blocked\r\n      }\r\n    }\r\n    \r\n    // Also check severity-based blocking\r\n    if (threats.some(t => t.severity === 'critical')) {\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n  \r\n  // Enforcement mode - check per-category flags\r\n  for (const threat of threats) {\r\n    const categoryKey = threat.category as keyof typeof ENFORCEMENT_FLAGS;\r\n    if (ENFORCEMENT_FLAGS[categoryKey]) {\r\n      return true;\r\n    }\r\n  }\r\n  \r\n  // Block on critical severity\r\n  if (threats.some(t => t.severity === 'critical')) {\r\n    return true;\r\n  }\r\n  \r\n  return false;\r\n}\r\n\r\n/**\r\n * Track a violation for rate limiting purposes\r\n */\r\nfunction trackViolation(ip: string, count: number): void {\r\n  const now = Date.now();\r\n  const existing = violationStore.get(ip);\r\n  \r\n  if (existing) {\r\n    // Check if we're still in the same window\r\n    if (now - existing.windowStart < VIOLATION_WINDOW_MS) {\r\n      existing.violations += count;\r\n      \r\n      // Check if threshold exceeded\r\n      if (existing.violations >= VIOLATION_THRESHOLD && !existing.blocked) {\r\n        existing.blocked = true;\r\n        logger.warn({\r\n          ip,\r\n          violations: existing.violations,\r\n          threshold: VIOLATION_THRESHOLD,\r\n          windowMs: VIOLATION_WINDOW_MS,\r\n        }, 'IP rate limited due to security violations');\r\n      }\r\n    } else {\r\n      // Start new window\r\n      violationStore.set(ip, {\r\n        violations: count,\r\n        windowStart: now,\r\n        blocked: false,\r\n      });\r\n    }\r\n  } else {\r\n    violationStore.set(ip, {\r\n      violations: count,\r\n      windowStart: now,\r\n      blocked: false,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Check if an IP is rate limited due to violations\r\n */\r\nfunction isIpViolationRateLimited(ip: string): boolean {\r\n  const record = violationStore.get(ip);\r\n  if (!record) return false;\r\n  \r\n  const now = Date.now();\r\n  \r\n  // Check if still in the rate limit window\r\n  if (now - record.windowStart > VIOLATION_WINDOW_MS) {\r\n    // Window expired, reset\r\n    record.blocked = false;\r\n    record.violations = 0;\r\n    record.windowStart = now;\r\n    return false;\r\n  }\r\n  \r\n  return record.blocked;\r\n}\r\n\r\n/**\r\n * Check if a specific category should be enforced (not in shadow mode)\r\n */\r\nexport function isCategoryEnforced(category: string): boolean {\r\n  if (SHADOW_MODE_ENABLED) return false;\r\n  \r\n  const categoryKey = category as keyof typeof ENFORCEMENT_FLAGS;\r\n  return ENFORCEMENT_FLAGS[categoryKey] ?? false;\r\n}\r\n\r\n/**\r\n * Get current security configuration status\r\n */\r\nexport function getSecurityConfig(): {\r\n  shadowMode: boolean;\r\n  enforcementFlags: Record<string, boolean>;\r\n  violationThreshold: number;\r\n  violationWindowMs: number;\r\n  maxBlocksPerHour: number;\r\n  maxBlocksPerDay: number;\r\n} {\r\n  return {\r\n    shadowMode: SHADOW_MODE_ENABLED,\r\n    enforcementFlags: { ...ENFORCEMENT_FLAGS },\r\n    violationThreshold: VIOLATION_THRESHOLD,\r\n    violationWindowMs: VIOLATION_WINDOW_MS,\r\n    maxBlocksPerHour: MAX_BLOCKS_PER_HOUR,\r\n    maxBlocksPerDay: MAX_BLOCKS_PER_DAY,\r\n  };\r\n}\r\n\r\n/**\r\n * Get threat history for an IP\r\n */\r\nexport function getThreatHistory(ip: string): {\r\n  count: number;\r\n  firstSeen: number;\r\n  lastSeen: number;\r\n  events: SecurityEvent[];\r\n} | null {\r\n  return threatStore.get(ip) || null;\r\n}\r\n\r\n/**\r\n * Check if IP should be blocked\r\n * Implements shadow mode, violation rate limiting, and safety caps\r\n */\r\nexport function shouldBlockIp(ip: string): boolean {\r\n  // Check violation-based rate limiting first (works even in shadow mode if violation threshold exceeded)\r\n  if (isIpViolationRateLimited(ip)) {\r\n    // Still respect shadow mode for actual blocking\r\n    if (SHADOW_MODE_ENABLED) {\r\n      logger.info({ ip }, 'IP would be blocked (violation rate limit) - SHADOW MODE');\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // Shadow mode: log-only, don't block\r\n  if (SHADOW_MODE_ENABLED) {\r\n    return false; // Log-only mode\r\n  }\r\n\r\n  // Safety caps: prevent mass blocking\r\n  const hourCount = blocksThisHour.get(ip) || 0;\r\n  const dayCount = blocksThisDay.get(ip) || 0;\r\n  \r\n  if (hourCount >= MAX_BLOCKS_PER_HOUR) {\r\n    logger.warn({ ip, hourCount }, 'Block cap reached for hour');\r\n    return false; // Cap reached, don't block more\r\n  }\r\n  \r\n  if (dayCount >= MAX_BLOCKS_PER_DAY) {\r\n    logger.warn({ ip, dayCount }, 'Block cap reached for day');\r\n    return false; // Cap reached, don't block more\r\n  }\r\n\r\n  const history = threatStore.get(ip);\r\n  if (!history) return false;\r\n\r\n  // Block if:\r\n  // - More than 10 threats in last hour\r\n  // - Any critical severity threat with enforcement enabled\r\n  const oneHourAgo = Date.now() - 60 * 60 * 1000;\r\n  const recentThreats = history.events.filter(e => \r\n    new Date(e.timestamp).getTime() > oneHourAgo\r\n  );\r\n\r\n  if (recentThreats.length > 10) {\r\n    blocksThisHour.set(ip, hourCount + 1);\r\n    blocksThisDay.set(ip, dayCount + 1);\r\n    return true;\r\n  }\r\n  \r\n  // Check for critical threats with enforcement\r\n  const criticalEnforcedThreats = recentThreats.filter(e => {\r\n    if (e.severity !== 'critical') return false;\r\n    const categoryKey = e.category as keyof typeof ENFORCEMENT_FLAGS;\r\n    return ENFORCEMENT_FLAGS[categoryKey] ?? false;\r\n  });\r\n  \r\n  if (criticalEnforcedThreats.length > 0) {\r\n    blocksThisHour.set(ip, hourCount + 1);\r\n    blocksThisDay.set(ip, dayCount + 1);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Get all blocked IPs\r\n */\r\nexport function getBlockedIps(): string[] {\r\n  const blocked: string[] = [];\r\n  threatStore.forEach((_, ip) => {\r\n    if (shouldBlockIp(ip)) {\r\n      blocked.push(ip);\r\n    }\r\n  });\r\n  return blocked;\r\n}\r\n\r\n/**\r\n * Get IPs that are violation rate-limited\r\n */\r\nexport function getViolationRateLimitedIps(): Array<{\r\n  ip: string;\r\n  violations: number;\r\n  windowStart: number;\r\n}> {\r\n  const rateLimited: Array<{ ip: string; violations: number; windowStart: number }> = [];\r\n  const now = Date.now();\r\n  \r\n  violationStore.forEach((record, ip) => {\r\n    if (record.blocked && now - record.windowStart < VIOLATION_WINDOW_MS) {\r\n      rateLimited.push({\r\n        ip,\r\n        violations: record.violations,\r\n        windowStart: record.windowStart,\r\n      });\r\n    }\r\n  });\r\n  \r\n  return rateLimited;\r\n}\r\n\r\n/**\r\n * Get security metrics for monitoring dashboards\r\n */\r\nexport function getSecurityMetrics(): SecurityMetrics {\r\n  // Convert Map to object for threatsByCategory\r\n  const threatsByCategory: Record<string, number> = {};\r\n  shadowModeMetrics.threatsByCategory.forEach((count, category) => {\r\n    threatsByCategory[category] = count;\r\n  });\r\n  \r\n  // Convert Map to object for blockedByCategory\r\n  const blockedCategories: Record<string, number> = {};\r\n  shadowModeMetrics.blockedByCategory.forEach((count, category) => {\r\n    blockedCategories[category] = count;\r\n  });\r\n  \r\n  // Build per-category enforcement stats\r\n  const byCategory: Record<string, { blocked: number; allowed: number }> = {};\r\n  Object.keys(ENFORCEMENT_FLAGS).forEach(category => {\r\n    const totalForCategory = threatsByCategory[category] || 0;\r\n    const blockedForCategory = blockedCategories[category] || 0;\r\n    byCategory[category] = {\r\n      blocked: blockedForCategory,\r\n      allowed: totalForCategory - blockedForCategory,\r\n    };\r\n  });\r\n  \r\n  // Count rate-limited IPs\r\n  let ipsRateLimited = 0;\r\n  let violationsInWindow = 0;\r\n  const now = Date.now();\r\n  \r\n  violationStore.forEach((record) => {\r\n    if (record.blocked && now - record.windowStart < VIOLATION_WINDOW_MS) {\r\n      ipsRateLimited++;\r\n    }\r\n    if (now - record.windowStart < VIOLATION_WINDOW_MS) {\r\n      violationsInWindow += record.violations;\r\n    }\r\n  });\r\n  \r\n  return {\r\n    threatsByCategory,\r\n    shadowModeStats: {\r\n      enabled: SHADOW_MODE_ENABLED,\r\n      wouldHaveBlocked: shadowModeMetrics.wouldHaveBlocked,\r\n      totalScanned: shadowModeMetrics.totalScanned,\r\n      blockedCategories,\r\n    },\r\n    enforcementStats: {\r\n      blocked: shadowModeMetrics.actuallyBlocked,\r\n      allowed: shadowModeMetrics.actuallyAllowed,\r\n      byCategory,\r\n    },\r\n    violationRateLimiting: {\r\n      ipsRateLimited,\r\n      violationsInWindow,\r\n    },\r\n    since: new Date(shadowModeMetrics.startTime).toISOString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Reset security metrics (for testing)\r\n */\r\nexport function resetSecurityMetrics(): void {\r\n  shadowModeMetrics.startTime = Date.now();\r\n  shadowModeMetrics.totalScanned = 0;\r\n  shadowModeMetrics.wouldHaveBlocked = 0;\r\n  shadowModeMetrics.blockedByCategory.clear();\r\n  shadowModeMetrics.actuallyBlocked = 0;\r\n  shadowModeMetrics.actuallyAllowed = 0;\r\n  shadowModeMetrics.threatsByCategory.clear();\r\n  violationStore.clear();\r\n  threatStore.clear();\r\n  blocksThisHour.clear();\r\n  blocksThisDay.clear();\r\n  logger.info('Security metrics reset');\r\n}\r\n\r\n"],"names":[],"mappings":"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"}