{"version":3,"sources":["../../../node_modules/%40x402/core/dist/esm/chunk-3IUBYRYG.mjs","../../../node_modules/%40x402/core/dist/esm/chunk-BJTO5JO5.mjs","../../../node_modules/%40x402/core/dist/esm/chunk-X4W4S5RB.mjs","../../../node_modules/%40x402/core/dist/esm/chunk-VE37GDG2.mjs","../../../node_modules/%40x402/core/dist/esm/chunk-XT4E3FX4.mjs"],"sourcesContent":["// src/utils/index.ts\nvar findSchemesByNetwork = (map, network) => {\n  let implementationsByScheme = map.get(network);\n  if (!implementationsByScheme) {\n    for (const [registeredNetworkPattern, implementations] of map.entries()) {\n      const pattern = registeredNetworkPattern.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/\\\\\\*/g, \".*\");\n      const regex = new RegExp(`^${pattern}$`);\n      if (regex.test(network)) {\n        implementationsByScheme = implementations;\n        break;\n      }\n    }\n  }\n  return implementationsByScheme;\n};\nvar findByNetworkAndScheme = (map, scheme, network) => {\n  return findSchemesByNetwork(map, network)?.get(scheme);\n};\nvar findFacilitatorBySchemeAndNetwork = (schemeMap, scheme, network) => {\n  const schemeData = schemeMap.get(scheme);\n  if (!schemeData) return void 0;\n  if (schemeData.networks.has(network)) {\n    return schemeData.facilitator;\n  }\n  const patternRegex = new RegExp(\"^\" + schemeData.pattern.replace(\"*\", \".*\") + \"$\");\n  if (patternRegex.test(network)) {\n    return schemeData.facilitator;\n  }\n  return void 0;\n};\nvar Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\nfunction safeBase64Encode(data) {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return globalThis.btoa(data);\n  }\n  return Buffer.from(data).toString(\"base64\");\n}\nfunction safeBase64Decode(data) {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    return globalThis.atob(data);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\nfunction deepEqual(obj1, obj2) {\n  const normalize = (obj) => {\n    if (obj === null || obj === void 0) return JSON.stringify(obj);\n    if (typeof obj !== \"object\") return JSON.stringify(obj);\n    if (Array.isArray(obj)) {\n      return JSON.stringify(\n        obj.map(\n          (item) => typeof item === \"object\" && item !== null ? JSON.parse(normalize(item)) : item\n        )\n      );\n    }\n    const sorted = {};\n    Object.keys(obj).sort().forEach((key) => {\n      const value = obj[key];\n      sorted[key] = typeof value === \"object\" && value !== null ? JSON.parse(normalize(value)) : value;\n    });\n    return JSON.stringify(sorted);\n  };\n  try {\n    return normalize(obj1) === normalize(obj2);\n  } catch {\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\n  }\n}\n\nexport {\n  findSchemesByNetwork,\n  findByNetworkAndScheme,\n  findFacilitatorBySchemeAndNetwork,\n  Base64EncodedRegex,\n  safeBase64Encode,\n  safeBase64Decode,\n  deepEqual\n};\n//# sourceMappingURL=chunk-3IUBYRYG.mjs.map","var __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\nexport {\n  __require\n};\n//# sourceMappingURL=chunk-BJTO5JO5.mjs.map","// src/types/facilitator.ts\nvar VerifyError = class extends Error {\n  /**\n   * Creates a VerifyError from a failed verification response.\n   *\n   * @param statusCode - HTTP status code from the facilitator\n   * @param response - The verify response containing error details\n   */\n  constructor(statusCode, response) {\n    super(`verification failed: ${response.invalidReason || \"unknown reason\"}`);\n    this.name = \"VerifyError\";\n    this.statusCode = statusCode;\n    this.invalidReason = response.invalidReason;\n    this.payer = response.payer;\n  }\n};\nvar SettleError = class extends Error {\n  /**\n   * Creates a SettleError from a failed settlement response.\n   *\n   * @param statusCode - HTTP status code from the facilitator\n   * @param response - The settle response containing error details\n   */\n  constructor(statusCode, response) {\n    super(`settlement failed: ${response.errorReason || \"unknown reason\"}`);\n    this.name = \"SettleError\";\n    this.statusCode = statusCode;\n    this.errorReason = response.errorReason;\n    this.payer = response.payer;\n    this.transaction = response.transaction;\n    this.network = response.network;\n  }\n};\n\nexport {\n  VerifyError,\n  SettleError\n};\n//# sourceMappingURL=chunk-X4W4S5RB.mjs.map","// src/index.ts\nvar x402Version = 2;\n\nexport {\n  x402Version\n};\n//# sourceMappingURL=chunk-VE37GDG2.mjs.map","import {\n  x402Version\n} from \"./chunk-VE37GDG2.mjs\";\nimport {\n  SettleError,\n  VerifyError\n} from \"./chunk-X4W4S5RB.mjs\";\nimport {\n  Base64EncodedRegex,\n  safeBase64Decode,\n  safeBase64Encode\n} from \"./chunk-3IUBYRYG.mjs\";\nimport {\n  __require\n} from \"./chunk-BJTO5JO5.mjs\";\n\n// src/http/x402HTTPResourceServer.ts\nvar RouteConfigurationError = class extends Error {\n  /**\n   * Creates a new RouteConfigurationError with the given validation errors.\n   *\n   * @param errors - The validation errors that caused this exception.\n   */\n  constructor(errors) {\n    const message = `x402 Route Configuration Errors:\n${errors.map((e) => `  - ${e.message}`).join(\"\\n\")}`;\n    super(message);\n    this.name = \"RouteConfigurationError\";\n    this.errors = errors;\n  }\n};\nvar x402HTTPResourceServer = class {\n  /**\n   * Creates a new x402HTTPResourceServer instance.\n   *\n   * @param ResourceServer - The core x402ResourceServer instance to use\n   * @param routes - Route configuration for payment-protected endpoints\n   */\n  constructor(ResourceServer, routes) {\n    this.compiledRoutes = [];\n    this.ResourceServer = ResourceServer;\n    this.routesConfig = routes;\n    const normalizedRoutes = typeof routes === \"object\" && !(\"accepts\" in routes) ? routes : { \"*\": routes };\n    for (const [pattern, config] of Object.entries(normalizedRoutes)) {\n      const parsed = this.parseRoutePattern(pattern);\n      this.compiledRoutes.push({\n        verb: parsed.verb,\n        regex: parsed.regex,\n        config\n      });\n    }\n  }\n  /**\n   * Initialize the HTTP resource server.\n   *\n   * This method initializes the underlying resource server (fetching facilitator support)\n   * and then validates that all route payment configurations have corresponding\n   * registered schemes and facilitator support.\n   *\n   * @throws RouteConfigurationError if any route's payment options don't have\n   *         corresponding registered schemes or facilitator support\n   *\n   * @example\n   * ```typescript\n   * const httpServer = new x402HTTPResourceServer(server, routes);\n   * await httpServer.initialize();\n   * ```\n   */\n  async initialize() {\n    await this.ResourceServer.initialize();\n    const errors = this.validateRouteConfiguration();\n    if (errors.length > 0) {\n      throw new RouteConfigurationError(errors);\n    }\n  }\n  /**\n   * Register a custom paywall provider for generating HTML\n   *\n   * @param provider - PaywallProvider instance\n   * @returns This service instance for chaining\n   */\n  registerPaywallProvider(provider) {\n    this.paywallProvider = provider;\n    return this;\n  }\n  /**\n   * Process HTTP request and return response instructions\n   * This is the main entry point for framework middleware\n   *\n   * @param context - HTTP request context\n   * @param paywallConfig - Optional paywall configuration\n   * @returns Process result indicating next action for middleware\n   */\n  async processHTTPRequest(context, paywallConfig) {\n    const { adapter, path, method } = context;\n    const routeConfig = this.getRouteConfig(path, method);\n    if (!routeConfig) {\n      return { type: \"no-payment-required\" };\n    }\n    const paymentOptions = this.normalizePaymentOptions(routeConfig);\n    const paymentPayload = this.extractPayment(adapter);\n    const resourceInfo = {\n      url: routeConfig.resource || context.adapter.getUrl(),\n      description: routeConfig.description || \"\",\n      mimeType: routeConfig.mimeType || \"\"\n    };\n    const requirements = await this.ResourceServer.buildPaymentRequirementsFromOptions(\n      paymentOptions,\n      context\n    );\n    let extensions = routeConfig.extensions;\n    if (extensions) {\n      extensions = this.ResourceServer.enrichExtensions(extensions, context);\n    }\n    const paymentRequired = this.ResourceServer.createPaymentRequiredResponse(\n      requirements,\n      resourceInfo,\n      !paymentPayload ? \"Payment required\" : void 0,\n      extensions\n    );\n    if (!paymentPayload) {\n      const unpaidBody = routeConfig.unpaidResponseBody ? await routeConfig.unpaidResponseBody(context) : void 0;\n      return {\n        type: \"payment-error\",\n        response: this.createHTTPResponse(\n          paymentRequired,\n          this.isWebBrowser(adapter),\n          paywallConfig,\n          routeConfig.customPaywallHtml,\n          unpaidBody\n        )\n      };\n    }\n    try {\n      const matchingRequirements = this.ResourceServer.findMatchingRequirements(\n        paymentRequired.accepts,\n        paymentPayload\n      );\n      if (!matchingRequirements) {\n        const errorResponse = this.ResourceServer.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"No matching payment requirements\",\n          routeConfig.extensions\n        );\n        return {\n          type: \"payment-error\",\n          response: this.createHTTPResponse(errorResponse, false, paywallConfig)\n        };\n      }\n      const verifyResult = await this.ResourceServer.verifyPayment(\n        paymentPayload,\n        matchingRequirements\n      );\n      if (!verifyResult.isValid) {\n        const errorResponse = this.ResourceServer.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          verifyResult.invalidReason,\n          routeConfig.extensions\n        );\n        return {\n          type: \"payment-error\",\n          response: this.createHTTPResponse(errorResponse, false, paywallConfig)\n        };\n      }\n      return {\n        type: \"payment-verified\",\n        paymentPayload,\n        paymentRequirements: matchingRequirements\n      };\n    } catch (error) {\n      const errorResponse = this.ResourceServer.createPaymentRequiredResponse(\n        requirements,\n        resourceInfo,\n        error instanceof Error ? error.message : \"Payment verification failed\",\n        routeConfig.extensions\n      );\n      return {\n        type: \"payment-error\",\n        response: this.createHTTPResponse(errorResponse, false, paywallConfig)\n      };\n    }\n  }\n  /**\n   * Process settlement after successful response\n   *\n   * @param paymentPayload - The verified payment payload\n   * @param requirements - The matching payment requirements\n   * @returns ProcessSettleResultResponse - SettleResponse with headers if success or errorReason if failure\n   */\n  async processSettlement(paymentPayload, requirements) {\n    try {\n      const settleResponse = await this.ResourceServer.settlePayment(paymentPayload, requirements);\n      if (!settleResponse.success) {\n        return {\n          ...settleResponse,\n          success: false,\n          errorReason: settleResponse.errorReason || \"Settlement failed\"\n        };\n      }\n      return {\n        ...settleResponse,\n        success: true,\n        headers: this.createSettlementHeaders(settleResponse, requirements),\n        requirements\n      };\n    } catch (error) {\n      if (error instanceof SettleError) {\n        return {\n          success: false,\n          errorReason: error.errorReason || error.message,\n          payer: error.payer,\n          network: error.network,\n          transaction: error.transaction\n        };\n      }\n      return {\n        success: false,\n        errorReason: error instanceof Error ? error.message : \"Settlement failed\",\n        network: requirements.network,\n        transaction: \"\"\n      };\n    }\n  }\n  /**\n   * Check if a request requires payment based on route configuration\n   *\n   * @param context - HTTP request context\n   * @returns True if the route requires payment, false otherwise\n   */\n  requiresPayment(context) {\n    const routeConfig = this.getRouteConfig(context.path, context.method);\n    return routeConfig !== void 0;\n  }\n  /**\n   * Normalizes a RouteConfig's accepts field into an array of PaymentOptions\n   * Handles both single PaymentOption and array formats\n   *\n   * @param routeConfig - Route configuration\n   * @returns Array of payment options\n   */\n  normalizePaymentOptions(routeConfig) {\n    return Array.isArray(routeConfig.accepts) ? routeConfig.accepts : [routeConfig.accepts];\n  }\n  /**\n   * Validates that all payment options in routes have corresponding registered schemes\n   * and facilitator support.\n   *\n   * @returns Array of validation errors (empty if all routes are valid)\n   */\n  validateRouteConfiguration() {\n    const errors = [];\n    const normalizedRoutes = typeof this.routesConfig === \"object\" && !(\"accepts\" in this.routesConfig) ? Object.entries(this.routesConfig) : [[\"*\", this.routesConfig]];\n    for (const [pattern, config] of normalizedRoutes) {\n      const paymentOptions = this.normalizePaymentOptions(config);\n      for (const option of paymentOptions) {\n        if (!this.ResourceServer.hasRegisteredScheme(option.network, option.scheme)) {\n          errors.push({\n            routePattern: pattern,\n            scheme: option.scheme,\n            network: option.network,\n            reason: \"missing_scheme\",\n            message: `Route \"${pattern}\": No scheme implementation registered for \"${option.scheme}\" on network \"${option.network}\"`\n          });\n          continue;\n        }\n        const supportedKind = this.ResourceServer.getSupportedKind(\n          x402Version,\n          option.network,\n          option.scheme\n        );\n        if (!supportedKind) {\n          errors.push({\n            routePattern: pattern,\n            scheme: option.scheme,\n            network: option.network,\n            reason: \"missing_facilitator\",\n            message: `Route \"${pattern}\": Facilitator does not support scheme \"${option.scheme}\" on network \"${option.network}\"`\n          });\n        }\n      }\n    }\n    return errors;\n  }\n  /**\n   * Get route configuration for a request\n   *\n   * @param path - Request path\n   * @param method - HTTP method\n   * @returns Route configuration or undefined if no match\n   */\n  getRouteConfig(path, method) {\n    const normalizedPath = this.normalizePath(path);\n    const upperMethod = method.toUpperCase();\n    const matchingRoute = this.compiledRoutes.find(\n      (route) => route.regex.test(normalizedPath) && (route.verb === \"*\" || route.verb === upperMethod)\n    );\n    return matchingRoute?.config;\n  }\n  /**\n   * Extract payment from HTTP headers (handles v1 and v2)\n   *\n   * @param adapter - HTTP adapter\n   * @returns Decoded payment payload or null\n   */\n  extractPayment(adapter) {\n    const header = adapter.getHeader(\"payment-signature\") || adapter.getHeader(\"PAYMENT-SIGNATURE\");\n    if (header) {\n      try {\n        return decodePaymentSignatureHeader(header);\n      } catch (error) {\n        console.warn(\"Failed to decode PAYMENT-SIGNATURE header:\", error);\n      }\n    }\n    return null;\n  }\n  /**\n   * Check if request is from a web browser\n   *\n   * @param adapter - HTTP adapter\n   * @returns True if request appears to be from a browser\n   */\n  isWebBrowser(adapter) {\n    const accept = adapter.getAcceptHeader();\n    const userAgent = adapter.getUserAgent();\n    return accept.includes(\"text/html\") && userAgent.includes(\"Mozilla\");\n  }\n  /**\n   * Create HTTP response instructions from payment required\n   *\n   * @param paymentRequired - Payment requirements\n   * @param isWebBrowser - Whether request is from browser\n   * @param paywallConfig - Paywall configuration\n   * @param customHtml - Custom HTML template\n   * @param unpaidResponse - Optional custom response (content type and body) for unpaid API requests\n   * @returns Response instructions\n   */\n  createHTTPResponse(paymentRequired, isWebBrowser, paywallConfig, customHtml, unpaidResponse) {\n    if (isWebBrowser) {\n      const html = this.generatePaywallHTML(paymentRequired, paywallConfig, customHtml);\n      return {\n        status: 402,\n        headers: { \"Content-Type\": \"text/html\" },\n        body: html,\n        isHtml: true\n      };\n    }\n    const response = this.createHTTPPaymentRequiredResponse(paymentRequired);\n    const contentType = unpaidResponse ? unpaidResponse.contentType : \"application/json\";\n    const body = unpaidResponse ? unpaidResponse.body : {};\n    return {\n      status: 402,\n      headers: {\n        \"Content-Type\": contentType,\n        ...response.headers\n      },\n      body\n    };\n  }\n  /**\n   * Create HTTP payment required response (v1 puts in body, v2 puts in header)\n   *\n   * @param paymentRequired - Payment required object\n   * @returns Headers and body for the HTTP response\n   */\n  createHTTPPaymentRequiredResponse(paymentRequired) {\n    return {\n      headers: {\n        \"PAYMENT-REQUIRED\": encodePaymentRequiredHeader(paymentRequired)\n      }\n    };\n  }\n  /**\n   * Create settlement response headers\n   *\n   * @param settleResponse - Settlement response\n   * @param requirements - Payment requirements that were settled\n   * @returns Headers to add to response\n   */\n  createSettlementHeaders(settleResponse, requirements) {\n    const encoded = encodePaymentResponseHeader({\n      ...settleResponse,\n      requirements\n    });\n    return { \"PAYMENT-RESPONSE\": encoded };\n  }\n  /**\n   * Parse route pattern into verb and regex\n   *\n   * @param pattern - Route pattern like \"GET /api/*\" or \"/api/[id]\"\n   * @returns Parsed pattern with verb and regex\n   */\n  parseRoutePattern(pattern) {\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\n    const regex = new RegExp(\n      `^${path.replace(/[$()+.?^{|}]/g, \"\\\\$&\").replace(/\\*/g, \".*?\").replace(/\\[([^\\]]+)\\]/g, \"[^/]+\").replace(/\\//g, \"\\\\/\")}$`,\n      \"i\"\n    );\n    return { verb: verb.toUpperCase(), regex };\n  }\n  /**\n   * Normalize path for matching\n   *\n   * @param path - Raw path from request\n   * @returns Normalized path\n   */\n  normalizePath(path) {\n    try {\n      const pathWithoutQuery = path.split(/[?#]/)[0];\n      const decodedPath = decodeURIComponent(pathWithoutQuery);\n      return decodedPath.replace(/\\\\/g, \"/\").replace(/\\/+/g, \"/\").replace(/(.+?)\\/+$/, \"$1\");\n    } catch {\n      return path;\n    }\n  }\n  /**\n   * Generate paywall HTML for browser requests\n   *\n   * @param paymentRequired - Payment required response\n   * @param paywallConfig - Optional paywall configuration\n   * @param customHtml - Optional custom HTML template\n   * @returns HTML string\n   */\n  generatePaywallHTML(paymentRequired, paywallConfig, customHtml) {\n    if (customHtml) {\n      return customHtml;\n    }\n    if (this.paywallProvider) {\n      return this.paywallProvider.generateHtml(paymentRequired, paywallConfig);\n    }\n    try {\n      const paywall = __require(\"@x402/paywall\");\n      const displayAmount2 = this.getDisplayAmount(paymentRequired);\n      const resource2 = paymentRequired.resource;\n      return paywall.getPaywallHtml({\n        amount: displayAmount2,\n        paymentRequired,\n        currentUrl: resource2?.url || paywallConfig?.currentUrl || \"\",\n        testnet: paywallConfig?.testnet ?? true,\n        appName: paywallConfig?.appName,\n        appLogo: paywallConfig?.appLogo,\n        sessionTokenEndpoint: paywallConfig?.sessionTokenEndpoint\n      });\n    } catch {\n    }\n    const resource = paymentRequired.resource;\n    const displayAmount = this.getDisplayAmount(paymentRequired);\n    return `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <title>Payment Required</title>\n          <meta charset=\"UTF-8\">\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        </head>\n        <body>\n          <div style=\"max-width: 600px; margin: 50px auto; padding: 20px; font-family: system-ui, -apple-system, sans-serif;\">\n            ${paywallConfig?.appLogo ? `<img src=\"${paywallConfig.appLogo}\" alt=\"${paywallConfig.appName || \"App\"}\" style=\"max-width: 200px; margin-bottom: 20px;\">` : \"\"}\n            <h1>Payment Required</h1>\n            ${resource ? `<p><strong>Resource:</strong> ${resource.description || resource.url}</p>` : \"\"}\n            <p><strong>Amount:</strong> $${displayAmount.toFixed(2)} USDC</p>\n            <div id=\"payment-widget\" \n                 data-requirements='${JSON.stringify(paymentRequired)}'\n                 data-app-name=\"${paywallConfig?.appName || \"\"}\"\n                 data-testnet=\"${paywallConfig?.testnet || false}\">\n              <!-- Install @x402/paywall for full wallet integration -->\n              <p style=\"margin-top: 2rem; padding: 1rem; background: #fef3c7; border-radius: 0.5rem;\">\n                <strong>Note:</strong> Install <code>@x402/paywall</code> for full wallet connection and payment UI.\n              </p>\n            </div>\n          </div>\n        </body>\n      </html>\n    `;\n  }\n  /**\n   * Extract display amount from payment requirements.\n   *\n   * @param paymentRequired - The payment required object\n   * @returns The display amount in decimal format\n   */\n  getDisplayAmount(paymentRequired) {\n    const accepts = paymentRequired.accepts;\n    if (accepts && accepts.length > 0) {\n      const firstReq = accepts[0];\n      if (\"amount\" in firstReq) {\n        return parseFloat(firstReq.amount) / 1e6;\n      }\n    }\n    return 0;\n  }\n};\n\n// src/http/httpFacilitatorClient.ts\nvar DEFAULT_FACILITATOR_URL = \"https://x402.org/facilitator\";\nvar HTTPFacilitatorClient = class {\n  /**\n   * Creates a new HTTPFacilitatorClient instance.\n   *\n   * @param config - Configuration options for the facilitator client\n   */\n  constructor(config) {\n    this.url = config?.url || DEFAULT_FACILITATOR_URL;\n    this._createAuthHeaders = config?.createAuthHeaders;\n  }\n  /**\n   * Verify a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to verify\n   * @param paymentRequirements - The requirements to verify against\n   * @returns Verification response\n   */\n  async verify(paymentPayload, paymentRequirements) {\n    let headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"verify\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n    const response = await fetch(`${this.url}/verify`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        x402Version: paymentPayload.x402Version,\n        paymentPayload: this.toJsonSafe(paymentPayload),\n        paymentRequirements: this.toJsonSafe(paymentRequirements)\n      })\n    });\n    const data = await response.json();\n    if (typeof data === \"object\" && data !== null && \"isValid\" in data) {\n      const verifyResponse = data;\n      if (!response.ok) {\n        throw new VerifyError(response.status, verifyResponse);\n      }\n      return verifyResponse;\n    }\n    throw new Error(`Facilitator verify failed (${response.status}): ${JSON.stringify(data)}`);\n  }\n  /**\n   * Settle a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to settle\n   * @param paymentRequirements - The requirements for settlement\n   * @returns Settlement response\n   */\n  async settle(paymentPayload, paymentRequirements) {\n    let headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"settle\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n    const response = await fetch(`${this.url}/settle`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        x402Version: paymentPayload.x402Version,\n        paymentPayload: this.toJsonSafe(paymentPayload),\n        paymentRequirements: this.toJsonSafe(paymentRequirements)\n      })\n    });\n    const data = await response.json();\n    if (typeof data === \"object\" && data !== null && \"success\" in data) {\n      const settleResponse = data;\n      if (!response.ok) {\n        throw new SettleError(response.status, settleResponse);\n      }\n      return settleResponse;\n    }\n    throw new Error(`Facilitator settle failed (${response.status}): ${JSON.stringify(data)}`);\n  }\n  /**\n   * Get supported payment kinds and extensions from the facilitator\n   *\n   * @returns Supported payment kinds and extensions\n   */\n  async getSupported() {\n    let headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"supported\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n    const response = await fetch(`${this.url}/supported`, {\n      method: \"GET\",\n      headers\n    });\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => response.statusText);\n      throw new Error(`Facilitator getSupported failed (${response.status}): ${errorText}`);\n    }\n    return await response.json();\n  }\n  /**\n   * Creates authentication headers for a specific path.\n   *\n   * @param path - The path to create authentication headers for (e.g., \"verify\", \"settle\", \"supported\")\n   * @returns An object containing the authentication headers for the specified path\n   */\n  async createAuthHeaders(path) {\n    if (this._createAuthHeaders) {\n      const authHeaders = await this._createAuthHeaders();\n      return {\n        headers: authHeaders[path] ?? {}\n      };\n    }\n    return {\n      headers: {}\n    };\n  }\n  /**\n   * Helper to convert objects to JSON-safe format.\n   * Handles BigInt and other non-JSON types.\n   *\n   * @param obj - The object to convert\n   * @returns The JSON-safe representation of the object\n   */\n  toJsonSafe(obj) {\n    return JSON.parse(\n      JSON.stringify(obj, (_, value) => typeof value === \"bigint\" ? value.toString() : value)\n    );\n  }\n};\n\n// src/http/x402HTTPClient.ts\nvar x402HTTPClient = class {\n  /**\n   * Creates a new x402HTTPClient instance.\n   *\n   * @param client - The underlying x402Client for payment logic\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * Encodes a payment payload into appropriate HTTP headers based on version.\n   *\n   * @param paymentPayload - The payment payload to encode\n   * @returns HTTP headers containing the encoded payment signature\n   */\n  encodePaymentSignatureHeader(paymentPayload) {\n    switch (paymentPayload.x402Version) {\n      case 2:\n        return {\n          \"PAYMENT-SIGNATURE\": encodePaymentSignatureHeader(paymentPayload)\n        };\n      case 1:\n        return {\n          \"X-PAYMENT\": encodePaymentSignatureHeader(paymentPayload)\n        };\n      default:\n        throw new Error(\n          `Unsupported x402 version: ${paymentPayload.x402Version}`\n        );\n    }\n  }\n  /**\n   * Extracts payment required information from HTTP response.\n   *\n   * @param getHeader - Function to retrieve header value by name (case-insensitive)\n   * @param body - Optional response body for v1 compatibility\n   * @returns The payment required object\n   */\n  getPaymentRequiredResponse(getHeader, body) {\n    const paymentRequired = getHeader(\"PAYMENT-REQUIRED\");\n    if (paymentRequired) {\n      return decodePaymentRequiredHeader(paymentRequired);\n    }\n    if (body && body instanceof Object && \"x402Version\" in body && body.x402Version === 1) {\n      return body;\n    }\n    throw new Error(\"Invalid payment required response\");\n  }\n  /**\n   * Extracts payment settlement response from HTTP headers.\n   *\n   * @param getHeader - Function to retrieve header value by name (case-insensitive)\n   * @returns The settlement response object\n   */\n  getPaymentSettleResponse(getHeader) {\n    const paymentResponse = getHeader(\"PAYMENT-RESPONSE\");\n    if (paymentResponse) {\n      return decodePaymentResponseHeader(paymentResponse);\n    }\n    const xPaymentResponse = getHeader(\"X-PAYMENT-RESPONSE\");\n    if (xPaymentResponse) {\n      return decodePaymentResponseHeader(xPaymentResponse);\n    }\n    throw new Error(\"Payment response header not found\");\n  }\n  /**\n   * Creates a payment payload for the given payment requirements.\n   * Delegates to the underlying x402Client.\n   *\n   * @param paymentRequired - The payment required response from the server\n   * @returns Promise resolving to the payment payload\n   */\n  async createPaymentPayload(paymentRequired) {\n    return this.client.createPaymentPayload(paymentRequired);\n  }\n};\n\n// src/http/index.ts\nfunction encodePaymentSignatureHeader(paymentPayload) {\n  return safeBase64Encode(JSON.stringify(paymentPayload));\n}\nfunction decodePaymentSignatureHeader(paymentSignatureHeader) {\n  if (!Base64EncodedRegex.test(paymentSignatureHeader)) {\n    throw new Error(\"Invalid payment signature header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentSignatureHeader));\n}\nfunction encodePaymentRequiredHeader(paymentRequired) {\n  return safeBase64Encode(JSON.stringify(paymentRequired));\n}\nfunction decodePaymentRequiredHeader(paymentRequiredHeader) {\n  if (!Base64EncodedRegex.test(paymentRequiredHeader)) {\n    throw new Error(\"Invalid payment required header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentRequiredHeader));\n}\nfunction encodePaymentResponseHeader(paymentResponse) {\n  return safeBase64Encode(JSON.stringify(paymentResponse));\n}\nfunction decodePaymentResponseHeader(paymentResponseHeader) {\n  if (!Base64EncodedRegex.test(paymentResponseHeader)) {\n    throw new Error(\"Invalid payment response header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentResponseHeader));\n}\n\nexport {\n  RouteConfigurationError,\n  x402HTTPResourceServer,\n  HTTPFacilitatorClient,\n  encodePaymentSignatureHeader,\n  decodePaymentSignatureHeader,\n  encodePaymentRequiredHeader,\n  decodePaymentRequiredHeader,\n  encodePaymentResponseHeader,\n  decodePaymentResponseHeader,\n  x402HTTPClient\n};\n//# sourceMappingURL=chunk-XT4E3FX4.mjs.map"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4]}