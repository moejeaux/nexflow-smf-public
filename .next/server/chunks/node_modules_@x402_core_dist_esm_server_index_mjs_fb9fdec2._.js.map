{"version":3,"sources":["../../../node_modules/%40x402/core/dist/esm/server/index.mjs"],"sourcesContent":["import {\n  HTTPFacilitatorClient,\n  RouteConfigurationError,\n  x402HTTPResourceServer\n} from \"../chunk-XT4E3FX4.mjs\";\nimport {\n  x402Version\n} from \"../chunk-VE37GDG2.mjs\";\nimport \"../chunk-X4W4S5RB.mjs\";\nimport {\n  deepEqual,\n  findByNetworkAndScheme\n} from \"../chunk-3IUBYRYG.mjs\";\nimport \"../chunk-BJTO5JO5.mjs\";\n\n// src/server/x402ResourceServer.ts\nvar x402ResourceServer = class {\n  /**\n   * Creates a new x402ResourceServer instance.\n   *\n   * @param facilitatorClients - Optional facilitator client(s) for payment processing\n   */\n  constructor(facilitatorClients) {\n    this.registeredServerSchemes = /* @__PURE__ */ new Map();\n    this.supportedResponsesMap = /* @__PURE__ */ new Map();\n    this.facilitatorClientsMap = /* @__PURE__ */ new Map();\n    this.registeredExtensions = /* @__PURE__ */ new Map();\n    this.beforeVerifyHooks = [];\n    this.afterVerifyHooks = [];\n    this.onVerifyFailureHooks = [];\n    this.beforeSettleHooks = [];\n    this.afterSettleHooks = [];\n    this.onSettleFailureHooks = [];\n    if (!facilitatorClients) {\n      this.facilitatorClients = [new HTTPFacilitatorClient()];\n    } else if (Array.isArray(facilitatorClients)) {\n      this.facilitatorClients = facilitatorClients.length > 0 ? facilitatorClients : [new HTTPFacilitatorClient()];\n    } else {\n      this.facilitatorClients = [facilitatorClients];\n    }\n  }\n  /**\n   * Register a scheme/network server implementation.\n   *\n   * @param network - The network identifier\n   * @param server - The scheme/network server implementation\n   * @returns The x402ResourceServer instance for chaining\n   */\n  register(network, server) {\n    if (!this.registeredServerSchemes.has(network)) {\n      this.registeredServerSchemes.set(network, /* @__PURE__ */ new Map());\n    }\n    const serverByScheme = this.registeredServerSchemes.get(network);\n    if (!serverByScheme.has(server.scheme)) {\n      serverByScheme.set(server.scheme, server);\n    }\n    return this;\n  }\n  /**\n   * Check if a scheme is registered for a given network.\n   *\n   * @param network - The network identifier\n   * @param scheme - The payment scheme name\n   * @returns True if the scheme is registered for the network, false otherwise\n   */\n  hasRegisteredScheme(network, scheme) {\n    return !!findByNetworkAndScheme(this.registeredServerSchemes, scheme, network);\n  }\n  /**\n   * Registers a resource service extension that can enrich extension declarations.\n   *\n   * @param extension - The extension to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  registerExtension(extension) {\n    this.registeredExtensions.set(extension.key, extension);\n    return this;\n  }\n  /**\n   * Enriches declared extensions using registered extension hooks.\n   *\n   * @param declaredExtensions - Extensions declared on the route\n   * @param transportContext - Transport-specific context (HTTP, A2A, MCP, etc.)\n   * @returns Enriched extensions map\n   */\n  enrichExtensions(declaredExtensions, transportContext) {\n    const enriched = {};\n    for (const [key, declaration] of Object.entries(declaredExtensions)) {\n      const extension = this.registeredExtensions.get(key);\n      if (extension?.enrichDeclaration) {\n        enriched[key] = extension.enrichDeclaration(declaration, transportContext);\n      } else {\n        enriched[key] = declaration;\n      }\n    }\n    return enriched;\n  }\n  /**\n   * Register a hook to execute before payment verification.\n   * Can abort verification by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onBeforeVerify(hook) {\n    this.beforeVerifyHooks.push(hook);\n    return this;\n  }\n  /**\n   * Register a hook to execute after successful payment verification.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onAfterVerify(hook) {\n    this.afterVerifyHooks.push(hook);\n    return this;\n  }\n  /**\n   * Register a hook to execute when payment verification fails.\n   * Can recover from failure by returning { recovered: true, result: VerifyResponse }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onVerifyFailure(hook) {\n    this.onVerifyFailureHooks.push(hook);\n    return this;\n  }\n  /**\n   * Register a hook to execute before payment settlement.\n   * Can abort settlement by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onBeforeSettle(hook) {\n    this.beforeSettleHooks.push(hook);\n    return this;\n  }\n  /**\n   * Register a hook to execute after successful payment settlement.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onAfterSettle(hook) {\n    this.afterSettleHooks.push(hook);\n    return this;\n  }\n  /**\n   * Register a hook to execute when payment settlement fails.\n   * Can recover from failure by returning { recovered: true, result: SettleResponse }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onSettleFailure(hook) {\n    this.onSettleFailureHooks.push(hook);\n    return this;\n  }\n  /**\n   * Initialize by fetching supported kinds from all facilitators\n   * Creates mappings for supported responses and facilitator clients\n   * Earlier facilitators in the array get precedence\n   */\n  async initialize() {\n    this.supportedResponsesMap.clear();\n    this.facilitatorClientsMap.clear();\n    for (const facilitatorClient of this.facilitatorClients) {\n      try {\n        const supported = await facilitatorClient.getSupported();\n        for (const kind of supported.kinds) {\n          const x402Version2 = kind.x402Version;\n          if (!this.supportedResponsesMap.has(x402Version2)) {\n            this.supportedResponsesMap.set(x402Version2, /* @__PURE__ */ new Map());\n          }\n          const responseVersionMap = this.supportedResponsesMap.get(x402Version2);\n          if (!this.facilitatorClientsMap.has(x402Version2)) {\n            this.facilitatorClientsMap.set(x402Version2, /* @__PURE__ */ new Map());\n          }\n          const clientVersionMap = this.facilitatorClientsMap.get(x402Version2);\n          if (!responseVersionMap.has(kind.network)) {\n            responseVersionMap.set(kind.network, /* @__PURE__ */ new Map());\n          }\n          const responseNetworkMap = responseVersionMap.get(kind.network);\n          if (!clientVersionMap.has(kind.network)) {\n            clientVersionMap.set(kind.network, /* @__PURE__ */ new Map());\n          }\n          const clientNetworkMap = clientVersionMap.get(kind.network);\n          if (!responseNetworkMap.has(kind.scheme)) {\n            responseNetworkMap.set(kind.scheme, supported);\n            clientNetworkMap.set(kind.scheme, facilitatorClient);\n          }\n        }\n      } catch (error) {\n        console.warn(`Failed to fetch supported kinds from facilitator: ${error}`);\n      }\n    }\n  }\n  /**\n   * Get supported kind for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The supported kind or undefined if not found\n   */\n  getSupportedKind(x402Version2, network, scheme) {\n    const versionMap = this.supportedResponsesMap.get(x402Version2);\n    if (!versionMap) return void 0;\n    const supportedResponse = findByNetworkAndScheme(versionMap, scheme, network);\n    if (!supportedResponse) return void 0;\n    return supportedResponse.kinds.find(\n      (kind) => kind.x402Version === x402Version2 && kind.network === network && kind.scheme === scheme\n    );\n  }\n  /**\n   * Get facilitator extensions for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The facilitator extensions or empty array if not found\n   */\n  getFacilitatorExtensions(x402Version2, network, scheme) {\n    const versionMap = this.supportedResponsesMap.get(x402Version2);\n    if (!versionMap) return [];\n    const supportedResponse = findByNetworkAndScheme(versionMap, scheme, network);\n    return supportedResponse?.extensions || [];\n  }\n  /**\n   * Build payment requirements for a protected resource\n   *\n   * @param resourceConfig - Configuration for the protected resource\n   * @returns Array of payment requirements\n   */\n  async buildPaymentRequirements(resourceConfig) {\n    const requirements = [];\n    const scheme = resourceConfig.scheme;\n    const SchemeNetworkServer = findByNetworkAndScheme(\n      this.registeredServerSchemes,\n      scheme,\n      resourceConfig.network\n    );\n    if (!SchemeNetworkServer) {\n      console.warn(\n        `No server implementation registered for scheme: ${scheme}, network: ${resourceConfig.network}`\n      );\n      return requirements;\n    }\n    const supportedKind = this.getSupportedKind(\n      x402Version,\n      resourceConfig.network,\n      SchemeNetworkServer.scheme\n    );\n    if (!supportedKind) {\n      throw new Error(\n        `Facilitator does not support ${SchemeNetworkServer.scheme} on ${resourceConfig.network}. Make sure to call initialize() to fetch supported kinds from facilitators.`\n      );\n    }\n    const facilitatorExtensions = this.getFacilitatorExtensions(\n      x402Version,\n      resourceConfig.network,\n      SchemeNetworkServer.scheme\n    );\n    const parsedPrice = await SchemeNetworkServer.parsePrice(\n      resourceConfig.price,\n      resourceConfig.network\n    );\n    const baseRequirements = {\n      scheme: SchemeNetworkServer.scheme,\n      network: resourceConfig.network,\n      amount: parsedPrice.amount,\n      asset: parsedPrice.asset,\n      payTo: resourceConfig.payTo,\n      maxTimeoutSeconds: resourceConfig.maxTimeoutSeconds || 300,\n      // Default 5 minutes\n      extra: {\n        ...parsedPrice.extra\n      }\n    };\n    const requirement = await SchemeNetworkServer.enhancePaymentRequirements(\n      baseRequirements,\n      {\n        ...supportedKind,\n        x402Version\n      },\n      facilitatorExtensions\n    );\n    requirements.push(requirement);\n    return requirements;\n  }\n  /**\n   * Build payment requirements from multiple payment options\n   * This method handles resolving dynamic payTo/price functions and builds requirements for each option\n   *\n   * @param paymentOptions - Array of payment options to convert\n   * @param context - HTTP request context for resolving dynamic functions\n   * @returns Array of payment requirements (one per option)\n   */\n  async buildPaymentRequirementsFromOptions(paymentOptions, context) {\n    const allRequirements = [];\n    for (const option of paymentOptions) {\n      const resolvedPayTo = typeof option.payTo === \"function\" ? await option.payTo(context) : option.payTo;\n      const resolvedPrice = typeof option.price === \"function\" ? await option.price(context) : option.price;\n      const resourceConfig = {\n        scheme: option.scheme,\n        payTo: resolvedPayTo,\n        price: resolvedPrice,\n        network: option.network,\n        maxTimeoutSeconds: option.maxTimeoutSeconds\n      };\n      const requirements = await this.buildPaymentRequirements(resourceConfig);\n      allRequirements.push(...requirements);\n    }\n    return allRequirements;\n  }\n  /**\n   * Create a payment required response\n   *\n   * @param requirements - Payment requirements\n   * @param resourceInfo - Resource information\n   * @param error - Error message\n   * @param extensions - Optional extensions\n   * @returns Payment required response object\n   */\n  createPaymentRequiredResponse(requirements, resourceInfo, error, extensions) {\n    const response = {\n      x402Version: 2,\n      error,\n      resource: resourceInfo,\n      accepts: requirements\n    };\n    if (extensions && Object.keys(extensions).length > 0) {\n      response.extensions = extensions;\n    }\n    return response;\n  }\n  /**\n   * Verify a payment against requirements\n   *\n   * @param paymentPayload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @returns Verification response\n   */\n  async verifyPayment(paymentPayload, requirements) {\n    const context = {\n      paymentPayload,\n      requirements\n    };\n    for (const hook of this.beforeVerifyHooks) {\n      const result = await hook(context);\n      if (result && \"abort\" in result && result.abort) {\n        return {\n          isValid: false,\n          invalidReason: result.reason\n        };\n      }\n    }\n    try {\n      const facilitatorClient = this.getFacilitatorClient(\n        paymentPayload.x402Version,\n        requirements.network,\n        requirements.scheme\n      );\n      let verifyResult;\n      if (!facilitatorClient) {\n        let lastError;\n        for (const client of this.facilitatorClients) {\n          try {\n            verifyResult = await client.verify(paymentPayload, requirements);\n            break;\n          } catch (error) {\n            lastError = error;\n          }\n        }\n        if (!verifyResult) {\n          throw lastError || new Error(\n            `No facilitator supports ${requirements.scheme} on ${requirements.network} for v${paymentPayload.x402Version}`\n          );\n        }\n      } else {\n        verifyResult = await facilitatorClient.verify(paymentPayload, requirements);\n      }\n      const resultContext = {\n        ...context,\n        result: verifyResult\n      };\n      for (const hook of this.afterVerifyHooks) {\n        await hook(resultContext);\n      }\n      return verifyResult;\n    } catch (error) {\n      const failureContext = {\n        ...context,\n        error\n      };\n      for (const hook of this.onVerifyFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.result;\n        }\n      }\n      throw error;\n    }\n  }\n  /**\n   * Settle a verified payment\n   *\n   * @param paymentPayload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @returns Settlement response\n   */\n  async settlePayment(paymentPayload, requirements) {\n    const context = {\n      paymentPayload,\n      requirements\n    };\n    for (const hook of this.beforeSettleHooks) {\n      const result = await hook(context);\n      if (result && \"abort\" in result && result.abort) {\n        throw new Error(`Settlement aborted: ${result.reason}`);\n      }\n    }\n    try {\n      const facilitatorClient = this.getFacilitatorClient(\n        paymentPayload.x402Version,\n        requirements.network,\n        requirements.scheme\n      );\n      let settleResult;\n      if (!facilitatorClient) {\n        let lastError;\n        for (const client of this.facilitatorClients) {\n          try {\n            settleResult = await client.settle(paymentPayload, requirements);\n            break;\n          } catch (error) {\n            lastError = error;\n          }\n        }\n        if (!settleResult) {\n          throw lastError || new Error(\n            `No facilitator supports ${requirements.scheme} on ${requirements.network} for v${paymentPayload.x402Version}`\n          );\n        }\n      } else {\n        settleResult = await facilitatorClient.settle(paymentPayload, requirements);\n      }\n      const resultContext = {\n        ...context,\n        result: settleResult\n      };\n      for (const hook of this.afterSettleHooks) {\n        await hook(resultContext);\n      }\n      return settleResult;\n    } catch (error) {\n      const failureContext = {\n        ...context,\n        error\n      };\n      for (const hook of this.onSettleFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.result;\n        }\n      }\n      throw error;\n    }\n  }\n  /**\n   * Find matching payment requirements for a payment\n   *\n   * @param availableRequirements - Array of available payment requirements\n   * @param paymentPayload - The payment payload\n   * @returns Matching payment requirements or undefined\n   */\n  findMatchingRequirements(availableRequirements, paymentPayload) {\n    switch (paymentPayload.x402Version) {\n      case 2:\n        return availableRequirements.find(\n          (paymentRequirements) => deepEqual(paymentRequirements, paymentPayload.accepted)\n        );\n      case 1:\n        return availableRequirements.find(\n          (req) => req.scheme === paymentPayload.accepted.scheme && req.network === paymentPayload.accepted.network\n        );\n      default:\n        throw new Error(\n          `Unsupported x402 version: ${paymentPayload.x402Version}`\n        );\n    }\n  }\n  /**\n   * Process a payment request\n   *\n   * @param paymentPayload - Optional payment payload if provided\n   * @param resourceConfig - Configuration for the protected resource\n   * @param resourceInfo - Information about the resource being accessed\n   * @param extensions - Optional extensions to include in the response\n   * @returns Processing result\n   */\n  async processPaymentRequest(paymentPayload, resourceConfig, resourceInfo, extensions) {\n    const requirements = await this.buildPaymentRequirements(resourceConfig);\n    if (!paymentPayload) {\n      return {\n        success: false,\n        requiresPayment: this.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"Payment required\",\n          extensions\n        )\n      };\n    }\n    const matchingRequirements = this.findMatchingRequirements(requirements, paymentPayload);\n    if (!matchingRequirements) {\n      return {\n        success: false,\n        requiresPayment: this.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"No matching payment requirements found\",\n          extensions\n        )\n      };\n    }\n    const verificationResult = await this.verifyPayment(paymentPayload, matchingRequirements);\n    if (!verificationResult.isValid) {\n      return {\n        success: false,\n        error: verificationResult.invalidReason,\n        verificationResult\n      };\n    }\n    return {\n      success: true,\n      verificationResult\n    };\n  }\n  /**\n   * Get facilitator client for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The facilitator client or undefined if not found\n   */\n  getFacilitatorClient(x402Version2, network, scheme) {\n    const versionMap = this.facilitatorClientsMap.get(x402Version2);\n    if (!versionMap) return void 0;\n    return findByNetworkAndScheme(versionMap, scheme, network);\n  }\n};\nexport {\n  HTTPFacilitatorClient,\n  RouteConfigurationError,\n  x402HTTPResourceServer,\n  x402ResourceServer\n};\n//# sourceMappingURL=index.mjs.map"],"names":[],"mappings":"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","ignoreList":[0]}