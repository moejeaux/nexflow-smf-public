module.exports=[3096,18818,s=>{"use strict";var e=s.i(62604),t=Object.defineProperty,n={},i={UpstashError:()=>c,UpstashJSONParseError:()=>h,UrlError:()=>o};for(var r in i)t(n,r,{get:i[r],enumerable:!0});var c=class extends Error{constructor(s,e){super(s,e),this.name="UpstashError"}},o=class extends Error{constructor(s){super(`Upstash Redis client was passed an invalid URL. You should pass a URL starting with https. Received: "${s}". `),this.name="UrlError"}},h=class extends c{constructor(s,e){super(`Unable to parse response body: ${s.length>200?s.slice(0,200)+"...":s}`,e),this.name="UpstashJSONParseError"}};function a(s){try{return function s(e){let t=Array.isArray(e)?e.map(e=>{try{return s(e)}catch{return e}}):JSON.parse(e);return"number"==typeof t&&t.toString()!==e?e:t}(s)}catch{return s}}function p(s){return[s[0],...a(s.slice(1))]}function l(s){let[e,t]=s,n=[];for(let s=0;s<t.length;s+=2)n.push({key:t[s],type:t[s+1]});return[e,n]}function u(s){if("object"==typeof s&&null!==s&&!Array.isArray(s))return s;if(!Array.isArray(s))return{};let e={};for(let t=0;t<s.length;t+=2)"string"==typeof s[t]&&(e[s[t]]=s[t+1]);return e}var m=class{baseUrl;headers;options;readYourWrites;upstashSyncToken="";hasCredentials;retry;constructor(s){if(this.options={backend:s.options?.backend,agent:s.agent,responseEncoding:s.responseEncoding??"base64",cache:s.cache,signal:s.signal,keepAlive:s.keepAlive??!0},this.upstashSyncToken="",this.readYourWrites=s.readYourWrites??!0,this.baseUrl=(s.baseUrl||"").replace(/\/$/,""),this.baseUrl&&!/^https?:\/\/[^\s#$./?].\S*$/.test(this.baseUrl))throw new o(this.baseUrl);this.headers={"Content-Type":"application/json",...s.headers},this.hasCredentials=!!(this.baseUrl&&this.headers.authorization.split(" ")[1]),"base64"===this.options.responseEncoding&&(this.headers["Upstash-Encoding"]="base64"),this.retry="boolean"!=typeof s.retry||s.retry?{attempts:s.retry?.retries??5,backoff:s.retry?.backoff??(s=>50*Math.exp(s))}:{attempts:1,backoff:()=>0}}mergeTelemetry(s){this.headers=w(this.headers,"Upstash-Telemetry-Runtime",s.runtime),this.headers=w(this.headers,"Upstash-Telemetry-Platform",s.platform),this.headers=w(this.headers,"Upstash-Telemetry-Sdk",s.sdk)}async request(s){let e,t=function(...s){let e={};for(let t of s)if(t)for(let[s,n]of Object.entries(t))null!=n&&(e[s]=n);return e}(this.headers,s.headers??{}),n=[this.baseUrl,...s.path??[]].join("/"),i="text/event-stream"===t.Accept,r=s.signal??this.options.signal,o="function"==typeof r,a={cache:this.options.cache,method:"POST",headers:t,body:JSON.stringify(s.body),keepalive:this.options.keepAlive,agent:this.options.agent,signal:o?r():r,backend:this.options.backend};if(this.hasCredentials||console.warn("[Upstash Redis] Redis client was initialized without url or token. Failed to execute command."),this.readYourWrites){let s=this.upstashSyncToken;this.headers["upstash-sync-token"]=s}let p=null,l=null;for(let s=0;s<=this.retry.attempts;s++)try{p=await fetch(n,a);break}catch(e){if(a.signal?.aborted&&o)throw e;if(a.signal?.aborted){p=new Response(new Blob([JSON.stringify({result:a.signal.reason??"Aborted"})]),{status:200,statusText:a.signal.reason??"Aborted"});break}l=e,s<this.retry.attempts&&await new Promise(e=>setTimeout(e,this.retry.backoff(s)))}if(!p)throw l??Error("Exhausted all retries");if(!p.ok){let e,t=await p.text();try{e=JSON.parse(t)}catch(s){throw new h(t,{cause:s})}throw new c(`${e.error}, command was: ${JSON.stringify(s.body)}`)}if(this.readYourWrites){let s=p.headers;this.upstashSyncToken=s.get("upstash-sync-token")??""}if(i&&s&&s.onMessage&&p.body){let e=p.body.getReader(),t=new TextDecoder;return(async()=>{try{for(;;){let{value:n,done:i}=await e.read();if(i)break;for(let e of t.decode(n).split("\n"))if(e.startsWith("data: ")){let t=e.slice(6);s.onMessage?.(t)}}}catch(s){s instanceof Error&&"AbortError"===s.name||console.error("Stream reading error:",s)}finally{try{await e.cancel()}catch{}}})(),{result:1}}let u=await p.text();try{e=JSON.parse(u)}catch(s){throw new h(u,{cause:s})}if(this.readYourWrites){let s=p.headers;this.upstashSyncToken=s.get("upstash-sync-token")??""}return"base64"===this.options.responseEncoding?Array.isArray(e)?e.map(({result:s,error:e})=>({result:x(s),error:e})):{result:x(e.result),error:e.error}:e}};function d(s){let e="";try{let t=atob(s),n=t.length,i=new Uint8Array(n);for(let s=0;s<n;s++)i[s]=t.charCodeAt(s);e=new TextDecoder().decode(i)}catch{e=s}return e}function x(s){let e;switch(typeof s){case"undefined":return s;case"number":e=s;break;case"object":e=Array.isArray(s)?s.map(s=>"string"==typeof s?d(s):Array.isArray(s)?s.map(s=>x(s)):s):null;break;case"string":e="OK"===s?"OK":d(s)}return e}function w(s,e,t){return t&&(s[e]=s[e]?[s[e],t].join(","):t),s}var y=s=>{switch(typeof s){case"string":case"number":case"boolean":return s;default:return JSON.stringify(s)}},g=class{command;serialize;deserialize;headers;path;onMessage;isStreaming;signal;constructor(s,e){if(this.serialize=y,this.deserialize=e?.automaticDeserialization===void 0||e.automaticDeserialization?e?.deserialize??a:s=>s,this.command=s.map(s=>this.serialize(s)),this.headers=e?.headers,this.path=e?.path,this.onMessage=e?.streamOptions?.onMessage,this.isStreaming=e?.streamOptions?.isStreaming??!1,this.signal=e?.streamOptions?.signal,e?.latencyLogging){const s=this.exec.bind(this);this.exec=async e=>{let t=performance.now(),n=await s(e),i=(performance.now()-t).toFixed(2);return console.log(`Latency for \x1b[38;2;19;185;39m${this.command[0].toString().toUpperCase()}\x1b[0m: \x1b[38;2;0;255;255m${i} ms\x1b[0m`),n}}}async exec(s){let{result:e,error:t}=await s.request({body:this.command,path:this.path,upstashSyncToken:s.upstashSyncToken,headers:this.headers,onMessage:this.onMessage,isStreaming:this.isStreaming,signal:this.signal});if(t)throw new c(t);if(void 0===e)throw TypeError("Request did not return a result");return this.deserialize(e)}},O=class extends g{constructor(s,e){const t=["hrandfield",s[0]];"number"==typeof s[1]&&t.push(s[1]),s[2]&&t.push("WITHVALUES"),super(t,{deserialize:s[2]?s=>(function(s){if(0===s.length)return null;let e={};for(let t=0;t<s.length;t+=2){let n=s[t],i=s[t+1];try{e[n]=JSON.parse(i)}catch{e[n]=i}}return e})(s):e?.deserialize,...e})}},f=class extends g{constructor(s,e){super(["append",...s],e)}},b=class extends g{constructor([s,e,t],n){const i=["bitcount",s];"number"==typeof e&&i.push(e),"number"==typeof t&&i.push(t),super(i,n)}},E=class{constructor(s,e,t,n=s=>s.exec(this.client)){this.client=e,this.opts=t,this.execOperation=n,this.command=["bitfield",...s]}command;chain(...s){return this.command.push(...s),this}get(...s){return this.chain("get",...s)}set(...s){return this.chain("set",...s)}incrby(...s){return this.chain("incrby",...s)}overflow(s){return this.chain("overflow",s)}exec(){let s=new g(this.command,this.opts);return this.execOperation(s)}},S=class extends g{constructor(s,e){super(["bitop",...s],e)}},A=class extends g{constructor(s,e){super(["bitpos",...s],e)}},T=class extends g{constructor([s,e,t],n){super(["COPY",s,e,...t?.replace?["REPLACE"]:[]],{...n,deserialize:s=>s>0?"COPIED":"NOT_COPIED"})}},R=class extends g{constructor(s){super(["dbsize"],s)}},N=class extends g{constructor(s,e){super(["decr",...s],e)}},v=class extends g{constructor(s,e){super(["decrby",...s],e)}},z=class extends g{constructor(s,e){super(["del",...s],e)}},k=class extends g{constructor(s,e){super(["echo",...s],e)}},U=class extends g{constructor([s,e,t],n){super(["eval_ro",s,e.length,...e,...t??[]],n)}},C=class extends g{constructor([s,e,t],n){super(["eval",s,e.length,...e,...t??[]],n)}},P=class extends g{constructor([s,e,t],n){super(["evalsha_ro",s,e.length,...e,...t??[]],n)}},I=class extends g{constructor([s,e,t],n){super(["evalsha",s,e.length,...e,...t??[]],n)}},L=class extends g{constructor(s,e){super(s.map(s=>"string"==typeof s?s:String(s)),e)}},M=class extends g{constructor(s,e){super(["exists",...s],e)}},D=class extends g{constructor(s,e){super(["expire",...s.filter(Boolean)],e)}},J=class extends g{constructor(s,e){super(["expireat",...s],e)}},j=class extends g{constructor([s,e,t],n){super(["fcall",s,...e?[e.length,...e]:[0],...t??[]],n)}},_=class extends g{constructor([s,e,t],n){super(["fcall_ro",s,...e?[e.length,...e]:[0],...t??[]],n)}},F=class extends g{constructor(s,e){const t=["flushall"];s&&s.length>0&&s[0].async&&t.push("async"),super(t,e)}},Y=class extends g{constructor([s],e){const t=["flushdb"];s?.async&&t.push("async"),super(t,e)}},$=class extends g{constructor([s],e){super(["function","delete",s],e)}},W=class extends g{constructor(s){super(["function","flush"],s)}},X=class extends g{constructor([s],e){const t=["function","list"];s?.libraryName&&t.push("libraryname",s.libraryName),s?.withCode&&t.push("withcode"),super(t,{deserialize:H,...e})}};function H(s){return Array.isArray(s)?s.map(s=>{let e=u(s),t=e.functions.map(s=>u(s));return{libraryName:e.library_name,engine:e.engine,functions:t.map(s=>({name:s.name,description:s.description??void 0,flags:s.flags})),libraryCode:e.library_code}}):[]}var G=class extends g{constructor([s],e){super(["function","load",...s.replace?["replace"]:[],s.code],e)}},B=class extends g{constructor(s){super(["function","stats"],{deserialize:K,...s})}};function K(s){return{engines:Object.fromEntries(Object.entries(Object.fromEntries(Object.entries(u(u(s).engines)).map(([s,e])=>[s,u(e)]))).map(([s,e])=>[s,{librariesCount:e.libraries_count,functionsCount:e.functions_count}]))}}var q=class extends g{constructor([s,e,...t],n){const i=["geoadd",s];"nx"in e&&e.nx?i.push("nx"):"xx"in e&&e.xx&&i.push("xx"),"ch"in e&&e.ch&&i.push("ch"),"latitude"in e&&e.latitude&&i.push(e.longitude,e.latitude,e.member),i.push(...t.flatMap(({latitude:s,longitude:e,member:t})=>[e,s,t])),super(i,n)}},V=class extends g{constructor([s,e,t,n="M"],i){super(["GEODIST",s,e,t,n],i)}},Q=class extends g{constructor(s,e){const[t]=s;super(["GEOHASH",t,...Array.isArray(s[1])?s[1]:s.slice(1)],e)}},Z=class extends g{constructor(s,e){const[t]=s;super(["GEOPOS",t,...Array.isArray(s[1])?s[1]:s.slice(1)],{deserialize:s=>(function(s){let e=[];for(let t of s)t?.[0]&&t?.[1]&&e.push({lng:Number.parseFloat(t[0]),lat:Number.parseFloat(t[1])});return e})(s),...e})}},ss=class extends g{constructor([s,e,t,n,i],r){const c=["GEOSEARCH",s];("FROMMEMBER"===e.type||"frommember"===e.type)&&c.push(e.type,e.member),("FROMLONLAT"===e.type||"fromlonlat"===e.type)&&c.push(e.type,e.coordinate.lon,e.coordinate.lat),("BYRADIUS"===t.type||"byradius"===t.type)&&c.push(t.type,t.radius,t.radiusType),("BYBOX"===t.type||"bybox"===t.type)&&c.push(t.type,t.rect.width,t.rect.height,t.rectType),c.push(n),i?.count&&c.push("COUNT",i.count.limit,...i.count.any?["ANY"]:[]),super([...c,...i?.withCoord?["WITHCOORD"]:[],...i?.withDist?["WITHDIST"]:[],...i?.withHash?["WITHHASH"]:[]],{deserialize:s=>i?.withCoord||i?.withDist||i?.withHash?s.map(s=>{let e=1,t={};try{t.member=JSON.parse(s[0])}catch{t.member=s[0]}return i.withDist&&(t.dist=Number.parseFloat(s[e++])),i.withHash&&(t.hash=s[e++].toString()),i.withCoord&&(t.coord={long:Number.parseFloat(s[e][0]),lat:Number.parseFloat(s[e][1])}),t}):s.map(s=>{try{return{member:JSON.parse(s)}}catch{return{member:s}}}),...r})}},se=class extends g{constructor([s,e,t,n,i,r],c){const o=["GEOSEARCHSTORE",s,e];("FROMMEMBER"===t.type||"frommember"===t.type)&&o.push(t.type,t.member),("FROMLONLAT"===t.type||"fromlonlat"===t.type)&&o.push(t.type,t.coordinate.lon,t.coordinate.lat),("BYRADIUS"===n.type||"byradius"===n.type)&&o.push(n.type,n.radius,n.radiusType),("BYBOX"===n.type||"bybox"===n.type)&&o.push(n.type,n.rect.width,n.rect.height,n.rectType),o.push(i),r?.count&&o.push("COUNT",r.count.limit,...r.count.any?["ANY"]:[]),super([...o,...r?.storeDist?["STOREDIST"]:[]],c)}},st=class extends g{constructor(s,e){super(["get",...s],e)}},sn=class extends g{constructor(s,e){super(["getbit",...s],e)}},si=class extends g{constructor(s,e){super(["getdel",...s],e)}},sr=class extends g{constructor([s,e],t){const n=["getex",s];e&&("ex"in e&&"number"==typeof e.ex?n.push("ex",e.ex):"px"in e&&"number"==typeof e.px?n.push("px",e.px):"exat"in e&&"number"==typeof e.exat?n.push("exat",e.exat):"pxat"in e&&"number"==typeof e.pxat?n.push("pxat",e.pxat):"persist"in e&&e.persist&&n.push("persist")),super(n,t)}},sc=class extends g{constructor(s,e){super(["getrange",...s],e)}},so=class extends g{constructor(s,e){super(["getset",...s],e)}},sh=class extends g{constructor(s,e){super(["hdel",...s],e)}},sa=class extends g{constructor(s,e){super(["hexists",...s],e)}},sp=class extends g{constructor(s,e){const[t,n,i,r]=s,c=Array.isArray(n)?n:[n];super(["hexpire",t,i,...r?[r]:[],"FIELDS",c.length,...c],e)}},sl=class extends g{constructor(s,e){const[t,n,i,r]=s,c=Array.isArray(n)?n:[n];super(["hexpireat",t,i,...r?[r]:[],"FIELDS",c.length,...c],e)}},su=class extends g{constructor(s,e){const[t,n]=s,i=Array.isArray(n)?n:[n];super(["hexpiretime",t,"FIELDS",i.length,...i],e)}},sm=class extends g{constructor(s,e){const[t,n]=s,i=Array.isArray(n)?n:[n];super(["hpersist",t,"FIELDS",i.length,...i],e)}},sd=class extends g{constructor(s,e){const[t,n,i,r]=s,c=Array.isArray(n)?n:[n];super(["hpexpire",t,i,...r?[r]:[],"FIELDS",c.length,...c],e)}},sx=class extends g{constructor(s,e){const[t,n,i,r]=s,c=Array.isArray(n)?n:[n];super(["hpexpireat",t,i,...r?[r]:[],"FIELDS",c.length,...c],e)}},sw=class extends g{constructor(s,e){const[t,n]=s,i=Array.isArray(n)?n:[n];super(["hpexpiretime",t,"FIELDS",i.length,...i],e)}},sy=class extends g{constructor(s,e){const[t,n]=s,i=Array.isArray(n)?n:[n];super(["hpttl",t,"FIELDS",i.length,...i],e)}},sg=class extends g{constructor(s,e){super(["hget",...s],e)}},sO=class extends g{constructor(s,e){super(["hgetall",...s],{deserialize:s=>(function(s){if(0===s.length)return null;let e={};for(let t=0;t<s.length;t+=2){let n=s[t],i=s[t+1];try{let s=!Number.isNaN(Number(i))&&!Number.isSafeInteger(Number(i));e[n]=s?i:JSON.parse(i)}catch{e[n]=i}}return e})(s),...e})}},sf=class extends g{constructor(s,e){super(["hincrby",...s],e)}},sb=class extends g{constructor(s,e){super(["hincrbyfloat",...s],e)}},sE=class extends g{constructor([s],e){super(["hkeys",s],e)}},sS=class extends g{constructor(s,e){super(["hlen",...s],e)}},sA=class extends g{constructor([s,...e],t){super(["hmget",s,...e],{deserialize:s=>(function(s,e){if(e.every(s=>null===s))return null;let t={};for(let[n,i]of s.entries())try{t[i]=JSON.parse(e[n])}catch{t[i]=e[n]}return t})(e,s),...t})}},sT=class extends g{constructor([s,e],t){super(["hmset",s,...Object.entries(e).flatMap(([s,e])=>[s,e])],t)}},sR=class extends g{constructor([s,e,t],n){const i=["hscan",s,e];t?.match&&i.push("match",t.match),"number"==typeof t?.count&&i.push("count",t.count),super(i,{deserialize:p,...n})}},sN=class extends g{constructor([s,e],t){super(["hset",s,...Object.entries(e).flatMap(([s,e])=>[s,e])],t)}},sv=class extends g{constructor(s,e){super(["hsetnx",...s],e)}},sz=class extends g{constructor(s,e){super(["hstrlen",...s],e)}},sk=class extends g{constructor(s,e){const[t,n]=s,i=Array.isArray(n)?n:[n];super(["httl",t,"FIELDS",i.length,...i],e)}},sU=class extends g{constructor(s,e){super(["hvals",...s],e)}},sC=class extends g{constructor(s,e){super(["incr",...s],e)}},sP=class extends g{constructor(s,e){super(["incrby",...s],e)}},sI=class extends g{constructor(s,e){super(["incrbyfloat",...s],e)}},sL=class extends g{constructor(s,e){super(["JSON.ARRAPPEND",...s],e)}},sM=class extends g{constructor(s,e){super(["JSON.ARRINDEX",...s],e)}},sD=class extends g{constructor(s,e){super(["JSON.ARRINSERT",...s],e)}},sJ=class extends g{constructor(s,e){super(["JSON.ARRLEN",s[0],s[1]??"$"],e)}},sj=class extends g{constructor(s,e){super(["JSON.ARRPOP",...s],e)}},s_=class extends g{constructor(s,e){const t=s[1]??"$";super(["JSON.ARRTRIM",s[0],t,s[2]??0,s[3]??0],e)}},sF=class extends g{constructor(s,e){super(["JSON.CLEAR",...s],e)}},sY=class extends g{constructor(s,e){super(["JSON.DEL",...s],e)}},s$=class extends g{constructor(s,e){super(["JSON.FORGET",...s],e)}},sW=class extends g{constructor(s,e){const t=["JSON.GET"];"string"==typeof s[1]?t.push(...s):(t.push(s[0]),s[1]&&(s[1].indent&&t.push("INDENT",s[1].indent),s[1].newline&&t.push("NEWLINE",s[1].newline),s[1].space&&t.push("SPACE",s[1].space)),t.push(...s.slice(2))),super(t,e)}},sX=class extends g{constructor(s,e){super(["JSON.MERGE",...s],e)}},sH=class extends g{constructor(s,e){super(["JSON.MGET",...s[0],s[1]],e)}},sG=class extends g{constructor(s,e){const t=["JSON.MSET"];for(const e of s)t.push(e.key,e.path,e.value);super(t,e)}},sB=class extends g{constructor(s,e){super(["JSON.NUMINCRBY",...s],e)}},sK=class extends g{constructor(s,e){super(["JSON.NUMMULTBY",...s],e)}},sq=class extends g{constructor(s,e){super(["JSON.OBJKEYS",...s],e)}},sV=class extends g{constructor(s,e){super(["JSON.OBJLEN",...s],e)}},sQ=class extends g{constructor(s,e){super(["JSON.RESP",...s],e)}},sZ=class extends g{constructor(s,e){const t=["JSON.SET",s[0],s[1],s[2]];s[3]&&(s[3].nx?t.push("NX"):s[3].xx&&t.push("XX")),super(t,e)}},s1=class extends g{constructor(s,e){super(["JSON.STRAPPEND",...s],e)}},s0=class extends g{constructor(s,e){super(["JSON.STRLEN",...s],e)}},s2=class extends g{constructor(s,e){super(["JSON.TOGGLE",...s],e)}},s8=class extends g{constructor(s,e){super(["JSON.TYPE",...s],e)}},s3=class extends g{constructor(s,e){super(["keys",...s],e)}},s6=class extends g{constructor(s,e){super(["lindex",...s],e)}},s5=class extends g{constructor(s,e){super(["linsert",...s],e)}},s4=class extends g{constructor(s,e){super(["llen",...s],e)}},s9=class extends g{constructor(s,e){super(["lmove",...s],e)}},s7=class extends g{constructor(s,e){const[t,n,i,r]=s;super(["LMPOP",t,...n,i,...r?["COUNT",r]:[]],e)}},es=class extends g{constructor(s,e){super(["lpop",...s],e)}},ee=class extends g{constructor(s,e){const t=["lpos",s[0],s[1]];"number"==typeof s[2]?.rank&&t.push("rank",s[2].rank),"number"==typeof s[2]?.count&&t.push("count",s[2].count),"number"==typeof s[2]?.maxLen&&t.push("maxLen",s[2].maxLen),super(t,e)}},et=class extends g{constructor(s,e){super(["lpush",...s],e)}},en=class extends g{constructor(s,e){super(["lpushx",...s],e)}},ei=class extends g{constructor(s,e){super(["lrange",...s],e)}},er=class extends g{constructor(s,e){super(["lrem",...s],e)}},ec=class extends g{constructor(s,e){super(["lset",...s],e)}},eo=class extends g{constructor(s,e){super(["ltrim",...s],e)}},eh=class extends g{constructor(s,e){super(["mget",...Array.isArray(s[0])?s[0]:s],e)}},ea=class extends g{constructor([s],e){super(["mset",...Object.entries(s).flatMap(([s,e])=>[s,e])],e)}},ep=class extends g{constructor([s],e){super(["msetnx",...Object.entries(s).flat()],e)}},el=class extends g{constructor(s,e){super(["persist",...s],e)}},eu=class extends g{constructor(s,e){super(["pexpire",...s],e)}},em=class extends g{constructor(s,e){super(["pexpireat",...s],e)}},ed=class extends g{constructor(s,e){super(["pfadd",...s],e)}},ex=class extends g{constructor(s,e){super(["pfcount",...s],e)}},ew=class extends g{constructor(s,e){super(["pfmerge",...s],e)}},ey=class extends g{constructor(s,e){const t=["ping"];s?.[0]!==void 0&&t.push(s[0]),super(t,e)}},eg=class extends g{constructor(s,e){super(["psetex",...s],e)}},eO=class extends g{constructor(s,e){super(["pttl",...s],e)}},ef=class extends g{constructor(s,e){super(["publish",...s],e)}},eb=class extends g{constructor(s){super(["randomkey"],s)}},eE=class extends g{constructor(s,e){super(["rename",...s],e)}},eS=class extends g{constructor(s,e){super(["renamenx",...s],e)}},eA=class extends g{constructor(s,e){super(["rpop",...s],e)}},eT=class extends g{constructor(s,e){super(["rpush",...s],e)}},eR=class extends g{constructor(s,e){super(["rpushx",...s],e)}},eN=class extends g{constructor(s,e){super(["sadd",...s],e)}},ev=class extends g{constructor([s,e],t){const n=["scan",s];e?.match&&n.push("match",e.match),"number"==typeof e?.count&&n.push("count",e.count),e&&"withType"in e&&!0===e.withType?n.push("withtype"):e&&"type"in e&&e.type&&e.type.length>0&&n.push("type",e.type),super(n,{deserialize:e?.withType?l:p,...t})}},ez=class extends g{constructor(s,e){super(["scard",...s],e)}},ek=class extends g{constructor(s,e){super(["script","exists",...s],{deserialize:s=>s,...e})}},eU=class extends g{constructor([s],e){const t=["script","flush"];s?.sync?t.push("sync"):s?.async&&t.push("async"),super(t,e)}},eC=class extends g{constructor(s,e){super(["script","load",...s],e)}},eP=class extends g{constructor(s,e){super(["sdiff",...s],e)}},eI=class extends g{constructor(s,e){super(["sdiffstore",...s],e)}},eL=class extends g{constructor([s,e,t],n){const i=["set",s,e];t&&("nx"in t&&t.nx?i.push("nx"):"xx"in t&&t.xx&&i.push("xx"),"get"in t&&t.get&&i.push("get"),"ex"in t&&"number"==typeof t.ex?i.push("ex",t.ex):"px"in t&&"number"==typeof t.px?i.push("px",t.px):"exat"in t&&"number"==typeof t.exat?i.push("exat",t.exat):"pxat"in t&&"number"==typeof t.pxat?i.push("pxat",t.pxat):"keepTtl"in t&&t.keepTtl&&i.push("keepTtl")),super(i,n)}},eM=class extends g{constructor(s,e){super(["setbit",...s],e)}},eD=class extends g{constructor(s,e){super(["setex",...s],e)}},eJ=class extends g{constructor(s,e){super(["setnx",...s],e)}},ej=class extends g{constructor(s,e){super(["setrange",...s],e)}},e_=class extends g{constructor(s,e){super(["sinter",...s],e)}},eF=class extends g{constructor(s,e){super(["sinterstore",...s],e)}},eY=class extends g{constructor(s,e){super(["sismember",...s],e)}},e$=class extends g{constructor(s,e){super(["smembers",...s],e)}},eW=class extends g{constructor(s,e){super(["smismember",s[0],...s[1]],e)}},eX=class extends g{constructor(s,e){super(["smove",...s],e)}},eH=class extends g{constructor([s,e],t){const n=["spop",s];"number"==typeof e&&n.push(e),super(n,t)}},eG=class extends g{constructor([s,e],t){const n=["srandmember",s];"number"==typeof e&&n.push(e),super(n,t)}},eB=class extends g{constructor(s,e){super(["srem",...s],e)}},eK=class extends g{constructor([s,e,t],n){const i=["sscan",s,e];t?.match&&i.push("match",t.match),"number"==typeof t?.count&&i.push("count",t.count),super(i,{deserialize:p,...n})}},eq=class extends g{constructor(s,e){super(["strlen",...s],e)}},eV=class extends g{constructor(s,e){super(["sunion",...s],e)}},eQ=class extends g{constructor(s,e){super(["sunionstore",...s],e)}},eZ=class extends g{constructor(s){super(["time"],s)}},e1=class extends g{constructor(s,e){super(["touch",...s],e)}},e0=class extends g{constructor(s,e){super(["ttl",...s],e)}},e2=class extends g{constructor(s,e){super(["type",...s],e)}},e8=class extends g{constructor(s,e){super(["unlink",...s],e)}},e3=class extends g{constructor([s,e,t],n){super(["XACK",s,e,...Array.isArray(t)?[...t]:[t]],n)}},e6=class extends g{constructor([s,e,t,n],i){const r=["XADD",s];for(const[s,i]of(n&&(n.nomkStream&&r.push("NOMKSTREAM"),n.trim&&(r.push(n.trim.type,n.trim.comparison,n.trim.threshold),void 0!==n.trim.limit&&r.push("LIMIT",n.trim.limit))),r.push(e),Object.entries(t)))r.push(s,i);super(r,i)}},e5=class extends g{constructor([s,e,t,n,i,r],c){const o=[];r?.count&&o.push("COUNT",r.count),r?.justId&&o.push("JUSTID"),super(["XAUTOCLAIM",s,e,t,n,i,...o],c)}},e4=class extends g{constructor([s,e,t,n,i,r],c){const o=Array.isArray(i)?[...i]:[i],h=[];r?.idleMS&&h.push("IDLE",r.idleMS),r?.idleMS&&h.push("TIME",r.timeMS),r?.retryCount&&h.push("RETRYCOUNT",r.retryCount),r?.force&&h.push("FORCE"),r?.justId&&h.push("JUSTID"),r?.lastId&&h.push("LASTID",r.lastId),super(["XCLAIM",s,e,t,n,...o,...h],c)}},e9=class extends g{constructor([s,e],t){super(["XDEL",s,...Array.isArray(e)?[...e]:[e]],t)}},e7=class extends g{constructor([s,e],t){const n=["XGROUP"];switch(e.type){case"CREATE":n.push("CREATE",s,e.group,e.id),e.options&&(e.options.MKSTREAM&&n.push("MKSTREAM"),void 0!==e.options.ENTRIESREAD&&n.push("ENTRIESREAD",e.options.ENTRIESREAD.toString()));break;case"CREATECONSUMER":n.push("CREATECONSUMER",s,e.group,e.consumer);break;case"DELCONSUMER":n.push("DELCONSUMER",s,e.group,e.consumer);break;case"DESTROY":n.push("DESTROY",s,e.group);break;case"SETID":n.push("SETID",s,e.group,e.id),e.options?.ENTRIESREAD!==void 0&&n.push("ENTRIESREAD",e.options.ENTRIESREAD.toString());break;default:throw Error("Invalid XGROUP")}super(n,t)}},ts=class extends g{constructor([s,e],t){const n=[];"CONSUMERS"===e.type?n.push("CONSUMERS",s,e.group):n.push("GROUPS",s),super(["XINFO",...n],t)}},te=class extends g{constructor(s,e){super(["XLEN",...s],e)}},tt=class extends g{constructor([s,e,t,n,i,r],c){super(["XPENDING",s,e,...r?.idleTime?["IDLE",r.idleTime]:[],t,n,i,...r?.consumer===void 0?[]:Array.isArray(r.consumer)?[...r.consumer]:[r.consumer]],c)}},tn=class extends g{constructor([s,e,t,n],i){const r=["XRANGE",s,e,t];"number"==typeof n&&r.push("COUNT",n),super(r,{deserialize:s=>(function(s){let e={};for(let t of s)for(let s=0;s<t.length;s+=2){let n=t[s],i=t[s+1];n in e||(e[n]={});for(let s=0;s<i.length;s+=2){let t=i[s],r=i[s+1];try{e[n][t]=JSON.parse(r)}catch{e[n][t]=r}}}return e})(s),...i})}},ti=class extends g{constructor([s,e,t],n){if(Array.isArray(s)&&Array.isArray(e)&&s.length!==e.length)throw Error("ERR Unbalanced XREAD list of streams: for each stream key an ID or '$' must be specified");const i=[];"number"==typeof t?.count&&i.push("COUNT",t.count),"number"==typeof t?.blockMS&&i.push("BLOCK",t.blockMS),i.push("STREAMS",...Array.isArray(s)?[...s]:[s],...Array.isArray(e)?[...e]:[e]),super(["XREAD",...i],n)}},tr=class extends g{constructor([s,e,t,n,i],r){if(Array.isArray(t)&&Array.isArray(n)&&t.length!==n.length)throw Error("ERR Unbalanced XREADGROUP list of streams: for each stream key an ID or '$' must be specified");const c=[];"number"==typeof i?.count&&c.push("COUNT",i.count),"number"==typeof i?.blockMS&&c.push("BLOCK",i.blockMS),"boolean"==typeof i?.NOACK&&i.NOACK&&c.push("NOACK"),c.push("STREAMS",...Array.isArray(t)?[...t]:[t],...Array.isArray(n)?[...n]:[n]),super(["XREADGROUP","GROUP",s,e,...c],r)}},tc=class extends g{constructor([s,e,t,n],i){const r=["XREVRANGE",s,e,t];"number"==typeof n&&r.push("COUNT",n),super(r,{deserialize:s=>(function(s){let e={};for(let t of s)for(let s=0;s<t.length;s+=2){let n=t[s],i=t[s+1];n in e||(e[n]={});for(let s=0;s<i.length;s+=2){let t=i[s],r=i[s+1];try{e[n][t]=JSON.parse(r)}catch{e[n][t]=r}}}return e})(s),...i})}},to=class extends g{constructor([s,e],t){const{limit:n,strategy:i,threshold:r,exactness:c="~"}=e;super(["XTRIM",s,i,c,r,...n?["LIMIT",n]:[]],t)}},th=class extends g{constructor([s,e,...t],n){const i=["zadd",s];"nx"in e&&e.nx?i.push("nx"):"xx"in e&&e.xx&&i.push("xx"),"ch"in e&&e.ch&&i.push("ch"),"incr"in e&&e.incr&&i.push("incr"),"lt"in e&&e.lt?i.push("lt"):"gt"in e&&e.gt&&i.push("gt"),"score"in e&&"member"in e&&i.push(e.score,e.member),i.push(...t.flatMap(({score:s,member:e})=>[s,e])),super(i,n)}},ta=class extends g{constructor(s,e){super(["zcard",...s],e)}},tp=class extends g{constructor(s,e){super(["zcount",...s],e)}},tl=class extends g{constructor(s,e){super(["zincrby",...s],e)}},tu=class extends g{constructor([s,e,t,n],i){const r=["zinterstore",s,e];Array.isArray(t)?r.push(...t):r.push(t),n&&("weights"in n&&n.weights?r.push("weights",...n.weights):"weight"in n&&"number"==typeof n.weight&&r.push("weights",n.weight),"aggregate"in n&&r.push("aggregate",n.aggregate)),super(r,i)}},tm=class extends g{constructor(s,e){super(["zlexcount",...s],e)}},td=class extends g{constructor([s,e],t){const n=["zpopmax",s];"number"==typeof e&&n.push(e),super(n,t)}},tx=class extends g{constructor([s,e],t){const n=["zpopmin",s];"number"==typeof e&&n.push(e),super(n,t)}},tw=class extends g{constructor([s,e,t,n],i){const r=["zrange",s,e,t];n?.byScore&&r.push("byscore"),n?.byLex&&r.push("bylex"),n?.rev&&r.push("rev"),n?.count!==void 0&&void 0!==n.offset&&r.push("limit",n.offset,n.count),n?.withScores&&r.push("withscores"),super(r,i)}},ty=class extends g{constructor(s,e){super(["zrank",...s],e)}},tg=class extends g{constructor(s,e){super(["zrem",...s],e)}},tO=class extends g{constructor(s,e){super(["zremrangebylex",...s],e)}},tf=class extends g{constructor(s,e){super(["zremrangebyrank",...s],e)}},tb=class extends g{constructor(s,e){super(["zremrangebyscore",...s],e)}},tE=class extends g{constructor(s,e){super(["zrevrank",...s],e)}},tS=class extends g{constructor([s,e,t],n){const i=["zscan",s,e];t?.match&&i.push("match",t.match),"number"==typeof t?.count&&i.push("count",t.count),super(i,{deserialize:p,...n})}},tA=class extends g{constructor(s,e){super(["zscore",...s],e)}},tT=class extends g{constructor([s,e,t],n){const i=["zunion",s];Array.isArray(e)?i.push(...e):i.push(e),t&&("weights"in t&&t.weights?i.push("weights",...t.weights):"weight"in t&&"number"==typeof t.weight&&i.push("weights",t.weight),"aggregate"in t&&i.push("aggregate",t.aggregate),t.withScores&&i.push("withscores")),super(i,n)}},tR=class extends g{constructor([s,e,t,n],i){const r=["zunionstore",s,e];Array.isArray(t)?r.push(...t):r.push(t),n&&("weights"in n&&n.weights?r.push("weights",...n.weights):"weight"in n&&"number"==typeof n.weight&&r.push("weights",n.weight),"aggregate"in n&&r.push("aggregate",n.aggregate)),super(r,i)}},tN=class extends g{constructor(s,e){super(["zdiffstore",...s],e)}},tv=class extends g{constructor(s,e){const[t,n]=s;super(["zmscore",t,...n],e)}},tz=class{client;commands;commandOptions;multiExec;constructor(s){if(this.client=s.client,this.commands=[],this.commandOptions=s.commandOptions,this.multiExec=s.multiExec??!1,this.commandOptions?.latencyLogging){const s=this.exec.bind(this);this.exec=async e=>{let t=performance.now(),n=await (e?s(e):s()),i=(performance.now()-t).toFixed(2);return console.log(`Latency for \x1b[38;2;19;185;39m${this.multiExec?["MULTI-EXEC"]:["PIPELINE"].toString().toUpperCase()}\x1b[0m: \x1b[38;2;0;255;255m${i} ms\x1b[0m`),n}}}exec=async s=>{if(0===this.commands.length)throw Error("Pipeline is empty");let e=this.multiExec?["multi-exec"]:["pipeline"],t=await this.client.request({path:e,body:Object.values(this.commands).map(s=>s.command)});return s?.keepErrors?t.map(({error:s,result:e},t)=>({error:s,result:this.commands[t].deserialize(e)})):t.map(({error:s,result:e},t)=>{if(s)throw new c(`Command ${t+1} [ ${this.commands[t].command[0]} ] failed: ${s}`);return this.commands[t].deserialize(e)})};length(){return this.commands.length}chain(s){return this.commands.push(s),this}append=(...s)=>this.chain(new f(s,this.commandOptions));bitcount=(...s)=>this.chain(new b(s,this.commandOptions));bitfield=(...s)=>new E(s,this.client,this.commandOptions,this.chain.bind(this));bitop=(s,e,t,...n)=>this.chain(new S([s,e,t,...n],this.commandOptions));bitpos=(...s)=>this.chain(new A(s,this.commandOptions));copy=(...s)=>this.chain(new T(s,this.commandOptions));zdiffstore=(...s)=>this.chain(new tN(s,this.commandOptions));dbsize=()=>this.chain(new R(this.commandOptions));decr=(...s)=>this.chain(new N(s,this.commandOptions));decrby=(...s)=>this.chain(new v(s,this.commandOptions));del=(...s)=>this.chain(new z(s,this.commandOptions));echo=(...s)=>this.chain(new k(s,this.commandOptions));evalRo=(...s)=>this.chain(new U(s,this.commandOptions));eval=(...s)=>this.chain(new C(s,this.commandOptions));evalshaRo=(...s)=>this.chain(new P(s,this.commandOptions));evalsha=(...s)=>this.chain(new I(s,this.commandOptions));exists=(...s)=>this.chain(new M(s,this.commandOptions));expire=(...s)=>this.chain(new D(s,this.commandOptions));expireat=(...s)=>this.chain(new J(s,this.commandOptions));flushall=s=>this.chain(new F(s,this.commandOptions));flushdb=(...s)=>this.chain(new Y(s,this.commandOptions));geoadd=(...s)=>this.chain(new q(s,this.commandOptions));geodist=(...s)=>this.chain(new V(s,this.commandOptions));geopos=(...s)=>this.chain(new Z(s,this.commandOptions));geohash=(...s)=>this.chain(new Q(s,this.commandOptions));geosearch=(...s)=>this.chain(new ss(s,this.commandOptions));geosearchstore=(...s)=>this.chain(new se(s,this.commandOptions));get=(...s)=>this.chain(new st(s,this.commandOptions));getbit=(...s)=>this.chain(new sn(s,this.commandOptions));getdel=(...s)=>this.chain(new si(s,this.commandOptions));getex=(...s)=>this.chain(new sr(s,this.commandOptions));getrange=(...s)=>this.chain(new sc(s,this.commandOptions));getset=(s,e)=>this.chain(new so([s,e],this.commandOptions));hdel=(...s)=>this.chain(new sh(s,this.commandOptions));hexists=(...s)=>this.chain(new sa(s,this.commandOptions));hexpire=(...s)=>this.chain(new sp(s,this.commandOptions));hexpireat=(...s)=>this.chain(new sl(s,this.commandOptions));hexpiretime=(...s)=>this.chain(new su(s,this.commandOptions));httl=(...s)=>this.chain(new sk(s,this.commandOptions));hpexpire=(...s)=>this.chain(new sd(s,this.commandOptions));hpexpireat=(...s)=>this.chain(new sx(s,this.commandOptions));hpexpiretime=(...s)=>this.chain(new sw(s,this.commandOptions));hpttl=(...s)=>this.chain(new sy(s,this.commandOptions));hpersist=(...s)=>this.chain(new sm(s,this.commandOptions));hget=(...s)=>this.chain(new sg(s,this.commandOptions));hgetall=(...s)=>this.chain(new sO(s,this.commandOptions));hincrby=(...s)=>this.chain(new sf(s,this.commandOptions));hincrbyfloat=(...s)=>this.chain(new sb(s,this.commandOptions));hkeys=(...s)=>this.chain(new sE(s,this.commandOptions));hlen=(...s)=>this.chain(new sS(s,this.commandOptions));hmget=(...s)=>this.chain(new sA(s,this.commandOptions));hmset=(s,e)=>this.chain(new sT([s,e],this.commandOptions));hrandfield=(s,e,t)=>this.chain(new O([s,e,t],this.commandOptions));hscan=(...s)=>this.chain(new sR(s,this.commandOptions));hset=(s,e)=>this.chain(new sN([s,e],this.commandOptions));hsetnx=(s,e,t)=>this.chain(new sv([s,e,t],this.commandOptions));hstrlen=(...s)=>this.chain(new sz(s,this.commandOptions));hvals=(...s)=>this.chain(new sU(s,this.commandOptions));incr=(...s)=>this.chain(new sC(s,this.commandOptions));incrby=(...s)=>this.chain(new sP(s,this.commandOptions));incrbyfloat=(...s)=>this.chain(new sI(s,this.commandOptions));keys=(...s)=>this.chain(new s3(s,this.commandOptions));lindex=(...s)=>this.chain(new s6(s,this.commandOptions));linsert=(s,e,t,n)=>this.chain(new s5([s,e,t,n],this.commandOptions));llen=(...s)=>this.chain(new s4(s,this.commandOptions));lmove=(...s)=>this.chain(new s9(s,this.commandOptions));lpop=(...s)=>this.chain(new es(s,this.commandOptions));lmpop=(...s)=>this.chain(new s7(s,this.commandOptions));lpos=(...s)=>this.chain(new ee(s,this.commandOptions));lpush=(s,...e)=>this.chain(new et([s,...e],this.commandOptions));lpushx=(s,...e)=>this.chain(new en([s,...e],this.commandOptions));lrange=(...s)=>this.chain(new ei(s,this.commandOptions));lrem=(s,e,t)=>this.chain(new er([s,e,t],this.commandOptions));lset=(s,e,t)=>this.chain(new ec([s,e,t],this.commandOptions));ltrim=(...s)=>this.chain(new eo(s,this.commandOptions));mget=(...s)=>this.chain(new eh(s,this.commandOptions));mset=s=>this.chain(new ea([s],this.commandOptions));msetnx=s=>this.chain(new ep([s],this.commandOptions));persist=(...s)=>this.chain(new el(s,this.commandOptions));pexpire=(...s)=>this.chain(new eu(s,this.commandOptions));pexpireat=(...s)=>this.chain(new em(s,this.commandOptions));pfadd=(...s)=>this.chain(new ed(s,this.commandOptions));pfcount=(...s)=>this.chain(new ex(s,this.commandOptions));pfmerge=(...s)=>this.chain(new ew(s,this.commandOptions));ping=s=>this.chain(new ey(s,this.commandOptions));psetex=(s,e,t)=>this.chain(new eg([s,e,t],this.commandOptions));pttl=(...s)=>this.chain(new eO(s,this.commandOptions));publish=(...s)=>this.chain(new ef(s,this.commandOptions));randomkey=()=>this.chain(new eb(this.commandOptions));rename=(...s)=>this.chain(new eE(s,this.commandOptions));renamenx=(...s)=>this.chain(new eS(s,this.commandOptions));rpop=(...s)=>this.chain(new eA(s,this.commandOptions));rpush=(s,...e)=>this.chain(new eT([s,...e],this.commandOptions));rpushx=(s,...e)=>this.chain(new eR([s,...e],this.commandOptions));sadd=(s,e,...t)=>this.chain(new eN([s,e,...t],this.commandOptions));scan=(...s)=>this.chain(new ev(s,this.commandOptions));scard=(...s)=>this.chain(new ez(s,this.commandOptions));scriptExists=(...s)=>this.chain(new ek(s,this.commandOptions));scriptFlush=(...s)=>this.chain(new eU(s,this.commandOptions));scriptLoad=(...s)=>this.chain(new eC(s,this.commandOptions));sdiff=(...s)=>this.chain(new eP(s,this.commandOptions));sdiffstore=(...s)=>this.chain(new eI(s,this.commandOptions));set=(s,e,t)=>this.chain(new eL([s,e,t],this.commandOptions));setbit=(...s)=>this.chain(new eM(s,this.commandOptions));setex=(s,e,t)=>this.chain(new eD([s,e,t],this.commandOptions));setnx=(s,e)=>this.chain(new eJ([s,e],this.commandOptions));setrange=(...s)=>this.chain(new ej(s,this.commandOptions));sinter=(...s)=>this.chain(new e_(s,this.commandOptions));sinterstore=(...s)=>this.chain(new eF(s,this.commandOptions));sismember=(s,e)=>this.chain(new eY([s,e],this.commandOptions));smembers=(...s)=>this.chain(new e$(s,this.commandOptions));smismember=(s,e)=>this.chain(new eW([s,e],this.commandOptions));smove=(s,e,t)=>this.chain(new eX([s,e,t],this.commandOptions));spop=(...s)=>this.chain(new eH(s,this.commandOptions));srandmember=(...s)=>this.chain(new eG(s,this.commandOptions));srem=(s,...e)=>this.chain(new eB([s,...e],this.commandOptions));sscan=(...s)=>this.chain(new eK(s,this.commandOptions));strlen=(...s)=>this.chain(new eq(s,this.commandOptions));sunion=(...s)=>this.chain(new eV(s,this.commandOptions));sunionstore=(...s)=>this.chain(new eQ(s,this.commandOptions));time=()=>this.chain(new eZ(this.commandOptions));touch=(...s)=>this.chain(new e1(s,this.commandOptions));ttl=(...s)=>this.chain(new e0(s,this.commandOptions));type=(...s)=>this.chain(new e2(s,this.commandOptions));unlink=(...s)=>this.chain(new e8(s,this.commandOptions));zadd=(...s)=>("score"in s[1],this.chain(new th([s[0],s[1],...s.slice(2)],this.commandOptions)));xadd=(...s)=>this.chain(new e6(s,this.commandOptions));xack=(...s)=>this.chain(new e3(s,this.commandOptions));xdel=(...s)=>this.chain(new e9(s,this.commandOptions));xgroup=(...s)=>this.chain(new e7(s,this.commandOptions));xread=(...s)=>this.chain(new ti(s,this.commandOptions));xreadgroup=(...s)=>this.chain(new tr(s,this.commandOptions));xinfo=(...s)=>this.chain(new ts(s,this.commandOptions));xlen=(...s)=>this.chain(new te(s,this.commandOptions));xpending=(...s)=>this.chain(new tt(s,this.commandOptions));xclaim=(...s)=>this.chain(new e4(s,this.commandOptions));xautoclaim=(...s)=>this.chain(new e5(s,this.commandOptions));xtrim=(...s)=>this.chain(new to(s,this.commandOptions));xrange=(...s)=>this.chain(new tn(s,this.commandOptions));xrevrange=(...s)=>this.chain(new tc(s,this.commandOptions));zcard=(...s)=>this.chain(new ta(s,this.commandOptions));zcount=(...s)=>this.chain(new tp(s,this.commandOptions));zincrby=(s,e,t)=>this.chain(new tl([s,e,t],this.commandOptions));zinterstore=(...s)=>this.chain(new tu(s,this.commandOptions));zlexcount=(...s)=>this.chain(new tm(s,this.commandOptions));zmscore=(...s)=>this.chain(new tv(s,this.commandOptions));zpopmax=(...s)=>this.chain(new td(s,this.commandOptions));zpopmin=(...s)=>this.chain(new tx(s,this.commandOptions));zrange=(...s)=>this.chain(new tw(s,this.commandOptions));zrank=(s,e)=>this.chain(new ty([s,e],this.commandOptions));zrem=(s,...e)=>this.chain(new tg([s,...e],this.commandOptions));zremrangebylex=(...s)=>this.chain(new tO(s,this.commandOptions));zremrangebyrank=(...s)=>this.chain(new tf(s,this.commandOptions));zremrangebyscore=(...s)=>this.chain(new tb(s,this.commandOptions));zrevrank=(s,e)=>this.chain(new tE([s,e],this.commandOptions));zscan=(...s)=>this.chain(new tS(s,this.commandOptions));zscore=(s,e)=>this.chain(new tA([s,e],this.commandOptions));zunionstore=(...s)=>this.chain(new tR(s,this.commandOptions));zunion=(...s)=>this.chain(new tT(s,this.commandOptions));get json(){return{arrappend:(...s)=>this.chain(new sL(s,this.commandOptions)),arrindex:(...s)=>this.chain(new sM(s,this.commandOptions)),arrinsert:(...s)=>this.chain(new sD(s,this.commandOptions)),arrlen:(...s)=>this.chain(new sJ(s,this.commandOptions)),arrpop:(...s)=>this.chain(new sj(s,this.commandOptions)),arrtrim:(...s)=>this.chain(new s_(s,this.commandOptions)),clear:(...s)=>this.chain(new sF(s,this.commandOptions)),del:(...s)=>this.chain(new sY(s,this.commandOptions)),forget:(...s)=>this.chain(new s$(s,this.commandOptions)),get:(...s)=>this.chain(new sW(s,this.commandOptions)),merge:(...s)=>this.chain(new sX(s,this.commandOptions)),mget:(...s)=>this.chain(new sH(s,this.commandOptions)),mset:(...s)=>this.chain(new sG(s,this.commandOptions)),numincrby:(...s)=>this.chain(new sB(s,this.commandOptions)),nummultby:(...s)=>this.chain(new sK(s,this.commandOptions)),objkeys:(...s)=>this.chain(new sq(s,this.commandOptions)),objlen:(...s)=>this.chain(new sV(s,this.commandOptions)),resp:(...s)=>this.chain(new sQ(s,this.commandOptions)),set:(...s)=>this.chain(new sZ(s,this.commandOptions)),strappend:(...s)=>this.chain(new s1(s,this.commandOptions)),strlen:(...s)=>this.chain(new s0(s,this.commandOptions)),toggle:(...s)=>this.chain(new s2(s,this.commandOptions)),type:(...s)=>this.chain(new s8(s,this.commandOptions))}}get functions(){return{load:(...s)=>this.chain(new G(s,this.commandOptions)),list:(...s)=>this.chain(new X(s,this.commandOptions)),delete:(...s)=>this.chain(new $(s,this.commandOptions)),flush:()=>this.chain(new W(this.commandOptions)),stats:()=>this.chain(new B(this.commandOptions)),call:(...s)=>this.chain(new j(s,this.commandOptions)),callRo:(...s)=>this.chain(new _(s,this.commandOptions))}}},tk=new Set(["scan","keys","flushdb","flushall","dbsize","hscan","hgetall","hkeys","lrange","sscan","smembers","xrange","xrevrange","zscan","zrange","exec"]),tU=class{pipelinePromises=new WeakMap;activePipeline=null;indexInCurrentPipeline=0;redis;pipeline;pipelineCounter=0;constructor(s){this.redis=s,this.pipeline=s.pipeline()}async withAutoPipeline(s){let e=this.activePipeline??this.redis.pipeline();this.activePipeline||(this.activePipeline=e,this.indexInCurrentPipeline=0);let t=this.indexInCurrentPipeline++;s(e);let n=this.deferExecution().then(()=>{if(!this.pipelinePromises.has(e)){let s=e.exec({keepErrors:!0});this.pipelineCounter+=1,this.pipelinePromises.set(e,s),this.activePipeline=null}return this.pipelinePromises.get(e)}),i=(await n)[t];if(i.error)throw new c(`Command failed: ${i.error}`);return i.result}async deferExecution(){await Promise.resolve(),await Promise.resolve()}},tC=class extends g{constructor(s,e){super([],{...e,headers:{Accept:"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"},path:["psubscribe",...s],streamOptions:{isStreaming:!0,onMessage:e?.streamOptions?.onMessage,signal:e?.streamOptions?.signal}})}},tP=class extends EventTarget{subscriptions;client;listeners;opts;constructor(s,e,t=!1,n){for(const i of(super(),this.client=s,this.subscriptions=new Map,this.listeners=new Map,this.opts=n,e))t?this.subscribeToPattern(i):this.subscribeToChannel(i)}subscribeToChannel(s){let e=new AbortController,t=new tI([s],{streamOptions:{signal:e.signal,onMessage:s=>this.handleMessage(s,!1)}});t.exec(this.client).catch(s=>{"AbortError"!==s.name&&this.dispatchToListeners("error",s)}),this.subscriptions.set(s,{command:t,controller:e,isPattern:!1})}subscribeToPattern(s){let e=new AbortController,t=new tC([s],{streamOptions:{signal:e.signal,onMessage:s=>this.handleMessage(s,!0)}});t.exec(this.client).catch(s=>{"AbortError"!==s.name&&this.dispatchToListeners("error",s)}),this.subscriptions.set(s,{command:t,controller:e,isPattern:!0})}handleMessage(s,e){let t=s.replace(/^data:\s*/,""),n=t.indexOf(","),i=t.indexOf(",",n+1),r=e?t.indexOf(",",i+1):-1;if(-1!==n&&-1!==i){let s=t.slice(0,n);if(e&&"pmessage"===s&&-1!==r){let s=t.slice(n+1,i),e=t.slice(i+1,r),c=t.slice(r+1);try{let t=this.opts?.automaticDeserialization===!1?c:JSON.parse(c);this.dispatchToListeners("pmessage",{pattern:s,channel:e,message:t}),this.dispatchToListeners(`pmessage:${s}`,{pattern:s,channel:e,message:t})}catch(s){this.dispatchToListeners("error",Error(`Failed to parse message: ${s}`))}}else{let e=t.slice(n+1,i),r=t.slice(i+1);try{if("subscribe"===s||"psubscribe"===s||"unsubscribe"===s||"punsubscribe"===s){let e=Number.parseInt(r);this.dispatchToListeners(s,e)}else{let t=this.opts?.automaticDeserialization===!1?r:tL(r);this.dispatchToListeners(s,{channel:e,message:t}),this.dispatchToListeners(`${s}:${e}`,{channel:e,message:t})}}catch(s){this.dispatchToListeners("error",Error(`Failed to parse message: ${s}`))}}}}dispatchToListeners(s,e){let t=this.listeners.get(s);if(t)for(let s of t)s(e)}on(s,e){this.listeners.has(s)||this.listeners.set(s,new Set),this.listeners.get(s)?.add(e)}removeAllListeners(){this.listeners.clear()}async unsubscribe(s){if(s)for(let e of s){let s=this.subscriptions.get(e);if(s){try{s.controller.abort()}catch{}this.subscriptions.delete(e)}}else{for(let s of this.subscriptions.values())try{s.controller.abort()}catch{}this.subscriptions.clear(),this.removeAllListeners()}}getSubscribedChannels(){return[...this.subscriptions.keys()]}},tI=class extends g{constructor(s,e){super([],{...e,headers:{Accept:"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"},path:["subscribe",...s],streamOptions:{isStreaming:!0,onMessage:e?.streamOptions?.onMessage,signal:e?.streamOptions?.signal}})}},tL=s=>{try{return JSON.parse(s)}catch{return s}},tM=class{script;sha1;redis;constructor(s,e){this.redis=s,this.script=e,this.sha1="",this.init(e)}async init(s){this.sha1||(this.sha1=await this.digest(s))}async eval(s,e){return await this.init(this.script),await this.redis.eval(this.script,s,e)}async evalsha(s,e){return await this.init(this.script),await this.redis.evalsha(this.sha1,s,e)}async exec(s,e){return await this.init(this.script),await this.redis.evalsha(this.sha1,s,e).catch(async t=>{if(t instanceof Error&&t.message.toLowerCase().includes("noscript"))return await this.redis.eval(this.script,s,e);throw t})}async digest(s){let t=new TextEncoder().encode(s);return[...new Uint8Array(await e.subtle.digest("SHA-1",t))].map(s=>s.toString(16).padStart(2,"0")).join("")}},tD=class{script;sha1;redis;constructor(s,e){this.redis=s,this.sha1="",this.script=e,this.init(e)}async init(s){this.sha1||(this.sha1=await this.digest(s))}async evalRo(s,e){return await this.init(this.script),await this.redis.evalRo(this.script,s,e)}async evalshaRo(s,e){return await this.init(this.script),await this.redis.evalshaRo(this.sha1,s,e)}async exec(s,e){return await this.init(this.script),await this.redis.evalshaRo(this.sha1,s,e).catch(async t=>{if(t instanceof Error&&t.message.toLowerCase().includes("noscript"))return await this.redis.evalRo(this.script,s,e);throw t})}async digest(s){let t=new TextEncoder().encode(s);return[...new Uint8Array(await e.subtle.digest("SHA-1",t))].map(s=>s.toString(16).padStart(2,"0")).join("")}},tJ=class{client;opts;enableTelemetry;enableAutoPipelining;constructor(s,e){this.client=s,this.opts=e,this.enableTelemetry=e?.enableTelemetry??!0,e?.readYourWrites===!1&&(this.client.readYourWrites=!1),this.enableAutoPipelining=e?.enableAutoPipelining??!0}get readYourWritesSyncToken(){return this.client.upstashSyncToken}set readYourWritesSyncToken(s){this.client.upstashSyncToken=s}get json(){return{arrappend:(...s)=>new sL(s,this.opts).exec(this.client),arrindex:(...s)=>new sM(s,this.opts).exec(this.client),arrinsert:(...s)=>new sD(s,this.opts).exec(this.client),arrlen:(...s)=>new sJ(s,this.opts).exec(this.client),arrpop:(...s)=>new sj(s,this.opts).exec(this.client),arrtrim:(...s)=>new s_(s,this.opts).exec(this.client),clear:(...s)=>new sF(s,this.opts).exec(this.client),del:(...s)=>new sY(s,this.opts).exec(this.client),forget:(...s)=>new s$(s,this.opts).exec(this.client),get:(...s)=>new sW(s,this.opts).exec(this.client),merge:(...s)=>new sX(s,this.opts).exec(this.client),mget:(...s)=>new sH(s,this.opts).exec(this.client),mset:(...s)=>new sG(s,this.opts).exec(this.client),numincrby:(...s)=>new sB(s,this.opts).exec(this.client),nummultby:(...s)=>new sK(s,this.opts).exec(this.client),objkeys:(...s)=>new sq(s,this.opts).exec(this.client),objlen:(...s)=>new sV(s,this.opts).exec(this.client),resp:(...s)=>new sQ(s,this.opts).exec(this.client),set:(...s)=>new sZ(s,this.opts).exec(this.client),strappend:(...s)=>new s1(s,this.opts).exec(this.client),strlen:(...s)=>new s0(s,this.opts).exec(this.client),toggle:(...s)=>new s2(s,this.opts).exec(this.client),type:(...s)=>new s8(s,this.opts).exec(this.client)}}get functions(){return{load:(...s)=>new G(s,this.opts).exec(this.client),list:(...s)=>new X(s,this.opts).exec(this.client),delete:(...s)=>new $(s,this.opts).exec(this.client),flush:()=>new W(this.opts).exec(this.client),stats:()=>new B(this.opts).exec(this.client),call:(...s)=>new j(s,this.opts).exec(this.client),callRo:(...s)=>new _(s,this.opts).exec(this.client)}}use=s=>{let e=this.client.request.bind(this.client);this.client.request=t=>s(t,e)};addTelemetry=s=>{if(this.enableTelemetry)try{this.client.mergeTelemetry(s)}catch{}};createScript(s,e){return e?.readonly?new tD(this,s):new tM(this,s)}pipeline=()=>new tz({client:this.client,commandOptions:this.opts,multiExec:!1});autoPipeline=()=>(function s(e,t="root"){return e.autoPipelineExecutor||(e.autoPipelineExecutor=new tU(e)),new Proxy(e,{get:(e,n)=>{if("pipelineCounter"===n)return e.autoPipelineExecutor.pipelineCounter;if("root"===t&&"json"===n)return s(e,"json");if("root"===t&&"functions"===n)return s(e,"functions");if("root"===t){let s=n in e&&!(n in e.autoPipelineExecutor.pipeline),t=tk.has(n);if(s||t)return e[n]}let i=e.autoPipelineExecutor.pipeline,r="json"===t?i.json[n]:"functions"===t?i.functions[n]:i[n];return"function"==typeof r?(...s)=>e.autoPipelineExecutor.withAutoPipeline(e=>{("json"===t?e.json[n]:"functions"===t?e.functions[n]:e[n])(...s)}):r}})})(this);multi=()=>new tz({client:this.client,commandOptions:this.opts,multiExec:!0});bitfield=(...s)=>new E(s,this.client,this.opts);append=(...s)=>new f(s,this.opts).exec(this.client);bitcount=(...s)=>new b(s,this.opts).exec(this.client);bitop=(s,e,t,...n)=>new S([s,e,t,...n],this.opts).exec(this.client);bitpos=(...s)=>new A(s,this.opts).exec(this.client);copy=(...s)=>new T(s,this.opts).exec(this.client);dbsize=()=>new R(this.opts).exec(this.client);decr=(...s)=>new N(s,this.opts).exec(this.client);decrby=(...s)=>new v(s,this.opts).exec(this.client);del=(...s)=>new z(s,this.opts).exec(this.client);echo=(...s)=>new k(s,this.opts).exec(this.client);evalRo=(...s)=>new U(s,this.opts).exec(this.client);eval=(...s)=>new C(s,this.opts).exec(this.client);evalshaRo=(...s)=>new P(s,this.opts).exec(this.client);evalsha=(...s)=>new I(s,this.opts).exec(this.client);exec=s=>new L(s,this.opts).exec(this.client);exists=(...s)=>new M(s,this.opts).exec(this.client);expire=(...s)=>new D(s,this.opts).exec(this.client);expireat=(...s)=>new J(s,this.opts).exec(this.client);flushall=s=>new F(s,this.opts).exec(this.client);flushdb=(...s)=>new Y(s,this.opts).exec(this.client);geoadd=(...s)=>new q(s,this.opts).exec(this.client);geopos=(...s)=>new Z(s,this.opts).exec(this.client);geodist=(...s)=>new V(s,this.opts).exec(this.client);geohash=(...s)=>new Q(s,this.opts).exec(this.client);geosearch=(...s)=>new ss(s,this.opts).exec(this.client);geosearchstore=(...s)=>new se(s,this.opts).exec(this.client);get=(...s)=>new st(s,this.opts).exec(this.client);getbit=(...s)=>new sn(s,this.opts).exec(this.client);getdel=(...s)=>new si(s,this.opts).exec(this.client);getex=(...s)=>new sr(s,this.opts).exec(this.client);getrange=(...s)=>new sc(s,this.opts).exec(this.client);getset=(s,e)=>new so([s,e],this.opts).exec(this.client);hdel=(...s)=>new sh(s,this.opts).exec(this.client);hexists=(...s)=>new sa(s,this.opts).exec(this.client);hexpire=(...s)=>new sp(s,this.opts).exec(this.client);hexpireat=(...s)=>new sl(s,this.opts).exec(this.client);hexpiretime=(...s)=>new su(s,this.opts).exec(this.client);httl=(...s)=>new sk(s,this.opts).exec(this.client);hpexpire=(...s)=>new sd(s,this.opts).exec(this.client);hpexpireat=(...s)=>new sx(s,this.opts).exec(this.client);hpexpiretime=(...s)=>new sw(s,this.opts).exec(this.client);hpttl=(...s)=>new sy(s,this.opts).exec(this.client);hpersist=(...s)=>new sm(s,this.opts).exec(this.client);hget=(...s)=>new sg(s,this.opts).exec(this.client);hgetall=(...s)=>new sO(s,this.opts).exec(this.client);hincrby=(...s)=>new sf(s,this.opts).exec(this.client);hincrbyfloat=(...s)=>new sb(s,this.opts).exec(this.client);hkeys=(...s)=>new sE(s,this.opts).exec(this.client);hlen=(...s)=>new sS(s,this.opts).exec(this.client);hmget=(...s)=>new sA(s,this.opts).exec(this.client);hmset=(s,e)=>new sT([s,e],this.opts).exec(this.client);hrandfield=(s,e,t)=>new O([s,e,t],this.opts).exec(this.client);hscan=(...s)=>new sR(s,this.opts).exec(this.client);hset=(s,e)=>new sN([s,e],this.opts).exec(this.client);hsetnx=(s,e,t)=>new sv([s,e,t],this.opts).exec(this.client);hstrlen=(...s)=>new sz(s,this.opts).exec(this.client);hvals=(...s)=>new sU(s,this.opts).exec(this.client);incr=(...s)=>new sC(s,this.opts).exec(this.client);incrby=(...s)=>new sP(s,this.opts).exec(this.client);incrbyfloat=(...s)=>new sI(s,this.opts).exec(this.client);keys=(...s)=>new s3(s,this.opts).exec(this.client);lindex=(...s)=>new s6(s,this.opts).exec(this.client);linsert=(s,e,t,n)=>new s5([s,e,t,n],this.opts).exec(this.client);llen=(...s)=>new s4(s,this.opts).exec(this.client);lmove=(...s)=>new s9(s,this.opts).exec(this.client);lpop=(...s)=>new es(s,this.opts).exec(this.client);lmpop=(...s)=>new s7(s,this.opts).exec(this.client);lpos=(...s)=>new ee(s,this.opts).exec(this.client);lpush=(s,...e)=>new et([s,...e],this.opts).exec(this.client);lpushx=(s,...e)=>new en([s,...e],this.opts).exec(this.client);lrange=(...s)=>new ei(s,this.opts).exec(this.client);lrem=(s,e,t)=>new er([s,e,t],this.opts).exec(this.client);lset=(s,e,t)=>new ec([s,e,t],this.opts).exec(this.client);ltrim=(...s)=>new eo(s,this.opts).exec(this.client);mget=(...s)=>new eh(s,this.opts).exec(this.client);mset=s=>new ea([s],this.opts).exec(this.client);msetnx=s=>new ep([s],this.opts).exec(this.client);persist=(...s)=>new el(s,this.opts).exec(this.client);pexpire=(...s)=>new eu(s,this.opts).exec(this.client);pexpireat=(...s)=>new em(s,this.opts).exec(this.client);pfadd=(...s)=>new ed(s,this.opts).exec(this.client);pfcount=(...s)=>new ex(s,this.opts).exec(this.client);pfmerge=(...s)=>new ew(s,this.opts).exec(this.client);ping=s=>new ey(s,this.opts).exec(this.client);psetex=(s,e,t)=>new eg([s,e,t],this.opts).exec(this.client);psubscribe=s=>{let e=Array.isArray(s)?s:[s];return new tP(this.client,e,!0,this.opts)};pttl=(...s)=>new eO(s,this.opts).exec(this.client);publish=(...s)=>new ef(s,this.opts).exec(this.client);randomkey=()=>new eb().exec(this.client);rename=(...s)=>new eE(s,this.opts).exec(this.client);renamenx=(...s)=>new eS(s,this.opts).exec(this.client);rpop=(...s)=>new eA(s,this.opts).exec(this.client);rpush=(s,...e)=>new eT([s,...e],this.opts).exec(this.client);rpushx=(s,...e)=>new eR([s,...e],this.opts).exec(this.client);sadd=(s,e,...t)=>new eN([s,e,...t],this.opts).exec(this.client);scan(s,e){return new ev([s,e],this.opts).exec(this.client)}scard=(...s)=>new ez(s,this.opts).exec(this.client);scriptExists=(...s)=>new ek(s,this.opts).exec(this.client);scriptFlush=(...s)=>new eU(s,this.opts).exec(this.client);scriptLoad=(...s)=>new eC(s,this.opts).exec(this.client);sdiff=(...s)=>new eP(s,this.opts).exec(this.client);sdiffstore=(...s)=>new eI(s,this.opts).exec(this.client);set=(s,e,t)=>new eL([s,e,t],this.opts).exec(this.client);setbit=(...s)=>new eM(s,this.opts).exec(this.client);setex=(s,e,t)=>new eD([s,e,t],this.opts).exec(this.client);setnx=(s,e)=>new eJ([s,e],this.opts).exec(this.client);setrange=(...s)=>new ej(s,this.opts).exec(this.client);sinter=(...s)=>new e_(s,this.opts).exec(this.client);sinterstore=(...s)=>new eF(s,this.opts).exec(this.client);sismember=(s,e)=>new eY([s,e],this.opts).exec(this.client);smismember=(s,e)=>new eW([s,e],this.opts).exec(this.client);smembers=(...s)=>new e$(s,this.opts).exec(this.client);smove=(s,e,t)=>new eX([s,e,t],this.opts).exec(this.client);spop=(...s)=>new eH(s,this.opts).exec(this.client);srandmember=(...s)=>new eG(s,this.opts).exec(this.client);srem=(s,...e)=>new eB([s,...e],this.opts).exec(this.client);sscan=(...s)=>new eK(s,this.opts).exec(this.client);strlen=(...s)=>new eq(s,this.opts).exec(this.client);subscribe=s=>{let e=Array.isArray(s)?s:[s];return new tP(this.client,e,!1,this.opts)};sunion=(...s)=>new eV(s,this.opts).exec(this.client);sunionstore=(...s)=>new eQ(s,this.opts).exec(this.client);time=()=>new eZ().exec(this.client);touch=(...s)=>new e1(s,this.opts).exec(this.client);ttl=(...s)=>new e0(s,this.opts).exec(this.client);type=(...s)=>new e2(s,this.opts).exec(this.client);unlink=(...s)=>new e8(s,this.opts).exec(this.client);xadd=(...s)=>new e6(s,this.opts).exec(this.client);xack=(...s)=>new e3(s,this.opts).exec(this.client);xdel=(...s)=>new e9(s,this.opts).exec(this.client);xgroup=(...s)=>new e7(s,this.opts).exec(this.client);xread=(...s)=>new ti(s,this.opts).exec(this.client);xreadgroup=(...s)=>new tr(s,this.opts).exec(this.client);xinfo=(...s)=>new ts(s,this.opts).exec(this.client);xlen=(...s)=>new te(s,this.opts).exec(this.client);xpending=(...s)=>new tt(s,this.opts).exec(this.client);xclaim=(...s)=>new e4(s,this.opts).exec(this.client);xautoclaim=(...s)=>new e5(s,this.opts).exec(this.client);xtrim=(...s)=>new to(s,this.opts).exec(this.client);xrange=(...s)=>new tn(s,this.opts).exec(this.client);xrevrange=(...s)=>new tc(s,this.opts).exec(this.client);zadd=(...s)=>("score"in s[1],new th([s[0],s[1],...s.slice(2)],this.opts).exec(this.client));zcard=(...s)=>new ta(s,this.opts).exec(this.client);zcount=(...s)=>new tp(s,this.opts).exec(this.client);zdiffstore=(...s)=>new tN(s,this.opts).exec(this.client);zincrby=(s,e,t)=>new tl([s,e,t],this.opts).exec(this.client);zinterstore=(...s)=>new tu(s,this.opts).exec(this.client);zlexcount=(...s)=>new tm(s,this.opts).exec(this.client);zmscore=(...s)=>new tv(s,this.opts).exec(this.client);zpopmax=(...s)=>new td(s,this.opts).exec(this.client);zpopmin=(...s)=>new tx(s,this.opts).exec(this.client);zrange=(...s)=>new tw(s,this.opts).exec(this.client);zrank=(s,e)=>new ty([s,e],this.opts).exec(this.client);zrem=(s,...e)=>new tg([s,...e],this.opts).exec(this.client);zremrangebylex=(...s)=>new tO(s,this.opts).exec(this.client);zremrangebyrank=(...s)=>new tf(s,this.opts).exec(this.client);zremrangebyscore=(...s)=>new tb(s,this.opts).exec(this.client);zrevrank=(s,e)=>new tE([s,e],this.opts).exec(this.client);zscan=(...s)=>new tS(s,this.opts).exec(this.client);zscore=(s,e)=>new tA([s,e],this.opts).exec(this.client);zunion=(...s)=>new tT(s,this.opts).exec(this.client);zunionstore=(...s)=>new tR(s,this.opts).exec(this.client)},tj="v1.36.0";s.s(["HttpClient",()=>m,"Redis",()=>tJ,"VERSION",()=>tj,"error_exports",()=>n],18818),"undefined"==typeof atob&&(s.g.atob=s=>Buffer.from(s,"base64").toString("utf8"));var t_=class s extends tJ{constructor(s){if("request"in s)return void super(s);s.url?(s.url.startsWith(" ")||s.url.endsWith(" ")||/\r|\n/.test(s.url))&&console.warn("[Upstash Redis] The redis url contains whitespace or newline, which can cause errors!"):console.warn("[Upstash Redis] The 'url' property is missing or undefined in your Redis config."),s.token?(s.token.startsWith(" ")||s.token.endsWith(" ")||/\r|\n/.test(s.token))&&console.warn("[Upstash Redis] The redis token contains whitespace or newline, which can cause errors!"):console.warn("[Upstash Redis] The 'token' property is missing or undefined in your Redis config.");const e=new m({baseUrl:s.url,retry:s.retry,headers:{authorization:`Bearer ${s.token}`},agent:s.agent,responseEncoding:s.responseEncoding,cache:s.cache??"no-store",signal:s.signal,keepAlive:s.keepAlive,readYourWrites:s.readYourWrites}),t="object"==typeof process&&process&&"object"==typeof process.env&&process.env?process.env:{};super(e,{automaticDeserialization:s.automaticDeserialization,enableTelemetry:s.enableTelemetry??!t.UPSTASH_DISABLE_TELEMETRY,latencyLogging:s.latencyLogging,enableAutoPipelining:s.enableAutoPipelining});const n="object"==typeof process&&process?process.version:void 0;if(this.addTelemetry({runtime:"string"==typeof EdgeRuntime?"edge-light":n?`node@${n}`:"unknown",platform:t.UPSTASH_CONSOLE?"console":t.VERCEL?"vercel":t.AWS_REGION?"aws":"unknown",sdk:`@upstash/redis@${tj}`}),this.enableAutoPipelining)return this.autoPipeline()}static fromEnv(e){if("object"!=typeof process||!process||"object"!=typeof process.env||!process.env)throw TypeError('[Upstash Redis] Unable to get environment variables, `process.env` is undefined. If you are deploying to cloudflare, please import from "@upstash/redis/cloudflare" instead');let t=process.env.UPSTASH_REDIS_REST_URL||process.env.KV_REST_API_URL;t||console.warn("[Upstash Redis] Unable to find environment variable: `UPSTASH_REDIS_REST_URL`");let n=process.env.UPSTASH_REDIS_REST_TOKEN||process.env.KV_REST_API_TOKEN;return n||console.warn("[Upstash Redis] Unable to find environment variable: `UPSTASH_REDIS_REST_TOKEN`"),new s({...e,url:t,token:n})}};s.s(["Redis",()=>t_],3096)}];

//# sourceMappingURL=node_modules_%40upstash_redis_nodejs_mjs_85cd95da._.js.map