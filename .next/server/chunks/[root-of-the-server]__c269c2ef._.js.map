{"version":3,"sources":["turbopack:///[project]/node_modules/thread-stream/package.json","../../../src/db/api-keys.ts","../../../src/lib/auth.ts","../../../src/db/cron-jobs.ts"],"sourcesContent":["{\"name\":\"thread-stream\",\"version\":\"3.1.0\",\"description\":\"A streaming way to send data to a Node.js Worker Thread\",\"main\":\"index.js\",\"types\":\"index.d.ts\",\"dependencies\":{\"real-require\":\"^0.2.0\"},\"devDependencies\":{\"@types/node\":\"^20.1.0\",\"@types/tap\":\"^15.0.0\",\"@yao-pkg/pkg\":\"^5.11.5\",\"desm\":\"^1.3.0\",\"fastbench\":\"^1.0.1\",\"husky\":\"^9.0.6\",\"pino-elasticsearch\":\"^8.0.0\",\"sonic-boom\":\"^4.0.1\",\"standard\":\"^17.0.0\",\"tap\":\"^16.2.0\",\"ts-node\":\"^10.8.0\",\"typescript\":\"^5.3.2\",\"why-is-node-running\":\"^2.2.2\"},\"scripts\":{\"build\":\"tsc --noEmit\",\"test\":\"standard && npm run build && npm run transpile && tap \\\"test/**/*.test.*js\\\" && tap --ts test/*.test.*ts\",\"test:ci\":\"standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts\",\"test:ci:js\":\"tap --no-check-coverage --timeout=120 --coverage-report=lcovonly \\\"test/**/*.test.*js\\\"\",\"test:ci:ts\":\"tap --ts --no-check-coverage --coverage-report=lcovonly \\\"test/**/*.test.*ts\\\"\",\"test:yarn\":\"npm run transpile && tap \\\"test/**/*.test.js\\\" --no-check-coverage\",\"transpile\":\"sh ./test/ts/transpile.sh\",\"prepare\":\"husky install\"},\"standard\":{\"ignore\":[\"test/ts/**/*\",\"test/syntax-error.mjs\"]},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/mcollina/thread-stream.git\"},\"keywords\":[\"worker\",\"thread\",\"threads\",\"stream\"],\"author\":\"Matteo Collina <hello@matteocollina.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/mcollina/thread-stream/issues\"},\"homepage\":\"https://github.com/mcollina/thread-stream#readme\"}","// =============================================================================\r\n// API Keys Database Layer\r\n// =============================================================================\r\n\r\nimport crypto from 'crypto';\r\nimport { getDb } from './client';\r\n\r\nexport type ApiKeyRole = 'admin' | 'user' | 'read-only';\r\n\r\nexport interface ApiKey {\r\n  id: string;\r\n  keyHash: string;\r\n  name: string;\r\n  role: ApiKeyRole;\r\n  userId?: string;\r\n  rateLimit: number;\r\n  lastUsedAt?: string;\r\n  lastUsedIp?: string; // IP address of last use\r\n  expiresAt?: string;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  revokedAt?: string;\r\n  // x402 demo allowance tracking\r\n  x402DemoCallsUsed?: number;\r\n  x402DemoCallsLimit?: number;\r\n  x402DemoAmountUsed?: string; // Stored as string for precision\r\n  x402DemoAmountLimit?: string; // Stored as string for precision\r\n}\r\n\r\nexport interface CreateApiKeyInput {\r\n  name: string;\r\n  role?: ApiKeyRole;\r\n  userId?: string;\r\n  rateLimit?: number;\r\n  expiresAt?: string;\r\n}\r\n\r\nexport interface ApiKeyWithToken extends Omit<ApiKey, 'keyHash'> {\r\n  token: string; // Only returned on creation\r\n}\r\n\r\n/**\r\n * Generate a secure API key\r\n * \r\n * Security: Uses 32 bytes (256 bits) of cryptographically secure randomness.\r\n * Format: nf_live_<base64url_encoded_random_bytes>\r\n * \r\n * The prefix \"nf_live_\" is just for display/identification; the entropy\r\n * comes from the 32 random bytes, which when base64url encoded gives ~43 chars.\r\n */\r\nexport function generateApiKey(): string {\r\n  // Use 32 bytes (256 bits) of entropy for strong security\r\n  const randomBytes = crypto.randomBytes(32);\r\n  // Base64url encoding of 32 bytes gives ~43 characters (no padding needed)\r\n  const key = randomBytes.toString('base64url');\r\n  return `nf_live_${key}`;\r\n}\r\n\r\n/**\r\n * Hash an API key for storage\r\n */\r\nexport function hashApiKey(key: string): string {\r\n  return crypto.createHash('sha256').update(key).digest('hex');\r\n}\r\n\r\n/**\r\n * Create a new API key\r\n */\r\nexport async function createApiKey(input: CreateApiKeyInput): Promise<ApiKeyWithToken> {\r\n  const db = getDb();\r\n  const id = `key_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n  const token = generateApiKey();\r\n  const keyHash = hashApiKey(token);\r\n  const now = new Date().toISOString();\r\n\r\n  const apiKey: ApiKey = {\r\n    id,\r\n    keyHash,\r\n    name: input.name,\r\n    role: input.role || 'user',\r\n    userId: input.userId,\r\n    rateLimit: input.rateLimit || 1000,\r\n    expiresAt: input.expiresAt,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  };\r\n\r\n  // Use adapter to insert\r\n  await db.createApiKey(apiKey);\r\n\r\n  return {\r\n    ...apiKey,\r\n    token, // Include the plain token only on creation\r\n  };\r\n}\r\n\r\n/**\r\n * Find API key by hash\r\n */\r\nexport async function findApiKeyByHash(keyHash: string): Promise<ApiKey | null> {\r\n  const db = getDb();\r\n  return await db.findApiKeyByHash(keyHash);\r\n}\r\n\r\n/**\r\n * Find API key by token (validates and returns key)\r\n */\r\nexport async function findApiKeyByToken(token: string): Promise<ApiKey | null> {\r\n  const keyHash = hashApiKey(token);\r\n  return await findApiKeyByHash(keyHash);\r\n}\r\n\r\n/**\r\n * Update API key last used timestamp and IP address\r\n */\r\nexport async function updateApiKeyLastUsed(keyId: string, ipAddress?: string): Promise<void> {\r\n  const db = getDb();\r\n  await db.updateApiKeyLastUsed(keyId, ipAddress);\r\n}\r\n\r\n/**\r\n * Revoke an API key (soft delete)\r\n */\r\nexport async function revokeApiKey(keyId: string): Promise<boolean> {\r\n  const db = getDb();\r\n  return await db.revokeApiKey(keyId);\r\n}\r\n\r\n/**\r\n * List API keys for a user\r\n */\r\nexport async function listApiKeys(userId?: string): Promise<ApiKey[]> {\r\n  const db = getDb();\r\n  return await db.listApiKeys(userId);\r\n}\r\n\r\n/**\r\n * Update x402 demo allowance usage\r\n */\r\nexport async function updateApiKeyX402DemoAllowance(\r\n  keyId: string,\r\n  callsUsed: number,\r\n  amountUsed: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  await db.updateApiKeyX402DemoAllowance(keyId, callsUsed, amountUsed);\r\n}\r\n\r\n/**\r\n * Check if API key has remaining x402 demo allowance\r\n */\r\nexport function hasX402DemoAllowance(apiKey: ApiKey): {\r\n  hasAllowance: boolean;\r\n  callsRemaining: number;\r\n  amountRemaining: string;\r\n  reason?: string;\r\n} {\r\n  const callsUsed = apiKey.x402DemoCallsUsed || 0;\r\n  const callsLimit = apiKey.x402DemoCallsLimit || 200;\r\n  const amountUsed = BigInt(apiKey.x402DemoAmountUsed || '0');\r\n  const amountLimit = BigInt(apiKey.x402DemoAmountLimit || '1000000');\r\n  \r\n  if (callsUsed >= callsLimit) {\r\n    return {\r\n      hasAllowance: false,\r\n      callsRemaining: 0,\r\n      amountRemaining: '0',\r\n      reason: 'Calls limit reached',\r\n    };\r\n  }\r\n  \r\n  if (amountUsed >= amountLimit) {\r\n    return {\r\n      hasAllowance: false,\r\n      callsRemaining: callsLimit - callsUsed,\r\n      amountRemaining: '0',\r\n      reason: 'Amount limit reached',\r\n    };\r\n  }\r\n  \r\n  return {\r\n    hasAllowance: true,\r\n    callsRemaining: callsLimit - callsUsed,\r\n    amountRemaining: (amountLimit - amountUsed).toString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Update x402 demo limits for an API key\r\n */\r\nexport async function updateApiKeyX402DemoLimits(\r\n  keyId: string,\r\n  callsLimit?: number,\r\n  amountLimit?: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  await db.updateApiKeyX402DemoLimits(keyId, callsLimit, amountLimit);\r\n}\r\n\r\n/**\r\n * Find API key by ID (not hash)\r\n */\r\nexport async function findApiKeyById(keyId: string): Promise<ApiKey | null> {\r\n  const allKeys = await listApiKeys();\r\n  return allKeys.find(k => k.id === keyId) || null;\r\n}\r\n\r\n","// =============================================================================\r\n// Authentication Middleware\r\n// =============================================================================\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { findApiKeyByToken, updateApiKeyLastUsed, type ApiKey, type ApiKeyRole } from '@/db/api-keys';\r\n\r\nexport interface AuthenticatedRequest extends NextRequest {\r\n  apiKey?: ApiKey;\r\n}\r\n\r\n/**\r\n * Extract API key from request headers\r\n * Supports:\r\n * - Authorization: Bearer <token> or <token>\r\n * - x-api-key: <token>\r\n */\r\nexport function extractApiKey(request: NextRequest): string | null {\r\n  // First try x-api-key header (standard for API keys)\r\n  const apiKeyHeader = request.headers.get('x-api-key');\r\n  if (apiKeyHeader) {\r\n    return apiKeyHeader.trim();\r\n  }\r\n\r\n  // Fall back to Authorization header\r\n  const authHeader = request.headers.get('authorization');\r\n  if (!authHeader) return null;\r\n\r\n  // Support both \"Bearer <token>\" and \"<token>\" formats\r\n  if (authHeader.startsWith('Bearer ')) {\r\n    return authHeader.substring(7).trim();\r\n  }\r\n  return authHeader.trim();\r\n}\r\n\r\n/**\r\n * Authenticate request using API key\r\n */\r\nexport async function authenticateRequest(\r\n  request: NextRequest\r\n): Promise<{ apiKey: ApiKey } | { error: string; status: number }> {\r\n  const token = extractApiKey(request);\r\n\r\n  if (!token) {\r\n    return {\r\n      error: 'Authentication required',\r\n      status: 401,\r\n    };\r\n  }\r\n\r\n  // Validate token format (nf_live_... or nf_test_...)\r\n  if (!token.startsWith('nf_live_') && !token.startsWith('nf_test_')) {\r\n    return {\r\n      error: 'Invalid API key format',\r\n      status: 401,\r\n    };\r\n  }\r\n\r\n  // Find API key in database\r\n  const apiKey = await findApiKeyByToken(token);\r\n\r\n  if (!apiKey) {\r\n    return {\r\n      error: 'Invalid API key',\r\n      status: 401,\r\n    };\r\n  }\r\n\r\n  // Check if key is expired\r\n  if (apiKey.expiresAt && new Date(apiKey.expiresAt) < new Date()) {\r\n    return {\r\n      error: 'API key has expired',\r\n      status: 401,\r\n    };\r\n  }\r\n\r\n  // Extract IP address for tracking\r\n  const ipAddress = request.ip || \r\n    request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || \r\n    request.headers.get('x-real-ip') || \r\n    undefined;\r\n\r\n  // Update last used timestamp and IP (fire and forget)\r\n  updateApiKeyLastUsed(apiKey.id, ipAddress).catch((err) => {\r\n    console.error('[auth] Failed to update last used:', err);\r\n  });\r\n\r\n  return { apiKey };\r\n}\r\n\r\n/**\r\n * Check if API key has required role\r\n */\r\nexport function hasRole(apiKey: ApiKey, requiredRole: ApiKeyRole): boolean {\r\n  const roleHierarchy: Record<ApiKeyRole, number> = {\r\n    'read-only': 1,\r\n    'user': 2,\r\n    'admin': 3,\r\n  };\r\n\r\n  return roleHierarchy[apiKey.role] >= roleHierarchy[requiredRole];\r\n}\r\n\r\n/**\r\n * Require authentication middleware\r\n * Returns authenticated API key or error response\r\n */\r\nexport async function requireAuth(\r\n  request: NextRequest,\r\n  requiredRole: ApiKeyRole = 'user'\r\n): Promise<\r\n  | { apiKey: ApiKey; response?: never }\r\n  | { apiKey?: never; response: NextResponse }\r\n> {\r\n  const authResult = await authenticateRequest(request);\r\n\r\n  if ('error' in authResult) {\r\n    return {\r\n      response: NextResponse.json(\r\n        {\r\n          error: authResult.error,\r\n          code: 'UNAUTHORIZED',\r\n        },\r\n        { status: authResult.status }\r\n      ),\r\n    };\r\n  }\r\n\r\n  // Check role\r\n  if (!hasRole(authResult.apiKey, requiredRole)) {\r\n    return {\r\n      response: NextResponse.json(\r\n        {\r\n          error: 'Insufficient permissions',\r\n          code: 'FORBIDDEN',\r\n          details: `Required role: ${requiredRole}, your role: ${authResult.apiKey.role}`,\r\n        },\r\n        { status: 403 }\r\n      ),\r\n    };\r\n  }\r\n\r\n  return { apiKey: authResult.apiKey };\r\n}\r\n\r\n/**\r\n * Require any of the specified roles\r\n * Useful for routes that allow multiple role levels\r\n */\r\nexport async function requireAnyRole(\r\n  request: NextRequest,\r\n  allowedRoles: ApiKeyRole[]\r\n): Promise<\r\n  | { apiKey: ApiKey; response?: never }\r\n  | { apiKey?: never; response: NextResponse }\r\n> {\r\n  const authResult = await authenticateRequest(request);\r\n\r\n  if ('error' in authResult) {\r\n    return {\r\n      response: NextResponse.json(\r\n        {\r\n          error: authResult.error,\r\n          code: 'UNAUTHORIZED',\r\n        },\r\n        { status: authResult.status }\r\n      ),\r\n    };\r\n  }\r\n\r\n  // Check if API key has any of the allowed roles\r\n  const hasAllowedRole = allowedRoles.some(role => hasRole(authResult.apiKey, role));\r\n  \r\n  if (!hasAllowedRole) {\r\n    return {\r\n      response: NextResponse.json(\r\n        {\r\n          error: 'Insufficient permissions',\r\n          code: 'FORBIDDEN',\r\n          details: `Required one of roles: ${allowedRoles.join(', ')}, your role: ${authResult.apiKey.role}`,\r\n        },\r\n        { status: 403 }\r\n      ),\r\n    };\r\n  }\r\n\r\n  return { apiKey: authResult.apiKey };\r\n}\r\n\r\n","// =============================================================================\r\n// CRON JOB DATABASE OPERATIONS\r\n// =============================================================================\r\n// Database operations for cron job tracking and configuration.\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'CronJobDb' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport type CronJobStatus = 'pending' | 'running' | 'completed' | 'failed' | 'timeout';\r\nexport type TriggerSource = 'cron' | 'manual' | 'retry';\r\n\r\nexport interface CronJobRun {\r\n  id: string;\r\n  job_id: string;\r\n  status: CronJobStatus;\r\n  started_at: string;\r\n  completed_at?: string;\r\n  duration_ms?: number;\r\n  trigger_source: TriggerSource;\r\n  attempt_number: number;\r\n  input_params?: Record<string, any>;\r\n  output_summary?: Record<string, any>;\r\n  error_message?: string;\r\n  error_stack?: string;\r\n  metadata?: Record<string, any>;\r\n  created_at: string;\r\n}\r\n\r\nexport interface CronJobConfig {\r\n  job_id: string;\r\n  display_name: string;\r\n  description?: string;\r\n  schedule?: string;\r\n  enabled: boolean;\r\n  timeout_ms: number;\r\n  max_retries: number;\r\n  retry_delay_ms: number;\r\n  alert_on_failure: boolean;\r\n  consecutive_failures: number;\r\n  last_success_at?: string;\r\n  last_failure_at?: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface CreateJobRunInput {\r\n  jobId: string;\r\n  triggerSource?: TriggerSource;\r\n  attemptNumber?: number;\r\n  inputParams?: Record<string, any>;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nexport interface CompleteJobRunInput {\r\n  runId: string;\r\n  status: 'completed' | 'failed' | 'timeout';\r\n  outputSummary?: Record<string, any>;\r\n  errorMessage?: string;\r\n  errorStack?: string;\r\n}\r\n\r\n// =============================================================================\r\n// JOB RUN OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Create a new job run record\r\n */\r\nexport async function createJobRun(input: CreateJobRunInput): Promise<CronJobRun> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  \r\n  if ('pool' in db) {\r\n    // PostgreSQL\r\n    const result = await db.query(\r\n      `INSERT INTO cron_job_runs (id, job_id, status, trigger_source, attempt_number, input_params, metadata)\r\n       VALUES ($1, $2, 'running', $3, $4, $5, $6)\r\n       RETURNING *`,\r\n      [\r\n        id,\r\n        input.jobId,\r\n        input.triggerSource || 'cron',\r\n        input.attemptNumber || 1,\r\n        input.inputParams ? JSON.stringify(input.inputParams) : null,\r\n        input.metadata ? JSON.stringify(input.metadata) : null,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite\r\n    db.prepare(\r\n      `INSERT INTO cron_job_runs (id, job_id, status, trigger_source, attempt_number, input_params, metadata, started_at, created_at)\r\n       VALUES (?, ?, 'running', ?, ?, ?, ?, datetime('now'), datetime('now'))`\r\n    ).run(\r\n      id,\r\n      input.jobId,\r\n      input.triggerSource || 'cron',\r\n      input.attemptNumber || 1,\r\n      input.inputParams ? JSON.stringify(input.inputParams) : null,\r\n      input.metadata ? JSON.stringify(input.metadata) : null\r\n    );\r\n    return db.prepare('SELECT * FROM cron_job_runs WHERE id = ?').get(id) as CronJobRun;\r\n  }\r\n}\r\n\r\n/**\r\n * Complete a job run (success or failure)\r\n */\r\nexport async function completeJobRun(input: CompleteJobRunInput): Promise<void> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    await db.query(\r\n      `UPDATE cron_job_runs\r\n       SET status = $1,\r\n           completed_at = now(),\r\n           duration_ms = EXTRACT(EPOCH FROM (now() - started_at)) * 1000,\r\n           output_summary = $2,\r\n           error_message = $3,\r\n           error_stack = $4\r\n       WHERE id = $5`,\r\n      [\r\n        input.status,\r\n        input.outputSummary ? JSON.stringify(input.outputSummary) : null,\r\n        input.errorMessage || null,\r\n        input.errorStack || null,\r\n        input.runId,\r\n      ]\r\n    );\r\n  } else {\r\n    db.prepare(\r\n      `UPDATE cron_job_runs\r\n       SET status = ?,\r\n           completed_at = datetime('now'),\r\n           duration_ms = (julianday('now') - julianday(started_at)) * 86400000,\r\n           output_summary = ?,\r\n           error_message = ?,\r\n           error_stack = ?\r\n       WHERE id = ?`\r\n    ).run(\r\n      input.status,\r\n      input.outputSummary ? JSON.stringify(input.outputSummary) : null,\r\n      input.errorMessage || null,\r\n      input.errorStack || null,\r\n      input.runId\r\n    );\r\n  }\r\n\r\n  // Update config stats\r\n  await updateConfigStats(input);\r\n}\r\n\r\n/**\r\n * Update job config statistics after run completion\r\n */\r\nasync function updateConfigStats(input: CompleteJobRunInput): Promise<void> {\r\n  const db = getDb();\r\n  \r\n  // Get the job_id from the run\r\n  let jobId: string;\r\n  if ('pool' in db) {\r\n    const result = await db.query(\r\n      'SELECT job_id FROM cron_job_runs WHERE id = $1',\r\n      [input.runId]\r\n    );\r\n    if (result.rows.length === 0) return;\r\n    jobId = result.rows[0].job_id;\r\n  } else {\r\n    const row = db.prepare('SELECT job_id FROM cron_job_runs WHERE id = ?').get(input.runId) as { job_id: string } | undefined;\r\n    if (!row) return;\r\n    jobId = row.job_id;\r\n  }\r\n\r\n  if (input.status === 'completed') {\r\n    // Reset consecutive failures, update last success\r\n    if ('pool' in db) {\r\n      await db.query(\r\n        `UPDATE cron_job_config\r\n         SET consecutive_failures = 0, last_success_at = now(), updated_at = now()\r\n         WHERE job_id = $1`,\r\n        [jobId]\r\n      );\r\n    } else {\r\n      db.prepare(\r\n        `UPDATE cron_job_config\r\n         SET consecutive_failures = 0, last_success_at = datetime('now'), updated_at = datetime('now')\r\n         WHERE job_id = ?`\r\n      ).run(jobId);\r\n    }\r\n  } else if (input.status === 'failed' || input.status === 'timeout') {\r\n    // Increment consecutive failures, update last failure\r\n    if ('pool' in db) {\r\n      await db.query(\r\n        `UPDATE cron_job_config\r\n         SET consecutive_failures = consecutive_failures + 1, last_failure_at = now(), updated_at = now()\r\n         WHERE job_id = $1`,\r\n        [jobId]\r\n      );\r\n    } else {\r\n      db.prepare(\r\n        `UPDATE cron_job_config\r\n         SET consecutive_failures = consecutive_failures + 1, last_failure_at = datetime('now'), updated_at = datetime('now')\r\n         WHERE job_id = ?`\r\n      ).run(jobId);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get recent runs for a job\r\n */\r\nexport async function getRecentJobRuns(\r\n  jobId: string,\r\n  limit = 20\r\n): Promise<CronJobRun[]> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    const result = await db.query(\r\n      `SELECT * FROM cron_job_runs\r\n       WHERE job_id = $1\r\n       ORDER BY started_at DESC\r\n       LIMIT $2`,\r\n      [jobId, limit]\r\n    );\r\n    return result.rows;\r\n  } else {\r\n    return db.prepare(\r\n      `SELECT * FROM cron_job_runs\r\n       WHERE job_id = ?\r\n       ORDER BY started_at DESC\r\n       LIMIT ?`\r\n    ).all(jobId, limit) as CronJobRun[];\r\n  }\r\n}\r\n\r\n/**\r\n * Get all job runs across all jobs (recent)\r\n */\r\nexport async function getAllRecentRuns(limit = 50): Promise<CronJobRun[]> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    const result = await db.query(\r\n      `SELECT * FROM cron_job_runs\r\n       ORDER BY started_at DESC\r\n       LIMIT $1`,\r\n      [limit]\r\n    );\r\n    return result.rows;\r\n  } else {\r\n    return db.prepare(\r\n      `SELECT * FROM cron_job_runs\r\n       ORDER BY started_at DESC\r\n       LIMIT ?`\r\n    ).all(limit) as CronJobRun[];\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// JOB CONFIG OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Get job configuration\r\n */\r\nexport async function getJobConfig(jobId: string): Promise<CronJobConfig | null> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    const result = await db.query(\r\n      'SELECT * FROM cron_job_config WHERE job_id = $1',\r\n      [jobId]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    return db.prepare('SELECT * FROM cron_job_config WHERE job_id = ?').get(jobId) as CronJobConfig | null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all job configurations\r\n */\r\nexport async function getAllJobConfigs(): Promise<CronJobConfig[]> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    const result = await db.query('SELECT * FROM cron_job_config ORDER BY job_id');\r\n    return result.rows;\r\n  } else {\r\n    return db.prepare('SELECT * FROM cron_job_config ORDER BY job_id').all() as CronJobConfig[];\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a job is enabled\r\n */\r\nexport async function isJobEnabled(jobId: string): Promise<boolean> {\r\n  const config = await getJobConfig(jobId);\r\n  return config?.enabled ?? true;\r\n}\r\n\r\n/**\r\n * Get jobs with consecutive failures exceeding threshold\r\n */\r\nexport async function getFailingJobs(threshold = 3): Promise<CronJobConfig[]> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    const result = await db.query(\r\n      `SELECT * FROM cron_job_config\r\n       WHERE consecutive_failures >= $1 AND alert_on_failure = true\r\n       ORDER BY consecutive_failures DESC`,\r\n      [threshold]\r\n    );\r\n    return result.rows;\r\n  } else {\r\n    return db.prepare(\r\n      `SELECT * FROM cron_job_config\r\n       WHERE consecutive_failures >= ? AND alert_on_failure = 1\r\n       ORDER BY consecutive_failures DESC`\r\n    ).all(threshold) as CronJobConfig[];\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// CLEANUP\r\n// =============================================================================\r\n\r\n/**\r\n * Delete old job runs (older than retention days)\r\n */\r\nexport async function cleanupOldRuns(retentionDays = 30): Promise<number> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    const result = await db.query(\r\n      `DELETE FROM cron_job_runs\r\n       WHERE created_at < now() - interval '${retentionDays} days'`\r\n    );\r\n    const deleted = result.rowCount || 0;\r\n    logger.info({ retentionDays, deleted }, 'Cleaned up old cron job runs');\r\n    return deleted;\r\n  } else {\r\n    const result = db.prepare(\r\n      `DELETE FROM cron_job_runs\r\n       WHERE created_at < datetime('now', '-' || ? || ' days')`\r\n    ).run(retentionDays);\r\n    const deleted = result.changes;\r\n    logger.info({ retentionDays, deleted }, 'Cleaned up old cron job runs');\r\n    return deleted;\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}