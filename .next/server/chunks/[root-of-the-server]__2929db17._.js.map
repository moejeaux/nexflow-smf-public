{"version":3,"sources":["turbopack:///[project]/node_modules/thread-stream/package.json","../../../src/lib/circuit-breaker.ts","../../../src/integrations/x402/facilitators/route-context.ts","../../../src/integrations/x402/orchestrator/meta-facilitator.ts","../../../src/db/x402-watchlist.ts","../../../src/db/agent-recommendations.ts"],"sourcesContent":["{\"name\":\"thread-stream\",\"version\":\"3.1.0\",\"description\":\"A streaming way to send data to a Node.js Worker Thread\",\"main\":\"index.js\",\"types\":\"index.d.ts\",\"dependencies\":{\"real-require\":\"^0.2.0\"},\"devDependencies\":{\"@types/node\":\"^20.1.0\",\"@types/tap\":\"^15.0.0\",\"@yao-pkg/pkg\":\"^5.11.5\",\"desm\":\"^1.3.0\",\"fastbench\":\"^1.0.1\",\"husky\":\"^9.0.6\",\"pino-elasticsearch\":\"^8.0.0\",\"sonic-boom\":\"^4.0.1\",\"standard\":\"^17.0.0\",\"tap\":\"^16.2.0\",\"ts-node\":\"^10.8.0\",\"typescript\":\"^5.3.2\",\"why-is-node-running\":\"^2.2.2\"},\"scripts\":{\"build\":\"tsc --noEmit\",\"test\":\"standard && npm run build && npm run transpile && tap \\\"test/**/*.test.*js\\\" && tap --ts test/*.test.*ts\",\"test:ci\":\"standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts\",\"test:ci:js\":\"tap --no-check-coverage --timeout=120 --coverage-report=lcovonly \\\"test/**/*.test.*js\\\"\",\"test:ci:ts\":\"tap --ts --no-check-coverage --coverage-report=lcovonly \\\"test/**/*.test.*ts\\\"\",\"test:yarn\":\"npm run transpile && tap \\\"test/**/*.test.js\\\" --no-check-coverage\",\"transpile\":\"sh ./test/ts/transpile.sh\",\"prepare\":\"husky install\"},\"standard\":{\"ignore\":[\"test/ts/**/*\",\"test/syntax-error.mjs\"]},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/mcollina/thread-stream.git\"},\"keywords\":[\"worker\",\"thread\",\"threads\",\"stream\"],\"author\":\"Matteo Collina <hello@matteocollina.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/mcollina/thread-stream/issues\"},\"homepage\":\"https://github.com/mcollina/thread-stream#readme\"}","// =============================================================================\r\n// CIRCUIT BREAKER\r\n// =============================================================================\r\n// Protects against cascading failures from external services.\r\n// Implements the circuit breaker pattern with three states:\r\n// - CLOSED: Normal operation, requests pass through\r\n// - OPEN: Failure threshold exceeded, requests fail fast\r\n// - HALF_OPEN: Testing if service recovered\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'CircuitBreaker' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport type CircuitState = 'CLOSED' | 'OPEN' | 'HALF_OPEN';\r\n\r\nexport interface CircuitBreakerConfig {\r\n  /** Name for logging and metrics */\r\n  name: string;\r\n  \r\n  /** Number of failures before opening circuit */\r\n  failureThreshold: number;\r\n  \r\n  /** Number of successes in HALF_OPEN to close circuit */\r\n  successThreshold: number;\r\n  \r\n  /** Time in ms to wait before trying HALF_OPEN */\r\n  resetTimeout: number;\r\n  \r\n  /** Time window in ms to count failures */\r\n  failureWindow: number;\r\n  \r\n  /** Timeout for individual requests in ms */\r\n  requestTimeout?: number;\r\n  \r\n  /** Optional fallback function when circuit is open */\r\n  fallback?: <T>() => T | Promise<T>;\r\n}\r\n\r\nexport interface CircuitBreakerStats {\r\n  name: string;\r\n  state: CircuitState;\r\n  failures: number;\r\n  successes: number;\r\n  lastFailure?: Date;\r\n  lastSuccess?: Date;\r\n  openedAt?: Date;\r\n  totalRequests: number;\r\n  failedRequests: number;\r\n  successRate: number;\r\n}\r\n\r\n// =============================================================================\r\n// CIRCUIT BREAKER IMPLEMENTATION\r\n// =============================================================================\r\n\r\nexport class CircuitBreaker {\r\n  private state: CircuitState = 'CLOSED';\r\n  private failures: { timestamp: number }[] = [];\r\n  private successes = 0;\r\n  private lastFailure?: Date;\r\n  private lastSuccess?: Date;\r\n  private openedAt?: Date;\r\n  private totalRequests = 0;\r\n  private failedRequests = 0;\r\n\r\n  constructor(private config: CircuitBreakerConfig) {}\r\n\r\n  /**\r\n   * Execute a function with circuit breaker protection\r\n   */\r\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\r\n    this.totalRequests++;\r\n\r\n    // Check if circuit is open\r\n    if (this.state === 'OPEN') {\r\n      if (this.shouldAttemptReset()) {\r\n        this.transitionTo('HALF_OPEN');\r\n      } else {\r\n        this.failedRequests++;\r\n        logger.warn({\r\n          circuit: this.config.name,\r\n          state: this.state,\r\n          openedAt: this.openedAt,\r\n        }, 'Circuit breaker is OPEN - failing fast');\r\n\r\n        if (this.config.fallback) {\r\n          return this.config.fallback<T>();\r\n        }\r\n        throw new CircuitBreakerError(\r\n          `Circuit breaker ${this.config.name} is OPEN`,\r\n          this.config.name\r\n        );\r\n      }\r\n    }\r\n\r\n    // Execute the function\r\n    try {\r\n      const result = await this.executeWithTimeout(fn);\r\n      this.onSuccess();\r\n      return result;\r\n    } catch (error) {\r\n      this.onFailure(error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute function with optional timeout\r\n   */\r\n  private async executeWithTimeout<T>(fn: () => Promise<T>): Promise<T> {\r\n    if (!this.config.requestTimeout) {\r\n      return fn();\r\n    }\r\n\r\n    return Promise.race([\r\n      fn(),\r\n      new Promise<never>((_, reject) =>\r\n        setTimeout(\r\n          () => reject(new Error(`Request timeout after ${this.config.requestTimeout}ms`)),\r\n          this.config.requestTimeout\r\n        )\r\n      ),\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Handle successful execution\r\n   */\r\n  private onSuccess(): void {\r\n    this.lastSuccess = new Date();\r\n\r\n    if (this.state === 'HALF_OPEN') {\r\n      this.successes++;\r\n      if (this.successes >= this.config.successThreshold) {\r\n        this.transitionTo('CLOSED');\r\n      }\r\n    } else if (this.state === 'CLOSED') {\r\n      // Clear old failures outside the window\r\n      this.pruneOldFailures();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle failed execution\r\n   */\r\n  private onFailure(error: unknown): void {\r\n    this.failedRequests++;\r\n    this.lastFailure = new Date();\r\n    this.failures.push({ timestamp: Date.now() });\r\n\r\n    logger.warn({\r\n      circuit: this.config.name,\r\n      state: this.state,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n      failureCount: this.failures.length,\r\n    }, 'Circuit breaker recorded failure');\r\n\r\n    if (this.state === 'HALF_OPEN') {\r\n      // Any failure in HALF_OPEN reopens the circuit\r\n      this.transitionTo('OPEN');\r\n    } else if (this.state === 'CLOSED') {\r\n      this.pruneOldFailures();\r\n      if (this.failures.length >= this.config.failureThreshold) {\r\n        this.transitionTo('OPEN');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if we should attempt to reset from OPEN to HALF_OPEN\r\n   */\r\n  private shouldAttemptReset(): boolean {\r\n    if (!this.openedAt) return true;\r\n    return Date.now() - this.openedAt.getTime() >= this.config.resetTimeout;\r\n  }\r\n\r\n  /**\r\n   * Remove failures outside the failure window\r\n   */\r\n  private pruneOldFailures(): void {\r\n    const cutoff = Date.now() - this.config.failureWindow;\r\n    this.failures = this.failures.filter(f => f.timestamp > cutoff);\r\n  }\r\n\r\n  /**\r\n   * Transition to a new state\r\n   */\r\n  private transitionTo(newState: CircuitState): void {\r\n    const oldState = this.state;\r\n    this.state = newState;\r\n\r\n    logger.info({\r\n      circuit: this.config.name,\r\n      from: oldState,\r\n      to: newState,\r\n      failures: this.failures.length,\r\n      successes: this.successes,\r\n    }, 'Circuit breaker state transition');\r\n\r\n    if (newState === 'OPEN') {\r\n      this.openedAt = new Date();\r\n    } else if (newState === 'CLOSED') {\r\n      this.failures = [];\r\n      this.successes = 0;\r\n      this.openedAt = undefined;\r\n    } else if (newState === 'HALF_OPEN') {\r\n      this.successes = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current statistics\r\n   */\r\n  getStats(): CircuitBreakerStats {\r\n    return {\r\n      name: this.config.name,\r\n      state: this.state,\r\n      failures: this.failures.length,\r\n      successes: this.successes,\r\n      lastFailure: this.lastFailure,\r\n      lastSuccess: this.lastSuccess,\r\n      openedAt: this.openedAt,\r\n      totalRequests: this.totalRequests,\r\n      failedRequests: this.failedRequests,\r\n      successRate: this.totalRequests > 0\r\n        ? (this.totalRequests - this.failedRequests) / this.totalRequests\r\n        : 1,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Manually reset the circuit breaker\r\n   */\r\n  reset(): void {\r\n    this.transitionTo('CLOSED');\r\n    this.totalRequests = 0;\r\n    this.failedRequests = 0;\r\n    logger.info({ circuit: this.config.name }, 'Circuit breaker manually reset');\r\n  }\r\n\r\n  /**\r\n   * Check if circuit is allowing requests\r\n   */\r\n  isAllowingRequests(): boolean {\r\n    if (this.state === 'CLOSED') return true;\r\n    if (this.state === 'HALF_OPEN') return true;\r\n    return this.shouldAttemptReset();\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// CIRCUIT BREAKER ERROR\r\n// =============================================================================\r\n\r\nexport class CircuitBreakerError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public readonly circuitName: string\r\n  ) {\r\n    super(message);\r\n    this.name = 'CircuitBreakerError';\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// CIRCUIT BREAKER REGISTRY\r\n// =============================================================================\r\n\r\nconst circuitBreakers = new Map<string, CircuitBreaker>();\r\n\r\n/**\r\n * Get or create a circuit breaker\r\n */\r\nexport function getCircuitBreaker(config: CircuitBreakerConfig): CircuitBreaker {\r\n  let breaker = circuitBreakers.get(config.name);\r\n  if (!breaker) {\r\n    breaker = new CircuitBreaker(config);\r\n    circuitBreakers.set(config.name, breaker);\r\n    logger.info({ circuit: config.name }, 'Created new circuit breaker');\r\n  }\r\n  return breaker;\r\n}\r\n\r\n/**\r\n * Get all circuit breaker stats\r\n */\r\nexport function getAllCircuitBreakerStats(): CircuitBreakerStats[] {\r\n  return Array.from(circuitBreakers.values()).map(cb => cb.getStats());\r\n}\r\n\r\n/**\r\n * Reset all circuit breakers\r\n */\r\nexport function resetAllCircuitBreakers(): void {\r\n  circuitBreakers.forEach(cb => cb.reset());\r\n  logger.info({ count: circuitBreakers.size }, 'Reset all circuit breakers');\r\n}\r\n\r\n// =============================================================================\r\n// PRE-CONFIGURED CIRCUIT BREAKERS\r\n// =============================================================================\r\n\r\n/**\r\n * Circuit breaker for x402scan API\r\n */\r\nexport const x402scanCircuitBreaker = getCircuitBreaker({\r\n  name: 'x402scan',\r\n  failureThreshold: 3,\r\n  successThreshold: 2,\r\n  resetTimeout: 60000, // 1 minute\r\n  failureWindow: 300000, // 5 minutes\r\n  requestTimeout: 30000, // 30 seconds\r\n});\r\n\r\n/**\r\n * Circuit breaker for Scattering/Dune API\r\n */\r\nexport const scatteringCircuitBreaker = getCircuitBreaker({\r\n  name: 'scattering',\r\n  failureThreshold: 3,\r\n  successThreshold: 2,\r\n  resetTimeout: 60000,\r\n  failureWindow: 300000,\r\n  requestTimeout: 30000,\r\n});\r\n\r\n/**\r\n * Circuit breaker for facilitator health probes\r\n */\r\nexport const facilitatorProbeCircuitBreaker = getCircuitBreaker({\r\n  name: 'facilitator-probes',\r\n  failureThreshold: 5,\r\n  successThreshold: 3,\r\n  resetTimeout: 30000, // 30 seconds (more aggressive retry)\r\n  failureWindow: 120000, // 2 minutes\r\n  requestTimeout: 10000, // 10 seconds\r\n});\r\n\r\n","// =============================================================================\r\n// ROUTE CONTEXT\r\n// =============================================================================\r\n// Normalized request context for SMF routing\r\n// Ensures all facilitators receive consistent, x402-spec-compliant requests\r\n\r\nimport type { PaymentRequirements } from './base-facilitator';\r\n\r\n/**\r\n * RouteContext - Normalized request context for SMF routing\r\n * \r\n * This type ensures all facilitators receive consistent, x402-spec-compliant\r\n * requests regardless of how the request originated (API, SDK, etc.)\r\n */\r\nexport interface RouteContext {\r\n  // Payment details (x402 spec compliant)\r\n  network: string; // Legacy network identifier (e.g., 'base', 'ethereum')\r\n  token: string; // Token address (e.g., '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913')\r\n  amount: string; // Amount in atomic units (string to avoid precision loss)\r\n  \r\n  // CAIP identifiers (preferred for multi-chain)\r\n  networkCAIP?: string; // CAIP-2 network identifier (e.g., 'eip155:8453')\r\n  tokenCAIP?: string; // CAIP-19 asset identifier (e.g., 'eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913')\r\n  \r\n  // x402 version\r\n  x402Version: number; // x402 protocol version (currently 1 or 2)\r\n  \r\n  // Caller identification\r\n  callerId?: string; // Agent/merchant identifier\r\n  clientId?: string; // Client application identifier\r\n  \r\n  // Optional routing preferences\r\n  region?: string; // Geographic region (e.g., 'us-east', 'eu-west')\r\n  riskLevel?: 'low' | 'medium' | 'high'; // Risk assessment level\r\n  watchLevel?: 'normal' | 'enhanced' | 'strict'; // Compliance watch level\r\n  \r\n  // Additional context\r\n  preferences?: {\r\n    priority?: 'cost' | 'speed' | 'reliability' | 'compliance';\r\n    requireKYC?: boolean;\r\n    requireOFAC?: boolean;\r\n    maxLatencyMs?: number;\r\n    maxFeeBps?: number;\r\n  };\r\n  \r\n  // Original payment requirements (for compatibility)\r\n  requirements: PaymentRequirements;\r\n}\r\n\r\n/**\r\n * Convert RouteContext to facilitator request format\r\n * \r\n * This ensures all facilitators receive x402-spec-compliant requests\r\n */\r\nexport function routeContextToFacilitatorRequest(\r\n  context: RouteContext\r\n): {\r\n  version: number;\r\n  amount: string;\r\n  network: string;\r\n  token: string;\r\n  networkCAIP?: string;\r\n  tokenCAIP?: string;\r\n} {\r\n  return {\r\n    version: context.x402Version,\r\n    amount: context.amount,\r\n    network: context.network,\r\n    token: context.token,\r\n    networkCAIP: context.networkCAIP,\r\n    tokenCAIP: context.tokenCAIP,\r\n  };\r\n}\r\n\r\n/**\r\n * Create RouteContext from PaymentRequirements\r\n * \r\n * Normalizes various input formats into consistent RouteContext\r\n */\r\nexport function createRouteContext(\r\n  requirements: PaymentRequirements,\r\n  options?: {\r\n    callerId?: string;\r\n    clientId?: string;\r\n    region?: string;\r\n    riskLevel?: 'low' | 'medium' | 'high';\r\n    watchLevel?: 'normal' | 'enhanced' | 'strict';\r\n    x402Version?: number;\r\n  }\r\n): RouteContext {\r\n  // Extract network (legacy or CAIP)\r\n  const network = requirements.network || requirements.networks?.[0] || '';\r\n  const networkCAIP = requirements.networks?.[0]?.startsWith('eip155:') \r\n    ? requirements.networks[0] \r\n    : undefined;\r\n  \r\n  // Extract token/asset (legacy or CAIP)\r\n  const token = requirements.asset || requirements.assets?.[0] || '';\r\n  const tokenCAIP = requirements.assets?.[0]?.includes('/') \r\n    ? requirements.assets[0] \r\n    : undefined;\r\n  \r\n  return {\r\n    network,\r\n    token,\r\n    amount: requirements.maxAmountRequired || '0',\r\n    networkCAIP,\r\n    tokenCAIP,\r\n    x402Version: options?.x402Version || 1, // Default to v1, upgrade to v2 when ready\r\n    callerId: options?.callerId,\r\n    clientId: options?.clientId,\r\n    region: options?.region,\r\n    riskLevel: options?.riskLevel,\r\n    watchLevel: options?.watchLevel,\r\n    requirements,\r\n  };\r\n}\r\n\r\n","// =============================================================================\r\n// META-FACILITATOR ORCHESTRATION ENGINE\r\n// =============================================================================\r\n// High-level orchestration layer that sits above individual facilitators\r\n// Owns business logic, routing policy, and risk management\r\n\r\nimport { getFacilitatorRouter, type RoutingPreferences, type RoutingPolicy } from '../facilitators/facilitator-router';\r\nimport { type PaymentRequirements, type VerificationResult, type IFacilitator } from '../facilitators/base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { createRoute, updateRouteStatus, createRouteAttempt } from '@/db/smf';\r\nimport { createRouteContext } from '../facilitators/route-context';\r\n\r\n// Re-export for convenience\r\nexport { getFacilitatorRouter };\r\n\r\nconst logger = createLogger({ component: 'MetaFacilitator' });\r\n\r\n/**\r\n * Meta-facilitator orchestration result\r\n */\r\n/**\r\n * Decision trace for routing decisions\r\n * Enables explainer/debugger UI in NexFlow\r\n */\r\nexport interface DecisionTrace {\r\n  timestamp: string;\r\n  reason: string;\r\n  constraints: {\r\n    preferences?: RoutingPreferences;\r\n    policy?: Partial<RoutingPolicy>;\r\n    requirements: PaymentRequirements;\r\n  };\r\n  candidates: Array<{\r\n    facilitatorId: string;\r\n    facilitatorName: string;\r\n    score: number;\r\n    eligible: boolean;\r\n    reasons: string[];\r\n  }>;\r\n  selected: {\r\n    facilitatorId: string;\r\n    score: number;\r\n    alternativesConsidered: number;\r\n  };\r\n}\r\n\r\nexport interface OrchestrationResult extends VerificationResult {\r\n  facilitatorUsed: string;\r\n  routingReason: string;\r\n  alternativesConsidered: number;\r\n  decisionTrace?: DecisionTrace; // Compact decision trace for debugging\r\n  orchestrationMetadata?: {\r\n    cost?: number;\r\n    latency?: number;\r\n    complianceScore?: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Meta-Facilitator\r\n * Orchestrates multiple facilitators with business logic above raw settlement\r\n */\r\nexport class MetaFacilitator {\r\n  private router = getFacilitatorRouter();\r\n\r\n  /**\r\n   * Verify payment with orchestration\r\n   * \r\n   * This is the main entry point for payment verification.\r\n   * It handles:\r\n   * 1. Facilitator selection based on policy\r\n   * 2. Payment routing\r\n   * 3. Failover handling\r\n   * 4. Result aggregation\r\n   * 5. Business logic application\r\n   */\r\n  async verifyPayment(\r\n    payment: string,\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy,\r\n    context?: {\r\n      requestId?: string;\r\n      correlationId?: string;\r\n      clientId?: string;\r\n      agentId?: string;\r\n    }\r\n  ): Promise<OrchestrationResult> {\r\n    const startTime = Date.now();\r\n    let routeId: string | null = null;\r\n\r\n    try {\r\n      // 1. Create route context and route record\r\n      const routeContext = createRouteContext(requirements, {\r\n        callerId: context?.clientId || context?.agentId,\r\n        clientId: context?.clientId,\r\n        x402Version: 1, // Default to v1, can be upgraded\r\n      });\r\n\r\n      // 2. Select best facilitator based on policy\r\n      const facilitator = await this.router.routePayment(requirements, preferences, policy);\r\n\r\n      // 3. Create route record with selected facilitator\r\n      const route = await createRoute({\r\n        request_id: context?.requestId || null,\r\n        correlation_id: context?.correlationId || null,\r\n        client_id: context?.clientId || null,\r\n        agent_id: context?.agentId || null,\r\n        network: routeContext.network,\r\n        token: routeContext.token,\r\n        amount: routeContext.amount,\r\n        selected_facilitator_id: facilitator.id,\r\n        status: 'verifying',\r\n      });\r\n      routeId = route.id;\r\n\r\n      // Log decision trace (compact format)\r\n      logger.info({\r\n        routeId,\r\n        facilitatorId: facilitator.id,\r\n        network: requirements.network,\r\n        asset: requirements.asset,\r\n        settlementMode: requirements.settlementMode,\r\n        preferences: preferences ? {\r\n          priority: preferences.priority,\r\n          jurisdiction: preferences.jurisdiction,\r\n        } : undefined,\r\n      }, 'Routing payment to facilitator');\r\n\r\n      // 3. Verify payment with selected facilitator\r\n      const verifyStartTime = Date.now();\r\n      let result: VerificationResult;\r\n      let attemptResult: 'success' | 'failure' | 'timeout' | 'rate_limited' | 'insufficient_liquidity' | 'invalid_request' | 'network_error' = 'success';\r\n      let errorCode: string | null = null;\r\n      let rawStatus: number | null = null;\r\n\r\n      try {\r\n        result = await facilitator.verify(payment, requirements);\r\n        const verifyLatency = Date.now() - verifyStartTime;\r\n\r\n        // Determine attempt result\r\n        if (!result.success || !result.valid) {\r\n          attemptResult = 'failure';\r\n          errorCode = result.error || 'verification_failed';\r\n        }\r\n\r\n        // Log route attempt\r\n        await createRouteAttempt({\r\n          route_id: routeId,\r\n          facilitator_id: facilitator.id,\r\n          phase: 'verify',\r\n          result: attemptResult,\r\n          latency_ms: verifyLatency,\r\n          error_code: errorCode,\r\n          raw_status: rawStatus,\r\n          is_probe: false,\r\n        });\r\n      } catch (error) {\r\n        const verifyLatency = Date.now() - verifyStartTime;\r\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n\r\n        // Determine error type\r\n        if (errorMessage.includes('timeout') || errorMessage.includes('TIMEOUT')) {\r\n          attemptResult = 'timeout';\r\n        } else if (errorMessage.includes('rate') || errorMessage.includes('429')) {\r\n          attemptResult = 'rate_limited';\r\n          rawStatus = 429;\r\n        } else if (errorMessage.includes('network') || errorMessage.includes('ECONNREFUSED')) {\r\n          attemptResult = 'network_error';\r\n        } else {\r\n          attemptResult = 'failure';\r\n        }\r\n\r\n        errorCode = errorMessage;\r\n\r\n        // Log failed attempt\r\n        await createRouteAttempt({\r\n          route_id: routeId,\r\n          facilitator_id: facilitator.id,\r\n          phase: 'verify',\r\n          result: attemptResult,\r\n          latency_ms: verifyLatency,\r\n          error_code: errorCode,\r\n          raw_status: rawStatus,\r\n          is_probe: false,\r\n        });\r\n\r\n        // Create failure result\r\n        result = {\r\n          success: false,\r\n          valid: false,\r\n          error: errorMessage,\r\n          facilitatorId: facilitator.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // 4. Apply business logic (risk rules, compliance, etc.)\r\n      const orchestrated = this.applyBusinessLogic(result, requirements, policy);\r\n\r\n      // 5. Update route status\r\n      if (orchestrated.success && orchestrated.valid) {\r\n        await updateRouteStatus(routeId, 'settled', new Date().toISOString());\r\n      } else {\r\n        await updateRouteStatus(routeId, 'failed', new Date().toISOString());\r\n      }\r\n\r\n      // 6. Calculate orchestration metadata\r\n      const latency = Date.now() - startTime;\r\n      const metadata = {\r\n        latency,\r\n        complianceScore: this.calculateComplianceScore(result),\r\n      };\r\n\r\n      // 7. Build decision trace (for explainer/debugger UI)\r\n      const eligible = this.router.getFacilitators().filter((f) =>\r\n        f.supports(requirements.network, requirements.asset, requirements.scheme, requirements.settlementMode) && f.config.enabled\r\n      );\r\n      const decisionTrace = await this.buildDecisionTrace(\r\n        facilitator,\r\n        eligible,\r\n        requirements,\r\n        preferences,\r\n        policy\r\n      );\r\n\r\n      return {\r\n        ...orchestrated,\r\n        facilitatorUsed: facilitator.id,\r\n        routingReason: this.getRoutingReason(facilitator, preferences, policy),\r\n        alternativesConsidered: eligible.length - 1,\r\n        decisionTrace,\r\n        orchestrationMetadata: metadata,\r\n      };\r\n    } catch (error) {\r\n      logger.error({ error, requirements, routeId }, 'Orchestration error');\r\n\r\n      // Update route status to failed\r\n      if (routeId) {\r\n        await updateRouteStatus(routeId, 'failed', new Date().toISOString());\r\n      }\r\n\r\n      // Try failover if available\r\n      if (policy?.requireHealthCheck !== false) {\r\n        return await this.handleFailover(payment, requirements, preferences, policy, error, routeId);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply business logic to verification result\r\n   * SMF owns higher-level policy above raw settlement\r\n   */\r\n  private applyBusinessLogic(\r\n    result: VerificationResult,\r\n    requirements: PaymentRequirements,\r\n    policy?: RoutingPolicy\r\n  ): VerificationResult {\r\n    // 1. Risk rules\r\n    if (policy?.riskThreshold !== undefined) {\r\n      const riskScore = this.calculateRiskScore(result);\r\n      if (riskScore > policy.riskThreshold) {\r\n        return {\r\n          ...result,\r\n          valid: false,\r\n          error: `Risk score ${riskScore} exceeds threshold ${policy.riskThreshold}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // 2. Compliance rules\r\n    if (policy?.requireKYC) {\r\n      // Check if KYC is required for this amount\r\n      const amount = BigInt(requirements.maxAmountRequired);\r\n      const kycThreshold = BigInt('1000000000'); // 1000 USDC in smallest units\r\n      \r\n      if (amount > kycThreshold && result.kytStatus !== 'passed') {\r\n        return {\r\n          ...result,\r\n          valid: false,\r\n          error: 'KYC required for this amount',\r\n        };\r\n      }\r\n    }\r\n\r\n    // 3. Jurisdiction rules\r\n    if (policy?.jurisdictionRules) {\r\n      // Apply jurisdiction-specific rules\r\n      // This would integrate with geo-detection\r\n      // For now, pass through\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Calculate risk score (0-100)\r\n   */\r\n  private calculateRiskScore(result: VerificationResult): number {\r\n    let score = 0;\r\n\r\n    // KYT status\r\n    if (result.kytStatus === 'blocked') score += 50;\r\n    else if (result.kytStatus === 'flagged') score += 25;\r\n\r\n    // OFAC status\r\n    if (result.ofacStatus === 'blocked') score += 50;\r\n    else if (result.ofacStatus === 'flagged') score += 25;\r\n\r\n    // Error status\r\n    if (!result.success || !result.valid) score += 30;\r\n\r\n    return Math.min(100, score);\r\n  }\r\n\r\n  /**\r\n   * Calculate compliance score (0-100)\r\n   */\r\n  private calculateComplianceScore(result: VerificationResult): number {\r\n    let score = 100;\r\n\r\n    // Deduct for compliance issues\r\n    if (result.kytStatus === 'blocked') score -= 50;\r\n    else if (result.kytStatus === 'flagged') score -= 25;\r\n\r\n    if (result.ofacStatus === 'blocked') score -= 50;\r\n    else if (result.ofacStatus === 'flagged') score -= 25;\r\n\r\n    return Math.max(0, score);\r\n  }\r\n\r\n  /**\r\n   * Build decision trace for explainer/debugger UI\r\n   * Compact format for logging and future UI display\r\n   */\r\n  private async buildDecisionTrace(\r\n    selected: IFacilitator,\r\n    eligible: IFacilitator[],\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): Promise<DecisionTrace> {\r\n    // Score candidates to get detailed info\r\n    const router = getFacilitatorRouter();\r\n    const scored = await router.scoreFacilitators(\r\n      eligible,\r\n      requirements,\r\n      preferences,\r\n      policy\r\n    );\r\n\r\n    const candidates = eligible.map((f) => {\r\n      const scoredEntry = scored.find((s: any) => s.facilitator.id === f.id);\r\n      const score = scoredEntry?.score || 0;\r\n      const reasons = scoredEntry?.reasons || [];\r\n\r\n      return {\r\n        facilitatorId: f.id,\r\n        facilitatorName: f.name,\r\n        score,\r\n        eligible: true,\r\n        reasons,\r\n      };\r\n    });\r\n\r\n    return {\r\n      timestamp: new Date().toISOString(),\r\n      reason: this.getRoutingReason(selected, preferences, policy),\r\n      constraints: {\r\n        preferences,\r\n        policy: policy ? {\r\n          requireHealthCheck: policy.requireHealthCheck,\r\n          preferCheapest: policy.preferCheapest,\r\n          requireKYC: policy.requireKYC,\r\n        } : undefined,\r\n        requirements,\r\n      },\r\n      candidates,\r\n      selected: {\r\n        facilitatorId: selected.id,\r\n        score: scored.find((s: any) => s.facilitator.id === selected.id)?.score || 100,\r\n        alternativesConsidered: eligible.length - 1,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get routing reason for logging/analytics\r\n   */\r\n  private getRoutingReason(\r\n    facilitator: any,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): string {\r\n    const reasons: string[] = [];\r\n\r\n    if (preferences?.priority === 'cost') reasons.push('cost-optimized');\r\n    if (preferences?.priority === 'speed') reasons.push('speed-optimized');\r\n    if (preferences?.priority === 'compliance') reasons.push('compliance-optimized');\r\n    if (preferences?.priority === 'reliability') reasons.push('reliability-optimized');\r\n    if (preferences?.preferredNetworks) reasons.push('network-preference');\r\n    if (policy?.preferCheapest) reasons.push('cheapest-selected');\r\n    if (facilitator.config.priority === 1) reasons.push('primary-facilitator');\r\n\r\n    return reasons.join(', ') || 'default-routing';\r\n  }\r\n\r\n  /**\r\n   * Handle failover to alternative facilitator\r\n   */\r\n  private async handleFailover(\r\n    payment: string,\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy,\r\n    originalError?: any,\r\n    routeId?: string | null\r\n  ): Promise<OrchestrationResult> {\r\n    logger.warn({ originalError, requirements }, 'Attempting failover');\r\n\r\n    // Get all facilitators\r\n    const facilitators = this.router.getFacilitators();\r\n    const eligible = facilitators.filter((f) =>\r\n      f.supports(requirements.network, requirements.asset, requirements.scheme, requirements.settlementMode) && f.config.enabled\r\n    );\r\n\r\n    // Try each facilitator in order of priority\r\n    for (const facilitator of eligible.sort((a, b) => a.config.priority - b.config.priority)) {\r\n      const attemptStartTime = Date.now();\r\n      try {\r\n        const result = await facilitator.verify(payment, requirements);\r\n        const attemptLatency = Date.now() - attemptStartTime;\r\n        \r\n        // Log failover attempt\r\n        if (routeId) {\r\n          await createRouteAttempt({\r\n            route_id: routeId,\r\n            facilitator_id: facilitator.id,\r\n            phase: 'verify',\r\n            result: result.success && result.valid ? 'success' : 'failure',\r\n            latency_ms: attemptLatency,\r\n            is_probe: false,\r\n            error_code: result.error || null,\r\n            raw_status: null,\r\n          });\r\n        }\r\n        \r\n        if (result.success && result.valid) {\r\n          logger.info({ facilitatorId: facilitator.id, routeId }, 'Failover successful');\r\n          \r\n          // Update route with successful facilitator\r\n          if (routeId) {\r\n            await updateRouteStatus(routeId, 'settled', new Date().toISOString());\r\n          }\r\n          \r\n          return {\r\n            ...result,\r\n            facilitatorUsed: facilitator.id,\r\n            routingReason: 'failover',\r\n            alternativesConsidered: eligible.length - 1,\r\n          };\r\n        }\r\n      } catch (error) {\r\n        const attemptLatency = Date.now() - attemptStartTime;\r\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n        \r\n        // Log failed failover attempt\r\n        if (routeId) {\r\n          let attemptResult: 'timeout' | 'rate_limited' | 'network_error' | 'failure' = 'failure';\r\n          if (errorMessage.includes('timeout')) {\r\n            attemptResult = 'timeout';\r\n          } else if (errorMessage.includes('rate') || errorMessage.includes('429')) {\r\n            attemptResult = 'rate_limited';\r\n          } else if (errorMessage.includes('network') || errorMessage.includes('ECONNREFUSED')) {\r\n            attemptResult = 'network_error';\r\n          }\r\n          \r\n          await createRouteAttempt({\r\n            route_id: routeId,\r\n            facilitator_id: facilitator.id,\r\n            phase: 'verify',\r\n            result: attemptResult,\r\n            latency_ms: attemptLatency,\r\n            is_probe: false,\r\n            error_code: errorMessage,\r\n            raw_status: null,\r\n          });\r\n        }\r\n        \r\n        logger.warn({ facilitatorId: facilitator.id, error, routeId }, 'Failover attempt failed');\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // All facilitators failed\r\n    throw new Error(\r\n      `All facilitators failed. Original error: ${originalError instanceof Error ? originalError.message : 'Unknown error'}`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get orchestrator status\r\n   * Fixed: Aligns health semantics with facilitator health checks\r\n   */\r\n  async getStatus(): Promise<{\r\n    facilitators: number;\r\n    healthy: number;\r\n    networks: string[];\r\n    assets: string[];\r\n    facilitatorDetails: Array<{\r\n      id: string;\r\n      name: string;\r\n      healthy: boolean;\r\n      lastChecked?: string;\r\n    }>;\r\n  }> {\r\n    const facilitators = this.router.getFacilitators();\r\n    \r\n    // Check health of all facilitators (use actual health checks, not cached)\r\n    const healthChecks = await Promise.all(\r\n      facilitators.map(async (f) => {\r\n        try {\r\n          const health = await f.getHealth();\r\n          return {\r\n            id: f.id,\r\n            name: f.name,\r\n            healthy: health.healthy,\r\n            lastChecked: health.lastChecked,\r\n          };\r\n        } catch (error) {\r\n          return {\r\n            id: f.id,\r\n            name: f.name,\r\n            healthy: false,\r\n            lastChecked: new Date().toISOString(),\r\n          };\r\n        }\r\n      })\r\n    );\r\n\r\n    const healthy = healthChecks.filter((h) => h.healthy);\r\n\r\n    const networks = new Set<string>();\r\n    const assets = new Set<string>();\r\n\r\n    facilitators.forEach((f) => {\r\n      f.config.networks.forEach((n) => networks.add(n));\r\n      f.config.assets.forEach((a) => assets.add(a));\r\n    });\r\n\r\n    return {\r\n      facilitators: facilitators.length,\r\n      healthy: healthy.length,\r\n      networks: Array.from(networks),\r\n      assets: Array.from(assets),\r\n      facilitatorDetails: healthChecks,\r\n    };\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet metaFacilitator: MetaFacilitator | null = null;\r\n\r\n/**\r\n * Get meta-facilitator instance\r\n */\r\nexport function getMetaFacilitator(): MetaFacilitator {\r\n  if (!metaFacilitator) {\r\n    metaFacilitator = new MetaFacilitator();\r\n  }\r\n  return metaFacilitator;\r\n}\r\n\r\n","// =============================================================================\n// x402 WATCHLIST DATABASE OPERATIONS\n// =============================================================================\n// Database operations for x402 ecosystem watchlist tracking\n\nimport { getDb } from './client';\nimport { createLogger } from '@/lib/logger';\n\nconst logger = createLogger({ component: 'X402WatchlistDB' });\n\n// Shared type for x402 watchlist items\nexport type X402WatchCategory = \n  | 'spec' \n  | 'index' \n  | 'facilitator_docs' \n  | 'gateway_docs' \n  | 'example_api' \n  | 'ecosystem_blog'\n  | 'bazaar_discovery'\n  | 'facilitator_discovery';\nexport type X402WatchStatus = 'active' | 'paused';\n\nexport interface X402WatchItem {\n  id: string;\n  root_domain: string;\n  path_prefix: string | null;\n  category: X402WatchCategory;\n  priority: number;\n  status: X402WatchStatus;\n  last_checked_at: string | null;\n  last_change_at: string | null;\n  last_etag: string | null;\n  last_http_status: number | null;\n  notes: string | null;\n  created_at: string;\n  updated_at: string;\n}\n\nexport type X402WatchItemInsert = Omit<X402WatchItem, 'id' | 'created_at' | 'updated_at' | 'last_checked_at' | 'last_change_at' | 'last_etag' | 'last_http_status'>;\n\n/**\n * Get all active watchlist items, optionally filtered by minimum priority\n */\nexport async function getActiveWatchlistItems(minPriority?: number): Promise<X402WatchItem[]> {\n  const db = getDb();\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\n\n  let query = `SELECT * FROM x402_watchlist WHERE status = 'active'`;\n  const params: any[] = [];\n\n  if (minPriority !== undefined) {\n    if (isPostgres) {\n      query += ` AND priority >= $1`;\n      params.push(minPriority);\n    } else {\n      query += ` AND priority >= ?`;\n      params.push(minPriority);\n    }\n  }\n\n  query += ` ORDER BY priority DESC, last_checked_at ASC NULLS FIRST`;\n\n  if (isPostgres) {\n    const result = await (db as any).pool.query(query, params);\n    return result.rows;\n  } else {\n    // SQLite\n    const stmt = (db as any).prepare(query);\n    return params.length > 0 ? stmt.all(...params) : stmt.all();\n  }\n}\n\n/**\n * Upsert a watchlist item (by root_domain + path_prefix)\n */\nexport async function upsertWatchlistItem(item: X402WatchItemInsert): Promise<X402WatchItem> {\n  const db = getDb();\n  const id = crypto.randomUUID();\n  const now = new Date().toISOString();\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\n\n  if (isPostgres) {\n    const result = await (db as any).pool.query(\n      `INSERT INTO x402_watchlist (\n        id, root_domain, path_prefix, category, priority, status, notes, created_at, updated_at\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n      ON CONFLICT (root_domain, path_prefix)\n      DO UPDATE SET\n        category = EXCLUDED.category,\n        priority = EXCLUDED.priority,\n        status = EXCLUDED.status,\n        notes = EXCLUDED.notes,\n        updated_at = EXCLUDED.updated_at\n      RETURNING *`,\n      [\n        id,\n        item.root_domain,\n        item.path_prefix,\n        item.category,\n        item.priority,\n        item.status,\n        item.notes,\n        now,\n        now,\n      ]\n    );\n    return result.rows[0];\n  } else {\n    // SQLite - use INSERT OR REPLACE\n    const stmt = (db as any).prepare(`\n      INSERT OR REPLACE INTO x402_watchlist (\n        id, root_domain, path_prefix, category, priority, status, notes, created_at, updated_at\n      ) VALUES (\n        COALESCE((SELECT id FROM x402_watchlist WHERE root_domain = ? AND (path_prefix = ? OR (path_prefix IS NULL AND ? IS NULL))), ?),\n        ?, ?, ?, ?, ?, ?,\n        COALESCE((SELECT created_at FROM x402_watchlist WHERE root_domain = ? AND (path_prefix = ? OR (path_prefix IS NULL AND ? IS NULL))), ?),\n        ?\n      )\n    `);\n    stmt.run(\n      item.root_domain, item.path_prefix, item.path_prefix, id,\n      item.root_domain, item.path_prefix, item.category, item.priority, item.status, item.notes,\n      item.root_domain, item.path_prefix, item.path_prefix, now,\n      now\n    );\n\n    // Fetch the inserted/updated row\n    const selectStmt = (db as any).prepare(\n      `SELECT * FROM x402_watchlist WHERE root_domain = ? AND (path_prefix = ? OR (path_prefix IS NULL AND ? IS NULL))`\n    );\n    return selectStmt.get(item.root_domain, item.path_prefix, item.path_prefix);\n  }\n}\n\n/**\n * Update watchlist item after a crawl check\n */\nexport async function updateWatchlistItemAfterCheck(\n  id: string,\n  httpStatus: number,\n  etag: string | null,\n  changed: boolean\n): Promise<void> {\n  const db = getDb();\n  const now = new Date().toISOString();\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\n\n  if (isPostgres) {\n    if (changed) {\n      await (db as any).pool.query(\n        `UPDATE x402_watchlist \n         SET last_checked_at = $1, last_http_status = $2, last_etag = $3, last_change_at = $4, updated_at = $5\n         WHERE id = $6`,\n        [now, httpStatus, etag, now, now, id]\n      );\n    } else {\n      await (db as any).pool.query(\n        `UPDATE x402_watchlist \n         SET last_checked_at = $1, last_http_status = $2, last_etag = $3, updated_at = $4\n         WHERE id = $5`,\n        [now, httpStatus, etag, now, id]\n      );\n    }\n  } else {\n    // SQLite\n    if (changed) {\n      const stmt = (db as any).prepare(\n        `UPDATE x402_watchlist \n         SET last_checked_at = ?, last_http_status = ?, last_etag = ?, last_change_at = ?, updated_at = ?\n         WHERE id = ?`\n      );\n      stmt.run(now, httpStatus, etag, now, now, id);\n    } else {\n      const stmt = (db as any).prepare(\n        `UPDATE x402_watchlist \n         SET last_checked_at = ?, last_http_status = ?, last_etag = ?, updated_at = ?\n         WHERE id = ?`\n      );\n      stmt.run(now, httpStatus, etag, now, id);\n    }\n  }\n}\n\n/**\n * Get watchlist item by ID\n */\nexport async function getWatchlistItemById(id: string): Promise<X402WatchItem | null> {\n  const db = getDb();\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\n\n  if (isPostgres) {\n    const result = await (db as any).pool.query(\n      `SELECT * FROM x402_watchlist WHERE id = $1`,\n      [id]\n    );\n    return result.rows[0] || null;\n  } else {\n    const stmt = (db as any).prepare(`SELECT * FROM x402_watchlist WHERE id = ?`);\n    return stmt.get(id) || null;\n  }\n}\n\n/**\n * Get all watchlist items (for admin/debugging)\n */\nexport async function getAllWatchlistItems(): Promise<X402WatchItem[]> {\n  const db = getDb();\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\n\n  if (isPostgres) {\n    const result = await (db as any).pool.query(\n      `SELECT * FROM x402_watchlist ORDER BY priority DESC, root_domain`\n    );\n    return result.rows;\n  } else {\n    const stmt = (db as any).prepare(\n      `SELECT * FROM x402_watchlist ORDER BY priority DESC, root_domain`\n    );\n    return stmt.all();\n  }\n}\n\n/**\n * Map root domain to facilitator identifier\n */\nfunction deriveFacilitator(rootDomain: string): 'cdp' | 'payai' | 'cronos' | 'altlayer' | 'unknown' {\n  if (rootDomain.includes('cdp.coinbase.com') || rootDomain.includes('coinbase.com')) {\n    return 'cdp';\n  }\n  if (rootDomain.includes('payai.network')) {\n    return 'payai';\n  }\n  if (rootDomain.includes('cronos') || rootDomain.includes('cronoslabs.org')) {\n    return 'cronos';\n  }\n  if (rootDomain.includes('altlayer.io')) {\n    return 'altlayer';\n  }\n  return 'unknown';\n}\n\n/**\n * Map category to kind\n */\nfunction categoryToKind(category: X402WatchCategory): 'bazaar' | 'facilitator' | 'gateway_docs' | 'spec' | 'index' {\n  if (category === 'bazaar_discovery') {\n    return 'bazaar';\n  }\n  if (category === 'facilitator_discovery') {\n    return 'facilitator';\n  }\n  if (category === 'gateway_docs') {\n    return 'gateway_docs';\n  }\n  if (category === 'spec') {\n    return 'spec';\n  }\n  return 'index';\n}\n\n/**\n * Discovery resource for SMF routing logic\n */\nexport type X402DiscoveryResource = {\n  facilitator: 'cdp' | 'payai' | 'cronos' | 'altlayer' | 'unknown';\n  kind: 'bazaar' | 'facilitator' | 'gateway_docs' | 'spec' | 'index';\n  url: string;\n  lastHttpStatus: number | null;\n  lastSeenAt: string | null;\n  category: X402WatchCategory;\n  priority: number;\n};\n\n/**\n * Get x402 discovery resources for SMF\n * Returns normalized discovery endpoints that can be used by SMF routing logic\n */\nexport async function getX402DiscoveryResources(): Promise<X402DiscoveryResource[]> {\n  const items = await getAllWatchlistItems();\n  \n  return items\n    .filter(item => item.status === 'active')\n    .map(item => {\n      const url = `https://${item.root_domain}${item.path_prefix || ''}`;\n      return {\n        facilitator: deriveFacilitator(item.root_domain),\n        kind: categoryToKind(item.category),\n        url,\n        lastHttpStatus: item.last_http_status,\n        lastSeenAt: item.last_checked_at,\n        category: item.category,\n        priority: item.priority,\n      };\n    })\n    .sort((a, b) => {\n      // Sort by priority (desc) then by facilitator\n      if (b.priority !== a.priority) {\n        return b.priority - a.priority;\n      }\n      return a.facilitator.localeCompare(b.facilitator);\n    });\n}\n\n","// =============================================================================\r\n// AGENT RECOMMENDATIONS DATABASE\r\n// =============================================================================\r\n// Persistence layer for agent recommendations\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  AgentRecommendation,\r\n  AgentRecommendationType,\r\n  AgentId,\r\n  RecommendationStatus,\r\n} from '@/agents/types';\r\n\r\nconst logger = createLogger({ component: 'AgentRecommendationsDB' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface RecommendationFilter {\r\n  agent?: AgentId;\r\n  type?: AgentRecommendationType;\r\n  status?: RecommendationStatus;\r\n  facilitatorId?: string;\r\n  priority?: 'low' | 'medium' | 'high' | 'critical';\r\n  since?: Date;\r\n  limit?: number;\r\n}\r\n\r\nexport interface CreateRecommendationInput {\r\n  agent: AgentId;\r\n  type: AgentRecommendationType;\r\n  facilitatorId?: string;\r\n  resourceId?: string;\r\n  priority: 'low' | 'medium' | 'high' | 'critical';\r\n  confidence: number;\r\n  details: Record<string, unknown>;\r\n  reasoning: string;\r\n  expiresAt?: Date;\r\n}\r\n\r\n// =============================================================================\r\n// DATABASE OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Create a new recommendation\r\n */\r\nexport async function createRecommendation(\r\n  input: CreateRecommendationInput\r\n): Promise<AgentRecommendation> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  const recommendation: AgentRecommendation = {\r\n    id,\r\n    createdAt: now,\r\n    agent: input.agent,\r\n    type: input.type,\r\n    facilitatorId: input.facilitatorId,\r\n    resourceId: input.resourceId,\r\n    priority: input.priority,\r\n    confidence: input.confidence,\r\n    details: input.details,\r\n    reasoning: input.reasoning,\r\n    status: 'PENDING',\r\n    expiresAt: input.expiresAt,\r\n  };\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `INSERT INTO agent_recommendations (\r\n        id, created_at, agent, type, facilitator_id, resource_id,\r\n        priority, confidence, details, reasoning, status, expires_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`,\r\n      [\r\n        id,\r\n        now.toISOString(),\r\n        input.agent,\r\n        input.type,\r\n        input.facilitatorId || null,\r\n        input.resourceId || null,\r\n        input.priority,\r\n        input.confidence,\r\n        JSON.stringify(input.details),\r\n        input.reasoning,\r\n        'PENDING',\r\n        input.expiresAt?.toISOString() || null,\r\n      ]\r\n    );\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO agent_recommendations (\r\n        id, created_at, agent, type, facilitator_id, resource_id,\r\n        priority, confidence, details, reasoning, status, expires_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      now.toISOString(),\r\n      input.agent,\r\n      input.type,\r\n      input.facilitatorId || null,\r\n      input.resourceId || null,\r\n      input.priority,\r\n      input.confidence,\r\n      JSON.stringify(input.details),\r\n      input.reasoning,\r\n      'PENDING',\r\n      input.expiresAt?.toISOString() || null\r\n    );\r\n  }\r\n\r\n  logger.info({\r\n    recommendationId: id,\r\n    agent: input.agent,\r\n    type: input.type,\r\n    priority: input.priority,\r\n    msg: 'Created agent recommendation',\r\n  });\r\n\r\n  return recommendation;\r\n}\r\n\r\n/**\r\n * Create multiple recommendations in batch\r\n */\r\nexport async function createRecommendations(\r\n  inputs: CreateRecommendationInput[]\r\n): Promise<AgentRecommendation[]> {\r\n  const results: AgentRecommendation[] = [];\r\n  for (const input of inputs) {\r\n    const rec = await createRecommendation(input);\r\n    results.push(rec);\r\n  }\r\n  return results;\r\n}\r\n\r\n/**\r\n * List recommendations with optional filters\r\n */\r\nexport async function listRecommendations(\r\n  filter: RecommendationFilter = {}\r\n): Promise<AgentRecommendation[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let query = 'SELECT * FROM agent_recommendations WHERE 1=1';\r\n  const params: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (filter.agent) {\r\n    query += isPostgres ? ` AND agent = $${paramIndex++}` : ' AND agent = ?';\r\n    params.push(filter.agent);\r\n  }\r\n\r\n  if (filter.type) {\r\n    query += isPostgres ? ` AND type = $${paramIndex++}` : ' AND type = ?';\r\n    params.push(filter.type);\r\n  }\r\n\r\n  if (filter.status) {\r\n    query += isPostgres ? ` AND status = $${paramIndex++}` : ' AND status = ?';\r\n    params.push(filter.status);\r\n  }\r\n\r\n  if (filter.facilitatorId) {\r\n    query += isPostgres ? ` AND facilitator_id = $${paramIndex++}` : ' AND facilitator_id = ?';\r\n    params.push(filter.facilitatorId);\r\n  }\r\n\r\n  if (filter.priority) {\r\n    query += isPostgres ? ` AND priority = $${paramIndex++}` : ' AND priority = ?';\r\n    params.push(filter.priority);\r\n  }\r\n\r\n  if (filter.since) {\r\n    query += isPostgres ? ` AND created_at >= $${paramIndex++}` : ' AND created_at >= ?';\r\n    params.push(filter.since.toISOString());\r\n  }\r\n\r\n  query += ' ORDER BY created_at DESC';\r\n\r\n  if (filter.limit) {\r\n    query += isPostgres ? ` LIMIT $${paramIndex++}` : ' LIMIT ?';\r\n    params.push(filter.limit);\r\n  }\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, params);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all(...params);\r\n  }\r\n\r\n  return rows.map(rowToRecommendation);\r\n}\r\n\r\n/**\r\n * Get a single recommendation by ID\r\n */\r\nexport async function getRecommendation(id: string): Promise<AgentRecommendation | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let row: any;\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      'SELECT * FROM agent_recommendations WHERE id = $1',\r\n      [id]\r\n    );\r\n    row = result.rows[0];\r\n  } else {\r\n    const stmt = (db as any).prepare('SELECT * FROM agent_recommendations WHERE id = ?');\r\n    row = stmt.get(id);\r\n  }\r\n\r\n  return row ? rowToRecommendation(row) : null;\r\n}\r\n\r\n/**\r\n * Mark a recommendation as applied\r\n */\r\nexport async function markRecommendationApplied(\r\n  id: string,\r\n  reviewedBy: string,\r\n  metadata?: Record<string, unknown>\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE agent_recommendations\r\n       SET status = 'APPLIED', reviewed_by = $1, reviewed_at = $2,\r\n           details = details || $3\r\n       WHERE id = $4`,\r\n      [reviewedBy, now, JSON.stringify(metadata || {}), id]\r\n    );\r\n  } else {\r\n    // SQLite - simpler update\r\n    const stmt = (db as any).prepare(`\r\n      UPDATE agent_recommendations\r\n      SET status = 'APPLIED', reviewed_by = ?, reviewed_at = ?\r\n      WHERE id = ?\r\n    `);\r\n    stmt.run(reviewedBy, now, id);\r\n  }\r\n\r\n  logger.info({ recommendationId: id, reviewedBy, msg: 'Recommendation applied' });\r\n}\r\n\r\n/**\r\n * Mark a recommendation as rejected\r\n */\r\nexport async function markRecommendationRejected(\r\n  id: string,\r\n  reviewedBy: string,\r\n  reason: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE agent_recommendations\r\n       SET status = 'REJECTED', reviewed_by = $1, reviewed_at = $2,\r\n           details = details || $3\r\n       WHERE id = $4`,\r\n      [reviewedBy, now, JSON.stringify({ rejectionReason: reason }), id]\r\n    );\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      UPDATE agent_recommendations\r\n      SET status = 'REJECTED', reviewed_by = ?, reviewed_at = ?\r\n      WHERE id = ?\r\n    `);\r\n    stmt.run(reviewedBy, now, id);\r\n  }\r\n\r\n  logger.info({ recommendationId: id, reviewedBy, reason, msg: 'Recommendation rejected' });\r\n}\r\n\r\n/**\r\n * Expire old pending recommendations\r\n */\r\nexport async function expirePendingRecommendations(): Promise<number> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `UPDATE agent_recommendations\r\n       SET status = 'EXPIRED'\r\n       WHERE status = 'PENDING' AND expires_at IS NOT NULL AND expires_at < $1`,\r\n      [now]\r\n    );\r\n    return result.rowCount || 0;\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      UPDATE agent_recommendations\r\n      SET status = 'EXPIRED'\r\n      WHERE status = 'PENDING' AND expires_at IS NOT NULL AND expires_at < ?\r\n    `);\r\n    const info = stmt.run(now);\r\n    return info.changes || 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Get pending recommendations count by agent\r\n */\r\nexport async function getPendingCountByAgent(): Promise<Record<AgentId, number>> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  const query = `\r\n    SELECT agent, COUNT(*) as count\r\n    FROM agent_recommendations\r\n    WHERE status = 'PENDING'\r\n    GROUP BY agent\r\n  `;\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all();\r\n  }\r\n\r\n  const counts: Record<string, number> = {};\r\n  for (const row of rows) {\r\n    counts[row.agent] = parseInt(row.count, 10);\r\n  }\r\n  return counts as Record<AgentId, number>;\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\nfunction rowToRecommendation(row: any): AgentRecommendation {\r\n  return {\r\n    id: row.id,\r\n    createdAt: new Date(row.created_at),\r\n    agent: row.agent,\r\n    type: row.type,\r\n    facilitatorId: row.facilitator_id || undefined,\r\n    resourceId: row.resource_id || undefined,\r\n    priority: row.priority,\r\n    confidence: parseFloat(row.confidence),\r\n    details: typeof row.details === 'string' ? JSON.parse(row.details) : row.details,\r\n    reasoning: row.reasoning,\r\n    status: row.status,\r\n    reviewedBy: row.reviewed_by || undefined,\r\n    reviewedAt: row.reviewed_at ? new Date(row.reviewed_at) : undefined,\r\n    expiresAt: row.expires_at ? new Date(row.expires_at) : undefined,\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"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"}