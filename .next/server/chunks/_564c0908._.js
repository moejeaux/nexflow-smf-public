module.exports=[67591,e=>e.a(async(t,n)=>{try{var a=e.i(97739),r=e.i(88391),s=e.i(54735),i=e.i(83786),o=e.i(87349),d=e.i(54799),u=e.i(24924),c=e.i(50377),l=t([u]);[u]=l.then?(await l)():l;let R=(0,c.createLogger)({component:"PlanPayments"}),y="0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",E=process.env.NEXFLOW_TREASURY_ADDRESS||"0x0000000000000000000000000000000000000000",_={free:0,starter:29,pro:99,enterprise:0};(0,s.parseAbi)(["event Transfer(address indexed from, address indexed to, uint256 value)","function balanceOf(address account) view returns (uint256)"]);let A=(0,a.createPublicClient)({chain:o.base,transport:(0,r.http)(process.env.BASE_RPC_URL||"https://mainnet.base.org")});async function p(e,t){let n=(0,u.getDb)(),a=_[t];if(void 0===a)throw Error(`Unknown plan: ${t}`);if(0===a)throw Error(`Plan ${t} is free or requires custom pricing`);if("0x0000000000000000000000000000000000000000"===E)throw Error("NEXFLOW_TREASURY_ADDRESS not configured");let r=`pi_${Date.now()}_${d.default.randomBytes(8).toString("hex")}`,s=new Date,i=new Date(s.getTime()+18e5),o=(BigInt(a)*BigInt(1e6)).toString(),c={id:r,accountId:e,planId:t,amountUsdc:a.toString(),amountAtomic:o,recipientAddress:E,status:"pending",createdAt:s.toISOString(),expiresAt:i.toISOString()};return await n.query(`
    INSERT INTO plan_payment_intents (
      id, account_id, plan_id, amount_usdc, amount_atomic, 
      recipient_address, status, created_at, expires_at
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
  `,[c.id,c.accountId,c.planId,c.amountUsdc,c.amountAtomic,c.recipientAddress,c.status,c.createdAt,c.expiresAt]),R.info({intentId:r,accountId:e,planId:t,amountUsdc:a},"Payment intent created"),c}async function m(e){let t=(0,u.getDb)(),n=await t.query("SELECT * FROM plan_payment_intents WHERE id = $1",[e]);if(0===n.rows.length)return null;let a=n.rows[0];return{id:a.id,accountId:a.account_id,planId:a.plan_id,amountUsdc:a.amount_usdc,amountAtomic:a.amount_atomic,recipientAddress:a.recipient_address,status:a.status,txHash:a.tx_hash||void 0,createdAt:a.created_at,expiresAt:a.expires_at,verifiedAt:a.verified_at||void 0}}async function f(e,t,n){try{let a=await A.getTransactionReceipt({hash:e});if(!a)return{success:!1,error:"Transaction not found"};if("success"!==a.status)return{success:!1,error:"Transaction failed"};for(let r of a.logs.filter(e=>e.address.toLowerCase()===y.toLowerCase()))try{if(r.topics.length>=3){let s=`0x${r.topics[2]?.slice(-40)}`.toLowerCase(),o=BigInt(r.data);if(s===t.toLowerCase()&&o>=BigInt(n)){let t=`0x${r.topics[1]?.slice(-40)}`;return{success:!0,txHash:e,fromAddress:t,amount:(0,i.formatUnits)(o,6),blockNumber:a.blockNumber}}}}catch(e){continue}return{success:!1,error:"No matching USDC transfer found in transaction"}}catch(t){return R.error({error:t,txHash:e},"Payment verification failed"),{success:!1,error:t.message||"Verification failed"}}}async function h(e,t){let n=(0,u.getDb)(),a=await m(e);if(!a)return{success:!1,error:"Payment intent not found"};if("verified"===a.status)return{success:!1,error:"Payment already verified"};if("expired"===a.status||new Date(a.expiresAt)<new Date)return{success:!1,error:"Payment intent expired"};if((await n.query("SELECT id FROM plan_payment_intents WHERE tx_hash = $1 AND id != $2",[t,e])).rows.length>0)return{success:!1,error:"Transaction already used for another payment"};let r=await f(t,a.recipientAddress,a.amountAtomic);if(!r.success)return await n.query("UPDATE plan_payment_intents SET status = 'failed', tx_hash = $1 WHERE id = $2",[t,e]),{success:!1,error:r.error};let s=new Date().toISOString();await n.query(`
    UPDATE plan_payment_intents 
    SET status = 'verified', tx_hash = $1, verified_at = $2 
    WHERE id = $3
  `,[t,s,e]),await n.query(`
    UPDATE account_plans 
    SET is_current = false, expires_at = $1 
    WHERE account_id = $2 AND is_current = true
  `,[s,a.accountId]);let i=await n.query("SELECT daily_limit, monthly_limit FROM plans WHERE id = $1",[a.planId]);if(0===i.rows.length)return{success:!1,error:"Plan not found"};let o=i.rows[0];return await n.query(`
    INSERT INTO account_plans (account_id, plan_id, daily_limit, monthly_limit, started_at, is_current)
    VALUES ($1, $2, $3, $4, $5, true)
  `,[a.accountId,a.planId,o.daily_limit,o.monthly_limit,s]),R.info({intentId:e,accountId:a.accountId,planId:a.planId,txHash:t,fromAddress:r.fromAddress},"Plan payment verified and upgraded"),{success:!0,newPlan:a.planId}}e.s(["TREASURY_ADDRESS",0,E,"USDC_ADDRESS",0,y,"createPlanPaymentIntent",()=>p,"getPaymentIntent",()=>m,"verifyAndProcessPlanPayment",()=>h]),n()}catch(e){n(e)}},!1),58687,e=>e.a(async(t,n)=>{try{var a=e.i(89171),r=e.i(22632),s=e.i(79832),i=e.i(67591),o=e.i(24924),d=t([s,i,o]);[s,i,o]=d.then?(await d)():d;let p=r.z.object({planId:r.z.enum(["starter","pro"],{errorMap:()=>({message:"Only starter and pro plans require payment"})})});async function u(e){let t=await (0,s.requireAuth)(e);if(t.response)return t.response;let{apiKey:n}=t,r=n.userId;if(!r)return a.NextResponse.json({error:"No account associated with this API key",code:"NO_ACCOUNT"},{status:400});try{let t=await e.json(),n=p.safeParse(t);if(!n.success)return a.NextResponse.json({error:"Validation failed",code:"VALIDATION_ERROR",details:n.error.issues},{status:400});let{planId:s}=n.data;if("0x0000000000000000000000000000000000000000"===i.TREASURY_ADDRESS)return a.NextResponse.json({error:"Payment system not configured",code:"PAYMENT_NOT_CONFIGURED",details:"NEXFLOW_TREASURY_ADDRESS environment variable is not set"},{status:503});let d=(0,o.getDb)(),u=await d.query("SELECT plan_id FROM account_plans WHERE account_id = $1 AND is_current = true",[r]);if(u.rows[0]?.plan_id===s)return a.NextResponse.json({error:"You are already on this plan",code:"ALREADY_ON_PLAN"},{status:400});let c=await (0,i.createPlanPaymentIntent)(r,s);return a.NextResponse.json({success:!0,paymentIntent:{id:c.id,planId:c.planId,amount:{usdc:c.amountUsdc,atomic:c.amountAtomic,display:`$${c.amountUsdc} USDC`},recipient:{address:c.recipientAddress,network:"Base (Chain ID: 8453)",token:{symbol:"USDC",address:i.USDC_ADDRESS,decimals:6}},expiresAt:c.expiresAt,expiresInSeconds:Math.floor((new Date(c.expiresAt).getTime()-Date.now())/1e3)},instructions:{step1:"Send the exact USDC amount to the recipient address on Base network",step2:"Copy the transaction hash after the transfer is confirmed",step3:"Submit the transaction hash using PUT /api/v1/user/upgrade-plan/payment",note:"Payment must be completed within 30 minutes"}})}catch(e){return console.error("[upgrade-plan/payment] Create error:",e),a.NextResponse.json({error:e.message||"Failed to create payment intent",code:"INTERNAL_ERROR"},{status:500})}}let m=r.z.object({paymentIntentId:r.z.string().min(1,"Payment intent ID is required"),txHash:r.z.string().regex(/^0x[a-fA-F0-9]{64}$/,"Invalid transaction hash format")});async function c(e){let t=await (0,s.requireAuth)(e);if(t.response)return t.response;let{apiKey:n}=t,r=n.userId;if(!r)return a.NextResponse.json({error:"No account associated with this API key",code:"NO_ACCOUNT"},{status:400});try{let t=await e.json(),n=m.safeParse(t);if(!n.success)return a.NextResponse.json({error:"Validation failed",code:"VALIDATION_ERROR",details:n.error.issues},{status:400});let{paymentIntentId:s,txHash:d}=n.data,u=await (0,i.getPaymentIntent)(s);if(!u)return a.NextResponse.json({error:"Payment intent not found",code:"INTENT_NOT_FOUND"},{status:404});if(u.accountId!==r)return a.NextResponse.json({error:"Payment intent belongs to another account",code:"UNAUTHORIZED"},{status:403});let c=await (0,i.verifyAndProcessPlanPayment)(s,d);if(!c.success)return a.NextResponse.json({error:c.error||"Payment verification failed",code:"PAYMENT_VERIFICATION_FAILED"},{status:400});let l=(0,o.getDb)(),p=(await l.query("SELECT name, daily_limit, monthly_limit FROM plans WHERE id = $1",[c.newPlan])).rows[0];return a.NextResponse.json({success:!0,message:`Successfully upgraded to ${p?.name||c.newPlan} plan!`,plan:{id:c.newPlan,name:p?.name,dailyLimit:p?.daily_limit,monthlyLimit:p?.monthly_limit},payment:{txHash:d,verifiedAt:new Date().toISOString(),network:"Base",basescanUrl:`https://basescan.org/tx/${d}`}})}catch(e){return console.error("[upgrade-plan/payment] Verify error:",e),a.NextResponse.json({error:e.message||"Failed to verify payment",code:"INTERNAL_ERROR"},{status:500})}}async function l(e){let t=await (0,s.requireAuth)(e);if(t.response)return t.response;let{apiKey:n}=t,r=n.userId;if(!r)return a.NextResponse.json({error:"No account associated with this API key",code:"NO_ACCOUNT"},{status:400});let d=e.nextUrl.searchParams.get("intentId");if(!d){let e=(0,o.getDb)(),t=await e.query(`
      SELECT id, plan_id, amount_usdc, status, created_at, expires_at
      FROM plan_payment_intents
      WHERE account_id = $1
      ORDER BY created_at DESC
      LIMIT 10
    `,[r]);return a.NextResponse.json({success:!0,intents:t.rows.map(e=>({id:e.id,planId:e.plan_id,amountUsdc:e.amount_usdc,status:e.status,createdAt:e.created_at,expiresAt:e.expires_at}))})}let u=await (0,i.getPaymentIntent)(d);return u?u.accountId!==r?a.NextResponse.json({error:"Unauthorized",code:"UNAUTHORIZED"},{status:403}):a.NextResponse.json({success:!0,intent:{id:u.id,planId:u.planId,amountUsdc:u.amountUsdc,amountAtomic:u.amountAtomic,recipientAddress:u.recipientAddress,status:u.status,txHash:u.txHash,createdAt:u.createdAt,expiresAt:u.expiresAt,verifiedAt:u.verifiedAt}}):a.NextResponse.json({error:"Payment intent not found",code:"INTENT_NOT_FOUND"},{status:404})}e.s(["GET",()=>l,"POST",()=>u,"PUT",()=>c]),n()}catch(e){n(e)}},!1),62545,e=>e.a(async(t,n)=>{try{var a=e.i(47909),r=e.i(74017),s=e.i(96250),i=e.i(59756),o=e.i(61916),d=e.i(14444),u=e.i(37092),c=e.i(69741),l=e.i(16795),p=e.i(87718),m=e.i(95169),f=e.i(47587),h=e.i(66012),R=e.i(70101),y=e.i(26937),E=e.i(10372),_=e.i(93695);e.i(52474);var A=e.i(220),w=e.i(58687),g=t([w]);[w]=g.then?(await g)():g;let I=new a.AppRouteRouteModule({definition:{kind:r.RouteKind.APP_ROUTE,page:"/api/v1/user/upgrade-plan/payment/route",pathname:"/api/v1/user/upgrade-plan/payment",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/v1/user/upgrade-plan/payment/route.ts",nextConfigOutput:"standalone",userland:w}),{workAsyncStorage:v,workUnitAsyncStorage:S,serverHooks:T}=I;function x(){return(0,s.patchFetch)({workAsyncStorage:v,workUnitAsyncStorage:S})}async function N(e,t,n){I.isDev&&(0,i.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let a="/api/v1/user/upgrade-plan/payment/route";a=a.replace(/\/index$/,"")||"/";let s=await I.prepare(e,t,{srcPage:a,multiZoneDraftMode:!1});if(!s)return t.statusCode=400,t.end("Bad Request"),null==n.waitUntil||n.waitUntil.call(n,Promise.resolve()),null;let{buildId:w,params:g,nextConfig:x,parsedUrl:N,isDraftMode:v,prerenderManifest:S,routerServerContext:T,isOnDemandRevalidate:P,revalidateOnlyGenerated:D,resolvedPathname:C,clientReferenceManifest:O,serverActionsManifest:U}=s,b=(0,c.normalizeAppPath)(a),$=!!(S.dynamicRoutes[b]||S.routes[C]),H=async()=>((null==T?void 0:T.render404)?await T.render404(e,t,N,!1):t.end("This page could not be found"),null);if($&&!v){let e=!!S.routes[C],t=S.dynamicRoutes[b];if(t&&!1===t.fallback&&!e){if(x.experimental.adapterPath)return await H();throw new _.NoFallbackError}}let L=null;!$||I.isDev||v||(L=C,L="/index"===L?"/":L);let q=!0===I.isDev||!$,j=$&&!q;U&&O&&(0,d.setReferenceManifestsSingleton)({page:a,clientReferenceManifest:O,serverActionsManifest:U,serverModuleMap:(0,u.createServerModuleMap)({serverActionsManifest:U})});let M=e.method||"GET",F=(0,o.getTracer)(),k=F.getActiveScopeSpan(),B={params:g,prerenderManifest:S,renderOpts:{experimental:{authInterrupts:!!x.experimental.authInterrupts},cacheComponents:!!x.cacheComponents,supportsDynamicResponse:q,incrementalCache:(0,i.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:x.cacheLife,waitUntil:n.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,n,a)=>I.onRequestError(e,t,a,T)},sharedContext:{buildId:w}},W=new l.NodeNextRequest(e),V=new l.NodeNextResponse(t),Y=p.NextRequestAdapter.fromNodeNextRequest(W,(0,p.signalFromNodeResponse)(t));try{let s=async e=>I.handle(Y,B).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let n=F.getRootSpanAttributes();if(!n)return;if(n.get("next.span_type")!==m.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${n.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let r=n.get("next.route");if(r){let t=`${M} ${r}`;e.setAttributes({"next.route":r,"http.route":r,"next.span_name":t}),e.updateName(t)}else e.updateName(`${M} ${a}`)}),d=!!(0,i.getRequestMeta)(e,"minimalMode"),u=async i=>{var o,u;let c=async({previousCacheEntry:r})=>{try{if(!d&&P&&D&&!r)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let a=await s(i);e.fetchMetrics=B.renderOpts.fetchMetrics;let o=B.renderOpts.pendingWaitUntil;o&&n.waitUntil&&(n.waitUntil(o),o=void 0);let u=B.renderOpts.collectedTags;if(!$)return await (0,h.sendResponse)(W,V,a,B.renderOpts.pendingWaitUntil),null;{let e=await a.blob(),t=(0,R.toNodeOutgoingHttpHeaders)(a.headers);u&&(t[E.NEXT_CACHE_TAGS_HEADER]=u),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let n=void 0!==B.renderOpts.collectedRevalidate&&!(B.renderOpts.collectedRevalidate>=E.INFINITE_CACHE)&&B.renderOpts.collectedRevalidate,r=void 0===B.renderOpts.collectedExpire||B.renderOpts.collectedExpire>=E.INFINITE_CACHE?void 0:B.renderOpts.collectedExpire;return{value:{kind:A.CachedRouteKind.APP_ROUTE,status:a.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:n,expire:r}}}}catch(t){throw(null==r?void 0:r.isStale)&&await I.onRequestError(e,t,{routerKind:"App Router",routePath:a,routeType:"route",revalidateReason:(0,f.getRevalidateReason)({isStaticGeneration:j,isOnDemandRevalidate:P})},T),t}},l=await I.handleResponse({req:e,nextConfig:x,cacheKey:L,routeKind:r.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:S,isRoutePPREnabled:!1,isOnDemandRevalidate:P,revalidateOnlyGenerated:D,responseGenerator:c,waitUntil:n.waitUntil,isMinimalMode:d});if(!$)return null;if((null==l||null==(o=l.value)?void 0:o.kind)!==A.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==l||null==(u=l.value)?void 0:u.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});d||t.setHeader("x-nextjs-cache",P?"REVALIDATED":l.isMiss?"MISS":l.isStale?"STALE":"HIT"),v&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let p=(0,R.fromNodeOutgoingHttpHeaders)(l.value.headers);return d&&$||p.delete(E.NEXT_CACHE_TAGS_HEADER),!l.cacheControl||t.getHeader("Cache-Control")||p.get("Cache-Control")||p.set("Cache-Control",(0,y.getCacheControlHeader)(l.cacheControl)),await (0,h.sendResponse)(W,V,new Response(l.value.body,{headers:p,status:l.value.status||200})),null};k?await u(k):await F.withPropagatedContext(e.headers,()=>F.trace(m.BaseServerSpan.handleRequest,{spanName:`${M} ${a}`,kind:o.SpanKind.SERVER,attributes:{"http.method":M,"http.target":e.url}},u))}catch(t){if(t instanceof _.NoFallbackError||await I.onRequestError(e,t,{routerKind:"App Router",routePath:b,routeType:"route",revalidateReason:(0,f.getRevalidateReason)({isStaticGeneration:j,isOnDemandRevalidate:P})}),$)throw t;return await (0,h.sendResponse)(W,V,new Response(null,{status:500})),null}}e.s(["handler",()=>N,"patchFetch",()=>x,"routeModule",()=>I,"serverHooks",()=>T,"workAsyncStorage",()=>v,"workUnitAsyncStorage",()=>S]),n()}catch(e){n(e)}},!1)];

//# sourceMappingURL=_564c0908._.js.map