{"version":3,"sources":["../../../node_modules/uncrypto/dist/crypto.node.mjs","../../../node_modules/viem/utils/signature/verifyTypedData.ts","../../../node_modules/viem/utils/signature/recoverTypedDataAddress.ts","../../../src/integrations/x402/facilitators/base-facilitator.ts","../../../src/services/facilitator-metrics-reader.ts"],"sourcesContent":["import nodeCrypto from 'node:crypto';\n\nconst subtle = nodeCrypto.webcrypto?.subtle || {};\nconst randomUUID = () => {\n  return nodeCrypto.randomUUID();\n};\nconst getRandomValues = (array) => {\n  return nodeCrypto.webcrypto.getRandomValues(array);\n};\nconst _crypto = {\n  randomUUID,\n  getRandomValues,\n  subtle\n};\n\nexport { _crypto as default, getRandomValues, randomUUID, subtle };\n","import type { Address, TypedData } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport { type GetAddressErrorType, getAddress } from '../address/getAddress.js'\nimport {\n  type IsAddressEqualErrorType,\n  isAddressEqual,\n} from '../address/isAddressEqual.js'\nimport {\n  type RecoverTypedDataAddressParameters,\n  recoverTypedDataAddress,\n} from './recoverTypedDataAddress.js'\n\nexport type VerifyTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType> & {\n  /** The address to verify the typed data for. */\n  address: Address\n  /** The signature to verify */\n  signature: Hex | ByteArray | Signature\n}\n\nexport type VerifyTypedDataReturnType = boolean\n\nexport type VerifyTypedDataErrorType =\n  | IsAddressEqualErrorType\n  | GetAddressErrorType\n  | RecoverTypedDataAddressParameters\n  | ErrorType\n\n/**\n * Verify that typed data was signed by the provided address.\n *\n * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.\n *        It is highly recommended to use `publicClient.verifyTypedData` instead to ensure\n *        wallet interoperability.\n *\n * - Docs {@link https://viem.sh/docs/utilities/verifyTypedData}\n *\n * @param parameters - {@link VerifyTypedDataParameters}\n * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}\n */\nexport async function verifyTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: VerifyTypedDataParameters<typedData, primaryType>,\n): Promise<VerifyTypedDataReturnType> {\n  const { address, domain, message, primaryType, signature, types } =\n    parameters as unknown as VerifyTypedDataParameters\n  return isAddressEqual(\n    getAddress(address),\n    await recoverTypedDataAddress({\n      domain,\n      message,\n      primaryType,\n      signature,\n      types,\n    } as RecoverTypedDataAddressParameters),\n  )\n}\n","import type { Address, TypedData } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport { type HashTypedDataErrorType, hashTypedData } from './hashTypedData.js'\nimport {\n  type RecoverAddressErrorType,\n  recoverAddress,\n} from './recoverAddress.js'\n\nexport type RecoverTypedDataAddressParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType> & {\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverTypedDataAddressReturnType = Address\n\nexport type RecoverTypedDataAddressErrorType =\n  | RecoverAddressErrorType\n  | HashTypedDataErrorType\n  | ErrorType\n\nexport async function recoverTypedDataAddress<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: RecoverTypedDataAddressParameters<typedData, primaryType>,\n): Promise<RecoverTypedDataAddressReturnType> {\n  const { domain, message, primaryType, signature, types } =\n    parameters as unknown as RecoverTypedDataAddressParameters\n  return recoverAddress({\n    hash: hashTypedData({\n      domain,\n      message,\n      primaryType,\n      types,\n    }),\n    signature,\n  })\n}\n","// =============================================================================\n// FACILITATOR ABSTRACTION LAYER\n// =============================================================================\n// Base interface and types for pluggable x402 facilitators\n// Enables multi-facilitator orchestration and routing\n\nimport { createLogger } from '@/lib/logger';\n\nconst logger = createLogger({ component: 'BaseFacilitator' });\n\n/**\n * CAIP-2 Network Identifier (e.g., \"eip155:8453\" for Base)\n * CAIP-19 Asset Identifier (e.g., \"eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\" for USDC on Base)\n */\nexport type CAIPNetworkId = string; // e.g., \"eip155:8453\", \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\", \"bip122:000000000019d6689c085ae165831e93\"\nexport type CAIPAssetId = string; // e.g., \"eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\"\n\n/**\n * Settlement mode for payments\n */\nexport type SettlementMode = 'immediate' | 'deferred' | 'batch';\n\n/**\n * Payment requirements for x402 payment verification\n * Extended to support CAIP identifiers and settlement modes\n */\nexport interface PaymentRequirements {\n  scheme: string; // 'exact', 'x402', etc.\n  network: string; // Legacy: 'base', 'ethereum', 'solana', etc.\n  networks?: CAIPNetworkId[]; // CAIP-2 network identifiers (multi-network support)\n  maxAmountRequired: string; // Amount in smallest units\n  resource: string; // Resource URL\n  description?: string;\n  mimeType?: string;\n  payTo: string; // Recipient address\n  maxTimeoutSeconds?: number;\n  asset: string; // Legacy: Token address\n  assets?: CAIPAssetId[]; // CAIP-19 asset identifiers (multi-asset support)\n  settlementMode?: SettlementMode; // 'immediate', 'deferred', or 'batch'\n}\n\n/**\n * Payment verification result\n */\nexport interface VerificationResult {\n  success: boolean;\n  valid: boolean;\n  transactionHash?: string;\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\n  error?: string;\n  errorDetails?: Record<string, any>;\n  facilitatorId: string; // Which facilitator verified this\n  verifiedAt: string; // ISO timestamp\n}\n\n/**\n * Facilitator health status\n */\nexport interface FacilitatorHealth {\n  healthy: boolean;\n  latency?: number; // ms\n  lastChecked: string; // ISO timestamp\n  error?: string;\n  capabilities: {\n    networks: string[];\n    assets: string[];\n    schemes: string[];\n  };\n}\n\n/**\n * Pricing information for a facilitator\n */\nexport interface PricingInfo {\n  network: string;\n  asset: string;\n  baseFee?: string; // Base fee in smallest units\n  percentageFee?: number; // Percentage fee (0-1)\n  estimatedGas?: string; // Estimated gas cost\n  currency: string; // Fee currency\n}\n\n/**\n * Facilitator configuration\n */\nexport interface FacilitatorConfig {\n  id: string;\n  name: string;\n  enabled: boolean;\n  priority: number; // Lower = higher priority\n  networks: string[]; // Legacy: Supported networks\n  networksCAIP?: CAIPNetworkId[]; // CAIP-2 network identifiers\n  assets: string[]; // Legacy: Supported assets\n  assetsCAIP?: CAIPAssetId[]; // CAIP-19 asset identifiers\n  schemes: string[]; // Supported schemes ('exact', 'x402', etc.)\n  settlementModes?: SettlementMode[]; // Supported settlement modes\n  healthCheckUrl?: string;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Base facilitator interface\n * All facilitators must implement this interface\n */\nexport interface IFacilitator {\n  /**\n   * Unique identifier for this facilitator\n   */\n  readonly id: string;\n\n  /**\n   * Human-readable name\n   */\n  readonly name: string;\n\n  /**\n   * Facilitator configuration\n   */\n  readonly config: FacilitatorConfig;\n\n  /**\n   * Verify an x402 payment\n   */\n  verify(\n    payment: string,\n    requirements: PaymentRequirements\n  ): Promise<VerificationResult>;\n\n  /**\n   * Check facilitator health\n   */\n  getHealth(): Promise<FacilitatorHealth>;\n\n  /**\n   * Get pricing information for a network/asset combination\n   */\n  getPricing(network: string, asset: string): Promise<PricingInfo | null>;\n\n  /**\n   * Check if facilitator supports a given network/asset/scheme\n   * Extended to support settlement modes\n   */\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean;\n\n  /**\n   * Check if facilitator supports a CAIP-2 network identifier\n   */\n  supportsCAIPNetwork(caip: CAIPNetworkId): boolean;\n\n  /**\n   * Check if facilitator supports a CAIP-19 asset identifier\n   */\n  supportsCAIPAsset(caip: CAIPAssetId): boolean;\n}\n\n/**\n * Base facilitator class with common functionality\n */\nexport abstract class BaseFacilitator implements IFacilitator {\n  abstract readonly id: string;\n  abstract readonly name: string;\n  abstract readonly config: FacilitatorConfig;\n\n  protected getLogger() {\n    return logger.child({ facilitator: this.constructor.name });\n  }\n\n  /**\n   * Verify payment (must be implemented by subclasses)\n   */\n  abstract verify(\n    payment: string,\n    requirements: PaymentRequirements\n  ): Promise<VerificationResult>;\n\n  /**\n   * Get health status (must be implemented by subclasses)\n   */\n  abstract getHealth(): Promise<FacilitatorHealth>;\n\n  /**\n   * Get pricing (default implementation returns null)\n   */\n  async getPricing(network: string, asset: string): Promise<PricingInfo | null> {\n    // Default: no pricing info available\n    return null;\n  }\n\n  /**\n   * Check if facilitator supports network/asset/scheme\n   * Enhanced to support both legacy and CAIP identifiers\n   */\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n\n    // Check scheme support\n    if (!this.config.schemes.includes(scheme)) {\n      return false;\n    }\n\n    // Check settlement mode support\n    if (settlementMode && this.config.settlementModes && !this.config.settlementModes.includes(settlementMode)) {\n      return false;\n    }\n\n    // Check network support (legacy or CAIP)\n    const supportsNetwork = \n      this.config.networks.includes(network) ||\n      (this.config.networksCAIP && this.config.networksCAIP.includes(network as CAIPNetworkId));\n\n    if (!supportsNetwork) {\n      return false;\n    }\n\n    // Check asset support (legacy or CAIP)\n    const supportsAsset = \n      this.config.assets.includes(asset) ||\n      (this.config.assetsCAIP && this.config.assetsCAIP.includes(asset as CAIPAssetId));\n\n    return supportsAsset;\n  }\n\n  /**\n   * Check if facilitator supports a CAIP-2 network identifier\n   */\n  supportsCAIPNetwork(caip: CAIPNetworkId): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n    return this.config.networksCAIP?.includes(caip) || false;\n  }\n\n  /**\n   * Check if facilitator supports a CAIP-19 asset identifier\n   */\n  supportsCAIPAsset(caip: CAIPAssetId): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n    return this.config.assetsCAIP?.includes(caip) || false;\n  }\n\n  /**\n   * Validate payment requirements\n   * Enhanced to support CAIP identifiers\n   */\n  protected validateRequirements(\n    requirements: PaymentRequirements\n  ): { valid: boolean; error?: string } {\n    // Check network (legacy or CAIP)\n    const hasNetwork = \n      !!requirements.network || \n      (requirements.networks && requirements.networks.length > 0);\n    \n    if (!hasNetwork) {\n      return { valid: false, error: 'Network is required' };\n    }\n\n    // Check asset (legacy or CAIP)\n    const hasAsset = \n      !!requirements.asset || \n      (requirements.assets && requirements.assets.length > 0);\n    \n    if (!hasAsset) {\n      return { valid: false, error: 'Asset is required' };\n    }\n\n    if (!requirements.payTo) {\n      return { valid: false, error: 'Recipient address (payTo) is required' };\n    }\n    if (!requirements.maxAmountRequired) {\n      return { valid: false, error: 'Amount is required' };\n    }\n\n    // Check support (use legacy network/asset for supports() check, or check CAIP directly)\n    const networkToCheck = requirements.network || (requirements.networks?.[0] || '');\n    const assetToCheck = requirements.asset || (requirements.assets?.[0] || '');\n    \n    // Check CAIP support if CAIP identifiers are provided\n    if (requirements.networks && requirements.networks.length > 0) {\n      const supportsAnyNetwork = requirements.networks.some((n) => \n        this.supportsCAIPNetwork(n) || this.config.networks.includes(n)\n      );\n      if (!supportsAnyNetwork) {\n        return {\n          valid: false,\n          error: `Facilitator ${this.id} does not support any of the requested networks: ${requirements.networks.join(', ')}`,\n        };\n      }\n    }\n\n    if (requirements.assets && requirements.assets.length > 0) {\n      const supportsAnyAsset = requirements.assets.some((a) => \n        this.supportsCAIPAsset(a) || this.config.assets.includes(a)\n      );\n      if (!supportsAnyAsset) {\n        return {\n          valid: false,\n          error: `Facilitator ${this.id} does not support any of the requested assets: ${requirements.assets.join(', ')}`,\n        };\n      }\n    }\n\n    // Check legacy support\n    if (!this.supports(networkToCheck, assetToCheck, requirements.scheme, requirements.settlementMode)) {\n      return {\n        valid: false,\n        error: `Facilitator ${this.id} does not support ${networkToCheck}/${assetToCheck}/${requirements.scheme}`,\n      };\n    }\n    return { valid: true };\n  }\n}\n\n","// =============================================================================\n// FACILITATOR METRICS READER\n// =============================================================================\n// Read-side helper for SMF to access facilitator path metrics\n// Used by the SMF router to inform routing decisions\n//\n// Scoring blends two data sources:\n// 1. x402scan: Observability metrics (success rate, latency, confidence)\n// 2. Scattering: Activity metrics (volume, tx count, unique buyers)\n\nimport { createLogger } from '@/lib/logger';\nimport {\n  type FacilitatorPathMetrics,\n  type FacilitatorSummary,\n  type FacilitatorPathMetricsTimeframe,\n} from '@/infra/x402scan/types';\nimport {\n  loadAllMetrics,\n  loadAllSummaries,\n  getSummary,\n  getMetricsForFacilitator,\n} from './facilitator-metrics-service';\nimport {\n  getScatteringMetricsForFacilitator,\n  computeActivityScore,\n} from './facilitator-volume-service';\nimport type { ScatteringFacilitatorMetrics } from '@/infra/scattering/types';\n\nconst logger = createLogger({ component: 'FacilitatorMetricsReader' });\n\n// =============================================================================\n// FRESHNESS & CONFIDENCE CONFIGURATION\n// =============================================================================\n\n/**\n * Configuration for determining when metrics are trustworthy\n * These thresholds prevent routing decisions based on stale or thin data\n */\nexport interface MetricsTrustConfig {\n  /** Maximum age of data to trust (hours) */\n  maxDataAgeHours: number;\n  /** Minimum invocations for high confidence scoring */\n  minInvocationsHighConfidence: number;\n  /** Minimum invocations to use data at all */\n  minInvocationsMinimum: number;\n  /** Penalty multiplier for low confidence data (0-1) */\n  lowConfidencePenalty: number;\n}\n\n/**\n * Default trust configuration\n * Can be overridden via environment variables\n */\nexport const DEFAULT_TRUST_CONFIG: MetricsTrustConfig = {\n  maxDataAgeHours: parseFloat(process.env.METRICS_MAX_AGE_HOURS ?? '4'),\n  minInvocationsHighConfidence: parseInt(process.env.METRICS_MIN_INVOCATIONS_HIGH ?? '1000', 10),\n  minInvocationsMinimum: parseInt(process.env.METRICS_MIN_INVOCATIONS ?? '100', 10),\n  lowConfidencePenalty: parseFloat(process.env.METRICS_LOW_CONFIDENCE_PENALTY ?? '0.5'),\n};\n\n/**\n * Check if metrics should be trusted for routing decisions\n */\nexport function shouldTrustMetrics(\n  dataAgeHours: number,\n  invocations: number,\n  config: MetricsTrustConfig = DEFAULT_TRUST_CONFIG\n): { trust: boolean; confidence: 'high' | 'medium' | 'low' | 'none'; reason: string } {\n  // Data too old\n  if (dataAgeHours > config.maxDataAgeHours) {\n    return {\n      trust: false,\n      confidence: 'none',\n      reason: `data-stale:${dataAgeHours.toFixed(1)}h-old`,\n    };\n  }\n\n  // Not enough data\n  if (invocations < config.minInvocationsMinimum) {\n    return {\n      trust: false,\n      confidence: 'none',\n      reason: `insufficient-data:${invocations}-invocations`,\n    };\n  }\n\n  // High confidence\n  if (invocations >= config.minInvocationsHighConfidence) {\n    return {\n      trust: true,\n      confidence: 'high',\n      reason: `high-confidence:${invocations}-invocations`,\n    };\n  }\n\n  // Medium confidence\n  return {\n    trust: true,\n    confidence: 'medium',\n    reason: `medium-confidence:${invocations}-invocations`,\n  };\n}\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface GetBestPathsParams {\n  /** Facilitator ID (NexFlow format, e.g., \"cdp\", \"payai\") */\n  facilitatorId: string;\n  \n  /** Network filter (optional) */\n  network?: string;\n  \n  /** Timeframe to consider (default: \"1d\") */\n  timeframe?: FacilitatorPathMetricsTimeframe;\n  \n  /** Maximum number of results */\n  limit?: number;\n}\n\nexport interface FacilitatorScoreParams {\n  /** Facilitator ID */\n  facilitatorId: string;\n  \n  /** Timeframe to consider */\n  timeframe?: FacilitatorPathMetricsTimeframe;\n}\n\nexport interface FacilitatorScore {\n  facilitatorId: string;\n  score: number;             // 0-100, higher is better\n  successRate: number;       // 0-1\n  avgLatencyMs?: number;\n  p95LatencyMs?: number;\n  totalInvocations: number;\n  dataFreshness: number;     // hours since last data\n  confidence: 'high' | 'medium' | 'low' | 'none';  // based on data availability\n  reasons: string[];\n  // Scattering activity metrics\n  scatteringActivityScore?: number;    // 0-1 activity score from Scattering\n  scatteringVolume3d?: number;         // 3-day volume in USD\n  scatteringTxCount3d?: number;        // 3-day transaction count\n  scatteringUniqueBuyers3d?: number;   // 3-day unique buyers\n  scatteringLowActivity?: boolean;     // true if below thresholds\n}\n\nexport interface FacilitatorRanking {\n  rankings: FacilitatorScore[];\n  timestamp: string;\n  timeframe: FacilitatorPathMetricsTimeframe;\n}\n\n// =============================================================================\n// SCORING WEIGHTS & CONFIGURATION\n// =============================================================================\n\n/**\n * Scattering score weight (0-1)\n * Controls how much Scattering activity metrics influence the final score\n * Default: 0.2 (20%) - configurable via SCATTERING_SCORE_WEIGHT env var\n */\nconst SCATTERING_SCORE_WEIGHT = parseFloat(process.env.SCATTERING_SCORE_WEIGHT ?? '0.2');\n\n/**\n * Minimum thresholds for Scattering data to be considered meaningful\n * Below these thresholds, activity is flagged as \"low\" and doesn't boost score\n */\nconst SCATTERING_MIN_TX_COUNT_3D = parseInt(process.env.SCATTERING_MIN_TX_COUNT ?? '100', 10);\nconst SCATTERING_MIN_VOLUME_USD_3D = parseFloat(process.env.SCATTERING_MIN_VOLUME ?? '100');\n\n/**\n * x402scan score weight (the remainder after Scattering)\n * x402scan measures reliability (success rate, latency, confidence)\n */\nconst X402SCAN_SCORE_WEIGHT = 1 - SCATTERING_SCORE_WEIGHT;\n\n/**\n * Internal weights for x402scan sub-components\n * These are applied to the x402scan portion of the score\n */\nconst SCORING_WEIGHTS = {\n  successRate: 50,     // 50% weight on success rate\n  latency: 30,         // 30% weight on latency\n  volume: 10,          // 10% weight on volume (more volume = more confidence)\n  freshness: 10,       // 10% weight on data freshness\n};\n\n// =============================================================================\n// QUERY FUNCTIONS\n// =============================================================================\n\n/**\n * Get best performing facilitator paths\n * Sorted by success rate, then by latency\n */\nexport async function getBestFacilitatorPaths(\n  params: GetBestPathsParams\n): Promise<FacilitatorPathMetrics[]> {\n  const timeframe = params.timeframe ?? '1d';\n  const limit = params.limit ?? 10;\n\n  try {\n    const metrics = await getMetricsForFacilitator(params.facilitatorId, timeframe);\n\n    if (metrics.length === 0) {\n      logger.debug({\n        facilitatorId: params.facilitatorId,\n        timeframe,\n        msg: 'No metrics found for facilitator',\n      });\n      return [];\n    }\n\n    // Sort by success rate (descending), then by latency (ascending)\n    const sorted = [...metrics].sort((a, b) => {\n      // Primary: higher success rate is better\n      const successRateDiff = (1 - b.errorRate) - (1 - a.errorRate);\n      if (Math.abs(successRateDiff) > 0.01) {\n        return successRateDiff > 0 ? 1 : -1;\n      }\n\n      // Secondary: lower latency is better\n      const aLatency = a.p95LatencyMs ?? a.avgLatencyMs ?? Infinity;\n      const bLatency = b.p95LatencyMs ?? b.avgLatencyMs ?? Infinity;\n      return aLatency - bLatency;\n    });\n\n    return sorted.slice(0, limit);\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId: params.facilitatorId,\n      msg: 'Failed to get best facilitator paths',\n    });\n    return [];\n  }\n}\n\n/**\n * Calculate a composite score for a facilitator blending:\n * 1. x402scan: reliability metrics (success rate, latency, confidence)\n * 2. Scattering: activity metrics (volume, tx count, unique buyers)\n * \n * Score is 0-100, higher is better\n * \n * The blend is controlled by SCATTERING_SCORE_WEIGHT (default 0.2):\n * - x402scan contributes (1 - SCATTERING_SCORE_WEIGHT) * x402scanScore\n * - Scattering contributes SCATTERING_SCORE_WEIGHT * scatteringScore\n */\nexport async function getFacilitatorScore(\n  params: FacilitatorScoreParams\n): Promise<FacilitatorScore | null> {\n  const timeframe = params.timeframe ?? '1d';\n  const reasons: string[] = [];\n\n  try {\n    // ==========================================================================\n    // PART 1: x402scan reliability metrics\n    // ==========================================================================\n    const summary = await getSummary(params.facilitatorId, timeframe);\n    \n    let x402scanScore = 50; // Default neutral\n    let successRate = 0;\n    let hoursOld = Infinity;\n    let totalInvocations = 0;\n    let avgLatencyMs: number | undefined;\n    let p95LatencyMs: number | undefined;\n    let hasX402scanData = false;\n\n    if (summary) {\n      hasX402scanData = true;\n      \n      // Calculate success rate score (0-50)\n      successRate = 1 - summary.overallErrorRate;\n      const successRateScore = successRate * SCORING_WEIGHTS.successRate;\n      reasons.push(`success-rate:${(successRate * 100).toFixed(1)}%`);\n\n      // Calculate latency score (0-30)\n      let latencyScore = SCORING_WEIGHTS.latency;\n      const p95 = summary.avgP90LatencyMs ?? summary.avgP99LatencyMs;\n      if (p95 !== undefined) {\n        const normalizedLatency = Math.min(p95, 2000) / 2000;\n        latencyScore = (1 - normalizedLatency) * SCORING_WEIGHTS.latency;\n        reasons.push(`p95-latency:${p95.toFixed(0)}ms`);\n        p95LatencyMs = summary.avgP90LatencyMs;\n      } else {\n        latencyScore = SCORING_WEIGHTS.latency * 0.5;\n        reasons.push('latency:unknown');\n      }\n\n      // Calculate volume score (0-10)\n      const volumeThreshold = 1000;\n      const volumeRatio = Math.min(summary.totalInvocations / volumeThreshold, 1);\n      const volumeScore = volumeRatio * SCORING_WEIGHTS.volume;\n      totalInvocations = summary.totalInvocations;\n      reasons.push(`x402scan:${summary.totalInvocations}/${summary.totalInvocations >= 1000 ? 'high' : summary.totalInvocations >= 100 ? 'medium' : 'low'}-confidence`);\n\n      // Calculate freshness score (0-10)\n      const fetchedAt = new Date(summary.fetchedAt);\n      hoursOld = (Date.now() - fetchedAt.getTime()) / (1000 * 60 * 60);\n      const freshnessRatio = Math.max(0, 1 - hoursOld / 24);\n      const freshnessScore = freshnessRatio * SCORING_WEIGHTS.freshness;\n\n      x402scanScore = successRateScore + latencyScore + volumeScore + freshnessScore;\n      avgLatencyMs = summary.avgP50LatencyMs;\n    } else {\n      reasons.push('x402scan:no-data');\n    }\n\n    // ==========================================================================\n    // PART 2: Scattering activity metrics\n    // ==========================================================================\n    let scatteringActivityScore = 0;\n    let scatteringVolume3d: number | undefined;\n    let scatteringTxCount3d: number | undefined;\n    let scatteringUniqueBuyers3d: number | undefined;\n    let scatteringLowActivity = false;\n    let hasScatteringData = false;\n\n    try {\n      const scattering = await getScatteringMetricsForFacilitator(params.facilitatorId);\n      \n      if (scattering) {\n        hasScatteringData = true;\n        scatteringVolume3d = scattering.volumeUsd3d;\n        scatteringTxCount3d = scattering.txCount3d;\n        scatteringUniqueBuyers3d = scattering.uniqueBuyers3d;\n\n        // Check for low activity guardrail\n        const isLowActivity = \n          scattering.txCount3d < SCATTERING_MIN_TX_COUNT_3D &&\n          scattering.volumeUsd3d < SCATTERING_MIN_VOLUME_USD_3D;\n\n        if (isLowActivity) {\n          scatteringLowActivity = true;\n          scatteringActivityScore = 0.1; // Minimal score for low activity\n          reasons.push(`scattering-low-activity:${scattering.txCount3d}tx/$${scattering.volumeUsd3d.toFixed(0)}`);\n        } else {\n          // Compute normalized activity score (0-1)\n          scatteringActivityScore = computeActivityScore(scattering);\n          reasons.push(`scattering-activity:${scatteringActivityScore.toFixed(2)}`);\n        }\n      } else {\n        reasons.push('scattering:no-data');\n      }\n    } catch (error) {\n      logger.debug({\n        error: error instanceof Error ? error.message : 'Unknown',\n        facilitatorId: params.facilitatorId,\n        msg: 'Failed to fetch Scattering metrics for scoring',\n      });\n      reasons.push('scattering:error');\n    }\n\n    // ==========================================================================\n    // PART 3: Blend x402scan and Scattering scores\n    // ==========================================================================\n    let finalScore: number;\n    \n    if (hasX402scanData && hasScatteringData) {\n      // Both sources available - blend according to weights\n      // x402scan score is 0-100, Scattering score is 0-1 (convert to 0-100)\n      finalScore = (X402SCAN_SCORE_WEIGHT * x402scanScore) + \n                   (SCATTERING_SCORE_WEIGHT * scatteringActivityScore * 100);\n    } else if (hasX402scanData) {\n      // Only x402scan - use full weight\n      finalScore = x402scanScore;\n    } else if (hasScatteringData) {\n      // Only Scattering - convert to 0-100 scale\n      finalScore = scatteringActivityScore * 100;\n    } else {\n      // No data - neutral score\n      finalScore = 50;\n    }\n\n    // ==========================================================================\n    // PART 4: Determine confidence level\n    // ==========================================================================\n    let confidence: 'high' | 'medium' | 'low' | 'none' = 'none';\n    \n    if (hasX402scanData) {\n      if (totalInvocations >= 1000 && hoursOld < 6) {\n        confidence = 'high';\n      } else if (totalInvocations >= 100 && hoursOld < 24) {\n        confidence = 'medium';\n      } else {\n        confidence = 'low';\n      }\n    } else if (hasScatteringData && !scatteringLowActivity) {\n      // Scattering-only data provides some confidence\n      confidence = scatteringActivityScore > 0.5 ? 'medium' : 'low';\n    }\n\n    return {\n      facilitatorId: params.facilitatorId,\n      score: Math.round(finalScore),\n      successRate,\n      avgLatencyMs,\n      p95LatencyMs,\n      totalInvocations,\n      dataFreshness: hoursOld,\n      confidence,\n      reasons,\n      // Scattering fields\n      scatteringActivityScore: hasScatteringData ? scatteringActivityScore : undefined,\n      scatteringVolume3d,\n      scatteringTxCount3d,\n      scatteringUniqueBuyers3d,\n      scatteringLowActivity: scatteringLowActivity || undefined,\n    };\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId: params.facilitatorId,\n      msg: 'Failed to get facilitator score',\n    });\n    return null;\n  }\n}\n\n/**\n * Rank multiple facilitators by their x402scan-derived score\n * Enforces freshness and confidence thresholds - only returns trusted scores\n * \n * @param facilitatorIds - List of facilitator IDs to rank\n * @param timeframe - Timeframe for metrics (default: '1d')\n * @param config - Trust configuration (default: DEFAULT_TRUST_CONFIG)\n */\nexport async function rankFacilitators(\n  facilitatorIds: string[],\n  timeframe: FacilitatorPathMetricsTimeframe = '1d',\n  config: MetricsTrustConfig = DEFAULT_TRUST_CONFIG\n): Promise<FacilitatorRanking> {\n  const scores: FacilitatorScore[] = [];\n  const untrusted: Array<{ id: string; reason: string }> = [];\n\n  for (const id of facilitatorIds) {\n    const score = await getFacilitatorScore({ facilitatorId: id, timeframe });\n    \n    if (!score) {\n      untrusted.push({ id, reason: 'no-data' });\n      continue;\n    }\n\n    // Check if metrics meet trust thresholds\n    const trustCheck = shouldTrustMetrics(\n      score.dataFreshness,\n      score.totalInvocations,\n      config\n    );\n\n    if (!trustCheck.trust) {\n      untrusted.push({ id, reason: trustCheck.reason });\n      // Still include in rankings but with penalized score\n      scores.push({\n        ...score,\n        score: score.score * config.lowConfidencePenalty, // Heavy penalty\n        confidence: 'low',\n        reasons: [...score.reasons, `untrusted:${trustCheck.reason}`],\n      });\n      continue;\n    }\n\n    // Apply confidence-based adjustments\n    if (trustCheck.confidence === 'medium') {\n      // Slight penalty for medium confidence\n      scores.push({\n        ...score,\n        score: score.score * 0.9, // 10% penalty\n        confidence: 'medium',\n        reasons: [...score.reasons, trustCheck.reason],\n      });\n    } else {\n      // High confidence - use score as-is\n      scores.push({\n        ...score,\n        reasons: [...score.reasons, trustCheck.reason],\n      });\n    }\n  }\n\n  // Log untrusted facilitators for visibility\n  if (untrusted.length > 0) {\n    logger.debug({\n      untrusted,\n      trusted: scores.filter((s) => s.confidence !== 'low').map((s) => s.facilitatorId),\n      msg: 'Facilitator metrics trust check results',\n    });\n  }\n\n  // Sort by score descending\n  scores.sort((a, b) => b.score - a.score);\n\n  return {\n    rankings: scores,\n    timestamp: new Date().toISOString(),\n    timeframe,\n  };\n}\n\n/**\n * Get recommended facilitator for a given context\n * Uses x402scan data to inform the recommendation\n * Falls back to default candidate when metrics are stale/missing\n */\nexport async function getRecommendedFacilitator(\n  candidateIds: string[],\n  options?: {\n    network?: string;\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    prioritize?: 'latency' | 'reliability' | 'balanced';\n    trustConfig?: MetricsTrustConfig;\n  }\n): Promise<{\n  recommended: string | null;\n  ranking: FacilitatorRanking;\n  reason: string;\n  usedFallback: boolean;\n}> {\n  const timeframe = options?.timeframe ?? '1d';\n  const trustConfig = options?.trustConfig ?? DEFAULT_TRUST_CONFIG;\n  const ranking = await rankFacilitators(candidateIds, timeframe, trustConfig);\n\n  // Check if we have any trusted rankings\n  const trustedRankings = ranking.rankings.filter((r) => r.confidence !== 'low');\n\n  if (trustedRankings.length === 0) {\n    // No trusted data - fall back to first candidate\n    logger.warn({\n      candidates: candidateIds,\n      rankings: ranking.rankings.map((r) => ({\n        id: r.facilitatorId,\n        confidence: r.confidence,\n        reasons: r.reasons,\n      })),\n      msg: 'No trusted x402scan data available, using fallback',\n    });\n\n    return {\n      recommended: candidateIds[0] ?? null,\n      ranking,\n      reason: 'No trusted x402scan data (stale or insufficient), using default order',\n      usedFallback: true,\n    };\n  }\n\n  const prioritize = options?.prioritize ?? 'balanced';\n  let recommended: FacilitatorScore;\n\n  switch (prioritize) {\n    case 'latency':\n      // Sort by latency (ascending), filter out unknown latency, only trusted\n      const byLatency = trustedRankings\n        .filter((r) => r.p95LatencyMs !== undefined)\n        .sort((a, b) => (a.p95LatencyMs ?? Infinity) - (b.p95LatencyMs ?? Infinity));\n      recommended = byLatency[0] ?? trustedRankings[0];\n      break;\n\n    case 'reliability':\n      // Sort by success rate (descending), only trusted\n      const byReliability = [...trustedRankings].sort((a, b) => b.successRate - a.successRate);\n      recommended = byReliability[0];\n      break;\n\n    case 'balanced':\n    default:\n      // Use overall score from trusted rankings\n      recommended = trustedRankings[0];\n      break;\n  }\n\n  return {\n    recommended: recommended.facilitatorId,\n    ranking,\n    reason: `Selected ${recommended.facilitatorId} with score ${recommended.score} ` +\n      `(${recommended.confidence} confidence, ${recommended.reasons.slice(0, 3).join(', ')})`,\n    usedFallback: false,\n  };\n}\n\n/**\n * Check if a facilitator should be avoided based on recent performance\n */\nexport async function shouldAvoidFacilitator(\n  facilitatorId: string,\n  threshold: {\n    maxErrorRate?: number;    // Default: 0.2 (20%)\n    minInvocations?: number;  // Default: 10\n  } = {}\n): Promise<{\n  avoid: boolean;\n  reason?: string;\n}> {\n  const maxErrorRate = threshold.maxErrorRate ?? 0.2;\n  const minInvocations = threshold.minInvocations ?? 10;\n\n  try {\n    const score = await getFacilitatorScore({ facilitatorId, timeframe: '1d' });\n\n    if (!score) {\n      return { avoid: false, reason: 'No data available' };\n    }\n\n    // Not enough data to make a decision\n    if (score.totalInvocations < minInvocations) {\n      return { avoid: false, reason: `Insufficient data (${score.totalInvocations} invocations)` };\n    }\n\n    // Check error rate\n    const errorRate = 1 - score.successRate;\n    if (errorRate > maxErrorRate) {\n      return {\n        avoid: true,\n        reason: `Error rate ${(errorRate * 100).toFixed(1)}% exceeds threshold ${(maxErrorRate * 100).toFixed(1)}%`,\n      };\n    }\n\n    return { avoid: false };\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId,\n      msg: 'Failed to check if facilitator should be avoided',\n    });\n    return { avoid: false, reason: 'Error checking metrics' };\n  }\n}\n\n/**\n * Get all available facilitator summaries\n * Useful for dashboard/monitoring\n */\nexport async function getAllFacilitatorSummaries(): Promise<Record<string, FacilitatorSummary>> {\n  return loadAllSummaries();\n}\n\n// =============================================================================\n// SMF EXPLAINER\n// =============================================================================\n\n/**\n * Structured explanation for SMF routing decisions\n */\nexport interface FacilitatorExplanation {\n  facilitatorId: string;\n  selected: boolean;\n  score: number;\n  confidence: 'high' | 'medium' | 'low' | 'none';\n  shortReason: string;      // One-line summary\n  detailedReasons: string[];\n  metrics: {\n    successRate?: number;\n    errorRate?: number;\n    p95LatencyMs?: number;\n    invocations?: number;\n    dataAgeHours?: number;\n  };\n}\n\n/**\n * Get a structured explanation for why a facilitator was/wasn't selected\n * Used by SMF to provide transparent routing decisions\n * \n * @example\n * const explanation = await getFacilitatorExplainer('cdp', { timeframe: '1d' });\n * console.log(explanation.shortReason);\n * // \"cdp: 98.5% success, 185ms p95, high confidence (12K invocations)\"\n */\nexport async function getFacilitatorExplainer(\n  facilitatorId: string,\n  options?: {\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    wasSelected?: boolean;\n  }\n): Promise<FacilitatorExplanation> {\n  const timeframe = options?.timeframe ?? '1d';\n  const wasSelected = options?.wasSelected ?? false;\n\n  const score = await getFacilitatorScore({ facilitatorId, timeframe });\n\n  if (!score) {\n    return {\n      facilitatorId,\n      selected: wasSelected,\n      score: 50,\n      confidence: 'low',\n      shortReason: `${facilitatorId}: no x402scan data available`,\n      detailedReasons: ['No observability data from x402scan'],\n      metrics: {},\n    };\n  }\n\n  // Build short reason string\n  const successPct = (score.successRate * 100).toFixed(1);\n  const latencyStr = score.p95LatencyMs ? `${score.p95LatencyMs.toFixed(0)}ms p95` : 'latency unknown';\n  const volumeStr = score.totalInvocations >= 1000 \n    ? `${(score.totalInvocations / 1000).toFixed(1)}K invocations`\n    : `${score.totalInvocations} invocations`;\n\n  const shortReason = `${facilitatorId}: ${successPct}% success, ${latencyStr}, ${score.confidence} confidence (${volumeStr})`;\n\n  // Build detailed reasons\n  const detailedReasons: string[] = [];\n  \n  if (score.successRate >= 0.99) {\n    detailedReasons.push(`Excellent success rate: ${successPct}%`);\n  } else if (score.successRate >= 0.95) {\n    detailedReasons.push(`Good success rate: ${successPct}%`);\n  } else if (score.successRate >= 0.90) {\n    detailedReasons.push(`Acceptable success rate: ${successPct}%`);\n  } else {\n    detailedReasons.push(`⚠️ Low success rate: ${successPct}%`);\n  }\n\n  if (score.p95LatencyMs !== undefined) {\n    if (score.p95LatencyMs < 200) {\n      detailedReasons.push(`Fast response times: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    } else if (score.p95LatencyMs < 500) {\n      detailedReasons.push(`Moderate latency: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    } else {\n      detailedReasons.push(`⚠️ High latency: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    }\n  }\n\n  if (score.confidence === 'high') {\n    detailedReasons.push(`High confidence: ${volumeStr}, data ${score.dataFreshness.toFixed(1)}h old`);\n  } else if (score.confidence === 'medium') {\n    detailedReasons.push(`Medium confidence: ${volumeStr}`);\n  } else {\n    detailedReasons.push(`Low confidence: limited data (${volumeStr})`);\n  }\n\n  if (score.dataFreshness > 12) {\n    detailedReasons.push(`⚠️ Data is ${score.dataFreshness.toFixed(1)} hours old`);\n  }\n\n  return {\n    facilitatorId,\n    selected: wasSelected,\n    score: score.score,\n    confidence: score.confidence,\n    shortReason,\n    detailedReasons,\n    metrics: {\n      successRate: score.successRate,\n      errorRate: 1 - score.successRate,\n      p95LatencyMs: score.p95LatencyMs,\n      invocations: score.totalInvocations,\n      dataAgeHours: score.dataFreshness,\n    },\n  };\n}\n\n/**\n * Get explanations for multiple facilitators (for comparison)\n */\nexport async function getMultipleFacilitatorExplanations(\n  facilitatorIds: string[],\n  options?: {\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    selectedId?: string;\n  }\n): Promise<FacilitatorExplanation[]> {\n  const explanations: FacilitatorExplanation[] = [];\n\n  for (const id of facilitatorIds) {\n    const explanation = await getFacilitatorExplainer(id, {\n      timeframe: options?.timeframe,\n      wasSelected: id === options?.selectedId,\n    });\n    explanations.push(explanation);\n  }\n\n  // Sort by score descending\n  return explanations.sort((a, b) => b.score - a.score);\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0,1,2]}