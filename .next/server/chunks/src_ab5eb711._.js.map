{"version":3,"sources":["../../../src/integrations/x402/facilitators/cdp-facilitator-adapter.ts","../../../src/integrations/x402/facilitators/payai-facilitator.ts","../../../src/integrations/x402/facilitators/x402rs-facilitator.ts","../../../src/integrations/x402/facilitators/dexter-facilitator.ts","../../../src/integrations/x402/facilitators/cronos-facilitator.ts","../../../src/integrations/x402/facilitators/health-aggregator.ts","../../../src/types/facilitator-scores.ts","../../../src/db/facilitator-scores.ts","../../../src/services/smf/scoring.ts","../../../src/integrations/x402/facilitators/facilitator-router.ts"],"sourcesContent":["// =============================================================================\r\n// CDP FACILITATOR ADAPTER\r\n// =============================================================================\r\n// Adapter to make CDP facilitator conform to IFacilitator interface\r\n\r\nimport { BaseFacilitator, type IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorHealth, type FacilitatorConfig, type CAIPNetworkId, type CAIPAssetId } from './base-facilitator';\r\nimport { getCDPFacilitator, type CDPVerifyRequest, type CDPVerifyResponse, type X402PaymentRequirements } from '../cdp-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\n// Logger will be created per instance\r\n\r\n/**\r\n * Build CDP-specific payment requirements for probe mode\r\n * Uses known-good values for Base + USDC that CDP expects\r\n * CDP x402 v2 API expects: scheme, network, payTo, maxAmountRequired, resource, asset, etc.\r\n */\r\nfunction buildCdpProbePaymentRequirements(config: FacilitatorProbeConfig): X402PaymentRequirements {\r\n  // USDC contract address on Base\r\n  const USDC_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';\r\n  \r\n  // Use a test receiver address (can be any valid address you control)\r\n  // For probes, we use a known test address that won't cause issues\r\n  const PROBE_RECEIVER = '0x0000000000000000000000000000000000000001'; // Test address\r\n  \r\n  // CDP requires CAIP-2 format (e.g., \"eip155:8453\") for network\r\n  // Keep network in CAIP-2 format, don't convert to legacy\r\n  const network = config.network; // Already in CAIP-2 format (e.g., \"eip155:8453\")\r\n  \r\n  const now = Math.floor(Date.now() / 1000);\r\n  \r\n  return {\r\n    scheme: 'exact', // CDP expects 'exact' scheme for EVM fixed-amount flows\r\n    network: network, // Use CAIP-2 format (e.g., \"eip155:8453\")\r\n    to: PROBE_RECEIVER, // Internal field name\r\n    payTo: PROBE_RECEIVER, // CDP field name (required)\r\n    value: '1000000', // Internal field name (1 USDC in atomic units, must match authorization.value)\r\n    maxAmountRequired: '1000000', // CDP field name (required) - 1 USDC in atomic units\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    asset: USDC_BASE,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    maxTimeoutSeconds: 10, // Short timeout for probes\r\n    validAfter: now.toString(),\r\n    validBefore: (now + 300).toString(), // 5 minutes validity window\r\n  };\r\n}\r\n\r\n/**\r\n * CDP Facilitator Adapter\r\n * Wraps the existing CDP facilitator to implement IFacilitator interface\r\n */\r\nexport class CDPFacilitatorAdapter extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'cdp';\r\n  readonly name = 'Coinbase Developer Platform';\r\n  \r\n  readonly config: FacilitatorConfig = {\r\n    id: 'cdp',\r\n    name: 'Coinbase Developer Platform',\r\n    enabled: true,\r\n    priority: 1, // High priority (primary facilitator)\r\n    networks: ['base'], // Legacy: Currently Base only\r\n    networksCAIP: ['eip155:8453'], // CAIP-2: Base mainnet\r\n    assets: ['0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // Legacy: USDC on Base\r\n    assetsCAIP: ['eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'], // CAIP-19: USDC on Base\r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'], // CDP supports immediate settlement\r\n    healthCheckUrl: process.env.CDP_FACILITATOR_URL || 'https://api.cdp.coinbase.com/platform/v2/x402',\r\n    metadata: {\r\n      provider: 'Coinbase',\r\n      kytEnabled: true,\r\n      ofacEnabled: true,\r\n      complianceLevel: 'enterprise',\r\n    },\r\n  };\r\n\r\n  private cdpFacilitator = getCDPFacilitator();\r\n\r\n  /**\r\n   * Verify payment using CDP facilitator\r\n   * \r\n   * Note: This adapter expects the payment header to be passed as-is.\r\n   * The CDP facilitator will parse it internally. For a more complete\r\n   * adapter, we could parse the header here and extract the authorization,\r\n   * but for now we rely on CDP's internal parsing.\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Import payment header parser to extract authorization\r\n      const { parseAndVerifyPaymentHeader } = await import('../payment-header-parser');\r\n      const parsed = await parseAndVerifyPaymentHeader(payment);\r\n\r\n      if (!parsed.valid || !parsed.payment) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parsed.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Detect probe mode: check if resource URL matches probe pattern\r\n      // Probe resources use pattern: https://probe.nexflow.dev/health/{facilitatorId}/{network}/{token}\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n      \r\n      // For probe mode, build CDP-specific probe paymentRequirements\r\n      // Extract probe config from resource URL if in probe mode\r\n      let cdpPaymentRequirements: X402PaymentRequirements;\r\n      if (isProbe) {\r\n        // Extract facilitatorId, network, token from resource URL\r\n        // Format: https://probe.nexflow.dev/health/{facilitatorId}/{network}/{token}\r\n        const resourceMatch = requirements.resource.match(/\\/health\\/([^/]+)\\/([^/]+)\\/([^/]+)/);\r\n        if (resourceMatch) {\r\n          const [, facilitatorId, network, token] = resourceMatch;\r\n          const probeConfig: FacilitatorProbeConfig = {\r\n            id: `${facilitatorId}-${network}-${token.toLowerCase()}`,\r\n            facilitatorId,\r\n            network,\r\n            token,\r\n            desiredIntervalSeconds: 30, // Default, not used for building requirements\r\n            enabled: true,\r\n          };\r\n          cdpPaymentRequirements = buildCdpProbePaymentRequirements(probeConfig);\r\n          this.getLogger().info({\r\n            component: 'CDPFacilitatorAdapter',\r\n            isProbe: true,\r\n            probeConfigId: probeConfig.id,\r\n            hasPaymentRequirements: true,\r\n            msg: 'Using probe-specific paymentRequirements for CDP',\r\n          });\r\n        } else {\r\n          // Fallback: use requirements as-is if we can't parse probe config\r\n          cdpPaymentRequirements = {\r\n            scheme: requirements.scheme,\r\n            network: requirements.network,\r\n            maxAmountRequired: requirements.maxAmountRequired,\r\n            resource: requirements.resource,\r\n            description: requirements.description || '',\r\n            mimeType: requirements.mimeType || 'application/json',\r\n            payTo: requirements.payTo,\r\n            maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n            asset: requirements.asset,\r\n          };\r\n        }\r\n      } else {\r\n        // Normal mode: use requirements from caller\r\n        cdpPaymentRequirements = {\r\n          scheme: requirements.scheme,\r\n          network: requirements.network,\r\n          maxAmountRequired: requirements.maxAmountRequired,\r\n          resource: requirements.resource,\r\n          description: requirements.description || '',\r\n          mimeType: requirements.mimeType || 'application/json',\r\n          payTo: requirements.payTo,\r\n          maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n          asset: requirements.asset,\r\n        };\r\n      }\r\n\r\n      // Build CDP request with parsed payment data\r\n      const cdpRequest: CDPVerifyRequest = {\r\n        payment,\r\n        paymentPayload: {\r\n          x402Version: 1,\r\n          scheme: 'x402' as const,\r\n          network: parsed.payment.network || requirements.network,\r\n          payload: {\r\n            signature: parsed.payment.signature,\r\n            authorization: parsed.payment.authorization,\r\n          },\r\n        },\r\n        paymentRequirements: cdpPaymentRequirements,\r\n      };\r\n\r\n      // Verify with CDP\r\n      const result = await this.cdpFacilitator.verifyPaymentWithRetry(cdpRequest);\r\n\r\n      return {\r\n        success: result.success,\r\n        valid: result.valid,\r\n        transactionHash: result.transactionHash,\r\n        kytStatus: result.kytStatus,\r\n        ofacStatus: result.ofacStatus,\r\n        error: result.error,\r\n        errorDetails: result.errorDetails,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      this.getLogger().error({ error, requirements }, 'CDP verification error');\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: error instanceof Error ? error.message : 'Verification failed',\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get CDP facilitator health\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    try {\r\n      const start = Date.now();\r\n      const health = await this.cdpFacilitator.healthCheck();\r\n      const latency = Date.now() - start;\r\n\r\n      return {\r\n        healthy: health.healthy,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        healthy: false,\r\n        lastChecked: new Date().toISOString(),\r\n        error: error instanceof Error ? error.message : 'Health check failed',\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing (CDP doesn't charge fees, but we track gas costs)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    if (network === 'base' && asset === '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913') {\r\n      return {\r\n        network: 'base',\r\n        asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n        baseFee: '0', // CDP doesn't charge fees\r\n        percentageFee: 0,\r\n        estimatedGas: '21000', // Typical gas for USDC transfer\r\n        currency: 'USDC',\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get CDP facilitator adapter instance\r\n */\r\nlet cdpAdapter: CDPFacilitatorAdapter | null = null;\r\n\r\nexport function getCDPFacilitatorAdapter(): CDPFacilitatorAdapter {\r\n  if (!cdpAdapter) {\r\n    cdpAdapter = new CDPFacilitatorAdapter();\r\n  }\r\n  return cdpAdapter;\r\n}\r\n\r\n","// =============================================================================\r\n// PAYAI FACILITATOR\r\n// =============================================================================\r\n// Multi-chain facilitator for x402 payment verification\r\n// Supports Base, Solana, Ethereum, BNB Chain, and other networks\r\n\r\nimport { BaseFacilitator, type IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorHealth, type FacilitatorConfig, type CAIPNetworkId, type CAIPAssetId } from './base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\nconst logger = createLogger({ component: 'PayAIFacilitator' });\r\n\r\n/**\r\n * Build PayAI-specific payment requirements for probe mode\r\n * Uses known-good values for Base + USDC that PayAI expects\r\n */\r\nfunction buildPayAIProbePaymentRequirements(config: FacilitatorProbeConfig): PaymentRequirements {\r\n  // USDC contract address on Base\r\n  const USDC_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';\r\n  \r\n  // Use a test receiver address (can be any valid address you control)\r\n  // For probes, we use a known test address that won't cause issues\r\n  const PROBE_RECEIVER = '0x0000000000000000000000000000000000000001'; // Test address\r\n  \r\n  // Convert CAIP-2 network to legacy format\r\n  let legacyNetwork = config.network;\r\n  if (config.network === 'eip155:8453') {\r\n    legacyNetwork = 'base';\r\n  }\r\n  \r\n  return {\r\n    scheme: 'x402',\r\n    network: legacyNetwork,\r\n    asset: USDC_BASE,\r\n    maxAmountRequired: '1', // Minimal amount (1 atomic unit)\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    payTo: PROBE_RECEIVER, // Use test receiver address for probes\r\n    maxTimeoutSeconds: 10, // Short timeout for probes\r\n    settlementMode: 'immediate',\r\n  };\r\n}\r\n\r\n/**\r\n * PayAI Facilitator\r\n * \r\n * Multi-chain facilitator supporting multiple networks beyond Base.\r\n * Implements x402 payment verification via PayAI facilitator API.\r\n */\r\nexport class PayAIFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'payai';\r\n  readonly name = 'PayAI Facilitator';\r\n\r\n  readonly config: FacilitatorConfig = {\r\n    id: 'payai',\r\n    name: 'PayAI Facilitator',\r\n    enabled: process.env.PAYAI_ENABLED !== 'false', // Enabled by default, can be disabled via env\r\n    priority: 2, // Lower priority than CDP (CDP = 1, PayAI = 2)\r\n    \r\n    // Legacy network identifiers\r\n    networks: ['base', 'ethereum', 'solana', 'bnb', 'polygon'],\r\n    \r\n    // CAIP-2 network identifiers (multi-chain support)\r\n    networksCAIP: [\r\n      'eip155:1',      // Ethereum mainnet\r\n      'eip155:8453',   // Base mainnet\r\n      'eip155:56',     // BNB Chain\r\n      'eip155:137',    // Polygon\r\n      'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp', // Solana mainnet\r\n    ],\r\n    \r\n    // Legacy asset identifiers\r\n    assets: [\r\n      '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base\r\n      '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC on Ethereum\r\n    ],\r\n    \r\n    // CAIP-19 asset identifiers (multi-chain support)\r\n    assetsCAIP: [\r\n      // Ethereum USDC\r\n      'eip155:1/erc20:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\r\n      // Base USDC\r\n      'eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n      // BNB Chain USDC\r\n      'eip155:56/erc20:0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d',\r\n      // Polygon USDC\r\n      'eip155:137/erc20:0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\r\n      // Solana USDC (EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v)\r\n      // Note: Solana CAIP-19 format may differ, adding placeholder\r\n      // 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp/spl:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',\r\n    ],\r\n    \r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'], // PayAI supports immediate settlement\r\n    \r\n    healthCheckUrl: process.env.PAYAI_FACILITATOR_URL || 'https://facilitator.payai.network',\r\n    \r\n    metadata: {\r\n      provider: 'PayAI',\r\n      multiChain: true,\r\n      complianceLevel: 'standard',\r\n      website: 'https://payai.network',\r\n    },\r\n  };\r\n\r\n  private baseUrl: string;\r\n\r\n  constructor(\r\n    baseUrl?: string\r\n  ) {\r\n    super();\r\n    // No API key required for hosted facilitator\r\n    this.baseUrl = baseUrl || process.env.PAYAI_FACILITATOR_URL || 'https://facilitator.payai.network';\r\n  }\r\n\r\n  /**\r\n   * Call PayAI /verify endpoint with retry logic for transient errors\r\n   * \r\n   * Retries on: 429 (rate limit), 500-504 (server errors), network timeouts\r\n   * Does NOT retry on: 400 (invalid_request), 401 (unauthorized), other 4xx\r\n   * \r\n   * Returns normalized result with success, valid, status, errorType, errorMessage, etc.\r\n   */\r\n  private async callPayAIVerifyWithRetries(\r\n    verifyUrl: string,\r\n    requestBody: any,\r\n    isProbe: boolean\r\n  ): Promise<{\r\n    success: boolean;\r\n    valid: boolean;\r\n    status: number;\r\n    errorType?: string;\r\n    errorMessage?: string;\r\n    isRateLimited: boolean;\r\n    isNetworkError: boolean;\r\n    latencyMs: number;\r\n    data?: any;\r\n  }> {\r\n    const maxRetries = 3;\r\n    const retryableStatuses = [429, 500, 502, 503, 504];\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const response = await fetch(verifyUrl, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify(requestBody),\r\n          signal: AbortSignal.timeout(10000), // 10 second timeout\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data = text ? JSON.parse(text) : {};\r\n        const latencyMs = Date.now() - startTime;\r\n\r\n        // Success case\r\n        if (response.ok && data.valid === true) {\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            status: response.status,\r\n            isRateLimited: false,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Check if retryable error\r\n        const isRetryable = retryableStatuses.includes(response.status);\r\n        const isRateLimit = response.status === 429;\r\n        \r\n        // If not retryable or last attempt, return error\r\n        if (!isRetryable || attempt === maxRetries - 1) {\r\n          const errorMessage = data.message || data.reason || data.error || `HTTP ${response.status}`;\r\n          const errorType = data.errorType || data.code || (isRateLimit ? 'rate_limit' : 'PAYAI_VERIFY_FAILED');\r\n          \r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            status: response.status,\r\n            errorType,\r\n            errorMessage,\r\n            isRateLimited: isRateLimit,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Retry with exponential backoff\r\n        const delay = 100 * Math.pow(2, attempt); // 100ms, 200ms, 400ms\r\n        logger.info({\r\n          component: 'PayAIFacilitator',\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          status: response.status,\r\n          delay,\r\n          isProbe,\r\n          msg: 'Retrying PayAI verification after transient error',\r\n        });\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        \r\n      } catch (error: any) {\r\n        const latencyMs = Date.now() - startTime;\r\n        const isTimeout = error?.name === 'AbortError' || error?.message?.toLowerCase().includes('timeout');\r\n        const isNetworkError = error?.message?.toLowerCase().includes('network') || \r\n                              error?.message?.toLowerCase().includes('fetch') ||\r\n                              error?.message?.toLowerCase().includes('econnrefused');\r\n        \r\n        // If network error and not last attempt, retry\r\n        if ((isTimeout || isNetworkError) && attempt < maxRetries - 1) {\r\n          const delay = 100 * Math.pow(2, attempt);\r\n          logger.info({\r\n            component: 'PayAIFacilitator',\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error?.message,\r\n            delay,\r\n            isProbe,\r\n            msg: 'Retrying PayAI verification after network error',\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n        \r\n        // Last attempt or non-network error\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          status: 0,\r\n          errorType: isTimeout ? 'timeout' : isNetworkError ? 'network_error' : 'PAYAI_VERIFY_FAILED',\r\n          errorMessage: error?.message || 'PayAI verification failed',\r\n          isRateLimited: false,\r\n          isNetworkError: isTimeout || isNetworkError,\r\n          latencyMs,\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Should never reach here, but TypeScript needs a return\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      status: 0,\r\n      errorType: 'PAYAI_VERIFY_FAILED',\r\n      errorMessage: 'Max retries exceeded',\r\n      isRateLimited: false,\r\n      isNetworkError: false,\r\n      latencyMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify payment using PayAI facilitator\r\n   * \r\n   * POST to /verify endpoint with paymentPayload and paymentRequirements.\r\n   * No authentication required for hosted facilitator.\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    const start = Date.now();\r\n\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Parse payment header to extract authorization details\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Detect probe mode: check if resource URL matches probe pattern\r\n      // Probe resources use pattern: https://probe.nexflow.dev/health/{facilitatorId}/{network}/{token}\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n      \r\n      // For probe mode, build PayAI-specific probe paymentRequirements\r\n      // Extract probe config from resource URL if in probe mode\r\n      let probeRequirements: PaymentRequirements;\r\n      if (isProbe) {\r\n        // Extract facilitatorId, network, token from resource URL\r\n        // Format: https://probe.nexflow.dev/health/{facilitatorId}/{network}/{token}\r\n        const resourceMatch = requirements.resource.match(/\\/health\\/([^/]+)\\/([^/]+)\\/([^/]+)/);\r\n        if (resourceMatch) {\r\n          const [, facilitatorId, network, token] = resourceMatch;\r\n          const probeConfig: FacilitatorProbeConfig = {\r\n            id: `${facilitatorId}-${network}-${token.toLowerCase()}`,\r\n            facilitatorId,\r\n            network,\r\n            token,\r\n            desiredIntervalSeconds: 120, // Default, not used for building requirements\r\n            enabled: true,\r\n          };\r\n          probeRequirements = buildPayAIProbePaymentRequirements(probeConfig);\r\n          logger.info({\r\n            component: 'PayAIFacilitator',\r\n            isProbe: true,\r\n            probeConfigId: probeConfig.id,\r\n            hasPaymentRequirements: true,\r\n            msg: 'Using probe-specific paymentRequirements for PayAI',\r\n          });\r\n        } else {\r\n          // Fallback: use requirements as-is if we can't parse probe config\r\n          probeRequirements = requirements;\r\n        }\r\n      } else {\r\n        // Normal mode: use requirements from caller\r\n        probeRequirements = requirements;\r\n      }\r\n\r\n      // Build paymentPayload from parsed payment header\r\n      const paymentPayload = {\r\n        x402Version: 2, // x402 v2\r\n        scheme: probeRequirements.scheme || 'x402',\r\n        network: parsed.network || probeRequirements.network,\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: {\r\n            from: parsed.authorization.from,\r\n            to: parsed.authorization.to,\r\n            value: parsed.authorization.value,\r\n            validAfter: parsed.authorization.validAfter,\r\n            validBefore: parsed.authorization.validBefore,\r\n            nonce: parsed.authorization.nonce,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Build paymentRequirements from requirements (use probe-specific if in probe mode)\r\n      const paymentRequirements = {\r\n        scheme: probeRequirements.scheme,\r\n        network: probeRequirements.network,\r\n        maxAmountRequired: probeRequirements.maxAmountRequired,\r\n        resource: probeRequirements.resource,\r\n        description: probeRequirements.description || '',\r\n        mimeType: probeRequirements.mimeType || 'application/json',\r\n        payTo: probeRequirements.payTo,\r\n        maxTimeoutSeconds: probeRequirements.maxTimeoutSeconds || 300,\r\n        asset: probeRequirements.asset,\r\n      };\r\n\r\n      // POST to PayAI verification endpoint with retry logic\r\n      const verifyUrl = `${this.baseUrl}/verify`;\r\n      const requestBody = {\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      };\r\n\r\n      // isProbe already declared above (line 300), reuse it\r\n      logger.info({\r\n        component: \"PayAIFacilitator\",\r\n        isProbe,\r\n        network: paymentRequirements.network,\r\n        asset: paymentRequirements.asset,\r\n        url: verifyUrl,\r\n        msg: \"Sending PayAI /verify request\"\r\n      });\r\n\r\n      // Call PayAI /verify with retry logic\r\n      const result = await this.callPayAIVerifyWithRetries(\r\n        verifyUrl,\r\n        requestBody,\r\n        isProbe\r\n      );\r\n\r\n      const latency = result.latencyMs;\r\n\r\n      // Handle success\r\n      if (result.success && result.valid) {\r\n        logger.info({ latencyMs: result.latencyMs }, 'Payment verified successfully by PayAI');\r\n        return {\r\n          success: true,\r\n          valid: true,\r\n          transactionHash: result.data?.transactionHash || result.data?.txHash,\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Handle error - map PayAI errorType/errorMessage to our error classification\r\n      const payaiErrorType = result.errorType || 'PAYAI_VERIFY_FAILED';\r\n      const payaiErrorMessage = result.errorMessage || 'PayAI verification failed';\r\n      \r\n      // Map error types to result/errorCode\r\n      let errorCode = 'facilitator_error';\r\n      if (result.isRateLimited || payaiErrorType === 'rate_limit') {\r\n        errorCode = 'rate_limited';\r\n      } else if (result.isNetworkError) {\r\n        errorCode = 'network_error';\r\n      } else if (payaiErrorType === 'invalid_request' || result.status === 400) {\r\n        errorCode = 'invalid_request';\r\n      } else if (result.status === 401) {\r\n        errorCode = 'unauthorized';\r\n      }\r\n\r\n      logger.debug({\r\n        status: result.status,\r\n        errorType: payaiErrorType,\r\n        errorMessage: payaiErrorMessage,\r\n        errorCode,\r\n        isRateLimited: result.isRateLimited,\r\n        isNetworkError: result.isNetworkError,\r\n        latencyMs: result.latencyMs,\r\n      }, 'PayAI verification failed');\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: payaiErrorMessage,\r\n        errorDetails: {\r\n          error: payaiErrorMessage,\r\n          errorType: payaiErrorType,\r\n          httpStatus: result.status,\r\n          errorCode,\r\n          isRateLimited: result.isRateLimited,\r\n          isNetworkError: result.isNetworkError,\r\n          payaiResponse: result.data,\r\n        },\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'PayAI verification error');\r\n      \r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: isTimeout ? 'PayAI_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get PayAI facilitator health\r\n   * \r\n   * Calls GET /list endpoint. If 200 with non-empty networks/assets, returns healthy.\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // PayAI redirects /list to /discovery/resources\r\n      const healthUrl = `${this.baseUrl}/discovery/resources`;\r\n      \r\n      const response = await fetch(healthUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000), // 5 second timeout\r\n      });\r\n\r\n      const latency = Date.now() - start;\r\n\r\n      if (response.ok) {\r\n        const data = await response.json();\r\n        \r\n        // Check if response has networks/assets (non-empty)\r\n        const hasNetworks = data.networks && Array.isArray(data.networks) && data.networks.length > 0;\r\n        const hasAssets = data.assets && Array.isArray(data.assets) && data.assets.length > 0;\r\n\r\n        if (hasNetworks || hasAssets) {\r\n          return {\r\n            healthy: true,\r\n            latency,\r\n            lastChecked: new Date().toISOString(),\r\n            capabilities: {\r\n              networks: data.networks || this.config.networks,\r\n              assets: data.assets || this.config.assets,\r\n              schemes: data.schemes || this.config.schemes,\r\n            },\r\n          };\r\n        }\r\n\r\n        // 200 but empty response - consider unhealthy\r\n        return {\r\n          healthy: false,\r\n          latency,\r\n          lastChecked: new Date().toISOString(),\r\n          error: 'Health check returned empty networks/assets',\r\n          capabilities: {\r\n            networks: this.config.networks,\r\n            assets: this.config.assets,\r\n            schemes: this.config.schemes,\r\n          },\r\n        };\r\n      }\r\n\r\n      // Non-2xx response\r\n      const errorText = await response.text().catch(() => `HTTP ${response.status}`);\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: errorText,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Health check failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: isTimeout ? 'Health check timeout' : errorMessage,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing information\r\n   * \r\n   * Returns null for now - can be implemented once PayAI pricing API is available.\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    // TODO: Implement pricing lookup if PayAI provides pricing API\r\n    // For now, return null (allowed by interface)\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   * Uses base class implementation which checks config\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: string): boolean {\r\n    return super.supports(network, asset, scheme, settlementMode as any);\r\n  }\r\n}\r\n\r\n/**\r\n * Singleton PayAI facilitator instance\r\n */\r\nlet payaiFacilitator: PayAIFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton PayAI facilitator instance\r\n */\r\nexport function getPayAIFacilitator(): PayAIFacilitator {\r\n  if (!payaiFacilitator) {\r\n    payaiFacilitator = new PayAIFacilitator();\r\n  }\r\n  return payaiFacilitator;\r\n}\r\n\r\n","// =============================================================================\r\n// X402RS FACILITATOR\r\n// =============================================================================\r\n// Rust-based x402 facilitator operated by the x402 community\r\n// Public hosted endpoint: https://facilitator.x402.rs\r\n// Can also be self-hosted via Docker: https://github.com/x402-rs/x402-rs\r\n// Supported networks: Base, Base Sepolia, XDC, Solana (configurable)\r\n\r\nimport {\r\n  BaseFacilitator,\r\n  type IFacilitator,\r\n  type PaymentRequirements,\r\n  type VerificationResult,\r\n  type FacilitatorHealth,\r\n  type FacilitatorConfig,\r\n  type CAIPNetworkId,\r\n  type CAIPAssetId,\r\n  type SettlementMode,\r\n} from './base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\nconst logger = createLogger({ component: 'X402rsFacilitator' });\r\n\r\n/**\r\n * Build X402rs-specific payment requirements for probe mode\r\n * Uses known-good values that X402rs expects\r\n */\r\nfunction buildX402rsProbePaymentRequirements(config: FacilitatorProbeConfig): PaymentRequirements {\r\n  // USDC contract address on Base\r\n  const USDC_BASE = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';\r\n  // USDC on Base Sepolia (testnet)\r\n  const USDC_BASE_SEPOLIA = '0x036CbD53842c5426634e7929541eC2318f3dCF7e';\r\n  \r\n  // Determine asset based on network\r\n  let asset = USDC_BASE;\r\n  if (config.network === 'eip155:84532') {\r\n    asset = USDC_BASE_SEPOLIA;\r\n  }\r\n  \r\n  // Use a test receiver address for probes\r\n  const PROBE_RECEIVER = '0x0000000000000000000000000000000000000001';\r\n  \r\n  return {\r\n    scheme: 'x402',\r\n    network: config.network,\r\n    asset,\r\n    maxAmountRequired: '1', // Minimal amount (1 atomic unit)\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    payTo: PROBE_RECEIVER,\r\n    maxTimeoutSeconds: 10,\r\n    settlementMode: 'immediate',\r\n  };\r\n}\r\n\r\n/**\r\n * X402rs Facilitator\r\n * \r\n * Rust-based community facilitator with public hosted endpoint.\r\n * Public URL: https://facilitator.x402.rs\r\n * GitHub: https://github.com/x402-rs/x402-rs\r\n * \r\n * Supports Base, Base Sepolia, XDC, and Solana networks.\r\n */\r\nexport class X402rsFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'x402rs';\r\n  readonly name = 'X402rs Facilitator';\r\n\r\n  readonly config: FacilitatorConfig = {\r\n    id: 'x402rs',\r\n    name: 'X402rs Facilitator',\r\n    enabled: process.env.X402RS_ENABLED !== 'false', // Enabled by default\r\n    priority: 2, // Same priority tier as PayAI\r\n    \r\n    // Legacy network identifiers\r\n    networks: ['base', 'base-sepolia', 'xdc'],\r\n    \r\n    // CAIP-2 network identifiers\r\n    networksCAIP: [\r\n      'eip155:84532',  // Base Sepolia (testnet)\r\n      'eip155:8453',   // Base mainnet\r\n      'xdc:50',        // XDC mainnet\r\n    ],\r\n    \r\n    // Legacy asset identifiers (include both contract addresses and symbols for probe compatibility)\r\n    assets: [\r\n      'USDC', // Symbol alias for probes\r\n      '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base mainnet\r\n      '0x036CbD53842c5426634e7929541eC2318f3dCF7e', // USDC on Base Sepolia\r\n    ],\r\n    \r\n    // CAIP-19 asset identifiers\r\n    assetsCAIP: [\r\n      'eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',   // USDC on Base mainnet\r\n      'eip155:84532/erc20:0x036CbD53842c5426634e7929541eC2318f3dCF7e',  // USDC on Base Sepolia\r\n    ],\r\n    \r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'],\r\n    \r\n    healthCheckUrl: process.env.X402RS_FACILITATOR_URL || 'https://facilitator.x402.rs',\r\n    \r\n    metadata: {\r\n      provider: 'x402 Community',\r\n      label: 'X402rs Facilitator',\r\n      url: 'https://facilitator.x402.rs',\r\n      website: 'https://x402.org',\r\n      rustBased: true,\r\n      openSource: true,\r\n      complianceLevel: 'community',\r\n    },\r\n  };\r\n\r\n  private baseUrl: string;\r\n\r\n  constructor(baseUrl?: string) {\r\n    super();\r\n    this.baseUrl = baseUrl || process.env.X402RS_FACILITATOR_URL || 'https://facilitator.x402.rs';\r\n  }\r\n\r\n  /**\r\n   * Get the facilitator URL\r\n   */\r\n  getUrl(): string {\r\n    return this.baseUrl;\r\n  }\r\n\r\n  /**\r\n   * Call X402rs /verify endpoint with retry logic for transient errors\r\n   */\r\n  private async callX402rsVerifyWithRetries(\r\n    verifyUrl: string,\r\n    requestBody: any,\r\n    isProbe: boolean\r\n  ): Promise<{\r\n    success: boolean;\r\n    valid: boolean;\r\n    status: number;\r\n    errorType?: string;\r\n    errorMessage?: string;\r\n    isRateLimited: boolean;\r\n    isNetworkError: boolean;\r\n    latencyMs: number;\r\n    data?: any;\r\n  }> {\r\n    const maxRetries = 3;\r\n    const retryableStatuses = [429, 500, 502, 503, 504];\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const response = await fetch(verifyUrl, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify(requestBody),\r\n          signal: AbortSignal.timeout(10000), // 10 second timeout\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data = text ? JSON.parse(text) : {};\r\n        const latencyMs = Date.now() - startTime;\r\n\r\n        // Success case\r\n        if (response.ok && data.valid === true) {\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            status: response.status,\r\n            isRateLimited: false,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Check if retryable error\r\n        const isRetryable = retryableStatuses.includes(response.status);\r\n        const isRateLimit = response.status === 429;\r\n        \r\n        // If not retryable or last attempt, return error\r\n        if (!isRetryable || attempt === maxRetries - 1) {\r\n          const errorMessage = data.message || data.reason || data.error || `HTTP ${response.status}`;\r\n          const errorType = data.errorType || data.code || (isRateLimit ? 'rate_limit' : 'X402RS_VERIFY_FAILED');\r\n          \r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            status: response.status,\r\n            errorType,\r\n            errorMessage,\r\n            isRateLimited: isRateLimit,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Retry with exponential backoff\r\n        const delay = 100 * Math.pow(2, attempt);\r\n        logger.info({\r\n          component: 'X402rsFacilitator',\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          status: response.status,\r\n          delay,\r\n          isProbe,\r\n          msg: 'Retrying X402rs verification after transient error',\r\n        });\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        \r\n      } catch (error: any) {\r\n        const latencyMs = Date.now() - startTime;\r\n        const isTimeout = error?.name === 'AbortError' || error?.message?.toLowerCase().includes('timeout');\r\n        const isNetworkError = error?.message?.toLowerCase().includes('network') || \r\n                              error?.message?.toLowerCase().includes('fetch') ||\r\n                              error?.message?.toLowerCase().includes('econnrefused');\r\n        \r\n        if ((isTimeout || isNetworkError) && attempt < maxRetries - 1) {\r\n          const delay = 100 * Math.pow(2, attempt);\r\n          logger.info({\r\n            component: 'X402rsFacilitator',\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error?.message,\r\n            delay,\r\n            isProbe,\r\n            msg: 'Retrying X402rs verification after network error',\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n        \r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          status: 0,\r\n          errorType: isTimeout ? 'timeout' : isNetworkError ? 'network_error' : 'X402RS_VERIFY_FAILED',\r\n          errorMessage: error?.message || 'X402rs verification failed',\r\n          isRateLimited: false,\r\n          isNetworkError: isTimeout || isNetworkError,\r\n          latencyMs,\r\n        };\r\n      }\r\n    }\r\n    \r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      status: 0,\r\n      errorType: 'X402RS_VERIFY_FAILED',\r\n      errorMessage: 'Max retries exceeded',\r\n      isRateLimited: false,\r\n      isNetworkError: false,\r\n      latencyMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify payment using X402rs facilitator\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    const start = Date.now();\r\n\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Parse payment header\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Detect probe mode\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n      \r\n      // Build payment payload\r\n      const paymentPayload = {\r\n        x402Version: 2,\r\n        scheme: requirements.scheme || 'x402',\r\n        network: parsed.network || requirements.network,\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: {\r\n            from: parsed.authorization.from,\r\n            to: parsed.authorization.to,\r\n            value: parsed.authorization.value,\r\n            validAfter: parsed.authorization.validAfter,\r\n            validBefore: parsed.authorization.validBefore,\r\n            nonce: parsed.authorization.nonce,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Build payment requirements\r\n      const paymentRequirements = {\r\n        scheme: requirements.scheme,\r\n        network: requirements.network,\r\n        maxAmountRequired: requirements.maxAmountRequired,\r\n        resource: requirements.resource,\r\n        description: requirements.description || '',\r\n        mimeType: requirements.mimeType || 'application/json',\r\n        payTo: requirements.payTo,\r\n        maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n        asset: requirements.asset,\r\n      };\r\n\r\n      // POST to X402rs verification endpoint\r\n      const verifyUrl = `${this.baseUrl}/verify`;\r\n      const requestBody = {\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      };\r\n\r\n      logger.info({\r\n        component: 'X402rsFacilitator',\r\n        isProbe,\r\n        network: paymentRequirements.network,\r\n        asset: paymentRequirements.asset,\r\n        url: verifyUrl,\r\n        facilitatorId: this.id,\r\n        facilitatorUrl: this.baseUrl,\r\n        msg: 'Sending X402rs /verify request',\r\n      });\r\n\r\n      // Call with retry logic\r\n      const result = await this.callX402rsVerifyWithRetries(verifyUrl, requestBody, isProbe);\r\n\r\n      // Handle success\r\n      if (result.success && result.valid) {\r\n        logger.info({\r\n          component: 'X402rsFacilitator',\r\n          facilitatorId: this.id,\r\n          facilitatorUrl: this.baseUrl,\r\n          latencyMs: result.latencyMs,\r\n          network: requirements.network,\r\n          msg: 'Payment verified successfully by X402rs',\r\n        });\r\n        return {\r\n          success: true,\r\n          valid: true,\r\n          transactionHash: result.data?.transactionHash || result.data?.txHash,\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Handle error\r\n      const errorType = result.errorType || 'X402RS_VERIFY_FAILED';\r\n      const errorMessage = result.errorMessage || 'X402rs verification failed';\r\n      \r\n      let errorCode = 'facilitator_error';\r\n      if (result.isRateLimited || errorType === 'rate_limit') {\r\n        errorCode = 'rate_limited';\r\n      } else if (result.isNetworkError) {\r\n        errorCode = 'network_error';\r\n      } else if (errorType === 'invalid_request' || result.status === 400) {\r\n        errorCode = 'invalid_request';\r\n      }\r\n\r\n      logger.debug({\r\n        component: 'X402rsFacilitator',\r\n        facilitatorId: this.id,\r\n        status: result.status,\r\n        errorType,\r\n        errorMessage,\r\n        errorCode,\r\n        isRateLimited: result.isRateLimited,\r\n        isNetworkError: result.isNetworkError,\r\n        latencyMs: result.latencyMs,\r\n        msg: 'X402rs verification failed',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: errorMessage,\r\n        errorDetails: {\r\n          error: errorMessage,\r\n          errorType,\r\n          httpStatus: result.status,\r\n          errorCode,\r\n          isRateLimited: result.isRateLimited,\r\n          isNetworkError: result.isNetworkError,\r\n          x402rsResponse: result.data,\r\n        },\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'X402rs verification error');\r\n      \r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: isTimeout ? 'X402RS_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get X402rs facilitator health\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // X402rs health check endpoint\r\n      const healthUrl = `${this.baseUrl}/health`;\r\n      \r\n      const response = await fetch(healthUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n\r\n      const latency = Date.now() - start;\r\n\r\n      if (response.ok) {\r\n        let data: any = {};\r\n        try {\r\n          data = await response.json();\r\n        } catch {\r\n          // Health endpoint might return simple OK\r\n        }\r\n\r\n        return {\r\n          healthy: true,\r\n          latency,\r\n          lastChecked: new Date().toISOString(),\r\n          capabilities: {\r\n            networks: data.networks || this.config.networks,\r\n            assets: data.assets || this.config.assets,\r\n            schemes: data.schemes || this.config.schemes,\r\n          },\r\n        };\r\n      }\r\n\r\n      const errorText = await response.text().catch(() => `HTTP ${response.status}`);\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: errorText,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Health check failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: isTimeout ? 'Health check timeout' : errorMessage,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing information (not available for X402rs yet)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    // TODO: Implement if X402rs provides pricing API\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\r\n    return super.supports(network, asset, scheme, settlementMode);\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet x402rsFacilitator: X402rsFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton X402rs facilitator instance\r\n */\r\nexport function getX402rsFacilitator(): X402rsFacilitator {\r\n  if (!x402rsFacilitator) {\r\n    x402rsFacilitator = new X402rsFacilitator();\r\n  }\r\n  return x402rsFacilitator;\r\n}\r\n\r\n","// =============================================================================\r\n// DEXTER FACILITATOR\r\n// =============================================================================\r\n// Solana-native x402 facilitator operated by Dexter\r\n// Public hosted endpoint: https://facilitator.dexter.cash\r\n// Standard x402 endpoints: /verify and /settle\r\n// Supports Solana mainnet and devnet networks\r\n\r\nimport {\r\n  BaseFacilitator,\r\n  type IFacilitator,\r\n  type PaymentRequirements,\r\n  type VerificationResult,\r\n  type FacilitatorHealth,\r\n  type FacilitatorConfig,\r\n  type CAIPNetworkId,\r\n  type CAIPAssetId,\r\n  type SettlementMode,\r\n} from './base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\nconst logger = createLogger({ component: 'DexterFacilitator' });\r\n\r\n/**\r\n * Dexter verify request body shape\r\n * Standard x402 payment verification format\r\n */\r\nexport interface DexterVerifyRequest {\r\n  paymentPayload: {\r\n    x402Version: number;\r\n    scheme: string;\r\n    network: string;\r\n    payload: {\r\n      signature: string;\r\n      authorization: {\r\n        from: string;\r\n        to: string;\r\n        value: string;\r\n        validAfter: string;\r\n        validBefore: string;\r\n        nonce: string;\r\n      };\r\n    };\r\n  };\r\n  paymentRequirements: {\r\n    scheme: string;\r\n    network: string;\r\n    maxAmountRequired: string;\r\n    resource: string;\r\n    description: string;\r\n    mimeType: string;\r\n    payTo: string;\r\n    maxTimeoutSeconds: number;\r\n    asset: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Dexter settle request body shape\r\n * Standard x402 settlement format\r\n */\r\nexport interface DexterSettleRequest {\r\n  paymentPayload: {\r\n    x402Version: number;\r\n    scheme: string;\r\n    network: string;\r\n    payload: {\r\n      signature: string;\r\n      authorization: {\r\n        from: string;\r\n        to: string;\r\n        value: string;\r\n        validAfter: string;\r\n        validBefore: string;\r\n        nonce: string;\r\n      };\r\n    };\r\n  };\r\n  paymentRequirements: {\r\n    scheme: string;\r\n    network: string;\r\n    maxAmountRequired: string;\r\n    resource: string;\r\n    description: string;\r\n    mimeType: string;\r\n    payTo: string;\r\n    maxTimeoutSeconds: number;\r\n    asset: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Facilitator verify result shape\r\n */\r\nexport interface FacilitatorVerifyResult {\r\n  success: boolean;\r\n  valid: boolean;\r\n  transactionHash?: string;\r\n  error?: string;\r\n  errorDetails?: Record<string, any>;\r\n  facilitatorId: string;\r\n  verifiedAt: string;\r\n}\r\n\r\n/**\r\n * Facilitator settle result shape\r\n */\r\nexport interface FacilitatorSettleResult {\r\n  success: boolean;\r\n  settled: boolean;\r\n  transactionHash?: string;\r\n  error?: string;\r\n  errorDetails?: Record<string, any>;\r\n  facilitatorId: string;\r\n  settledAt: string;\r\n}\r\n\r\n/**\r\n * Build Dexter-specific payment requirements for probe mode\r\n * Uses known-good values that Dexter expects\r\n */\r\nfunction buildDexterProbePaymentRequirements(config: FacilitatorProbeConfig): PaymentRequirements {\r\n  // USDC on Solana mainnet (SPL token mint address)\r\n  const USDC_SOLANA_MAINNET = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';\r\n  // USDC on Solana devnet (SPL token mint address)\r\n  const USDC_SOLANA_DEVNET = '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU';\r\n  \r\n  // Determine asset based on network\r\n  let asset = USDC_SOLANA_MAINNET;\r\n  if (config.network === 'solana:102' || config.network === 'solana:devnet') {\r\n    asset = USDC_SOLANA_DEVNET;\r\n  }\r\n  \r\n  // Use a test receiver address for probes\r\n  const PROBE_RECEIVER = '11111111111111111111111111111111'; // System program (placeholder)\r\n  \r\n  return {\r\n    scheme: 'x402',\r\n    network: config.network,\r\n    asset,\r\n    maxAmountRequired: '1', // Minimal amount (1 atomic unit)\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    payTo: PROBE_RECEIVER,\r\n    maxTimeoutSeconds: 10,\r\n    settlementMode: 'immediate',\r\n  };\r\n}\r\n\r\n/**\r\n * Dexter Facilitator\r\n * \r\n * Solana-native community facilitator with public hosted endpoint.\r\n * Public URL: https://facilitator.dexter.cash\r\n * \r\n * Supports Solana mainnet and devnet networks.\r\n */\r\nexport class DexterFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'dexter';\r\n  readonly name = 'Dexter Facilitator';\r\n\r\n  readonly config: FacilitatorConfig = {\r\n    id: 'dexter',\r\n    name: 'Dexter Facilitator',\r\n    enabled: process.env.DEXTER_ENABLED !== 'false', // Enabled by default\r\n    priority: 2, // Same priority tier as X402rs/PayAI for auto-routing\r\n    \r\n    // Legacy network identifiers\r\n    networks: ['solana', 'solana-mainnet', 'solana-devnet'],\r\n    \r\n    // CAIP-2 network identifiers\r\n    networksCAIP: [\r\n      'solana:101',    // Solana mainnet\r\n      'solana:102',    // Solana devnet\r\n      'solana:mainnet', // Legacy alias\r\n      'solana:devnet',  // Legacy alias\r\n    ],\r\n    \r\n    // Legacy asset identifiers (include both contract addresses and symbols for probe compatibility)\r\n    assets: [\r\n      'USDC', // Symbol alias for probes\r\n      'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC on Solana mainnet\r\n      '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU', // USDC on Solana devnet\r\n    ],\r\n    \r\n    // CAIP-19 asset identifiers\r\n    assetsCAIP: [\r\n      'solana:101/spl:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC on Solana mainnet\r\n      'solana:102/spl:4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU', // USDC on Solana devnet\r\n    ],\r\n    \r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'],\r\n    \r\n    healthCheckUrl: process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash',\r\n    \r\n    metadata: {\r\n      provider: 'Dexter',\r\n      label: 'Dexter Facilitator',\r\n      url: 'https://facilitator.dexter.cash',\r\n      website: 'https://dexter.cash',\r\n      solanaNative: true,\r\n      complianceLevel: 'community',\r\n      notes: 'Solana-native x402 facilitator',\r\n    },\r\n  };\r\n\r\n  private baseUrl: string;\r\n\r\n  constructor(baseUrl?: string) {\r\n    super();\r\n    this.baseUrl = baseUrl || process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash';\r\n  }\r\n\r\n  /**\r\n   * Get the facilitator URL\r\n   */\r\n  getUrl(): string {\r\n    return this.baseUrl;\r\n  }\r\n\r\n  /**\r\n   * Call Dexter /verify endpoint with retry logic for transient errors\r\n   */\r\n  private async callDexterVerifyWithRetries(\r\n    verifyUrl: string,\r\n    requestBody: DexterVerifyRequest,\r\n    isProbe: boolean\r\n  ): Promise<{\r\n    success: boolean;\r\n    valid: boolean;\r\n    status: number;\r\n    errorType?: string;\r\n    errorMessage?: string;\r\n    isRateLimited: boolean;\r\n    isNetworkError: boolean;\r\n    latencyMs: number;\r\n    data?: any;\r\n  }> {\r\n    const maxRetries = 3;\r\n    const retryableStatuses = [429, 500, 502, 503, 504];\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const response = await fetch(verifyUrl, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify(requestBody),\r\n          signal: AbortSignal.timeout(10000), // 10 second timeout\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data = text ? JSON.parse(text) : {};\r\n        const latencyMs = Date.now() - startTime;\r\n\r\n        // Success case\r\n        if (response.ok && data.valid === true) {\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            status: response.status,\r\n            isRateLimited: false,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Check if retryable error\r\n        const isRetryable = retryableStatuses.includes(response.status);\r\n        const isRateLimit = response.status === 429;\r\n        \r\n        // If not retryable or last attempt, return error\r\n        if (!isRetryable || attempt === maxRetries - 1) {\r\n          const errorMessage = data.message || data.reason || data.error || `HTTP ${response.status}`;\r\n          const errorType = data.errorType || data.code || (isRateLimit ? 'rate_limit' : 'DEXTER_VERIFY_FAILED');\r\n          \r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            status: response.status,\r\n            errorType,\r\n            errorMessage,\r\n            isRateLimited: isRateLimit,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Retry with exponential backoff\r\n        const delay = 100 * Math.pow(2, attempt);\r\n        logger.info({\r\n          component: 'DexterFacilitator',\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          status: response.status,\r\n          delay,\r\n          isProbe,\r\n          msg: 'Retrying Dexter verification after transient error',\r\n        });\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        \r\n      } catch (error: any) {\r\n        const latencyMs = Date.now() - startTime;\r\n        const isTimeout = error?.name === 'AbortError' || error?.message?.toLowerCase().includes('timeout');\r\n        const isNetworkError = error?.message?.toLowerCase().includes('network') || \r\n                              error?.message?.toLowerCase().includes('fetch') ||\r\n                              error?.message?.toLowerCase().includes('econnrefused');\r\n        \r\n        if ((isTimeout || isNetworkError) && attempt < maxRetries - 1) {\r\n          const delay = 100 * Math.pow(2, attempt);\r\n          logger.info({\r\n            component: 'DexterFacilitator',\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error?.message,\r\n            delay,\r\n            isProbe,\r\n            msg: 'Retrying Dexter verification after network error',\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n        \r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          status: 0,\r\n          errorType: isTimeout ? 'timeout' : isNetworkError ? 'network_error' : 'DEXTER_VERIFY_FAILED',\r\n          errorMessage: error?.message || 'Dexter verification failed',\r\n          isRateLimited: false,\r\n          isNetworkError: isTimeout || isNetworkError,\r\n          latencyMs,\r\n        };\r\n      }\r\n    }\r\n    \r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      status: 0,\r\n      errorType: 'DEXTER_VERIFY_FAILED',\r\n      errorMessage: 'Max retries exceeded',\r\n      isRateLimited: false,\r\n      isNetworkError: false,\r\n      latencyMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify payment using Dexter facilitator\r\n   * POST https://facilitator.dexter.cash/verify\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    const start = Date.now();\r\n\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Parse payment header\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Detect probe mode\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n      \r\n      // Build payment payload\r\n      const paymentPayload = {\r\n        x402Version: 2,\r\n        scheme: requirements.scheme || 'x402',\r\n        network: parsed.network || requirements.network,\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: {\r\n            from: parsed.authorization.from,\r\n            to: parsed.authorization.to,\r\n            value: parsed.authorization.value,\r\n            validAfter: parsed.authorization.validAfter,\r\n            validBefore: parsed.authorization.validBefore,\r\n            nonce: parsed.authorization.nonce,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Build payment requirements\r\n      const paymentRequirements = {\r\n        scheme: requirements.scheme,\r\n        network: requirements.network,\r\n        maxAmountRequired: requirements.maxAmountRequired,\r\n        resource: requirements.resource,\r\n        description: requirements.description || '',\r\n        mimeType: requirements.mimeType || 'application/json',\r\n        payTo: requirements.payTo,\r\n        maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n        asset: requirements.asset,\r\n      };\r\n\r\n      // POST to Dexter verification endpoint\r\n      const verifyUrl = `${this.baseUrl}/verify`;\r\n      const requestBody: DexterVerifyRequest = {\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      };\r\n\r\n      logger.info({\r\n        component: 'DexterFacilitator',\r\n        isProbe,\r\n        network: paymentRequirements.network,\r\n        asset: paymentRequirements.asset,\r\n        url: verifyUrl,\r\n        facilitatorId: this.id,\r\n        facilitatorUrl: this.baseUrl,\r\n        msg: 'Sending Dexter /verify request',\r\n      });\r\n\r\n      // Call with retry logic\r\n      const result = await this.callDexterVerifyWithRetries(verifyUrl, requestBody, isProbe);\r\n\r\n      // Handle success\r\n      if (result.success && result.valid) {\r\n        logger.info({\r\n          component: 'DexterFacilitator',\r\n          facilitatorId: this.id,\r\n          facilitatorUrl: this.baseUrl,\r\n          latencyMs: result.latencyMs,\r\n          network: requirements.network,\r\n          msg: 'Payment verified successfully by Dexter',\r\n        });\r\n        return {\r\n          success: true,\r\n          valid: true,\r\n          transactionHash: result.data?.transactionHash || result.data?.txHash,\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Handle error\r\n      const errorType = result.errorType || 'DEXTER_VERIFY_FAILED';\r\n      const errorMessage = result.errorMessage || 'Dexter verification failed';\r\n      \r\n      let errorCode = 'facilitator_error';\r\n      if (result.isRateLimited || errorType === 'rate_limit') {\r\n        errorCode = 'rate_limited';\r\n      } else if (result.isNetworkError) {\r\n        errorCode = 'network_error';\r\n      } else if (errorType === 'invalid_request' || result.status === 400) {\r\n        errorCode = 'invalid_request';\r\n      }\r\n\r\n      logger.debug({\r\n        component: 'DexterFacilitator',\r\n        facilitatorId: this.id,\r\n        status: result.status,\r\n        errorType,\r\n        errorMessage,\r\n        errorCode,\r\n        isRateLimited: result.isRateLimited,\r\n        isNetworkError: result.isNetworkError,\r\n        latencyMs: result.latencyMs,\r\n        msg: 'Dexter verification failed',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: errorMessage,\r\n        errorDetails: {\r\n          error: errorMessage,\r\n          errorType,\r\n          httpStatus: result.status,\r\n          errorCode,\r\n          isRateLimited: result.isRateLimited,\r\n          isNetworkError: result.isNetworkError,\r\n          dexterResponse: result.data,\r\n        },\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'Dexter verification error');\r\n      \r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: isTimeout ? 'DEXTER_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Settle payment using Dexter facilitator\r\n   * POST https://facilitator.dexter.cash/settle\r\n   */\r\n  async settle(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<FacilitatorSettleResult> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // Parse payment header\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          settled: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          settledAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Build payment payload\r\n      const paymentPayload = {\r\n        x402Version: 2,\r\n        scheme: requirements.scheme || 'x402',\r\n        network: parsed.network || requirements.network,\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: {\r\n            from: parsed.authorization.from,\r\n            to: parsed.authorization.to,\r\n            value: parsed.authorization.value,\r\n            validAfter: parsed.authorization.validAfter,\r\n            validBefore: parsed.authorization.validBefore,\r\n            nonce: parsed.authorization.nonce,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Build payment requirements\r\n      const paymentRequirements = {\r\n        scheme: requirements.scheme,\r\n        network: requirements.network,\r\n        maxAmountRequired: requirements.maxAmountRequired,\r\n        resource: requirements.resource,\r\n        description: requirements.description || '',\r\n        mimeType: requirements.mimeType || 'application/json',\r\n        payTo: requirements.payTo,\r\n        maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n        asset: requirements.asset,\r\n      };\r\n\r\n      // POST to Dexter settlement endpoint\r\n      const settleUrl = `${this.baseUrl}/settle`;\r\n      const requestBody: DexterSettleRequest = {\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      };\r\n\r\n      logger.info({\r\n        component: 'DexterFacilitator',\r\n        network: paymentRequirements.network,\r\n        asset: paymentRequirements.asset,\r\n        url: settleUrl,\r\n        facilitatorId: this.id,\r\n        facilitatorUrl: this.baseUrl,\r\n        msg: 'Sending Dexter /settle request',\r\n      });\r\n\r\n      const response = await fetch(settleUrl, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(requestBody),\r\n        signal: AbortSignal.timeout(30000), // 30 second timeout for settlement\r\n      });\r\n\r\n      const latencyMs = Date.now() - start;\r\n      const text = await response.text();\r\n      const data = text ? JSON.parse(text) : {};\r\n\r\n      if (response.ok && (data.settled === true || data.success === true)) {\r\n        logger.info({\r\n          component: 'DexterFacilitator',\r\n          facilitatorId: this.id,\r\n          facilitatorUrl: this.baseUrl,\r\n          latencyMs,\r\n          network: requirements.network,\r\n          transactionHash: data.transactionHash || data.txHash,\r\n          msg: 'Payment settled successfully by Dexter',\r\n        });\r\n        return {\r\n          success: true,\r\n          settled: true,\r\n          transactionHash: data.transactionHash || data.txHash,\r\n          facilitatorId: this.id,\r\n          settledAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const errorMessage = data.message || data.reason || data.error || `HTTP ${response.status}`;\r\n      logger.error({\r\n        component: 'DexterFacilitator',\r\n        facilitatorId: this.id,\r\n        status: response.status,\r\n        errorMessage,\r\n        latencyMs,\r\n        msg: 'Dexter settlement failed',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        settled: false,\r\n        error: errorMessage,\r\n        errorDetails: {\r\n          httpStatus: response.status,\r\n          dexterResponse: data,\r\n        },\r\n        facilitatorId: this.id,\r\n        settledAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Settlement failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'Dexter settlement error');\r\n      \r\n      return {\r\n        success: false,\r\n        settled: false,\r\n        error: isTimeout ? 'DEXTER_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        settledAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get Dexter facilitator health\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // Dexter health check endpoint\r\n      const healthUrl = `${this.baseUrl}/health`;\r\n      \r\n      const response = await fetch(healthUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n\r\n      const latency = Date.now() - start;\r\n\r\n      if (response.ok) {\r\n        let data: any = {};\r\n        try {\r\n          data = await response.json();\r\n        } catch {\r\n          // Health endpoint might return simple OK\r\n        }\r\n\r\n        return {\r\n          healthy: true,\r\n          latency,\r\n          lastChecked: new Date().toISOString(),\r\n          capabilities: {\r\n            networks: data.networks || this.config.networks,\r\n            assets: data.assets || this.config.assets,\r\n            schemes: data.schemes || this.config.schemes,\r\n          },\r\n        };\r\n      }\r\n\r\n      const errorText = await response.text().catch(() => `HTTP ${response.status}`);\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: errorText,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Health check failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: isTimeout ? 'Health check timeout' : errorMessage,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get pricing information (not available for Dexter yet)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    // TODO: Implement if Dexter provides pricing API\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\r\n    return super.supports(network, asset, scheme, settlementMode);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// STANDALONE VERIFY/SETTLE FUNCTIONS\r\n// =============================================================================\r\n// These functions can be used directly without the facilitator class\r\n\r\n/**\r\n * Verify payment using Dexter facilitator\r\n * Direct function for standalone use\r\n */\r\nexport async function dexterVerify(payload: DexterVerifyRequest): Promise<FacilitatorVerifyResult> {\r\n  const baseUrl = process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash';\r\n  const verifyUrl = `${baseUrl}/verify`;\r\n  const start = Date.now();\r\n\r\n  try {\r\n    const response = await fetch(verifyUrl, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify(payload),\r\n      signal: AbortSignal.timeout(10000),\r\n    });\r\n\r\n    const latencyMs = Date.now() - start;\r\n    const text = await response.text();\r\n    const data = text ? JSON.parse(text) : {};\r\n\r\n    if (response.ok && data.valid === true) {\r\n      return {\r\n        success: true,\r\n        valid: true,\r\n        transactionHash: data.transactionHash || data.txHash,\r\n        facilitatorId: 'dexter',\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      error: data.message || data.error || `HTTP ${response.status}`,\r\n      errorDetails: {\r\n        httpStatus: response.status,\r\n        dexterResponse: data,\r\n        latencyMs,\r\n      },\r\n      facilitatorId: 'dexter',\r\n      verifiedAt: new Date().toISOString(),\r\n    };\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      error: errorMessage,\r\n      facilitatorId: 'dexter',\r\n      verifiedAt: new Date().toISOString(),\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Settle payment using Dexter facilitator\r\n * Direct function for standalone use\r\n */\r\nexport async function dexterSettle(payload: DexterSettleRequest): Promise<FacilitatorSettleResult> {\r\n  const baseUrl = process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash';\r\n  const settleUrl = `${baseUrl}/settle`;\r\n  const start = Date.now();\r\n\r\n  try {\r\n    const response = await fetch(settleUrl, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify(payload),\r\n      signal: AbortSignal.timeout(30000),\r\n    });\r\n\r\n    const latencyMs = Date.now() - start;\r\n    const text = await response.text();\r\n    const data = text ? JSON.parse(text) : {};\r\n\r\n    if (response.ok && (data.settled === true || data.success === true)) {\r\n      return {\r\n        success: true,\r\n        settled: true,\r\n        transactionHash: data.transactionHash || data.txHash,\r\n        facilitatorId: 'dexter',\r\n        settledAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      settled: false,\r\n      error: data.message || data.error || `HTTP ${response.status}`,\r\n      errorDetails: {\r\n        httpStatus: response.status,\r\n        dexterResponse: data,\r\n        latencyMs,\r\n      },\r\n      facilitatorId: 'dexter',\r\n      settledAt: new Date().toISOString(),\r\n    };\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Settlement failed';\r\n    return {\r\n      success: false,\r\n      settled: false,\r\n      error: errorMessage,\r\n      facilitatorId: 'dexter',\r\n      settledAt: new Date().toISOString(),\r\n    };\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet dexterFacilitator: DexterFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton Dexter facilitator instance\r\n */\r\nexport function getDexterFacilitator(): DexterFacilitator {\r\n  if (!dexterFacilitator) {\r\n    dexterFacilitator = new DexterFacilitator();\r\n  }\r\n  return dexterFacilitator;\r\n}\r\n\r\n","// =============================================================================\r\n// CRONOS X402 FACILITATOR\r\n// =============================================================================\r\n// Official Cronos Labs x402 facilitator for Cronos network payments.\r\n// Documentation: https://docs.cronos.org/cronos-x402-facilitator\r\n// Resources: https://docs.cronos.org/cronos-x402-facilitator/resources-and-next-steps\r\n//\r\n// Base URL: https://facilitator.cronoslabs.org\r\n// Health: GET /healthcheck\r\n// Verify: POST /v2/x402/verify\r\n// Settle: POST /v2/x402/settle\r\n// Discovery: GET /v2/x402/supported\r\n//\r\n// Network field values:\r\n// - \"cronos\" for mainnet (chain ID 25)\r\n// - \"cronos-testnet\" for testnet (chain ID 338)\r\n//\r\n// Rate limits: 5 requests per minute per IP for settle/verify\r\n\r\nimport {\r\n  BaseFacilitator,\r\n  type IFacilitator,\r\n  type PaymentRequirements,\r\n  type VerificationResult,\r\n  type FacilitatorHealth,\r\n  type FacilitatorConfig,\r\n  type CAIPNetworkId,\r\n  type CAIPAssetId,\r\n  type SettlementMode,\r\n} from './base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type { FacilitatorProbeConfig } from './facilitator-probe-config';\r\n\r\nconst logger = createLogger({ component: 'CronosFacilitator' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\n/**\r\n * Cronos health check response\r\n * GET /healthcheck\r\n */\r\ninterface CronosHealthResponse {\r\n  status: 'OK' | string;\r\n  uptime?: number;\r\n  responseTime?: number;\r\n  timestamp?: string;\r\n}\r\n\r\n/**\r\n * Cronos supported assets response\r\n * GET /v2/x402/supported\r\n */\r\ninterface CronosSupportedResponse {\r\n  networks?: string[];\r\n  assets?: Array<{\r\n    network: string;\r\n    address: string;\r\n    symbol: string;\r\n    decimals: number;\r\n  }>;\r\n  limits?: {\r\n    maxAmount?: string;\r\n    minAmount?: string;\r\n    rateLimit?: {\r\n      requestsPerMinute: number;\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Cronos verify request body\r\n * POST /v2/x402/verify\r\n */\r\ninterface CronosVerifyRequest {\r\n  paymentPayload: {\r\n    x402Version: number;\r\n    scheme: string;\r\n    network: string; // \"cronos\" or \"cronos-testnet\"\r\n    payload: {\r\n      signature: string;\r\n      authorization: {\r\n        from: string;\r\n        to: string;\r\n        value: string;\r\n        validAfter: string;\r\n        validBefore: string;\r\n        nonce: string;\r\n      };\r\n    };\r\n  };\r\n  paymentRequirements: {\r\n    scheme: string;\r\n    network: string;\r\n    maxAmountRequired: string;\r\n    resource: string;\r\n    description?: string;\r\n    mimeType?: string;\r\n    payTo: string;\r\n    maxTimeoutSeconds?: number;\r\n    asset: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Cronos verify response\r\n */\r\ninterface CronosVerifyResponse {\r\n  valid: boolean;\r\n  transactionHash?: string;\r\n  error?: string;\r\n  errorCode?: string;\r\n}\r\n\r\n/**\r\n * Cronos settle request body\r\n * POST /v2/x402/settle\r\n */\r\ninterface CronosSettleRequest {\r\n  paymentIntent: {\r\n    x402Version: number;\r\n    scheme: string;\r\n    network: string;\r\n    payload: {\r\n      signature: string;\r\n      authorization: {\r\n        from: string;\r\n        to: string;\r\n        value: string;\r\n        validAfter: string;\r\n        validBefore: string;\r\n        nonce: string;\r\n      };\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Cronos settle response\r\n */\r\ninterface CronosSettleResponse {\r\n  success: boolean;\r\n  transactionHash?: string;\r\n  blockNumber?: number;\r\n  timestamp?: string;\r\n  error?: string;\r\n  errorCode?: string;\r\n}\r\n\r\n/**\r\n * Known Cronos facilitator error codes\r\n */\r\nconst CRONOS_ERROR_CODES = {\r\n  AUTHORIZATION_ALREADY_USED: 'authorization_already_used',\r\n  INVALID_SIGNATURE: 'invalid_signature',\r\n  INVALID_AUTHORIZATION: 'invalid_authorization',\r\n  RATE_LIMITED: 'rate_limited',\r\n  NETWORK_ERROR: 'network_error',\r\n  TIMEOUT: 'timeout',\r\n} as const;\r\n\r\n// =============================================================================\r\n// HELPER FUNCTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Convert CAIP-2 network identifier to Cronos network name\r\n */\r\nfunction caipToCronosNetwork(network: string): string {\r\n  const mapping: Record<string, string> = {\r\n    'eip155:25': 'cronos',\r\n    'eip155:338': 'cronos-testnet',\r\n    'cronos': 'cronos',\r\n    'cronos-testnet': 'cronos-testnet',\r\n    'cronos-mainnet': 'cronos',\r\n  };\r\n  return mapping[network] || network;\r\n}\r\n\r\n/**\r\n * Build Cronos-specific payment requirements for probe mode\r\n */\r\nfunction buildCronosProbePaymentRequirements(config: FacilitatorProbeConfig): PaymentRequirements {\r\n  // Placeholder USDX contract address on Cronos\r\n  // Replace with the official Cronos USDX contract from Cronos docs/block explorer\r\n  const USDX_CRONOS = '0x0000000000000000000000000000000000000000'; // TODO: Replace with actual USDX address\r\n  \r\n  // Test receiver address for probes\r\n  const PROBE_RECEIVER = '0x0000000000000000000000000000000000000001';\r\n  \r\n  // Convert CAIP-2 to Cronos network name\r\n  const cronosNetwork = caipToCronosNetwork(config.network);\r\n  \r\n  return {\r\n    scheme: 'x402',\r\n    network: cronosNetwork,\r\n    asset: USDX_CRONOS,\r\n    maxAmountRequired: '1', // Minimal amount (1 atomic unit)\r\n    resource: `https://probe.nexflow.dev/health/${config.facilitatorId}/${config.network}/${config.token}`,\r\n    description: `Health probe for ${config.facilitatorId} on ${config.network}`,\r\n    mimeType: 'application/json',\r\n    payTo: PROBE_RECEIVER,\r\n    maxTimeoutSeconds: 10,\r\n    settlementMode: 'immediate',\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// CRONOS FACILITATOR CLASS\r\n// =============================================================================\r\n\r\n/**\r\n * Cronos x402 Facilitator\r\n * \r\n * Official Cronos Labs x402 facilitator supporting Cronos mainnet and testnet.\r\n * Documentation: https://docs.cronos.org/cronos-x402-facilitator\r\n */\r\nexport class CronosFacilitator extends BaseFacilitator implements IFacilitator {\r\n  readonly id = 'cronos';\r\n  readonly name = 'Cronos x402 Facilitator';\r\n\r\n  readonly config: FacilitatorConfig = {\r\n    id: 'cronos',\r\n    name: 'Cronos x402 Facilitator',\r\n    enabled: process.env.CRONOS_ENABLED !== 'false', // Enabled by default\r\n    priority: 2, // Similar priority to other community facilitators\r\n    \r\n    // Legacy network identifiers\r\n    networks: ['cronos', 'cronos-testnet'],\r\n    \r\n    // CAIP-2 network identifiers\r\n    networksCAIP: [\r\n      'eip155:25',   // Cronos mainnet\r\n      'eip155:338',  // Cronos testnet\r\n    ],\r\n    \r\n    // Legacy asset identifiers\r\n    // Note: Replace placeholders with actual Cronos stablecoin contract addresses\r\n    // from Cronos docs/block explorer\r\n    assets: [\r\n      'USDC',\r\n      'USDX', // Placeholder - replace with actual contract address\r\n    ],\r\n    \r\n    // CAIP-19 asset identifiers\r\n    assetsCAIP: [\r\n      // Placeholder - replace with actual Cronos USDC/USDX CAIP-19 identifiers\r\n      // 'eip155:25/erc20:0x...',\r\n    ],\r\n    \r\n    schemes: ['exact', 'x402'],\r\n    settlementModes: ['immediate'],\r\n    \r\n    healthCheckUrl: process.env.CRONOS_FACILITATOR_URL || 'https://facilitator.cronoslabs.org',\r\n    \r\n    metadata: {\r\n      provider: 'Cronos Labs',\r\n      label: 'Cronos x402 Facilitator',\r\n      url: 'https://facilitator.cronoslabs.org',\r\n      website: 'https://cronos.org',\r\n      documentation: 'https://docs.cronos.org/cronos-x402-facilitator',\r\n      complianceLevel: 'standard',\r\n      // Rate limits as documented\r\n      rateLimits: {\r\n        requestsPerMinute: 5, // 5 requests per minute per IP for settle/verify\r\n      },\r\n    },\r\n  };\r\n\r\n  private baseUrl: string;\r\n  private cachedSupported: CronosSupportedResponse | null = null;\r\n  private lastSupportedFetch: number = 0;\r\n  private readonly SUPPORTED_CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\r\n\r\n  constructor(baseUrl?: string) {\r\n    super();\r\n    this.baseUrl = baseUrl || process.env.CRONOS_FACILITATOR_URL || 'https://facilitator.cronoslabs.org';\r\n  }\r\n\r\n  /**\r\n   * Get the facilitator base URL\r\n   */\r\n  getUrl(): string {\r\n    return this.baseUrl;\r\n  }\r\n\r\n  // ===========================================================================\r\n  // HEALTH & DISCOVERY\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get Cronos facilitator health status\r\n   * GET /healthcheck\r\n   */\r\n  async getHealth(): Promise<FacilitatorHealth> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      const healthUrl = `${this.baseUrl}/healthcheck`;\r\n      \r\n      const response = await fetch(healthUrl, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n\r\n      const latency = Date.now() - start;\r\n\r\n      if (response.ok) {\r\n        let data: CronosHealthResponse = { status: 'OK' };\r\n        try {\r\n          data = await response.json();\r\n        } catch {\r\n          // Health endpoint might return simple OK\r\n        }\r\n\r\n        const isHealthy = data.status === 'OK';\r\n\r\n        // Fetch supported assets for capabilities\r\n        const supported = await this.fetchSupported();\r\n\r\n        return {\r\n          healthy: isHealthy,\r\n          latency,\r\n          lastChecked: new Date().toISOString(),\r\n          capabilities: {\r\n            networks: supported?.networks || this.config.networks,\r\n            assets: supported?.assets?.map(a => a.symbol) || this.config.assets,\r\n            schemes: this.config.schemes,\r\n          },\r\n        };\r\n      }\r\n\r\n      const errorText = await response.text().catch(() => `HTTP ${response.status}`);\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: errorText,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Health check failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n\r\n      return {\r\n        healthy: false,\r\n        latency,\r\n        lastChecked: new Date().toISOString(),\r\n        error: isTimeout ? 'Health check timeout' : errorMessage,\r\n        capabilities: {\r\n          networks: this.config.networks,\r\n          assets: this.config.assets,\r\n          schemes: this.config.schemes,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch supported assets and networks from discovery endpoint\r\n   * GET /v2/x402/supported\r\n   */\r\n  async fetchSupported(): Promise<CronosSupportedResponse | null> {\r\n    // Check cache\r\n    if (this.cachedSupported && (Date.now() - this.lastSupportedFetch) < this.SUPPORTED_CACHE_TTL_MS) {\r\n      return this.cachedSupported;\r\n    }\r\n\r\n    try {\r\n      const url = `${this.baseUrl}/v2/x402/supported`;\r\n      \r\n      const response = await fetch(url, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(5000),\r\n      });\r\n\r\n      if (response.ok) {\r\n        const data: CronosSupportedResponse = await response.json();\r\n        this.cachedSupported = data;\r\n        this.lastSupportedFetch = Date.now();\r\n        \r\n        logger.info({\r\n          component: 'CronosFacilitator',\r\n          networks: data.networks,\r\n          assetsCount: data.assets?.length,\r\n          msg: 'Cronos supported assets refreshed',\r\n        });\r\n        \r\n        return data;\r\n      }\r\n\r\n      logger.warn({\r\n        component: 'CronosFacilitator',\r\n        status: response.status,\r\n        msg: 'Failed to fetch Cronos supported assets',\r\n      });\r\n      return null;\r\n    } catch (error) {\r\n      logger.warn({\r\n        component: 'CronosFacilitator',\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        msg: 'Error fetching Cronos supported assets',\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // VERIFY FLOW\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Call Cronos /v2/x402/verify endpoint with retry logic for transient errors\r\n   */\r\n  private async callCronosVerifyWithRetries(\r\n    verifyUrl: string,\r\n    requestBody: CronosVerifyRequest,\r\n    isProbe: boolean\r\n  ): Promise<{\r\n    success: boolean;\r\n    valid: boolean;\r\n    status: number;\r\n    errorType?: string;\r\n    errorMessage?: string;\r\n    isRateLimited: boolean;\r\n    isNetworkError: boolean;\r\n    latencyMs: number;\r\n    data?: CronosVerifyResponse;\r\n  }> {\r\n    const maxRetries = 3;\r\n    const retryableStatuses = [429, 500, 502, 503, 504];\r\n    const startTime = Date.now();\r\n    \r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const response = await fetch(verifyUrl, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify(requestBody),\r\n          signal: AbortSignal.timeout(10000), // 10 second timeout\r\n        });\r\n\r\n        const text = await response.text();\r\n        const data: CronosVerifyResponse = text ? JSON.parse(text) : {};\r\n        const latencyMs = Date.now() - startTime;\r\n\r\n        // Success case\r\n        if (response.ok && data.valid === true) {\r\n          return {\r\n            success: true,\r\n            valid: true,\r\n            status: response.status,\r\n            isRateLimited: false,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Check if retryable error\r\n        const isRetryable = retryableStatuses.includes(response.status);\r\n        const isRateLimit = response.status === 429;\r\n        \r\n        // If not retryable or last attempt, return error\r\n        if (!isRetryable || attempt === maxRetries - 1) {\r\n          const errorMessage = data.error || `HTTP ${response.status}`;\r\n          const errorType = data.errorCode || (isRateLimit ? CRONOS_ERROR_CODES.RATE_LIMITED : 'CRONOS_VERIFY_FAILED');\r\n          \r\n          return {\r\n            success: false,\r\n            valid: false,\r\n            status: response.status,\r\n            errorType,\r\n            errorMessage,\r\n            isRateLimited: isRateLimit,\r\n            isNetworkError: false,\r\n            latencyMs,\r\n            data,\r\n          };\r\n        }\r\n\r\n        // Retry with exponential backoff\r\n        const delay = 100 * Math.pow(2, attempt);\r\n        logger.info({\r\n          component: 'CronosFacilitator',\r\n          attempt: attempt + 1,\r\n          maxRetries,\r\n          status: response.status,\r\n          delay,\r\n          isProbe,\r\n          msg: 'Retrying Cronos verification after transient error',\r\n        });\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        \r\n      } catch (error: any) {\r\n        const latencyMs = Date.now() - startTime;\r\n        const isTimeout = error?.name === 'AbortError' || error?.message?.toLowerCase().includes('timeout');\r\n        const isNetworkError = error?.message?.toLowerCase().includes('network') || \r\n                              error?.message?.toLowerCase().includes('fetch') ||\r\n                              error?.message?.toLowerCase().includes('econnrefused');\r\n        \r\n        // If network error and not last attempt, retry\r\n        if ((isTimeout || isNetworkError) && attempt < maxRetries - 1) {\r\n          const delay = 100 * Math.pow(2, attempt);\r\n          logger.info({\r\n            component: 'CronosFacilitator',\r\n            attempt: attempt + 1,\r\n            maxRetries,\r\n            error: error?.message,\r\n            delay,\r\n            isProbe,\r\n            msg: 'Retrying Cronos verification after network error',\r\n          });\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n        \r\n        // Last attempt or non-network error\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          status: 0,\r\n          errorType: isTimeout ? CRONOS_ERROR_CODES.TIMEOUT : isNetworkError ? CRONOS_ERROR_CODES.NETWORK_ERROR : 'CRONOS_VERIFY_FAILED',\r\n          errorMessage: error?.message || 'Cronos verification failed',\r\n          isRateLimited: false,\r\n          isNetworkError: isTimeout || isNetworkError,\r\n          latencyMs,\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Should never reach here\r\n    return {\r\n      success: false,\r\n      valid: false,\r\n      status: 0,\r\n      errorType: 'CRONOS_VERIFY_FAILED',\r\n      errorMessage: 'Max retries exceeded',\r\n      isRateLimited: false,\r\n      isNetworkError: false,\r\n      latencyMs: Date.now() - startTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify payment using Cronos facilitator\r\n   * POST /v2/x402/verify\r\n   */\r\n  async verify(\r\n    payment: string,\r\n    requirements: PaymentRequirements\r\n  ): Promise<VerificationResult> {\r\n    const start = Date.now();\r\n\r\n    // Validate requirements\r\n    const validation = this.validateRequirements(requirements);\r\n    if (!validation.valid) {\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: validation.error,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Parse payment header to extract authorization details\r\n      const { parseX402Header } = await import('../payment-header-parser');\r\n      const parseResult = parseX402Header(payment);\r\n\r\n      if (!parseResult.valid || !parseResult.parsed) {\r\n        return {\r\n          success: false,\r\n          valid: false,\r\n          error: parseResult.error || 'Failed to parse payment header',\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      const parsed = parseResult.parsed;\r\n\r\n      // Detect probe mode\r\n      const isProbe = requirements.resource?.startsWith('https://probe.nexflow.dev/health/') ?? false;\r\n\r\n      // Convert network to Cronos format\r\n      const cronosNetwork = caipToCronosNetwork(requirements.network);\r\n\r\n      // Build verify request\r\n      const requestBody: CronosVerifyRequest = {\r\n        paymentPayload: {\r\n          x402Version: 2,\r\n          scheme: requirements.scheme || 'x402',\r\n          network: cronosNetwork,\r\n          payload: {\r\n            signature: parsed.signature,\r\n            authorization: {\r\n              from: parsed.authorization.from,\r\n              to: parsed.authorization.to,\r\n              value: parsed.authorization.value,\r\n              validAfter: parsed.authorization.validAfter,\r\n              validBefore: parsed.authorization.validBefore,\r\n              nonce: parsed.authorization.nonce,\r\n            },\r\n          },\r\n        },\r\n        paymentRequirements: {\r\n          scheme: requirements.scheme,\r\n          network: cronosNetwork,\r\n          maxAmountRequired: requirements.maxAmountRequired,\r\n          resource: requirements.resource,\r\n          description: requirements.description || '',\r\n          mimeType: requirements.mimeType || 'application/json',\r\n          payTo: requirements.payTo,\r\n          maxTimeoutSeconds: requirements.maxTimeoutSeconds || 300,\r\n          asset: requirements.asset,\r\n        },\r\n      };\r\n\r\n      // POST to Cronos verification endpoint\r\n      const verifyUrl = `${this.baseUrl}/v2/x402/verify`;\r\n\r\n      logger.info({\r\n        component: 'CronosFacilitator',\r\n        isProbe,\r\n        network: cronosNetwork,\r\n        asset: requirements.asset,\r\n        url: verifyUrl,\r\n        facilitatorId: this.id,\r\n        facilitatorUrl: this.baseUrl,\r\n        msg: 'Sending Cronos /v2/x402/verify request',\r\n      });\r\n\r\n      // Call with retry logic\r\n      const result = await this.callCronosVerifyWithRetries(verifyUrl, requestBody, isProbe);\r\n\r\n      // Handle success\r\n      if (result.success && result.valid) {\r\n        logger.info({\r\n          component: 'CronosFacilitator',\r\n          facilitatorId: this.id,\r\n          facilitatorUrl: this.baseUrl,\r\n          latencyMs: result.latencyMs,\r\n          network: cronosNetwork,\r\n          transactionHash: result.data?.transactionHash,\r\n          msg: 'Payment verified successfully by Cronos',\r\n        });\r\n        return {\r\n          success: true,\r\n          valid: true,\r\n          transactionHash: result.data?.transactionHash,\r\n          facilitatorId: this.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // Handle error - map Cronos error codes\r\n      const errorType = result.errorType || 'CRONOS_VERIFY_FAILED';\r\n      const errorMessage = result.errorMessage || 'Cronos verification failed';\r\n      \r\n      let errorCode = 'facilitator_error';\r\n      if (result.isRateLimited || errorType === CRONOS_ERROR_CODES.RATE_LIMITED) {\r\n        errorCode = 'rate_limited';\r\n      } else if (result.isNetworkError) {\r\n        errorCode = 'network_error';\r\n      } else if (errorType === CRONOS_ERROR_CODES.AUTHORIZATION_ALREADY_USED) {\r\n        errorCode = 'authorization_already_used';\r\n      } else if (errorType === CRONOS_ERROR_CODES.INVALID_SIGNATURE || errorType === CRONOS_ERROR_CODES.INVALID_AUTHORIZATION) {\r\n        errorCode = 'invalid_authorization';\r\n      } else if (result.status === 400) {\r\n        errorCode = 'invalid_request';\r\n      }\r\n\r\n      logger.debug({\r\n        component: 'CronosFacilitator',\r\n        facilitatorId: this.id,\r\n        status: result.status,\r\n        errorType,\r\n        errorMessage,\r\n        errorCode,\r\n        isRateLimited: result.isRateLimited,\r\n        isNetworkError: result.isNetworkError,\r\n        latencyMs: result.latencyMs,\r\n        msg: 'Cronos verification failed',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: errorMessage,\r\n        errorDetails: {\r\n          error: errorMessage,\r\n          errorType,\r\n          httpStatus: result.status,\r\n          errorCode,\r\n          isRateLimited: result.isRateLimited,\r\n          isNetworkError: result.isNetworkError,\r\n          cronosResponse: result.data,\r\n        },\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Verification failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n      \r\n      this.getLogger().error({ error, requirements, latency, isTimeout }, 'Cronos verification error');\r\n      \r\n      return {\r\n        success: false,\r\n        valid: false,\r\n        error: isTimeout ? 'CRONOS_REQUEST_TIMEOUT' : errorMessage,\r\n        facilitatorId: this.id,\r\n        verifiedAt: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // SETTLE FLOW\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Settle a verified payment intent with Cronos facilitator\r\n   * POST /v2/x402/settle\r\n   * \r\n   * Blocks until the facilitator returns the settlement receipt with\r\n   * transaction hash, block number, and timestamp.\r\n   */\r\n  async settle(\r\n    paymentIntent: {\r\n      x402Version: number;\r\n      scheme: string;\r\n      network: string;\r\n      payload: {\r\n        signature: string;\r\n        authorization: {\r\n          from: string;\r\n          to: string;\r\n          value: string;\r\n          validAfter: string;\r\n          validBefore: string;\r\n          nonce: string;\r\n        };\r\n      };\r\n    }\r\n  ): Promise<{\r\n    success: boolean;\r\n    transactionHash?: string;\r\n    blockNumber?: number;\r\n    timestamp?: string;\r\n    error?: string;\r\n    errorCode?: string;\r\n  }> {\r\n    const start = Date.now();\r\n\r\n    try {\r\n      // Convert network to Cronos format\r\n      const cronosNetwork = caipToCronosNetwork(paymentIntent.network);\r\n\r\n      const requestBody: CronosSettleRequest = {\r\n        paymentIntent: {\r\n          ...paymentIntent,\r\n          network: cronosNetwork,\r\n        },\r\n      };\r\n\r\n      const settleUrl = `${this.baseUrl}/v2/x402/settle`;\r\n\r\n      logger.info({\r\n        component: 'CronosFacilitator',\r\n        network: cronosNetwork,\r\n        url: settleUrl,\r\n        facilitatorId: this.id,\r\n        msg: 'Sending Cronos /v2/x402/settle request',\r\n      });\r\n\r\n      const response = await fetch(settleUrl, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(requestBody),\r\n        signal: AbortSignal.timeout(30000), // 30 second timeout for settlement\r\n      });\r\n\r\n      const latency = Date.now() - start;\r\n      const text = await response.text();\r\n      const data: CronosSettleResponse = text ? JSON.parse(text) : {};\r\n\r\n      if (response.ok && data.success) {\r\n        logger.info({\r\n          component: 'CronosFacilitator',\r\n          facilitatorId: this.id,\r\n          latencyMs: latency,\r\n          transactionHash: data.transactionHash,\r\n          blockNumber: data.blockNumber,\r\n          msg: 'Payment settled successfully by Cronos',\r\n        });\r\n\r\n        return {\r\n          success: true,\r\n          transactionHash: data.transactionHash,\r\n          blockNumber: data.blockNumber,\r\n          timestamp: data.timestamp,\r\n        };\r\n      }\r\n\r\n      // Handle known error codes\r\n      const errorCode = data.errorCode || 'CRONOS_SETTLE_FAILED';\r\n      const errorMessage = data.error || `HTTP ${response.status}`;\r\n\r\n      logger.warn({\r\n        component: 'CronosFacilitator',\r\n        facilitatorId: this.id,\r\n        status: response.status,\r\n        errorCode,\r\n        errorMessage,\r\n        latencyMs: latency,\r\n        msg: 'Cronos settlement failed',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        error: errorMessage,\r\n        errorCode,\r\n      };\r\n    } catch (error) {\r\n      const latency = Date.now() - start;\r\n      const errorMessage = error instanceof Error ? error.message : 'Settlement failed';\r\n      const isTimeout = error instanceof Error && (error.name === 'AbortError' || errorMessage.toLowerCase().includes('timeout'));\r\n\r\n      logger.error({\r\n        component: 'CronosFacilitator',\r\n        error: errorMessage,\r\n        latencyMs: latency,\r\n        isTimeout,\r\n        msg: 'Cronos settlement error',\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        error: isTimeout ? 'CRONOS_SETTLE_TIMEOUT' : errorMessage,\r\n        errorCode: isTimeout ? CRONOS_ERROR_CODES.TIMEOUT : CRONOS_ERROR_CODES.NETWORK_ERROR,\r\n      };\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // PRICING & SUPPORT\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get pricing information (not available yet for Cronos)\r\n   */\r\n  async getPricing(network: string, asset: string) {\r\n    // TODO: Implement if Cronos provides pricing API\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if facilitator supports network/asset/scheme\r\n   */\r\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\r\n    // Normalize network to check\r\n    const normalizedNetwork = caipToCronosNetwork(network);\r\n    const supportedNetworks = ['cronos', 'cronos-testnet', 'eip155:25', 'eip155:338'];\r\n    \r\n    if (!supportedNetworks.includes(network) && !supportedNetworks.includes(normalizedNetwork)) {\r\n      return false;\r\n    }\r\n\r\n    return super.supports(normalizedNetwork, asset, scheme, settlementMode);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// SINGLETON\r\n// =============================================================================\r\n\r\nlet cronosFacilitator: CronosFacilitator | null = null;\r\n\r\n/**\r\n * Get singleton Cronos facilitator instance\r\n */\r\nexport function getCronosFacilitator(): CronosFacilitator {\r\n  if (!cronosFacilitator) {\r\n    cronosFacilitator = new CronosFacilitator();\r\n  }\r\n  return cronosFacilitator;\r\n}\r\n\r\n/**\r\n * Export probe requirements builder for probe system\r\n */\r\nexport { buildCronosProbePaymentRequirements };\r\n\r\n","// =============================================================================\r\n// HEALTH AGGREGATOR\r\n// =============================================================================\r\n// Aggregates health metrics from route attempts for scoring and monitoring\r\n\r\nimport { getRouteAttemptsForHealth, upsertHealthSnapshot, getLatestHealthSnapshot, type RouteAttempt, type FacilitatorHealthSnapshot } from '@/db/smf';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'HealthAggregator' });\r\n\r\n/**\r\n * Calculate percentile from sorted array\r\n */\r\nfunction percentile(sortedValues: number[], p: number): number {\r\n  if (sortedValues.length === 0) return 0;\r\n  const index = Math.ceil((p / 100) * sortedValues.length) - 1;\r\n  return sortedValues[Math.max(0, index)];\r\n}\r\n\r\n/**\r\n * Aggregate health metrics from route attempts\r\n */\r\nexport async function aggregateHealthMetrics(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowStart: Date,\r\n  windowEnd: Date\r\n): Promise<FacilitatorHealthSnapshot | null> {\r\n  try {\r\n    const attempts = await getRouteAttemptsForHealth(\r\n      facilitatorId,\r\n      network,\r\n      token,\r\n      windowStart.toISOString(),\r\n      windowEnd.toISOString()\r\n    );\r\n\r\n    if (attempts.length === 0) {\r\n      logger.debug({ facilitatorId, network, token }, 'No attempts found for health aggregation');\r\n      return null;\r\n    }\r\n\r\n    // Calculate success rate\r\n    const successful = attempts.filter((a) => a.result === 'success').length;\r\n    const successRate = successful / attempts.length;\r\n\r\n    // Calculate latency percentiles\r\n    const latencies = attempts\r\n      .map((a) => a.latency_ms)\r\n      .filter((l) => l > 0)\r\n      .sort((a, b) => a - b);\r\n\r\n    const p50 = latencies.length > 0 ? percentile(latencies, 50) : null;\r\n    const p95 = latencies.length > 0 ? percentile(latencies, 95) : null;\r\n    const p99 = latencies.length > 0 ? percentile(latencies, 99) : null;\r\n\r\n    // Calculate error rate\r\n    const errors = attempts.filter((a) => a.result !== 'success').length;\r\n    const errorRate = errors / attempts.length;\r\n\r\n    // Get last error type\r\n    const failedAttempts = attempts.filter((a) => a.result !== 'success');\r\n    const lastErrorType = failedAttempts.length > 0 ? failedAttempts[failedAttempts.length - 1].result : null;\r\n\r\n    // Determine status\r\n    let status: 'healthy' | 'degraded' | 'down' = 'healthy';\r\n    if (successRate < 0.5) {\r\n      status = 'down';\r\n    } else if (successRate < 0.9 || (p95 && p95 > 5000)) {\r\n      status = 'degraded';\r\n    }\r\n\r\n    const snapshot: Omit<FacilitatorHealthSnapshot, 'id' | 'created_at'> = {\r\n      facilitator_id: facilitatorId,\r\n      network,\r\n      token,\r\n      window_start: windowStart.toISOString(),\r\n      window_end: windowEnd.toISOString(),\r\n      success_rate: successRate,\r\n      p50_latency_ms: p50,\r\n      p95_latency_ms: p95,\r\n      p99_latency_ms: p99,\r\n      error_rate: errorRate,\r\n      last_error_type: lastErrorType,\r\n      status,\r\n    };\r\n\r\n    const saved = await upsertHealthSnapshot(snapshot);\r\n    logger.info(\r\n      {\r\n        facilitatorId,\r\n        network,\r\n        token,\r\n        successRate,\r\n        p95Latency: p95,\r\n        status,\r\n        attempts: attempts.length,\r\n      },\r\n      'Health snapshot created'\r\n    );\r\n\r\n    return saved;\r\n  } catch (error) {\r\n    logger.error({ error, facilitatorId, network, token }, 'Failed to aggregate health metrics');\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get current health for a facilitator/network/token\r\n * Returns latest snapshot or calculates from recent attempts\r\n */\r\nexport async function getCurrentHealth(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowMinutes: number = 15\r\n): Promise<{\r\n  successRate: number;\r\n  p50LatencyMs: number | null;\r\n  p95LatencyMs: number | null;\r\n  p99LatencyMs: number | null;\r\n  errorRate: number;\r\n  lastErrorType: string | null;\r\n  status: 'healthy' | 'degraded' | 'down';\r\n}> {\r\n  // Try to get latest snapshot first\r\n  const snapshot = await getLatestHealthSnapshot(facilitatorId, network, token);\r\n\r\n  if (snapshot) {\r\n    const snapshotAge = Date.now() - new Date(snapshot.window_end).getTime();\r\n    const maxAge = windowMinutes * 60 * 1000;\r\n\r\n    // If snapshot is recent enough, use it\r\n    if (snapshotAge < maxAge) {\r\n      return {\r\n        successRate: Number(snapshot.success_rate),\r\n        p50LatencyMs: snapshot.p50_latency_ms,\r\n        p95LatencyMs: snapshot.p95_latency_ms,\r\n        p99LatencyMs: snapshot.p99_latency_ms,\r\n        errorRate: Number(snapshot.error_rate),\r\n        lastErrorType: snapshot.last_error_type,\r\n        status: snapshot.status,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Otherwise, calculate from recent attempts\r\n  const windowEnd = new Date();\r\n  const windowStart = new Date(windowEnd.getTime() - windowMinutes * 60 * 1000);\r\n\r\n  const aggregated = await aggregateHealthMetrics(facilitatorId, network, token, windowStart, windowEnd);\r\n\r\n  if (aggregated) {\r\n    return {\r\n      successRate: Number(aggregated.success_rate),\r\n      p50LatencyMs: aggregated.p50_latency_ms,\r\n      p95LatencyMs: aggregated.p95_latency_ms,\r\n      p99LatencyMs: aggregated.p99_latency_ms,\r\n      errorRate: Number(aggregated.error_rate),\r\n      lastErrorType: aggregated.last_error_type,\r\n      status: aggregated.status,\r\n    };\r\n  }\r\n\r\n  // Default values if no data\r\n  return {\r\n    successRate: 1.0,\r\n    p50LatencyMs: null,\r\n    p95LatencyMs: null,\r\n    p99LatencyMs: null,\r\n    errorRate: 0.0,\r\n    lastErrorType: null,\r\n    status: 'healthy',\r\n  };\r\n}\r\n\r\n/**\r\n * Periodic job to update health snapshots\r\n * Should be called every 5-15 minutes\r\n */\r\nexport async function updateHealthSnapshots(windowMinutes: number = 15): Promise<void> {\r\n  logger.info({ windowMinutes }, 'Starting health snapshot update');\r\n\r\n  // Get all unique facilitator/network/token combinations from recent routes\r\n  // For now, we'll focus on CDP/Base/USDC - can be expanded later\r\n  const combinations = [\r\n    { facilitatorId: 'cdp', network: 'base', token: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' },\r\n  ];\r\n\r\n  const windowEnd = new Date();\r\n  const windowStart = new Date(windowEnd.getTime() - windowMinutes * 60 * 1000);\r\n\r\n  await Promise.all(\r\n    combinations.map(async (combo) => {\r\n      try {\r\n        await aggregateHealthMetrics(combo.facilitatorId, combo.network, combo.token, windowStart, windowEnd);\r\n      } catch (error) {\r\n        logger.error({ error, ...combo }, 'Failed to update health snapshot');\r\n      }\r\n    })\r\n  );\r\n\r\n  logger.info('Health snapshot update complete');\r\n}\r\n\r\n","// =============================================================================\r\n// FACILITATOR SCORE TYPES\r\n// =============================================================================\r\n// TypeScript interfaces for facilitator score persistence, history, and experiments\r\n// Maps to migration 034_facilitator_scores.ts\r\n\r\n// =============================================================================\r\n// FACILITATOR SCORES\r\n// =============================================================================\r\n\r\n/**\r\n * Persistent facilitator score with time-based decay\r\n * One row per facilitator/chain combination\r\n */\r\nexport interface FacilitatorScore {\r\n  id: string;\r\n  facilitator_id: string;\r\n  chain_id: string;        // e.g., \"eip155:8453\" (Base)\r\n  score: number;           // 0-100 composite score\r\n  confidence: number;      // 0-1 confidence level\r\n  decay_factor: number;    // Legacy; kept for schema compat\r\n  sample_size: number;\r\n  last_updated_at: Date;\r\n  created_at: Date;\r\n}\r\n\r\n/**\r\n * Input for upserting a facilitator score\r\n */\r\nexport interface UpsertFacilitatorScoreInput {\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  score: number;           // 0-100 new observation\r\n  confidence: number;      // 0-1\r\n  sample_size: number;\r\n  now?: Date;\r\n}\r\n\r\n// =============================================================================\r\n// SCORE HISTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Historical score snapshot for trend analysis\r\n */\r\nexport interface FacilitatorScoreHistory {\r\n  id: string;\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  score: number;\r\n  confidence: number;\r\n  sample_size: number;\r\n  snapshot_at: Date;\r\n}\r\n\r\n// =============================================================================\r\n// ROUTING EXPERIMENTS\r\n// =============================================================================\r\n\r\n/**\r\n * Experiment status enum\r\n */\r\nexport type ExperimentStatus = 'draft' | 'running' | 'paused' | 'completed';\r\n\r\n/**\r\n * Routing experiment for A/B testing and canary deployments\r\n */\r\nexport interface RoutingExperiment {\r\n  id: string;\r\n  name: string;\r\n  variant: string;\r\n  facilitator_id: string | null;  // nullable - can apply to all facilitators\r\n  chain_id: string | null;        // nullable - can apply to all chains\r\n  traffic_share: number;          // 0-1 (e.g., 0.1 = 10% of traffic)\r\n  status: ExperimentStatus;\r\n  metrics_tracked: Record<string, unknown>;  // e.g., { success_rate: 0.95 }\r\n  started_at: Date | null;\r\n  ended_at: Date | null;\r\n  completed_at: Date | null;\r\n  created_at: Date;\r\n}\r\n\r\n/**\r\n * Input for creating a routing experiment\r\n */\r\nexport interface CreateRoutingExperimentInput {\r\n  name: string;\r\n  variant: string;\r\n  facilitator_id?: string;\r\n  chain_id?: string;\r\n  traffic_share: number;\r\n}\r\n\r\n/**\r\n * Input for updating experiment metrics\r\n */\r\nexport interface UpdateExperimentMetricsInput {\r\n  experiment_id: string;\r\n  metrics: Record<string, unknown>;\r\n}\r\n\r\n// =============================================================================\r\n// PAYMENT EXPERIMENT ASSIGNMENTS\r\n// =============================================================================\r\n\r\n/**\r\n * Outcome of a payment routed through an experiment\r\n */\r\nexport type PaymentOutcome = 'success' | 'failed' | 'timeout';\r\n\r\n/**\r\n * Payment experiment assignment\r\n * Tracks which payments were routed via which experiments\r\n */\r\nexport interface PaymentExperimentAssignment {\r\n  id: string;\r\n  payment_id: string;\r\n  experiment_id: string;\r\n  assigned_at: Date;\r\n  outcome: PaymentOutcome | null;\r\n  latency_ms: number | null;\r\n  created_at: Date;\r\n}\r\n\r\n/**\r\n * Input for recording a payment experiment assignment\r\n */\r\nexport interface RecordPaymentAssignmentInput {\r\n  payment_id: string;\r\n  experiment_id: string;\r\n  outcome?: PaymentOutcome;\r\n  latency_ms?: number;\r\n}\r\n\r\n// =============================================================================\r\n// ROUTING OUTCOME\r\n// =============================================================================\r\n\r\n/**\r\n * Input for recording a routing outcome\r\n */\r\nexport interface RoutingOutcomeInput {\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  payment_id: string;\r\n  success: boolean;\r\n  latency_ms: number;\r\n  http_status?: number;\r\n  amount_wei?: bigint;\r\n}\r\n\r\n/**\r\n * Effective score returned for routing decisions\r\n */\r\nexport interface EffectiveScore {\r\n  score: number;\r\n  confidence: number;\r\n}\r\n\r\n// =============================================================================\r\n// TIME DECAY CONFIGURATION\r\n// =============================================================================\r\n\r\n/**\r\n * Configuration for time-based score decay\r\n */\r\nexport interface DecayConfig {\r\n  /** Half-life in milliseconds (default: 1 hour = 3600000) */\r\n  halfLifeMs: number;\r\n}\r\n\r\n/**\r\n * Default decay configuration\r\n * After 1 hour, old score is weighted 50%\r\n */\r\nexport const DEFAULT_DECAY_CONFIG: DecayConfig = {\r\n  halfLifeMs: 3600000, // 1 hour\r\n};\r\n\r\n// =============================================================================\r\n// SCORE DELTA CALCULATION\r\n// =============================================================================\r\n\r\n/**\r\n * Configuration for converting outcomes to score deltas\r\n */\r\nexport interface ScoreDeltaConfig {\r\n  /** Base score for successful outcomes */\r\n  successBase: number;\r\n  /** Base score for failed outcomes */\r\n  failureBase: number;\r\n  /** Bonus for low latency (< 500ms) */\r\n  lowLatencyBonus: number;\r\n  /** Bonus for medium latency (< 1000ms) */\r\n  mediumLatencyBonus: number;\r\n  /** Penalty for high latency failures (> 2000ms) */\r\n  highLatencyPenalty: number;\r\n  /** Penalty for 5xx HTTP errors */\r\n  serverErrorPenalty: number;\r\n}\r\n\r\n/**\r\n * Default score delta configuration\r\n */\r\nexport const DEFAULT_SCORE_DELTA_CONFIG: ScoreDeltaConfig = {\r\n  successBase: 75,\r\n  failureBase: 25,\r\n  lowLatencyBonus: 15,      // < 500ms\r\n  mediumLatencyBonus: 5,    // < 1000ms\r\n  highLatencyPenalty: 10,   // > 2000ms\r\n  serverErrorPenalty: 15,   // HTTP 5xx\r\n};\r\n\r\n","// =============================================================================\r\n// FACILITATOR SCORES DATABASE OPERATIONS\r\n// =============================================================================\r\n// Query helpers for facilitator score persistence, history, and experiments\r\n// Supports both PostgreSQL and SQLite adapters\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  FacilitatorScore,\r\n  FacilitatorScoreHistory,\r\n  RoutingExperiment,\r\n  PaymentExperimentAssignment,\r\n  UpsertFacilitatorScoreInput,\r\n  RecordPaymentAssignmentInput,\r\n  CreateRoutingExperimentInput,\r\n  ExperimentStatus,\r\n  PaymentOutcome,\r\n  DecayConfig,\r\n} from '@/types/facilitator-scores';\r\nimport { DEFAULT_DECAY_CONFIG } from '@/types/facilitator-scores';\r\n\r\nconst logger = createLogger({ component: 'FacilitatorScoresDB' });\r\n\r\n// =============================================================================\r\n// HELPER FUNCTIONS\r\n// =============================================================================\r\n\r\nfunction isPostgres(db: any): boolean {\r\n  return 'pool' in db || typeof db?.pool?.query === 'function';\r\n}\r\n\r\n/**\r\n * Compute time-based exponential decay factor\r\n * After halfLifeMs milliseconds, old score is weighted 50%\r\n * \r\n * Formula: 2^(-elapsed / halfLife)\r\n */\r\nexport function computeTimeDecay(\r\n  lastUpdatedAt: Date,\r\n  now: Date,\r\n  halfLifeMs: number = DEFAULT_DECAY_CONFIG.halfLifeMs\r\n): number {\r\n  const elapsedMs = now.getTime() - lastUpdatedAt.getTime();\r\n  if (elapsedMs <= 0) return 1; // No decay for same or past time\r\n  return Math.pow(2, -elapsedMs / halfLifeMs);\r\n}\r\n\r\n/**\r\n * Convert database row to FacilitatorScore\r\n */\r\nfunction rowToFacilitatorScore(row: any): FacilitatorScore {\r\n  return {\r\n    id: row.id,\r\n    facilitator_id: row.facilitator_id,\r\n    chain_id: row.chain_id,\r\n    score: Number(row.score),\r\n    confidence: Number(row.confidence),\r\n    decay_factor: Number(row.decay_factor),\r\n    sample_size: Number(row.sample_size),\r\n    last_updated_at: new Date(row.last_updated_at),\r\n    created_at: new Date(row.created_at),\r\n  };\r\n}\r\n\r\n/**\r\n * Convert database row to FacilitatorScoreHistory\r\n */\r\nfunction rowToScoreHistory(row: any): FacilitatorScoreHistory {\r\n  return {\r\n    id: row.id,\r\n    facilitator_id: row.facilitator_id,\r\n    chain_id: row.chain_id,\r\n    score: Number(row.score),\r\n    confidence: Number(row.confidence),\r\n    sample_size: Number(row.sample_size),\r\n    snapshot_at: new Date(row.snapshot_at),\r\n  };\r\n}\r\n\r\n/**\r\n * Convert database row to RoutingExperiment\r\n */\r\nfunction rowToRoutingExperiment(row: any): RoutingExperiment {\r\n  return {\r\n    id: row.id,\r\n    name: row.name,\r\n    variant: row.variant,\r\n    facilitator_id: row.facilitator_id,\r\n    chain_id: row.chain_id,\r\n    traffic_share: Number(row.traffic_share),\r\n    status: row.status as ExperimentStatus,\r\n    metrics_tracked: typeof row.metrics_tracked === 'string'\r\n      ? JSON.parse(row.metrics_tracked)\r\n      : row.metrics_tracked || {},\r\n    started_at: row.started_at ? new Date(row.started_at) : null,\r\n    ended_at: row.ended_at ? new Date(row.ended_at) : null,\r\n    completed_at: row.completed_at ? new Date(row.completed_at) : null,\r\n    created_at: new Date(row.created_at),\r\n  };\r\n}\r\n\r\n/**\r\n * Convert database row to PaymentExperimentAssignment\r\n */\r\nfunction rowToPaymentAssignment(row: any): PaymentExperimentAssignment {\r\n  return {\r\n    id: row.id,\r\n    payment_id: row.payment_id,\r\n    experiment_id: row.experiment_id,\r\n    assigned_at: new Date(row.assigned_at),\r\n    outcome: row.outcome as PaymentOutcome | null,\r\n    latency_ms: row.latency_ms ? Number(row.latency_ms) : null,\r\n    created_at: new Date(row.created_at),\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// FACILITATOR SCORES\r\n// =============================================================================\r\n\r\n/**\r\n * Upsert a facilitator score with time-based decay\r\n * If row exists: blends old score with new observation using exponential decay\r\n * If row doesn't exist: inserts new score\r\n */\r\nexport async function upsertFacilitatorScore(\r\n  input: UpsertFacilitatorScoreInput,\r\n  decayConfig: DecayConfig = DEFAULT_DECAY_CONFIG\r\n): Promise<FacilitatorScore> {\r\n  const db = getDb();\r\n  const now = input.now || new Date();\r\n  const nowStr = now.toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    // Check for existing score\r\n    const existing = await (db as any).pool.query(\r\n      `SELECT id, score, confidence, sample_size, last_updated_at \r\n       FROM facilitator_scores \r\n       WHERE facilitator_id = $1 AND chain_id = $2`,\r\n      [input.facilitator_id, input.chain_id]\r\n    );\r\n\r\n    if (existing.rows.length === 0) {\r\n      // Insert new score\r\n      const id = crypto.randomUUID();\r\n      const result = await (db as any).pool.query(\r\n        `INSERT INTO facilitator_scores \r\n         (id, facilitator_id, chain_id, score, confidence, decay_factor, \r\n          sample_size, last_updated_at, created_at)\r\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\r\n         RETURNING *`,\r\n        [\r\n          id,\r\n          input.facilitator_id,\r\n          input.chain_id,\r\n          input.score,\r\n          input.confidence,\r\n          0.9, // Legacy decay_factor\r\n          input.sample_size,\r\n          nowStr,\r\n          nowStr,\r\n        ]\r\n      );\r\n      logger.debug({\r\n        facilitator_id: input.facilitator_id,\r\n        chain_id: input.chain_id,\r\n        score: input.score,\r\n        action: 'insert',\r\n      }, 'Facilitator score inserted');\r\n      return rowToFacilitatorScore(result.rows[0]);\r\n    } else {\r\n      // Apply time-based decay and blend with new observation\r\n      const oldRow = existing.rows[0];\r\n      const lastUpdated = new Date(oldRow.last_updated_at);\r\n      const decayFactor = computeTimeDecay(lastUpdated, now, decayConfig.halfLifeMs);\r\n      \r\n      // Blend: old_score * decay + new_score * (1 - decay)\r\n      const decayedOldScore = Number(oldRow.score) * decayFactor;\r\n      const blendedScore = decayedOldScore + input.score * (1 - decayFactor);\r\n      \r\n      // Confidence: weighted average\r\n      const blendedConfidence = Number(oldRow.confidence) * decayFactor + input.confidence * (1 - decayFactor);\r\n      \r\n      // Sample size: cumulative\r\n      const newSampleSize = Number(oldRow.sample_size) + input.sample_size;\r\n\r\n      const result = await (db as any).pool.query(\r\n        `UPDATE facilitator_scores \r\n         SET score = $1, confidence = $2, sample_size = $3, last_updated_at = $4\r\n         WHERE id = $5\r\n         RETURNING *`,\r\n        [blendedScore, blendedConfidence, newSampleSize, nowStr, oldRow.id]\r\n      );\r\n\r\n      logger.debug({\r\n        facilitator_id: input.facilitator_id,\r\n        chain_id: input.chain_id,\r\n        old_score: Number(oldRow.score),\r\n        new_observation: input.score,\r\n        decay_factor: decayFactor,\r\n        blended_score: blendedScore,\r\n        action: 'update',\r\n      }, 'Facilitator score updated with decay');\r\n\r\n      return rowToFacilitatorScore(result.rows[0]);\r\n    }\r\n  } else {\r\n    // SQLite path\r\n    const existing = (db as any).prepare(\r\n      `SELECT id, score, confidence, sample_size, last_updated_at \r\n       FROM facilitator_scores \r\n       WHERE facilitator_id = ? AND chain_id = ?`\r\n    ).get(input.facilitator_id, input.chain_id);\r\n\r\n    if (!existing) {\r\n      const id = crypto.randomUUID();\r\n      (db as any).prepare(\r\n        `INSERT INTO facilitator_scores \r\n         (id, facilitator_id, chain_id, score, confidence, decay_factor, \r\n          sample_size, last_updated_at, created_at)\r\n         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`\r\n      ).run(\r\n        id,\r\n        input.facilitator_id,\r\n        input.chain_id,\r\n        input.score,\r\n        input.confidence,\r\n        0.9,\r\n        input.sample_size,\r\n        nowStr,\r\n        nowStr\r\n      );\r\n      const row = (db as any).prepare('SELECT * FROM facilitator_scores WHERE id = ?').get(id);\r\n      return rowToFacilitatorScore(row);\r\n    } else {\r\n      const lastUpdated = new Date(existing.last_updated_at);\r\n      const decayFactor = computeTimeDecay(lastUpdated, now, decayConfig.halfLifeMs);\r\n      const decayedOldScore = existing.score * decayFactor;\r\n      const blendedScore = decayedOldScore + input.score * (1 - decayFactor);\r\n      const blendedConfidence = existing.confidence * decayFactor + input.confidence * (1 - decayFactor);\r\n      const newSampleSize = existing.sample_size + input.sample_size;\r\n\r\n      (db as any).prepare(\r\n        `UPDATE facilitator_scores \r\n         SET score = ?, confidence = ?, sample_size = ?, last_updated_at = ?\r\n         WHERE id = ?`\r\n      ).run(blendedScore, blendedConfidence, newSampleSize, nowStr, existing.id);\r\n\r\n      const row = (db as any).prepare('SELECT * FROM facilitator_scores WHERE id = ?').get(existing.id);\r\n      return rowToFacilitatorScore(row);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get facilitator score for a specific facilitator/chain combination\r\n */\r\nexport async function getFacilitatorScore(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<FacilitatorScore | null> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_scores \r\n       WHERE facilitator_id = $1 AND chain_id = $2`,\r\n      [facilitator_id, chain_id]\r\n    );\r\n    return result.rows[0] ? rowToFacilitatorScore(result.rows[0]) : null;\r\n  } else {\r\n    const row = (db as any).prepare(\r\n      `SELECT * FROM facilitator_scores \r\n       WHERE facilitator_id = ? AND chain_id = ?`\r\n    ).get(facilitator_id, chain_id);\r\n    return row ? rowToFacilitatorScore(row) : null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all facilitator scores for a chain\r\n */\r\nexport async function getFacilitatorScoresByChain(\r\n  chain_id: string\r\n): Promise<FacilitatorScore[]> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_scores WHERE chain_id = $1 ORDER BY score DESC`,\r\n      [chain_id]\r\n    );\r\n    return result.rows.map(rowToFacilitatorScore);\r\n  } else {\r\n    const rows = (db as any).prepare(\r\n      `SELECT * FROM facilitator_scores WHERE chain_id = ? ORDER BY score DESC`\r\n    ).all(chain_id);\r\n    return rows.map(rowToFacilitatorScore);\r\n  }\r\n}\r\n\r\n/**\r\n * Get all scores for a facilitator across all chains\r\n */\r\nexport async function getFacilitatorScoresByFacilitator(\r\n  facilitator_id: string\r\n): Promise<FacilitatorScore[]> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_scores WHERE facilitator_id = $1 ORDER BY chain_id`,\r\n      [facilitator_id]\r\n    );\r\n    return result.rows.map(rowToFacilitatorScore);\r\n  } else {\r\n    const rows = (db as any).prepare(\r\n      `SELECT * FROM facilitator_scores WHERE facilitator_id = ? ORDER BY chain_id`\r\n    ).all(facilitator_id);\r\n    return rows.map(rowToFacilitatorScore);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// SCORE HISTORY / SNAPSHOTS\r\n// =============================================================================\r\n\r\n/**\r\n * Snapshot all current facilitator scores to history\r\n * Returns count of rows inserted\r\n */\r\nexport async function snapshotFacilitatorScores(now?: Date): Promise<number> {\r\n  const db = getDb();\r\n  const snapshotTime = (now || new Date()).toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO facilitator_score_history \r\n       (id, facilitator_id, chain_id, score, confidence, sample_size, snapshot_at)\r\n       SELECT \r\n         gen_random_uuid(),\r\n         facilitator_id,\r\n         chain_id,\r\n         score,\r\n         confidence,\r\n         sample_size,\r\n         $1\r\n       FROM facilitator_scores`,\r\n      [snapshotTime]\r\n    );\r\n    logger.info({ count: result.rowCount, snapshot_at: snapshotTime }, 'Facilitator scores snapshotted');\r\n    return result.rowCount || 0;\r\n  } else {\r\n    // SQLite: need to iterate and insert\r\n    const scores = (db as any).prepare('SELECT * FROM facilitator_scores').all();\r\n    let count = 0;\r\n    for (const score of scores) {\r\n      (db as any).prepare(\r\n        `INSERT INTO facilitator_score_history \r\n         (id, facilitator_id, chain_id, score, confidence, sample_size, snapshot_at)\r\n         VALUES (?, ?, ?, ?, ?, ?, ?)`\r\n      ).run(\r\n        crypto.randomUUID(),\r\n        score.facilitator_id,\r\n        score.chain_id,\r\n        score.score,\r\n        score.confidence,\r\n        score.sample_size,\r\n        snapshotTime\r\n      );\r\n      count++;\r\n    }\r\n    logger.info({ count, snapshot_at: snapshotTime }, 'Facilitator scores snapshotted');\r\n    return count;\r\n  }\r\n}\r\n\r\n/**\r\n * Get score history for a facilitator/chain\r\n */\r\nexport async function getScoreHistory(\r\n  facilitator_id: string,\r\n  chain_id: string,\r\n  limit: number = 100\r\n): Promise<FacilitatorScoreHistory[]> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_score_history \r\n       WHERE facilitator_id = $1 AND chain_id = $2 \r\n       ORDER BY snapshot_at DESC \r\n       LIMIT $3`,\r\n      [facilitator_id, chain_id, limit]\r\n    );\r\n    return result.rows.map(rowToScoreHistory);\r\n  } else {\r\n    const rows = (db as any).prepare(\r\n      `SELECT * FROM facilitator_score_history \r\n       WHERE facilitator_id = ? AND chain_id = ? \r\n       ORDER BY snapshot_at DESC \r\n       LIMIT ?`\r\n    ).all(facilitator_id, chain_id, limit);\r\n    return rows.map(rowToScoreHistory);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// ROUTING EXPERIMENTS\r\n// =============================================================================\r\n\r\n/**\r\n * Create a new routing experiment\r\n */\r\nexport async function createRoutingExperiment(\r\n  input: CreateRoutingExperimentInput\r\n): Promise<RoutingExperiment> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO routing_experiments \r\n       (id, name, variant, facilitator_id, chain_id, traffic_share, status, created_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, 'draft', $7)\r\n       RETURNING *`,\r\n      [\r\n        id,\r\n        input.name,\r\n        input.variant,\r\n        input.facilitator_id || null,\r\n        input.chain_id || null,\r\n        input.traffic_share,\r\n        now,\r\n      ]\r\n    );\r\n    return rowToRoutingExperiment(result.rows[0]);\r\n  } else {\r\n    (db as any).prepare(\r\n      `INSERT INTO routing_experiments \r\n       (id, name, variant, facilitator_id, chain_id, traffic_share, status, created_at)\r\n       VALUES (?, ?, ?, ?, ?, ?, 'draft', ?)`\r\n    ).run(\r\n      id,\r\n      input.name,\r\n      input.variant,\r\n      input.facilitator_id || null,\r\n      input.chain_id || null,\r\n      input.traffic_share,\r\n      now\r\n    );\r\n    const row = (db as any).prepare('SELECT * FROM routing_experiments WHERE id = ?').get(id);\r\n    return rowToRoutingExperiment(row);\r\n  }\r\n}\r\n\r\n/**\r\n * Get a running experiment for a facilitator/chain\r\n */\r\nexport async function getRunningExperiment(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<RoutingExperiment | null> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    // Check for specific facilitator/chain experiment first\r\n    let result = await (db as any).pool.query(\r\n      `SELECT * FROM routing_experiments \r\n       WHERE facilitator_id = $1 AND chain_id = $2 AND status = 'running'\r\n       LIMIT 1`,\r\n      [facilitator_id, chain_id]\r\n    );\r\n\r\n    if (result.rows.length > 0) {\r\n      return rowToRoutingExperiment(result.rows[0]);\r\n    }\r\n\r\n    // Check for facilitator-wide experiment (any chain)\r\n    result = await (db as any).pool.query(\r\n      `SELECT * FROM routing_experiments \r\n       WHERE facilitator_id = $1 AND chain_id IS NULL AND status = 'running'\r\n       LIMIT 1`,\r\n      [facilitator_id]\r\n    );\r\n\r\n    if (result.rows.length > 0) {\r\n      return rowToRoutingExperiment(result.rows[0]);\r\n    }\r\n\r\n    // Check for chain-wide experiment (any facilitator)\r\n    result = await (db as any).pool.query(\r\n      `SELECT * FROM routing_experiments \r\n       WHERE facilitator_id IS NULL AND chain_id = $1 AND status = 'running'\r\n       LIMIT 1`,\r\n      [chain_id]\r\n    );\r\n\r\n    return result.rows.length > 0 ? rowToRoutingExperiment(result.rows[0]) : null;\r\n  } else {\r\n    // SQLite path\r\n    let row = (db as any).prepare(\r\n      `SELECT * FROM routing_experiments \r\n       WHERE facilitator_id = ? AND chain_id = ? AND status = 'running'\r\n       LIMIT 1`\r\n    ).get(facilitator_id, chain_id);\r\n\r\n    if (row) return rowToRoutingExperiment(row);\r\n\r\n    row = (db as any).prepare(\r\n      `SELECT * FROM routing_experiments \r\n       WHERE facilitator_id = ? AND chain_id IS NULL AND status = 'running'\r\n       LIMIT 1`\r\n    ).get(facilitator_id);\r\n\r\n    if (row) return rowToRoutingExperiment(row);\r\n\r\n    row = (db as any).prepare(\r\n      `SELECT * FROM routing_experiments \r\n       WHERE facilitator_id IS NULL AND chain_id = ? AND status = 'running'\r\n       LIMIT 1`\r\n    ).get(chain_id);\r\n\r\n    return row ? rowToRoutingExperiment(row) : null;\r\n  }\r\n}\r\n\r\n/**\r\n * Update experiment status\r\n */\r\nexport async function updateExperimentStatus(\r\n  experiment_id: string,\r\n  status: ExperimentStatus\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    let updateFields = 'status = $2';\r\n    const params: any[] = [experiment_id, status];\r\n\r\n    if (status === 'running') {\r\n      updateFields += ', started_at = COALESCE(started_at, $3)';\r\n      params.push(now);\r\n    } else if (status === 'paused' || status === 'completed') {\r\n      updateFields += ', ended_at = $3';\r\n      params.push(now);\r\n      if (status === 'completed') {\r\n        updateFields += ', completed_at = $' + (params.length + 1);\r\n        params.push(now);\r\n      }\r\n    }\r\n\r\n    await (db as any).pool.query(\r\n      `UPDATE routing_experiments SET ${updateFields} WHERE id = $1`,\r\n      params\r\n    );\r\n  } else {\r\n    if (status === 'running') {\r\n      (db as any).prepare(\r\n        `UPDATE routing_experiments \r\n         SET status = ?, started_at = COALESCE(started_at, ?)\r\n         WHERE id = ?`\r\n      ).run(status, now, experiment_id);\r\n    } else if (status === 'completed') {\r\n      (db as any).prepare(\r\n        `UPDATE routing_experiments \r\n         SET status = ?, ended_at = ?, completed_at = ?\r\n         WHERE id = ?`\r\n      ).run(status, now, now, experiment_id);\r\n    } else {\r\n      (db as any).prepare(\r\n        `UPDATE routing_experiments SET status = ?, ended_at = ? WHERE id = ?`\r\n      ).run(status, now, experiment_id);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get experiment by ID\r\n */\r\nexport async function getRoutingExperiment(\r\n  experiment_id: string\r\n): Promise<RoutingExperiment | null> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM routing_experiments WHERE id = $1`,\r\n      [experiment_id]\r\n    );\r\n    return result.rows[0] ? rowToRoutingExperiment(result.rows[0]) : null;\r\n  } else {\r\n    const row = (db as any).prepare(\r\n      `SELECT * FROM routing_experiments WHERE id = ?`\r\n    ).get(experiment_id);\r\n    return row ? rowToRoutingExperiment(row) : null;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// PAYMENT EXPERIMENT ASSIGNMENTS\r\n// =============================================================================\r\n\r\n/**\r\n * Record a payment's experiment assignment and outcome\r\n */\r\nexport async function recordPaymentExperimentAssignment(\r\n  input: RecordPaymentAssignmentInput\r\n): Promise<PaymentExperimentAssignment> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO payment_experiment_assignments \r\n       (id, payment_id, experiment_id, assigned_at, outcome, latency_ms, created_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, $7)\r\n       ON CONFLICT (payment_id) DO UPDATE SET\r\n         outcome = COALESCE(EXCLUDED.outcome, payment_experiment_assignments.outcome),\r\n         latency_ms = COALESCE(EXCLUDED.latency_ms, payment_experiment_assignments.latency_ms)\r\n       RETURNING *`,\r\n      [\r\n        id,\r\n        input.payment_id,\r\n        input.experiment_id,\r\n        now,\r\n        input.outcome || null,\r\n        input.latency_ms || null,\r\n        now,\r\n      ]\r\n    );\r\n    return rowToPaymentAssignment(result.rows[0]);\r\n  } else {\r\n    // SQLite: try insert, update if exists\r\n    const existing = (db as any).prepare(\r\n      `SELECT id FROM payment_experiment_assignments WHERE payment_id = ?`\r\n    ).get(input.payment_id);\r\n\r\n    if (existing) {\r\n      (db as any).prepare(\r\n        `UPDATE payment_experiment_assignments \r\n         SET outcome = COALESCE(?, outcome), latency_ms = COALESCE(?, latency_ms)\r\n         WHERE payment_id = ?`\r\n      ).run(input.outcome || null, input.latency_ms || null, input.payment_id);\r\n      const row = (db as any).prepare(\r\n        `SELECT * FROM payment_experiment_assignments WHERE payment_id = ?`\r\n      ).get(input.payment_id);\r\n      return rowToPaymentAssignment(row);\r\n    } else {\r\n      (db as any).prepare(\r\n        `INSERT INTO payment_experiment_assignments \r\n         (id, payment_id, experiment_id, assigned_at, outcome, latency_ms, created_at)\r\n         VALUES (?, ?, ?, ?, ?, ?, ?)`\r\n      ).run(\r\n        id,\r\n        input.payment_id,\r\n        input.experiment_id,\r\n        now,\r\n        input.outcome || null,\r\n        input.latency_ms || null,\r\n        now\r\n      );\r\n      const row = (db as any).prepare(\r\n        `SELECT * FROM payment_experiment_assignments WHERE id = ?`\r\n      ).get(id);\r\n      return rowToPaymentAssignment(row);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get experiment outcomes summary\r\n */\r\nexport async function getExperimentOutcomes(\r\n  experiment_id: string\r\n): Promise<{\r\n  total: number;\r\n  success: number;\r\n  failed: number;\r\n  timeout: number;\r\n  avg_latency_ms: number | null;\r\n}> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT \r\n         COUNT(*) as total,\r\n         COUNT(*) FILTER (WHERE outcome = 'success') as success,\r\n         COUNT(*) FILTER (WHERE outcome = 'failed') as failed,\r\n         COUNT(*) FILTER (WHERE outcome = 'timeout') as timeout,\r\n         AVG(latency_ms) as avg_latency_ms\r\n       FROM payment_experiment_assignments \r\n       WHERE experiment_id = $1`,\r\n      [experiment_id]\r\n    );\r\n    const row = result.rows[0];\r\n    return {\r\n      total: Number(row.total),\r\n      success: Number(row.success),\r\n      failed: Number(row.failed),\r\n      timeout: Number(row.timeout),\r\n      avg_latency_ms: row.avg_latency_ms ? Number(row.avg_latency_ms) : null,\r\n    };\r\n  } else {\r\n    const rows = (db as any).prepare(\r\n      `SELECT * FROM payment_experiment_assignments WHERE experiment_id = ?`\r\n    ).all(experiment_id);\r\n\r\n    const total = rows.length;\r\n    const success = rows.filter((r: any) => r.outcome === 'success').length;\r\n    const failed = rows.filter((r: any) => r.outcome === 'failed').length;\r\n    const timeout = rows.filter((r: any) => r.outcome === 'timeout').length;\r\n    const latencies = rows.filter((r: any) => r.latency_ms).map((r: any) => r.latency_ms);\r\n    const avg_latency_ms = latencies.length > 0\r\n      ? latencies.reduce((a: number, b: number) => a + b, 0) / latencies.length\r\n      : null;\r\n\r\n    return { total, success, failed, timeout, avg_latency_ms };\r\n  }\r\n}\r\n\r\n","// =============================================================================\r\n// SMF SCORING SERVICE\r\n// =============================================================================\r\n// Converts routing outcomes into score deltas and manages persistent scores\r\n// Integrates with time-based decay and experiment tracking\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport {\r\n  upsertFacilitatorScore,\r\n  getFacilitatorScore as getPersistedScore,\r\n  getRunningExperiment,\r\n  recordPaymentExperimentAssignment,\r\n} from '@/db/facilitator-scores';\r\nimport type {\r\n  FacilitatorScore,\r\n  RoutingOutcomeInput,\r\n  EffectiveScore,\r\n  ScoreDeltaConfig,\r\n} from '@/types/facilitator-scores';\r\nimport { DEFAULT_SCORE_DELTA_CONFIG } from '@/types/facilitator-scores';\r\n\r\nconst logger = createLogger({ component: 'SMFScoring' });\r\n\r\n// =============================================================================\r\n// SCORE DELTA CALCULATION\r\n// =============================================================================\r\n\r\n/**\r\n * Convert a routing outcome to a score (0-100)\r\n * Higher scores indicate better performance\r\n */\r\nexport function computeScoreDelta(\r\n  params: {\r\n    success: boolean;\r\n    latency_ms: number;\r\n    http_status?: number;\r\n  },\r\n  config: ScoreDeltaConfig = DEFAULT_SCORE_DELTA_CONFIG\r\n): number {\r\n  let score: number;\r\n\r\n  if (params.success) {\r\n    // Success: start at base success score\r\n    score = config.successBase;\r\n\r\n    // Bonus for low latency\r\n    if (params.latency_ms < 500) {\r\n      score += config.lowLatencyBonus;\r\n    } else if (params.latency_ms < 1000) {\r\n      score += config.mediumLatencyBonus;\r\n    }\r\n  } else {\r\n    // Failure: start at base failure score\r\n    score = config.failureBase;\r\n\r\n    // Extra penalty for high latency failures\r\n    if (params.latency_ms > 2000) {\r\n      score -= config.highLatencyPenalty;\r\n    }\r\n\r\n    // Penalty for server errors (5xx)\r\n    if (params.http_status && params.http_status >= 500) {\r\n      score -= config.serverErrorPenalty;\r\n    }\r\n  }\r\n\r\n  // Clamp to 0-100\r\n  return Math.max(0, Math.min(100, score));\r\n}\r\n\r\n// =============================================================================\r\n// ROUTING OUTCOME RECORDING\r\n// =============================================================================\r\n\r\n/**\r\n * Record a routing outcome and update persistent scores\r\n * \r\n * This function:\r\n * 1. Converts the outcome to a score delta\r\n * 2. Updates the persistent score with time-based decay\r\n * 3. Records experiment assignment if applicable\r\n */\r\nexport async function recordRoutingOutcome(\r\n  params: RoutingOutcomeInput\r\n): Promise<void> {\r\n  const { facilitator_id, chain_id, payment_id, success, latency_ms, http_status } = params;\r\n\r\n  // 1. Compute score from outcome\r\n  const score = computeScoreDelta({ success, latency_ms, http_status });\r\n\r\n  logger.debug({\r\n    facilitator_id,\r\n    chain_id,\r\n    payment_id,\r\n    success,\r\n    latency_ms,\r\n    http_status,\r\n    computed_score: score,\r\n  }, 'Recording routing outcome');\r\n\r\n  // 2. Update persistent score with decay\r\n  await upsertFacilitatorScore({\r\n    facilitator_id,\r\n    chain_id,\r\n    score,\r\n    confidence: 0.9, // High confidence for actual routing outcomes\r\n    sample_size: 1,\r\n  });\r\n\r\n  // 3. Check if this payment was routed via an experiment\r\n  const experiment = await getRunningExperiment(facilitator_id, chain_id);\r\n\r\n  if (experiment) {\r\n    await recordPaymentExperimentAssignment({\r\n      payment_id,\r\n      experiment_id: experiment.id,\r\n      outcome: success ? 'success' : 'failed',\r\n      latency_ms,\r\n    });\r\n\r\n    logger.debug({\r\n      payment_id,\r\n      experiment_id: experiment.id,\r\n      experiment_name: experiment.name,\r\n      outcome: success ? 'success' : 'failed',\r\n    }, 'Recorded experiment assignment');\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// EFFECTIVE SCORE RETRIEVAL\r\n// =============================================================================\r\n\r\n/**\r\n * Get the effective score for a facilitator/chain combination\r\n * Returns persisted score + confidence for routing decisions\r\n */\r\nexport async function getEffectiveScore(\r\n  params: {\r\n    facilitator_id: string;\r\n    chain_id: string;\r\n  }\r\n): Promise<EffectiveScore | null> {\r\n  const { facilitator_id, chain_id } = params;\r\n\r\n  const score = await getPersistedScore(facilitator_id, chain_id);\r\n\r\n  if (!score) {\r\n    return null;\r\n  }\r\n\r\n  return {\r\n    score: score.score,\r\n    confidence: score.confidence,\r\n  };\r\n}\r\n\r\n/**\r\n * Get the full facilitator score record\r\n */\r\nexport async function getFacilitatorScoreRecord(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<FacilitatorScore | null> {\r\n  return getPersistedScore(facilitator_id, chain_id);\r\n}\r\n\r\n// =============================================================================\r\n// EXPERIMENT HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Check if there's an active experiment affecting routing for this facilitator/chain\r\n */\r\nexport async function hasActiveExperiment(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<boolean> {\r\n  const experiment = await getRunningExperiment(facilitator_id, chain_id);\r\n  return experiment !== null;\r\n}\r\n\r\n/**\r\n * Get experiment traffic adjustment for scoring\r\n * Returns a small bonus if experiment is running\r\n */\r\nexport async function getExperimentTrafficAdjustment(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<{ adjustment: number; experiment_name: string | null }> {\r\n  const experiment = await getRunningExperiment(facilitator_id, chain_id);\r\n\r\n  if (!experiment || experiment.status !== 'running') {\r\n    return { adjustment: 0, experiment_name: null };\r\n  }\r\n\r\n  // Small bonus based on traffic share (e.g., 10% traffic share = +1 score)\r\n  const adjustment = experiment.traffic_share * 10;\r\n\r\n  return {\r\n    adjustment,\r\n    experiment_name: experiment.name,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// BATCH OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Record multiple routing outcomes in batch\r\n * Useful for bulk processing\r\n */\r\nexport async function recordRoutingOutcomesBatch(\r\n  outcomes: RoutingOutcomeInput[]\r\n): Promise<void> {\r\n  for (const outcome of outcomes) {\r\n    await recordRoutingOutcome(outcome);\r\n  }\r\n}\r\n\r\n","// =============================================================================\n// FACILITATOR ROUTER\n// =============================================================================\n// Smart routing logic for selecting the best facilitator based on policy\n// Implements \"meta-facilitator\" pattern: SDK expresses preferences, SMF owns policy\n\nimport { IFacilitator, type PaymentRequirements, type VerificationResult, type FacilitatorConfig, type CAIPNetworkId, type CAIPAssetId, type SettlementMode } from './base-facilitator';\nimport { getCDPFacilitatorAdapter } from './cdp-facilitator-adapter';\nimport { getPayAIFacilitator } from './payai-facilitator';\nimport { getX402rsFacilitator } from './x402rs-facilitator';\nimport { getDexterFacilitator } from './dexter-facilitator';\nimport { getCronosFacilitator } from './cronos-facilitator';\nimport { createLogger } from '@/lib/logger';\nimport { getCurrentHealth } from './health-aggregator';\nimport { getFacilitatorCapabilities } from '@/db/smf';\nimport type { FacilitatorId } from './facilitator-registry';\nimport {\n  getFacilitatorScore,\n  getFacilitatorExplainer,\n  type FacilitatorScore,\n  type FacilitatorExplanation,\n} from '@/services/facilitator-metrics-reader';\nimport type { FacilitatorPathMetricsTimeframe } from '@/infra/x402scan/types';\nimport {\n  getScatteringMetricsForFacilitator,\n  computeActivityScore,\n} from '@/services/facilitator-volume-service';\nimport type { ScatteringFacilitatorMetrics } from '@/infra/scattering/types';\nimport {\n  getEffectiveScore as getPersistedScore,\n  getExperimentTrafficAdjustment,\n} from '@/services/smf/scoring';\n\nconst logger = createLogger({ component: 'FacilitatorRouter' });\n\n// =============================================================================\n// X402SCAN METRICS INTEGRATION CONFIG\n// =============================================================================\n\n/**\n * Configuration for trusting x402scan metrics in routing decisions\n * Metrics are only used if they meet these freshness/confidence thresholds\n */\nexport interface X402ScanMetricsTrustConfig {\n  /** Maximum age of data to trust (hours) */\n  maxDataAgeHours: number;\n  /** Minimum invocations required for high confidence */\n  minInvocationsHighConfidence: number;\n  /** Minimum invocations required for medium confidence */\n  minInvocationsMediumConfidence: number;\n  /** Weight applied to x402scan score in overall routing (0-1) */\n  x402scanScoreWeight: number;\n  /** Timeframe to use for metrics */\n  timeframe: FacilitatorPathMetricsTimeframe;\n  /** Whether to log detailed explanations */\n  logExplanations: boolean;\n}\n\n/**\n * Default x402scan metrics trust configuration\n * Can be overridden via environment variables\n */\nconst DEFAULT_X402SCAN_TRUST_CONFIG: X402ScanMetricsTrustConfig = {\n  maxDataAgeHours: parseFloat(process.env.X402SCAN_MAX_DATA_AGE_HOURS ?? '4'),\n  minInvocationsHighConfidence: parseInt(process.env.X402SCAN_MIN_INVOCATIONS_HIGH ?? '1000', 10),\n  minInvocationsMediumConfidence: parseInt(process.env.X402SCAN_MIN_INVOCATIONS_MEDIUM ?? '100', 10),\n  x402scanScoreWeight: parseFloat(process.env.X402SCAN_SCORE_WEIGHT ?? '0.3'), // 30% weight\n  timeframe: (process.env.X402SCAN_TIMEFRAME ?? '1d') as FacilitatorPathMetricsTimeframe,\n  logExplanations: process.env.X402SCAN_LOG_EXPLANATIONS !== 'false',\n};\n\n// =============================================================================\n// SCATTERING / DUNE METRICS INTEGRATION CONFIG\n// =============================================================================\n\n/**\n * Configuration for Scattering/Dune activity metrics in routing decisions\n */\nexport interface ScatteringMetricsTrustConfig {\n  /** Weight applied to Scattering score in overall routing (0-1) */\n  scatteringScoreWeight: number;\n  /** Minimum 3-day transaction count to trust metrics */\n  minTxCount3d: number;\n  /** Maximum age of data to trust (hours) */\n  maxDataAgeHours: number;\n  /** Whether to log Scattering metrics */\n  logScatteringMetrics: boolean;\n}\n\n/**\n * Default Scattering metrics configuration\n */\nconst DEFAULT_SCATTERING_CONFIG: ScatteringMetricsTrustConfig = {\n  scatteringScoreWeight: parseFloat(process.env.SCATTERING_SCORE_WEIGHT ?? '0.2'), // 20% weight\n  minTxCount3d: parseInt(process.env.SCATTERING_MIN_TX_3D ?? '100', 10),\n  maxDataAgeHours: parseFloat(process.env.SCATTERING_MAX_DATA_AGE_HOURS ?? '24'),\n  logScatteringMetrics: process.env.SCATTERING_LOG_METRICS !== 'false',\n};\n\n// =============================================================================\n// PERSISTED SCORE CONFIG (Stage 5: Score Persistence + Decay)\n// =============================================================================\n\n/**\n * Configuration for persisted score integration\n * Persisted scores blend with real-time metrics for routing decisions\n */\nexport interface PersistedScoreConfig {\n  /** Weight applied to persisted score (0-1), rest goes to real-time metrics */\n  persistedScoreWeight: number;\n  /** Minimum confidence required to use persisted score */\n  minConfidence: number;\n  /** Whether to apply experiment traffic adjustments */\n  enableExperimentAdjustments: boolean;\n  /** Log persisted score integration */\n  logPersistedScore: boolean;\n}\n\n/**\n * Default persisted score configuration\n */\nconst DEFAULT_PERSISTED_SCORE_CONFIG: PersistedScoreConfig = {\n  persistedScoreWeight: parseFloat(process.env.PERSISTED_SCORE_WEIGHT ?? '0.3'), // 30% weight\n  minConfidence: parseFloat(process.env.PERSISTED_SCORE_MIN_CONFIDENCE ?? '0.5'),\n  enableExperimentAdjustments: process.env.ENABLE_EXPERIMENT_ADJUSTMENTS !== 'false',\n  logPersistedScore: process.env.LOG_PERSISTED_SCORE !== 'false',\n};\n\n/**\n * Check if Scattering metrics should be trusted based on freshness and activity\n */\nfunction shouldTrustScatteringMetrics(\n  metrics: ScatteringFacilitatorMetrics | null,\n  config: ScatteringMetricsTrustConfig = DEFAULT_SCATTERING_CONFIG\n): { trust: boolean; reason: string } {\n  if (!metrics) {\n    return { trust: false, reason: 'no-scattering-data' };\n  }\n\n  // Check data freshness\n  const dataAgeHours = (Date.now() - new Date(metrics.fetchedAt).getTime()) / (1000 * 60 * 60);\n  if (dataAgeHours > config.maxDataAgeHours) {\n    return { trust: false, reason: `data-too-old:${dataAgeHours.toFixed(1)}h` };\n  }\n\n  // Check minimum activity\n  if (metrics.txCount3d < config.minTxCount3d) {\n    return { trust: false, reason: `low-activity:${metrics.txCount3d}-txns` };\n  }\n\n  return { trust: true, reason: 'active' };\n}\n\n/**\n * Check if x402scan metrics should be trusted based on freshness/confidence\n */\nfunction shouldTrustX402ScanMetrics(\n  score: FacilitatorScore | null,\n  config: X402ScanMetricsTrustConfig = DEFAULT_X402SCAN_TRUST_CONFIG\n): { trust: boolean; reason: string } {\n  if (!score) {\n    return { trust: false, reason: 'no-x402scan-data' };\n  }\n\n  // Check data freshness\n  if (score.dataFreshness > config.maxDataAgeHours) {\n    return { trust: false, reason: `data-too-old:${score.dataFreshness.toFixed(1)}h` };\n  }\n\n  // Check minimum invocations for medium confidence\n  if (score.totalInvocations < config.minInvocationsMediumConfidence) {\n    return { trust: false, reason: `insufficient-data:${score.totalInvocations}-invocations` };\n  }\n\n  // Trust with appropriate confidence level\n  if (score.totalInvocations >= config.minInvocationsHighConfidence) {\n    return { trust: true, reason: 'high-confidence' };\n  }\n\n  return { trust: true, reason: 'medium-confidence' };\n}\n\n/**\n * Facilitator strategy for routing decisions\n * \n * - \"auto\": SMF chooses optimal facilitator based on health, cost, and policy\n * - \"cdp\": Force routing through Coinbase Developer Platform\n * - \"payai\": Force routing through PayAI facilitator\n * - \"x402rs\": Force routing through X402rs (Rust community facilitator)\n * - \"dexter\": Force routing through Dexter (Solana-native facilitator)\n * - \"cronos\": Force routing through Cronos x402 Facilitator (https://facilitator.cronoslabs.org)\n */\nexport type FacilitatorStrategy = 'auto' | 'cdp' | 'payai' | 'x402rs' | 'dexter' | 'cronos';\n\n/**\n * Routing preferences (from SDK/agent)\n * SDK expresses preferences, SMF owns policy\n */\nexport interface RoutingPreferences {\n  preferredNetworks?: string[]; // Legacy: e.g., ['solana', 'base']\n  preferredNetworksCAIP?: CAIPNetworkId[]; // CAIP-2 network identifiers\n  preferredAssets?: string[]; // Legacy: e.g., ['USDC']\n  preferredAssetsCAIP?: CAIPAssetId[]; // CAIP-19 asset identifiers\n  avoidNetworks?: string[]; // Legacy: e.g., ['ethereum'] (mainnet too expensive)\n  avoidNetworksCAIP?: CAIPNetworkId[]; // CAIP-2 networks to avoid\n  maxCost?: number; // Maximum cost in USD\n  requireCompliance?: boolean; // Require KYT/OFAC\n  priority?: 'cost' | 'speed' | 'reliability' | 'compliance';\n  jurisdiction?: string; // ISO country code (e.g., 'US', 'GB')\n  settlementMode?: SettlementMode; // Preferred settlement mode\n  /** Facilitator strategy - explicit facilitator selection or auto */\n  facilitatorStrategy?: FacilitatorStrategy;\n}\n\n/**\n * Routing policy (SMF business logic)\n * SMF owns higher-level policy above raw settlement\n */\nexport interface RoutingPolicy {\n  // Risk rules\n  riskThreshold?: number; // Max risk score (0-100)\n  requireKYC?: boolean; // Require KYC for certain amounts\n  \n  // Cost optimization\n  preferCheapest?: boolean; // Prefer cheapest facilitator\n  maxCostMultiplier?: number; // Max cost vs cheapest (1.5 = 50% premium)\n  \n  // Compliance rules\n  jurisdictionRules?: JurisdictionRule[];\n  \n  // Reliability\n  requireHealthCheck?: boolean; // Only route to healthy facilitators\n  minUptime?: number; // Minimum uptime percentage (0-1)\n  \n  // Custom rules\n  customRules?: (facilitator: IFacilitator, requirements: PaymentRequirements) => boolean;\n}\n\n/**\n * Jurisdiction-based routing rules\n */\nexport interface JurisdictionRule {\n  country?: string; // ISO country code\n  region?: string; // Region name\n  allowedNetworks?: string[];\n  requiredKYC?: boolean;\n  maxAmount?: string; // Max amount in smallest units\n  blockedFacilitators?: string[]; // Facilitator IDs to avoid\n}\n\n/**\n * Facilitator router\n * Implements smart routing based on preferences and policy\n */\nexport class FacilitatorRouter {\n  private facilitators: Map<string, IFacilitator> = new Map();\n  private facilitatorHealth: Map<string, { healthy: boolean; lastChecked: number }> = new Map();\n  private healthCheckInterval: NodeJS.Timeout | null = null;\n\n  constructor() {\n    // Register default facilitators\n    this.registerFacilitator(getCDPFacilitatorAdapter());\n    \n    // Register PayAI facilitator (multi-chain support)\n    this.registerFacilitator(getPayAIFacilitator());\n    \n    // Register X402rs facilitator (Rust-based community facilitator)\n    // Supports: Base Sepolia, Base mainnet, XDC mainnet\n    if (process.env.X402RS_ENABLED !== 'false') {\n      this.registerFacilitator(getX402rsFacilitator());\n      logger.info({ facilitatorId: 'x402rs', url: 'https://facilitator.x402.rs' }, 'X402rs facilitator registered');\n    }\n    \n    // Register Dexter facilitator (Solana-native x402 facilitator)\n    // Supports: Solana mainnet, Solana devnet\n    if (process.env.DEXTER_ENABLED !== 'false') {\n      this.registerFacilitator(getDexterFacilitator());\n      logger.info({ facilitatorId: 'dexter', url: 'https://facilitator.dexter.cash' }, 'Dexter facilitator registered');\n    }\n    \n    // Register Cronos x402 Facilitator\n    // Cronos x402 facilitator (https://facilitator.cronoslabs.org)  see Cronos x402 Facilitator docs for details.\n    // Supports: Cronos mainnet (chain ID 25), Cronos testnet (chain ID 338)\n    // Documentation: https://docs.cronos.org/cronos-x402-facilitator\n    if (process.env.CRONOS_ENABLED !== 'false') {\n      this.registerFacilitator(getCronosFacilitator());\n      logger.info({ facilitatorId: 'cronos', url: 'https://facilitator.cronoslabs.org' }, 'Cronos x402 facilitator registered');\n    }\n    \n    // Register dummy facilitator for testing (wraps CDP, different priority)\n    // This allows testing routing logic, priority ties, failover, etc.\n    // SAFETY: Only enabled in non-production environments\n    if (process.env.ENABLE_DUMMY_FACILITATOR === 'true' && process.env.NODE_ENV !== 'production') {\n      const { createDummyFacilitator } = require('./dummy-facilitator');\n      const dummy = createDummyFacilitator('dummy', {\n        wrapCDP: true, // Wrap CDP for realistic testing\n        priority: 2, // Lower priority than CDP\n      });\n      this.registerFacilitator(dummy);\n      logger.warn('Dummy facilitator registered (development only)');\n    } else if (process.env.ENABLE_DUMMY_FACILITATOR === 'true' && process.env.NODE_ENV === 'production') {\n      logger.error('ENABLE_DUMMY_FACILITATOR is set but ignored in production environment');\n    }\n    \n    // Start health check interval (every 5 minutes)\n    this.startHealthChecks();\n  }\n\n  /**\n   * Register a facilitator\n   */\n  registerFacilitator(facilitator: IFacilitator): void {\n    this.facilitators.set(facilitator.id, facilitator);\n    logger.info({ facilitatorId: facilitator.id, name: facilitator.name }, 'Facilitator registered');\n  }\n\n  /**\n   * Unregister a facilitator\n   */\n  unregisterFacilitator(facilitatorId: string): void {\n    this.facilitators.delete(facilitatorId);\n    this.facilitatorHealth.delete(facilitatorId);\n    logger.info({ facilitatorId }, 'Facilitator unregistered');\n  }\n\n  /**\n   * Get all registered facilitators\n   */\n  getFacilitators(): IFacilitator[] {\n    return Array.from(this.facilitators.values());\n  }\n\n  /**\n   * Route payment to best facilitator\n   * \n   * @param requirements - Payment requirements\n   * @param preferences - SDK/agent preferences\n   * @param policy - SMF business logic policy\n   */\n  async routePayment(\n    requirements: PaymentRequirements,\n    preferences?: RoutingPreferences,\n    policy?: RoutingPolicy\n  ): Promise<IFacilitator> {\n    // ==========================================================================\n    // Handle explicit facilitator strategy (non-auto)\n    // ==========================================================================\n    if (preferences?.facilitatorStrategy && preferences.facilitatorStrategy !== 'auto') {\n      const explicitFacilitator = this.facilitators.get(preferences.facilitatorStrategy);\n      \n      if (explicitFacilitator && explicitFacilitator.config.enabled) {\n        // Check if explicit facilitator supports the requested network/asset\n        if (explicitFacilitator.supports(requirements.network, requirements.asset, requirements.scheme, requirements.settlementMode)) {\n          logger.info({\n            facilitatorId: explicitFacilitator.id,\n            facilitatorUrl: explicitFacilitator.config.healthCheckUrl,\n            strategy: preferences.facilitatorStrategy,\n            network: requirements.network,\n            asset: requirements.asset,\n            mode: 'explicit',\n            msg: 'Facilitator selected via explicit strategy',\n          });\n          return explicitFacilitator;\n        } else {\n          logger.warn({\n            facilitatorId: preferences.facilitatorStrategy,\n            network: requirements.network,\n            asset: requirements.asset,\n            msg: 'Explicit facilitator does not support requested network/asset, falling back to auto',\n          });\n          // Fall through to auto selection\n        }\n      } else {\n        logger.warn({\n          facilitatorId: preferences.facilitatorStrategy,\n          enabled: explicitFacilitator?.config.enabled,\n          msg: 'Explicit facilitator not found or disabled, falling back to auto',\n        });\n        // Fall through to auto selection\n      }\n    }\n\n    // ==========================================================================\n    // Auto selection: Get eligible facilitators\n    // ==========================================================================\n    const eligible = this.getEligibleFacilitators(requirements, preferences, policy);\n\n    if (eligible.length === 0) {\n      throw new Error(\n        `No eligible facilitator found for ${requirements.network}/${requirements.asset}/${requirements.scheme}`\n      );\n    }\n\n    // Score and rank facilitators\n    const scored = await this.scoreFacilitators(eligible, requirements, preferences, policy);\n\n    // Select best facilitator\n    const best = scored[0].facilitator;\n    const bestExplanation = scored[0].x402scanExplanation;\n    \n    // =======================================================================\n    // Log x402scan explanation for the selected facilitator (if available)\n    // =======================================================================\n    if (bestExplanation && DEFAULT_X402SCAN_TRUST_CONFIG.logExplanations) {\n      logger.info({\n        facilitatorId: best.id,\n        x402scan: {\n          selected: true,\n          score: bestExplanation.score,\n          confidence: bestExplanation.confidence,\n          shortReason: bestExplanation.shortReason,\n          metrics: bestExplanation.metrics,\n        },\n        msg: 'x402scan routing explanation',\n      });\n    }\n\n    // Log alternatives with their x402scan data (for debugging/ML)\n    if (scored.length > 1 && DEFAULT_X402SCAN_TRUST_CONFIG.logExplanations) {\n      const alternatives = scored.slice(1, 4).map((s) => ({\n        id: s.facilitator.id,\n        score: s.score,\n        x402scan: s.x402scanExplanation ? {\n          score: s.x402scanExplanation.score,\n          confidence: s.x402scanExplanation.confidence,\n          shortReason: s.x402scanExplanation.shortReason,\n        } : null,\n      }));\n      logger.debug({ alternatives, msg: 'Alternative facilitators considered' });\n    }\n    \n    // Log decision trace (compact format for explainer/debugger UI)\n    // Include facilitatorUrl for per-facilitator logging\n    logger.info({\n      facilitatorId: best.id,\n      facilitatorUrl: best.config.healthCheckUrl,\n      score: scored[0].score,\n      x402scanScore: bestExplanation?.score,\n      x402scanConfidence: bestExplanation?.confidence,\n      alternatives: scored.length - 1,\n      reasons: scored[0].reasons,\n      strategy: preferences?.facilitatorStrategy || 'auto',\n      mode: 'auto',\n      constraints: {\n        preferences: preferences ? {\n          priority: preferences.priority,\n          preferredNetworks: preferences.preferredNetworks,\n          preferredAssets: preferences.preferredAssets,\n          facilitatorStrategy: preferences.facilitatorStrategy,\n        } : undefined,\n        settlementMode: requirements.settlementMode,\n      },\n      candidates: scored.map((s) => ({\n        id: s.facilitator.id,\n        url: s.facilitator.config.healthCheckUrl,\n        score: s.score,\n        reasons: s.reasons,\n      })),\n      msg: 'Facilitator selected',\n    });\n\n    return best;\n  }\n\n  /**\n   * Get eligible facilitators based on requirements, preferences, and policy\n   * Extended to support CAIP identifiers and settlement modes\n   */\n  private getEligibleFacilitators(\n    requirements: PaymentRequirements,\n    preferences?: RoutingPreferences,\n    policy?: RoutingPolicy\n  ): IFacilitator[] {\n    const facilitators = Array.from(this.facilitators.values());\n\n    return facilitators.filter((facilitator) => {\n      // 1. Check basic support (legacy or CAIP)\n      let supportsNetwork = false;\n      let supportsAsset = false;\n\n      // Check network support\n      if (requirements.networks && requirements.networks.length > 0) {\n        // CAIP networks\n        supportsNetwork = requirements.networks.some((n) =>\n          facilitator.supportsCAIPNetwork(n)\n        );\n      } else {\n        // Legacy network\n        supportsNetwork = facilitator.config.networks.includes(requirements.network);\n      }\n\n      // Check asset support\n      if (requirements.assets && requirements.assets.length > 0) {\n        // CAIP assets\n        supportsAsset = requirements.assets.some((a) =>\n          facilitator.supportsCAIPAsset(a)\n        );\n      } else {\n        // Legacy asset\n        supportsAsset = facilitator.config.assets.includes(requirements.asset);\n      }\n\n      if (\n        !supportsNetwork ||\n        !supportsAsset ||\n        !facilitator.supports(\n          requirements.network,\n          requirements.asset,\n          requirements.scheme,\n          requirements.settlementMode\n        )\n      ) {\n        return false;\n      }\n\n      // 2. Check if enabled\n      if (!facilitator.config.enabled) {\n        return false;\n      }\n\n      // 3. Check preferences (SDK preferences) - support both legacy and CAIP\n      const preferredNetworks = [\n        ...(preferences?.preferredNetworks || []),\n        ...(preferences?.preferredNetworksCAIP || []),\n      ];\n      if (preferredNetworks.length > 0) {\n        const facilitatorNetworks = [\n          ...facilitator.config.networks,\n          ...(facilitator.config.networksCAIP || []),\n        ];\n        if (!preferredNetworks.some((p) => facilitatorNetworks.some((n) => n.includes(p) || p.includes(n)))) {\n          return false;\n        }\n      }\n\n      const avoidedNetworks = [\n        ...(preferences?.avoidNetworks || []),\n        ...(preferences?.avoidNetworksCAIP || []),\n      ];\n      if (avoidedNetworks.length > 0) {\n        const facilitatorNetworks = [\n          ...facilitator.config.networks,\n          ...(facilitator.config.networksCAIP || []),\n        ];\n        if (avoidedNetworks.some((a) => facilitatorNetworks.some((n) => n.includes(a) || a.includes(n)))) {\n          return false;\n        }\n      }\n\n      const preferredAssets = [\n        ...(preferences?.preferredAssets || []),\n        ...(preferences?.preferredAssetsCAIP || []),\n      ];\n      if (preferredAssets.length > 0) {\n        const facilitatorAssets = [\n          ...facilitator.config.assets,\n          ...(facilitator.config.assetsCAIP || []),\n        ];\n        if (!preferredAssets.some((p) => facilitatorAssets.some((a) => a.includes(p) || p.includes(a)))) {\n          return false;\n        }\n      }\n\n      // 3b. Check jurisdiction (if specified)\n      if (preferences?.jurisdiction) {\n        // This would integrate with jurisdiction rules\n        // For now, pass through (can be enhanced later)\n      }\n\n      // 3c. Check settlement mode preference\n      if (preferences?.settlementMode) {\n        if (facilitator.config.settlementModes && !facilitator.config.settlementModes.includes(preferences.settlementMode)) {\n          return false;\n        }\n      }\n\n      // 4. Check policy (SMF business logic)\n      if (policy?.requireHealthCheck) {\n        const health = this.facilitatorHealth.get(facilitator.id);\n        if (!health || !health.healthy) {\n          return false;\n        }\n      }\n\n      // Note: Database health snapshot check is done in scoreFacilitators (async)\n      // to avoid blocking the synchronous filter operation\n\n      if (policy?.customRules) {\n        if (!policy.customRules(facilitator, requirements)) {\n          return false;\n        }\n      }\n\n      // 5. Check compliance requirements\n      if (preferences?.requireCompliance || policy?.requireKYC) {\n        // Check if facilitator supports compliance\n        const metadata = facilitator.config.metadata;\n        if (!metadata?.kytEnabled && !metadata?.ofacEnabled) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Score facilitators based on preferences and policy\n   * Uses real health metrics from database AND x402scan ecosystem data for accurate scoring\n   * Handles priority ties with randomization\n   * Exposed for decision trace building\n   */\n  public async scoreFacilitators(\n    facilitators: IFacilitator[],\n    requirements: PaymentRequirements,\n    preferences?: RoutingPreferences,\n    policy?: RoutingPolicy\n  ): Promise<Array<{ facilitator: IFacilitator; score: number; reasons: string[]; x402scanExplanation?: FacilitatorExplanation }>> {\n    const x402scanConfig = DEFAULT_X402SCAN_TRUST_CONFIG;\n    \n    const scored = await Promise.all(\n      facilitators.map(async (facilitator) => {\n        let score = 100; // Start with base score\n        const reasons: string[] = [];\n        let x402scanExplanation: FacilitatorExplanation | undefined;\n\n        // 1. Base priority (lower priority number = higher priority)\n        const basePriority = facilitator.config.priority;\n        score += basePriority * 10;\n        reasons.push(`priority:${basePriority}`);\n\n        // 2. Get real health metrics from database\n        const network = requirements.network;\n        const token = requirements.asset;\n        let healthMetrics;\n        try {\n          healthMetrics = await getCurrentHealth(facilitator.id, network, token, 15);\n        } catch (error) {\n          logger.warn({ error, facilitatorId: facilitator.id, network, token }, 'Failed to get health metrics, using defaults');\n          healthMetrics = {\n            successRate: 1.0,\n            p95LatencyMs: null,\n            errorRate: 0.0,\n            status: 'healthy' as const,\n          };\n        }\n\n        // =======================================================================\n        // 2b. Get x402scan ecosystem metrics (if available and trusted)\n        // =======================================================================\n        let x402scanScore: FacilitatorScore | null = null;\n        let x402scanTrust = { trust: false, reason: 'not-fetched' };\n        \n        try {\n          x402scanScore = await getFacilitatorScore({\n            facilitatorId: facilitator.id,\n            timeframe: x402scanConfig.timeframe,\n          });\n          x402scanTrust = shouldTrustX402ScanMetrics(x402scanScore, x402scanConfig);\n          \n          // Get detailed explanation for logging\n          if (x402scanConfig.logExplanations) {\n            x402scanExplanation = await getFacilitatorExplainer(facilitator.id, {\n              timeframe: x402scanConfig.timeframe,\n            });\n          }\n        } catch (error) {\n          logger.debug({ error, facilitatorId: facilitator.id }, 'Failed to get x402scan metrics');\n          x402scanTrust = { trust: false, reason: 'fetch-error' };\n        }\n\n        // 3. Success rate scoring (w1 * successRate)\n        const w1 = 50; // Weight for success rate\n        const successRateScore = healthMetrics.successRate * w1;\n        score += successRateScore;\n        reasons.push(`success-rate:${(healthMetrics.successRate * 100).toFixed(1)}%`);\n\n        // 4. Latency scoring (w2 * p95LatencyMs) - lower is better\n        const w2 = 0.1; // Weight for latency penalty\n        if (healthMetrics.p95LatencyMs !== null) {\n          const latencyPenalty = healthMetrics.p95LatencyMs * w2;\n          score -= latencyPenalty;\n          reasons.push(`p95-latency:${healthMetrics.p95LatencyMs}ms`);\n        }\n\n        // 5. Fee scoring (w3 * feeBps) - get from capabilities\n        const w3 = 0.5; // Weight for fee penalty\n        try {\n          const capabilities = await getFacilitatorCapabilities(facilitator.id, network, token);\n          const capability = capabilities[0];\n          if (capability) {\n            const feePenalty = capability.fee_bps * w3;\n            score -= feePenalty;\n            reasons.push(`fee:${capability.fee_bps}bps`);\n          }\n        } catch (error) {\n          logger.debug({ error, facilitatorId: facilitator.id }, 'Failed to get capabilities for fee scoring');\n        }\n\n        // 6. Risk penalty (w4 * riskPenalty) - based on error rate and status\n        const w4 = 30; // Weight for risk penalty\n        const riskPenalty = healthMetrics.errorRate * w4;\n        score -= riskPenalty;\n        if (healthMetrics.status === 'down') {\n          // Refuse routing to down facilitators (set score to very low value)\n          score = -1000; // Effectively prevents routing\n          reasons.push('status:down');\n          logger.warn(\n            { facilitatorId: facilitator.id, network: requirements.network, token: requirements.asset },\n            'Refusing to route - facilitator is down'\n          );\n        } else if (healthMetrics.status === 'degraded') {\n          score -= 25; // Moderate penalty for degraded\n          reasons.push('status:degraded');\n          logger.warn(\n            { facilitatorId: facilitator.id, network: requirements.network, token: requirements.asset },\n            'Facilitator is degraded - routing with caution'\n          );\n        }\n\n        // 7. Health status check (cached)\n        const health = this.facilitatorHealth.get(facilitator.id);\n        if (health && !health.healthy) {\n          score -= 30; // Additional penalty for unhealthy in cache\n          reasons.push('cache-unhealthy');\n        }\n\n        // =======================================================================\n        // 8. X402SCAN ECOSYSTEM METRICS INTEGRATION\n        // =======================================================================\n        if (x402scanTrust.trust && x402scanScore) {\n          // Apply x402scan score as weighted bonus/penalty\n          // x402scan score is 0-100, normalize to contribute proportionally\n          const x402scanNormalized = (x402scanScore.score - 50) / 50; // -1 to +1\n          const x402scanBonus = x402scanNormalized * 30 * x402scanConfig.x402scanScoreWeight;\n          score += x402scanBonus;\n          reasons.push(`x402scan:${x402scanScore.score}/${x402scanTrust.reason}`);\n\n          // Extra bonus for high success rate in ecosystem data\n          if (x402scanScore.successRate >= 0.99) {\n            score += 10 * x402scanConfig.x402scanScoreWeight;\n            reasons.push('x402scan-excellent');\n          } else if (x402scanScore.successRate < 0.90) {\n            score -= 15 * x402scanConfig.x402scanScoreWeight;\n            reasons.push('x402scan-degraded');\n          }\n\n          // Latency bonus/penalty from ecosystem data\n          if (x402scanScore.p95LatencyMs !== undefined) {\n            if (x402scanScore.p95LatencyMs < 200) {\n              score += 5 * x402scanConfig.x402scanScoreWeight;\n              reasons.push(`x402scan-fast:${x402scanScore.p95LatencyMs.toFixed(0)}ms`);\n            } else if (x402scanScore.p95LatencyMs > 1000) {\n              score -= 10 * x402scanConfig.x402scanScoreWeight;\n              reasons.push(`x402scan-slow:${x402scanScore.p95LatencyMs.toFixed(0)}ms`);\n            }\n          }\n        } else {\n          // Log why x402scan data wasn't trusted\n          reasons.push(`x402scan-skipped:${x402scanTrust.reason}`);\n        }\n\n        // =======================================================================\n        // 8b. SCATTERING / DUNE ACTIVITY METRICS INTEGRATION\n        // =======================================================================\n        const scatteringConfig = DEFAULT_SCATTERING_CONFIG;\n        let scatteringMetrics: ScatteringFacilitatorMetrics | null = null;\n        let scatteringTrust = { trust: false, reason: 'not-fetched' };\n\n        try {\n          scatteringMetrics = await getScatteringMetricsForFacilitator(facilitator.id);\n          scatteringTrust = shouldTrustScatteringMetrics(scatteringMetrics, scatteringConfig);\n        } catch (error) {\n          logger.debug({ error, facilitatorId: facilitator.id }, 'Failed to get Scattering metrics');\n          scatteringTrust = { trust: false, reason: 'fetch-error' };\n        }\n\n        if (scatteringTrust.trust && scatteringMetrics) {\n          // Compute activity score (0-1)\n          const activityScore = computeActivityScore(scatteringMetrics);\n          \n          // Apply as weighted bonus (activity score 0.5+ is good, higher is better)\n          const activityBonus = (activityScore - 0.3) * 100 * scatteringConfig.scatteringScoreWeight;\n          score += activityBonus;\n          reasons.push(`scattering-activity:${(activityScore * 100).toFixed(1)}%`);\n\n          // Volume bonus for high-volume facilitators\n          if (scatteringMetrics.volumeUsd3d >= 100_000) {\n            score += 10 * scatteringConfig.scatteringScoreWeight;\n            reasons.push(`scattering-high-volume:$${(scatteringMetrics.volumeUsd3d / 1000).toFixed(1)}K`);\n          }\n\n          // User diversity bonus (more unique buyers = more trusted)\n          if (scatteringMetrics.uniqueBuyers3d >= 1000) {\n            score += 5 * scatteringConfig.scatteringScoreWeight;\n            reasons.push(`scattering-high-adoption:${scatteringMetrics.uniqueBuyers3d}-buyers`);\n          }\n\n          // Growth bonus/penalty\n          if (scatteringMetrics.volumeChangeRate !== undefined) {\n            if (scatteringMetrics.volumeChangeRate > 20) {\n              // Growing facilitator\n              score += 5 * scatteringConfig.scatteringScoreWeight;\n              reasons.push(`scattering-growing:+${scatteringMetrics.volumeChangeRate.toFixed(0)}%`);\n            } else if (scatteringMetrics.volumeChangeRate < -50) {\n              // Declining significantly\n              score -= 10 * scatteringConfig.scatteringScoreWeight;\n              reasons.push(`scattering-declining:${scatteringMetrics.volumeChangeRate.toFixed(0)}%`);\n            }\n          }\n\n          // Log Scattering metrics if enabled\n          if (scatteringConfig.logScatteringMetrics) {\n            logger.debug({\n              facilitatorId: facilitator.id,\n              scattering: {\n                volumeUsd3d: scatteringMetrics.volumeUsd3d,\n                txCount3d: scatteringMetrics.txCount3d,\n                uniqueBuyers3d: scatteringMetrics.uniqueBuyers3d,\n                activityScore: activityScore.toFixed(3),\n                volumeChangeRate: scatteringMetrics.volumeChangeRate,\n              },\n              msg: 'Scattering metrics applied',\n            });\n          }\n        } else {\n          reasons.push(`scattering-skipped:${scatteringTrust.reason}`);\n        }\n\n        // =======================================================================\n        // 8c. PERSISTED SCORE INTEGRATION (Stage 5)\n        // =======================================================================\n        // Blend historical scores with real-time metrics for routing decisions\n        // Persisted scores use time-based decay (1-hour half-life)\n        const persistedConfig = DEFAULT_PERSISTED_SCORE_CONFIG;\n        \n        try {\n          const persistedScore = await getPersistedScore({\n            facilitator_id: facilitator.id,\n            chain_id: network,\n          });\n\n          if (persistedScore && persistedScore.confidence >= persistedConfig.minConfidence) {\n            // Blend persisted score into current score\n            // Persisted score is 0-100, current score varies but centered around ~100-150\n            // Normalize persisted score contribution: (persistedScore - 50) gives -50 to +50 range\n            const persistedContribution = (persistedScore.score - 50) * persistedConfig.persistedScoreWeight;\n            score += persistedContribution;\n            reasons.push(`persisted:${persistedScore.score.toFixed(0)}/${persistedScore.confidence.toFixed(2)}`);\n\n            if (persistedConfig.logPersistedScore) {\n              logger.debug({\n                facilitatorId: facilitator.id,\n                chain_id: network,\n                persisted: {\n                  score: persistedScore.score,\n                  confidence: persistedScore.confidence,\n                  contribution: persistedContribution,\n                },\n                msg: 'Persisted score applied',\n              });\n            }\n          } else if (persistedScore) {\n            reasons.push(`persisted-low-confidence:${persistedScore.confidence.toFixed(2)}`);\n          } else {\n            reasons.push('persisted-none');\n          }\n\n          // Check for running experiments and apply traffic adjustments\n          if (persistedConfig.enableExperimentAdjustments) {\n            const experimentAdjustment = await getExperimentTrafficAdjustment(\n              facilitator.id,\n              network\n            );\n\n            if (experimentAdjustment.adjustment > 0) {\n              score += experimentAdjustment.adjustment;\n              reasons.push(`experiment:${experimentAdjustment.experiment_name}:+${experimentAdjustment.adjustment.toFixed(1)}`);\n              \n              if (persistedConfig.logPersistedScore) {\n                logger.debug({\n                  facilitatorId: facilitator.id,\n                  experiment: experimentAdjustment.experiment_name,\n                  adjustment: experimentAdjustment.adjustment,\n                  msg: 'Experiment traffic adjustment applied',\n                });\n              }\n            }\n          }\n        } catch (error) {\n          logger.debug({ error, facilitatorId: facilitator.id }, 'Failed to get persisted score');\n          reasons.push('persisted-error');\n        }\n\n        // 9. Cost optimization (if policy requires)\n        if (policy?.preferCheapest || preferences?.priority === 'cost') {\n          const pricing = await facilitator.getPricing(requirements.network, requirements.asset);\n          if (pricing) {\n            // Lower cost = higher score (normalize)\n            score += 20; // Bonus for having pricing info\n            reasons.push('has-pricing');\n          }\n        }\n\n        // 10. Speed optimization (if preference)\n        if (preferences?.priority === 'speed') {\n          if (healthMetrics.p95LatencyMs !== null) {\n            // Lower latency = higher score\n            const latencyBonus = Math.max(0, 30 - healthMetrics.p95LatencyMs / 10);\n            score += latencyBonus;\n            reasons.push(`speed-optimized:${healthMetrics.p95LatencyMs}ms`);\n          }\n          // Also factor in x402scan latency for speed priority\n          if (x402scanTrust.trust && x402scanScore?.p95LatencyMs !== undefined) {\n            const x402LatencyBonus = Math.max(0, 20 - x402scanScore.p95LatencyMs / 25);\n            score += x402LatencyBonus * x402scanConfig.x402scanScoreWeight;\n          }\n        }\n\n        // 11. Compliance optimization\n        if (preferences?.priority === 'compliance' || policy?.requireKYC) {\n          const metadata = facilitator.config.metadata;\n          if (metadata?.kytEnabled && metadata?.ofacEnabled) {\n            score += 30; // Bonus for compliance\n            reasons.push('compliance-enabled');\n          }\n        }\n\n        // 12. Reliability optimization - strongly weight x402scan for reliability priority\n        if (preferences?.priority === 'reliability') {\n          if (healthMetrics.status === 'healthy' && healthMetrics.successRate > 0.95) {\n            score += 25;\n            reasons.push('high-reliability');\n          }\n          // Double weight x402scan for reliability priority\n          if (x402scanTrust.trust && x402scanScore) {\n            if (x402scanScore.successRate >= 0.98 && x402scanScore.confidence === 'high') {\n              score += 20; // Strong bonus for proven reliability\n              reasons.push('x402scan-proven-reliable');\n            }\n          }\n        }\n\n        // 13. Settlement mode optimization\n        if (requirements.settlementMode) {\n          if (facilitator.config.settlementModes?.includes(requirements.settlementMode)) {\n            score += 15; // Bonus for supporting requested settlement mode\n            reasons.push(`settlement:${requirements.settlementMode}`);\n          }\n        }\n\n        return { facilitator, score, reasons, x402scanExplanation };\n      })\n    );\n\n    // Sort by score (highest first)\n    const sorted = scored.sort((a, b) => b.score - a.score);\n\n    // Handle priority ties with randomization\n    // If top scores are within 5 points, randomize order\n    if (sorted.length > 1) {\n      const topScore = sorted[0].score;\n      const tied = sorted.filter((s) => Math.abs(s.score - topScore) <= 5);\n      \n      if (tied.length > 1) {\n        // Shuffle tied facilitators\n        for (let i = tied.length - 1; i > 0; i--) {\n          const j = Math.floor(Math.random() * (i + 1));\n          [tied[i], tied[j]] = [tied[j], tied[i]];\n        }\n        // Rebuild sorted array with shuffled ties\n        const rest = sorted.filter((s) => Math.abs(s.score - topScore) > 5);\n        return [...tied, ...rest];\n      }\n    }\n\n    return sorted;\n  }\n\n  /**\n   * Start periodic health checks\n   */\n  private startHealthChecks(): void {\n    this.healthCheckInterval = setInterval(async () => {\n      await this.checkAllFacilitators();\n    }, 5 * 60 * 1000); // Every 5 minutes\n\n    // Initial health check\n    this.checkAllFacilitators();\n  }\n\n  /**\n   * Check health of all facilitators\n   */\n  private async checkAllFacilitators(): Promise<void> {\n    const facilitators = Array.from(this.facilitators.values());\n    \n    await Promise.all(\n      facilitators.map(async (facilitator) => {\n        try {\n          const health = await facilitator.getHealth();\n          this.facilitatorHealth.set(facilitator.id, {\n            healthy: health.healthy,\n            lastChecked: Date.now(),\n          });\n        } catch (error) {\n          logger.error({ facilitatorId: facilitator.id, error }, 'Health check failed');\n          this.facilitatorHealth.set(facilitator.id, {\n            healthy: false,\n            lastChecked: Date.now(),\n          });\n        }\n      })\n    );\n  }\n\n  /**\n   * Get facilitator by ID\n   */\n  getFacilitator(id: string): IFacilitator | undefined {\n    return this.facilitators.get(id);\n  }\n\n  /**\n   * Get facilitator health status\n   */\n  getFacilitatorHealth(id: string): { healthy: boolean; lastChecked: number } | undefined {\n    return this.facilitatorHealth.get(id);\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n    }\n  }\n}\n\n// Singleton instance\nlet router: FacilitatorRouter | null = null;\n\n/**\n * Get facilitator router instance\n */\nexport function getFacilitatorRouter(): FacilitatorRouter {\n  if (!router) {\n    router = new FacilitatorRouter();\n  }\n  return router;\n}\n\n"],"names":[],"mappings":"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"}