{"version":3,"sources":["turbopack:///[project]/node_modules/thread-stream/package.json","../../../src/lib/rate-limit-unified.ts","../../../src/lib/rate-limit-store.ts","../../../node_modules/uncrypto/dist/crypto.node.mjs","../../../node_modules/viem/utils/signature/verifyTypedData.ts","../../../node_modules/viem/utils/signature/recoverTypedDataAddress.ts","../../../src/db/api-keys.ts","../../../src/lib/auth.ts","../../../src/lib/request-id.ts","../../../src/lib/request-logging.ts","../../../src/db/metered-endpoints.ts","../../../src/integrations/x402/x402-call-log.ts","../../../src/integrations/x402/payment-header-parser.ts"],"sourcesContent":["{\"name\":\"thread-stream\",\"version\":\"3.1.0\",\"description\":\"A streaming way to send data to a Node.js Worker Thread\",\"main\":\"index.js\",\"types\":\"index.d.ts\",\"dependencies\":{\"real-require\":\"^0.2.0\"},\"devDependencies\":{\"@types/node\":\"^20.1.0\",\"@types/tap\":\"^15.0.0\",\"@yao-pkg/pkg\":\"^5.11.5\",\"desm\":\"^1.3.0\",\"fastbench\":\"^1.0.1\",\"husky\":\"^9.0.6\",\"pino-elasticsearch\":\"^8.0.0\",\"sonic-boom\":\"^4.0.1\",\"standard\":\"^17.0.0\",\"tap\":\"^16.2.0\",\"ts-node\":\"^10.8.0\",\"typescript\":\"^5.3.2\",\"why-is-node-running\":\"^2.2.2\"},\"scripts\":{\"build\":\"tsc --noEmit\",\"test\":\"standard && npm run build && npm run transpile && tap \\\"test/**/*.test.*js\\\" && tap --ts test/*.test.*ts\",\"test:ci\":\"standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts\",\"test:ci:js\":\"tap --no-check-coverage --timeout=120 --coverage-report=lcovonly \\\"test/**/*.test.*js\\\"\",\"test:ci:ts\":\"tap --ts --no-check-coverage --coverage-report=lcovonly \\\"test/**/*.test.*ts\\\"\",\"test:yarn\":\"npm run transpile && tap \\\"test/**/*.test.js\\\" --no-check-coverage\",\"transpile\":\"sh ./test/ts/transpile.sh\",\"prepare\":\"husky install\"},\"standard\":{\"ignore\":[\"test/ts/**/*\",\"test/syntax-error.mjs\"]},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/mcollina/thread-stream.git\"},\"keywords\":[\"worker\",\"thread\",\"threads\",\"stream\"],\"author\":\"Matteo Collina <hello@matteocollina.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/mcollina/thread-stream/issues\"},\"homepage\":\"https://github.com/mcollina/thread-stream#readme\"}","// =============================================================================\r\n// UNIFIED RATE LIMITING\r\n// =============================================================================\r\n// Single implementation for both Edge and Node.js environments.\r\n// Supports distributed rate limiting via Redis with in-memory fallback.\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { getRateLimitStore, getEdgeRateLimitStore, type RateLimitStore } from './rate-limit-store';\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface RateLimitConfig {\r\n  windowMs: number;\r\n  maxRequests: number;\r\n  identifier: string;\r\n}\r\n\r\nexport interface RateLimitResult {\r\n  allowed: boolean;\r\n  remaining: number;\r\n  resetAt: number;\r\n  limit: number;\r\n}\r\n\r\nexport interface RateLimitTier {\r\n  name: string;\r\n  windowMs: number;\r\n  maxRequests: number;\r\n}\r\n\r\n// =============================================================================\r\n// DEFAULT TIERS\r\n// =============================================================================\r\n\r\nexport const RATE_LIMIT_TIERS: Record<string, RateLimitTier> = {\r\n  // Per-IP global limits\r\n  global: { name: 'global', windowMs: 60 * 60 * 1000, maxRequests: 1000 },\r\n  \r\n  // Per-endpoint limits (per IP, per minute)\r\n  endpoint: { name: 'endpoint', windowMs: 60 * 1000, maxRequests: 100 },\r\n  \r\n  // API key tiers (per hour)\r\n  free: { name: 'free', windowMs: 60 * 60 * 1000, maxRequests: 100 },\r\n  starter: { name: 'starter', windowMs: 60 * 60 * 1000, maxRequests: 1000 },\r\n  pro: { name: 'pro', windowMs: 60 * 60 * 1000, maxRequests: 5000 },\r\n  enterprise: { name: 'enterprise', windowMs: 60 * 60 * 1000, maxRequests: 50000 },\r\n  \r\n  // Cron job rate limiting (per minute)\r\n  cron: { name: 'cron', windowMs: 60 * 1000, maxRequests: 1 },\r\n};\r\n\r\n// =============================================================================\r\n// METRICS TRACKING\r\n// =============================================================================\r\n\r\ninterface RateLimitMetrics {\r\n  requests: Map<string, number>;      // tier:type -> total requests\r\n  blocked: Map<string, number>;       // tier:type -> blocked requests\r\n  latencies: Map<string, number[]>;   // tier:type -> latencies (last 100)\r\n  lastReset: number;\r\n}\r\n\r\nconst metrics: RateLimitMetrics = {\r\n  requests: new Map(),\r\n  blocked: new Map(),\r\n  latencies: new Map(),\r\n  lastReset: Date.now(),\r\n};\r\n\r\nconst MAX_LATENCY_SAMPLES = 100;\r\nconst METRICS_RESET_INTERVAL_MS = 60 * 60 * 1000; // 1 hour\r\n\r\n/**\r\n * Record a rate limit check\r\n */\r\nfunction recordMetric(\r\n  type: string,\r\n  allowed: boolean,\r\n  latencyMs: number\r\n): void {\r\n  // Reset metrics hourly\r\n  const now = Date.now();\r\n  if (now - metrics.lastReset > METRICS_RESET_INTERVAL_MS) {\r\n    metrics.requests.clear();\r\n    metrics.blocked.clear();\r\n    metrics.latencies.clear();\r\n    metrics.lastReset = now;\r\n  }\r\n  \r\n  // Record request\r\n  const key = type;\r\n  metrics.requests.set(key, (metrics.requests.get(key) || 0) + 1);\r\n  \r\n  // Record blocked\r\n  if (!allowed) {\r\n    metrics.blocked.set(key, (metrics.blocked.get(key) || 0) + 1);\r\n  }\r\n  \r\n  // Record latency (keep last N samples)\r\n  let latencies = metrics.latencies.get(key);\r\n  if (!latencies) {\r\n    latencies = [];\r\n    metrics.latencies.set(key, latencies);\r\n  }\r\n  latencies.push(latencyMs);\r\n  if (latencies.length > MAX_LATENCY_SAMPLES) {\r\n    latencies.shift();\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate percentile from sorted array\r\n */\r\nfunction percentile(sorted: number[], p: number): number {\r\n  if (sorted.length === 0) return 0;\r\n  const idx = Math.ceil(sorted.length * p) - 1;\r\n  return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];\r\n}\r\n\r\n/**\r\n * Get rate limit metrics for observability\r\n */\r\nexport function getRateLimitMetrics(): {\r\n  byType: Record<string, {\r\n    total: number;\r\n    blocked: number;\r\n    blockRate: string;\r\n    latency: { p50: number; p95: number; p99: number };\r\n  }>;\r\n  totals: {\r\n    requests: number;\r\n    blocked: number;\r\n    blockRate: string;\r\n  };\r\n  lastReset: string;\r\n} {\r\n  const byType: Record<string, any> = {};\r\n  let totalRequests = 0;\r\n  let totalBlocked = 0;\r\n  \r\n  const types = new Set([\r\n    ...metrics.requests.keys(),\r\n    ...metrics.blocked.keys(),\r\n  ]);\r\n  \r\n  for (const type of types) {\r\n    const requests = metrics.requests.get(type) || 0;\r\n    const blocked = metrics.blocked.get(type) || 0;\r\n    const latencies = metrics.latencies.get(type) || [];\r\n    \r\n    totalRequests += requests;\r\n    totalBlocked += blocked;\r\n    \r\n    // Calculate latency percentiles\r\n    const sorted = [...latencies].sort((a, b) => a - b);\r\n    \r\n    byType[type] = {\r\n      total: requests,\r\n      blocked,\r\n      blockRate: requests > 0 ? ((blocked / requests) * 100).toFixed(2) + '%' : '0%',\r\n      latency: {\r\n        p50: Math.round(percentile(sorted, 0.5)),\r\n        p95: Math.round(percentile(sorted, 0.95)),\r\n        p99: Math.round(percentile(sorted, 0.99)),\r\n      },\r\n    };\r\n  }\r\n  \r\n  return {\r\n    byType,\r\n    totals: {\r\n      requests: totalRequests,\r\n      blocked: totalBlocked,\r\n      blockRate: totalRequests > 0 \r\n        ? ((totalBlocked / totalRequests) * 100).toFixed(2) + '%' \r\n        : '0%',\r\n    },\r\n    lastReset: new Date(metrics.lastReset).toISOString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Reset rate limit metrics (for testing)\r\n */\r\nexport function resetRateLimitMetrics(): void {\r\n  metrics.requests.clear();\r\n  metrics.blocked.clear();\r\n  metrics.latencies.clear();\r\n  metrics.lastReset = Date.now();\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Extract API key from Authorization header\r\n */\r\nexport function extractApiKey(request: NextRequest): string | null {\r\n  const authHeader = request.headers.get('authorization');\r\n  if (!authHeader) return null;\r\n  \r\n  if (authHeader.startsWith('Bearer ')) {\r\n    return authHeader.substring(7).trim();\r\n  }\r\n  return authHeader.trim();\r\n}\r\n\r\n/**\r\n * Get client IP address\r\n */\r\nexport function getClientIp(request: NextRequest): string {\r\n  return (\r\n    request.ip ||\r\n    request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() ||\r\n    request.headers.get('x-real-ip') ||\r\n    'unknown'\r\n  );\r\n}\r\n\r\n/**\r\n * Hash a string for use as rate limit key (don't store full API keys)\r\n */\r\nfunction hashKey(key: string): string {\r\n  // Use first 16 chars as identifier (safe for rate limiting)\r\n  return key.substring(0, 16);\r\n}\r\n\r\n// =============================================================================\r\n// CORE RATE LIMIT CHECK\r\n// =============================================================================\r\n\r\n/**\r\n * Check rate limit against a store\r\n */\r\nasync function checkRateLimitAsync(\r\n  store: RateLimitStore,\r\n  config: RateLimitConfig,\r\n  metricType?: string\r\n): Promise<RateLimitResult> {\r\n  const start = Date.now();\r\n  const entry = await store.increment(config.identifier, config.windowMs);\r\n  \r\n  const allowed = entry.count <= config.maxRequests;\r\n  const remaining = Math.max(0, config.maxRequests - entry.count);\r\n  \r\n  // Record metrics if type provided\r\n  if (metricType) {\r\n    recordMetric(metricType, allowed, Date.now() - start);\r\n  }\r\n  \r\n  return {\r\n    allowed,\r\n    remaining,\r\n    resetAt: entry.resetAt,\r\n    limit: config.maxRequests,\r\n  };\r\n}\r\n\r\n/**\r\n * Synchronous check for Edge runtime\r\n */\r\nfunction checkRateLimitSync(\r\n  store: RateLimitStore,\r\n  config: RateLimitConfig\r\n): RateLimitResult {\r\n  const now = Date.now();\r\n  const key = config.identifier;\r\n  \r\n  // Note: This is a simplified sync version that may not be perfectly accurate\r\n  // but works for Edge runtime where we can't await\r\n  const resetAt = now + config.windowMs;\r\n  \r\n  return {\r\n    allowed: true, // Edge allows through, Node enforces\r\n    remaining: config.maxRequests,\r\n    resetAt,\r\n    limit: config.maxRequests,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API - ASYNC (Node.js)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by API key (Node.js - database lookup)\r\n */\r\nexport async function rateLimitByApiKey(\r\n  request: NextRequest,\r\n  apiKeyRateLimit?: number\r\n): Promise<RateLimitResult | null> {\r\n  const token = extractApiKey(request);\r\n  if (!token) return null;\r\n  \r\n  const store = await getRateLimitStore();\r\n  const limit = apiKeyRateLimit || RATE_LIMIT_TIERS.starter.maxRequests;\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.starter.windowMs,\r\n    maxRequests: limit,\r\n    identifier: `api_key:${hashKey(token)}`,\r\n  }, 'api_key');\r\n}\r\n\r\n/**\r\n * Rate limit by endpoint (Node.js)\r\n */\r\nexport async function rateLimitByEndpoint(\r\n  request: NextRequest,\r\n  endpointId: string,\r\n  maxRequests?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.endpoint.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.endpoint.maxRequests,\r\n    identifier: `endpoint:${endpointId}:${ip}`,\r\n  }, `endpoint:${endpointId}`);\r\n}\r\n\r\n/**\r\n * Rate limit by IP (Node.js)\r\n */\r\nexport async function rateLimitByIp(\r\n  request: NextRequest,\r\n  maxRequests?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.global.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.global.maxRequests,\r\n    identifier: `global:${ip}`,\r\n  }, 'global');\r\n}\r\n\r\n/**\r\n * Rate limit cron job (prevent concurrent runs)\r\n */\r\nexport async function rateLimitCronJob(\r\n  cronId: string,\r\n  intervalMs?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: intervalMs || RATE_LIMIT_TIERS.cron.windowMs,\r\n    maxRequests: RATE_LIMIT_TIERS.cron.maxRequests,\r\n    identifier: `cron:${cronId}`,\r\n  }, `cron:${cronId}`);\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API - SYNC (Edge Runtime)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by IP (Edge - sync, in-memory only)\r\n */\r\nexport function rateLimitByIpEdge(\r\n  request: NextRequest,\r\n  maxRequests?: number\r\n): RateLimitResult {\r\n  const store = getEdgeRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.global.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.global.maxRequests,\r\n    identifier: `global:${ip}`,\r\n  });\r\n}\r\n\r\n/**\r\n * Rate limit by API key (Edge - sync, default limit only)\r\n */\r\nexport function rateLimitByApiKeyEdge(\r\n  request: NextRequest,\r\n  defaultLimit?: number\r\n): RateLimitResult | null {\r\n  const token = extractApiKey(request);\r\n  if (!token) return null;\r\n  \r\n  const store = getEdgeRateLimitStore();\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.starter.windowMs,\r\n    maxRequests: defaultLimit || RATE_LIMIT_TIERS.starter.maxRequests,\r\n    identifier: `api_key:${hashKey(token)}`,\r\n  });\r\n}\r\n\r\n// =============================================================================\r\n// RESPONSE HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Add rate limit headers to response\r\n */\r\nexport function addRateLimitHeaders(\r\n  response: NextResponse,\r\n  result: RateLimitResult\r\n): NextResponse {\r\n  response.headers.set('X-RateLimit-Limit', result.limit.toString());\r\n  response.headers.set('X-RateLimit-Remaining', result.remaining.toString());\r\n  response.headers.set('X-RateLimit-Reset', new Date(result.resetAt).toISOString());\r\n  return response;\r\n}\r\n\r\n/**\r\n * Create rate limit error response\r\n */\r\nexport function createRateLimitResponse(result: RateLimitResult): NextResponse {\r\n  const resetDate = new Date(result.resetAt).toISOString();\r\n  const retryAfter = Math.ceil((result.resetAt - Date.now()) / 1000);\r\n  \r\n  const response = NextResponse.json(\r\n    {\r\n      error: 'Rate limit exceeded',\r\n      code: 'RATE_LIMIT_EXCEEDED',\r\n      message: `Too many requests. Limit: ${result.limit} per hour. Try again after ${resetDate}`,\r\n      retryAfter,\r\n    },\r\n    { status: 429 }\r\n  );\r\n  \r\n  response.headers.set('Retry-After', retryAfter.toString());\r\n  return addRateLimitHeaders(response, result);\r\n}\r\n\r\n// =============================================================================\r\n// COMPOSITE CHECKS\r\n// =============================================================================\r\n\r\n/**\r\n * Check all rate limits (API key + endpoint + global)\r\n * Returns first exceeded limit, or null if all pass\r\n */\r\nexport async function checkAllRateLimits(\r\n  request: NextRequest,\r\n  options?: {\r\n    endpointId?: string;\r\n    apiKeyRateLimit?: number;\r\n  }\r\n): Promise<{ result: RateLimitResult; type: string } | null> {\r\n  // 1. Global IP limit\r\n  const globalResult = await rateLimitByIp(request);\r\n  if (!globalResult.allowed) {\r\n    return { result: globalResult, type: 'global' };\r\n  }\r\n  \r\n  // 2. API key limit (if authenticated)\r\n  const apiKeyResult = await rateLimitByApiKey(request, options?.apiKeyRateLimit);\r\n  if (apiKeyResult && !apiKeyResult.allowed) {\r\n    return { result: apiKeyResult, type: 'api_key' };\r\n  }\r\n  \r\n  // 3. Endpoint limit (if specified)\r\n  if (options?.endpointId) {\r\n    const endpointResult = await rateLimitByEndpoint(request, options.endpointId);\r\n    if (!endpointResult.allowed) {\r\n      return { result: endpointResult, type: 'endpoint' };\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * Get rate limit info for response headers (async version)\r\n * Returns the most restrictive limit for informational headers\r\n */\r\nexport async function getRateLimitHeaders(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): Promise<RateLimitResult | null> {\r\n  const results: RateLimitResult[] = [];\r\n\r\n  // Global IP limit\r\n  const globalResult = await rateLimitByIp(request);\r\n  results.push(globalResult);\r\n\r\n  // API key limit\r\n  const apiKeyResult = await rateLimitByApiKey(request);\r\n  if (apiKeyResult) {\r\n    results.push(apiKeyResult);\r\n  }\r\n\r\n  // Endpoint limit\r\n  if (endpointId) {\r\n    const endpointResult = await rateLimitByEndpoint(request, endpointId);\r\n    results.push(endpointResult);\r\n  }\r\n\r\n  // Return the most restrictive (lowest remaining)\r\n  if (results.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return results.reduce((min, current) =>\r\n    current.remaining < min.remaining ? current : min\r\n  );\r\n}\r\n\r\n// =============================================================================\r\n// EDGE-COMPATIBLE FUNCTIONS (Sync)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by endpoint (Edge - sync, in-memory only)\r\n */\r\nexport function rateLimitByEndpointEdge(\r\n  request: NextRequest,\r\n  endpointId: string,\r\n  maxRequests?: number\r\n): RateLimitResult {\r\n  const store = getEdgeRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.endpoint.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.endpoint.maxRequests,\r\n    identifier: `endpoint:${endpointId}:${ip}`,\r\n  });\r\n}\r\n\r\n/**\r\n * Check all rate limits (Edge-compatible, sync version)\r\n * Returns first exceeded limit, or null if all pass\r\n */\r\nexport function checkAllRateLimitsEdge(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): { result: RateLimitResult; type: string } | null {\r\n  // 1. Global IP limit\r\n  const globalResult = rateLimitByIpEdge(request);\r\n  if (!globalResult.allowed) {\r\n    return { result: globalResult, type: 'global' };\r\n  }\r\n  \r\n  // 2. API key limit (Edge uses default limit)\r\n  const apiKeyResult = rateLimitByApiKeyEdge(request);\r\n  if (apiKeyResult && !apiKeyResult.allowed) {\r\n    return { result: apiKeyResult, type: 'api_key' };\r\n  }\r\n  \r\n  // 3. Endpoint limit (if specified)\r\n  if (endpointId) {\r\n    const endpointResult = rateLimitByEndpointEdge(request, endpointId);\r\n    if (!endpointResult.allowed) {\r\n      return { result: endpointResult, type: 'endpoint' };\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * Get rate limit info for response headers (Edge-compatible, sync version)\r\n */\r\nexport function getRateLimitHeadersEdge(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): RateLimitResult | null {\r\n  const results: RateLimitResult[] = [];\r\n\r\n  // Global IP limit\r\n  results.push(rateLimitByIpEdge(request));\r\n\r\n  // API key limit\r\n  const apiKeyResult = rateLimitByApiKeyEdge(request);\r\n  if (apiKeyResult) {\r\n    results.push(apiKeyResult);\r\n  }\r\n\r\n  // Endpoint limit\r\n  if (endpointId) {\r\n    results.push(rateLimitByEndpointEdge(request, endpointId));\r\n  }\r\n\r\n  // Return the most restrictive (lowest remaining)\r\n  if (results.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return results.reduce((min, current) =>\r\n    current.remaining < min.remaining ? current : min\r\n  );\r\n}\r\n\r\n","// =============================================================================\r\n// RATE LIMIT STORE\r\n// =============================================================================\r\n// Pluggable backing store for rate limiting with Upstash Redis support and in-memory fallback.\r\n// Supports distributed rate limiting across serverless instances.\r\n//\r\n// Environment Variables:\r\n// - UPSTASH_REDIS_REST_URL: Upstash Redis REST URL (from Vercel integration)\r\n// - UPSTASH_REDIS_REST_TOKEN: Upstash Redis REST token (from Vercel integration)\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'RateLimitStore' });\r\n\r\nexport interface RateLimitEntry {\r\n  count: number;\r\n  resetAt: number;\r\n}\r\n\r\nexport interface RateLimitStore {\r\n  get(key: string): Promise<RateLimitEntry | null>;\r\n  set(key: string, entry: RateLimitEntry): Promise<void>;\r\n  increment(key: string, windowMs: number): Promise<RateLimitEntry>;\r\n}\r\n\r\n// =============================================================================\r\n// IN-MEMORY STORE (fallback)\r\n// =============================================================================\r\n\r\nclass InMemoryStore implements RateLimitStore {\r\n  private store = new Map<string, RateLimitEntry>();\r\n  private cleanupInterval: ReturnType<typeof setInterval> | null = null;\r\n\r\n  constructor() {\r\n    // Cleanup every 5 minutes\r\n    if (typeof setInterval !== 'undefined') {\r\n      this.cleanupInterval = setInterval(() => this.cleanup(), 5 * 60 * 1000);\r\n    }\r\n  }\r\n\r\n  private cleanup(): void {\r\n    const now = Date.now();\r\n    const keysToDelete: string[] = [];\r\n    this.store.forEach((value, key) => {\r\n      if (value.resetAt < now) {\r\n        keysToDelete.push(key);\r\n      }\r\n    });\r\n    keysToDelete.forEach(key => this.store.delete(key));\r\n  }\r\n\r\n  async get(key: string): Promise<RateLimitEntry | null> {\r\n    const entry = this.store.get(key);\r\n    if (!entry || entry.resetAt < Date.now()) {\r\n      return null;\r\n    }\r\n    return entry;\r\n  }\r\n\r\n  async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n    this.store.set(key, entry);\r\n  }\r\n\r\n  async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n    const now = Date.now();\r\n    const existing = this.store.get(key);\r\n\r\n    if (!existing || existing.resetAt < now) {\r\n      const entry = { count: 1, resetAt: now + windowMs };\r\n      this.store.set(key, entry);\r\n      return entry;\r\n    }\r\n\r\n    existing.count++;\r\n    this.store.set(key, existing);\r\n    return existing;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// UPSTASH REDIS STORE (distributed)\r\n// =============================================================================\r\n\r\nclass UpstashRedisStore implements RateLimitStore {\r\n  private redis: any;\r\n\r\n  constructor(redisClient: any) {\r\n    this.redis = redisClient;\r\n  }\r\n\r\n  async get(key: string): Promise<RateLimitEntry | null> {\r\n    try {\r\n      const data = await this.redis.get(`ratelimit:${key}`);\r\n      if (!data) return null;\r\n      \r\n      // Upstash returns parsed JSON automatically if it's a JSON string\r\n      const entry = typeof data === 'string' ? JSON.parse(data) : data;\r\n      if (entry.resetAt < Date.now()) return null;\r\n      return entry as RateLimitEntry;\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis GET failed');\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n    try {\r\n      const ttlMs = Math.max(entry.resetAt - Date.now(), 1000);\r\n      const ttlSeconds = Math.ceil(ttlMs / 1000);\r\n      \r\n      await this.redis.set(\r\n        `ratelimit:${key}`,\r\n        JSON.stringify(entry),\r\n        { ex: ttlSeconds }\r\n      );\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis SET failed');\r\n    }\r\n  }\r\n\r\n  async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n    try {\r\n      const redisKey = `ratelimit:${key}`;\r\n      const now = Date.now();\r\n\r\n      // Get current entry\r\n      const data = await this.redis.get(redisKey);\r\n      \r\n      let count = 1;\r\n      let resetAt = now + windowMs;\r\n      \r\n      if (data) {\r\n        const entry = typeof data === 'string' ? JSON.parse(data) : data;\r\n        if (entry.resetAt > now) {\r\n          count = entry.count + 1;\r\n          resetAt = entry.resetAt;\r\n        }\r\n      }\r\n      \r\n      const newEntry = { count, resetAt };\r\n      const ttlMs = resetAt - now;\r\n      const ttlSeconds = Math.ceil(ttlMs / 1000);\r\n      \r\n      await this.redis.set(redisKey, JSON.stringify(newEntry), { ex: ttlSeconds });\r\n      \r\n      return newEntry;\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis INCR failed');\r\n      // Fallback: return a permissive entry\r\n      return { count: 1, resetAt: Date.now() + windowMs };\r\n    }\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// STORE FACTORY\r\n// =============================================================================\r\n\r\nlet storeInstance: RateLimitStore | null = null;\r\n\r\n/**\r\n * Get the rate limit store singleton.\r\n * Uses Upstash Redis if configured, otherwise falls back to in-memory.\r\n */\r\nexport async function getRateLimitStore(): Promise<RateLimitStore> {\r\n  if (storeInstance) {\r\n    return storeInstance;\r\n  }\r\n\r\n  // Check for Upstash Redis environment variables (set by Vercel integration)\r\n  const upstashUrl = process.env.UPSTASH_REDIS_REST_URL;\r\n  const upstashToken = process.env.UPSTASH_REDIS_REST_TOKEN;\r\n\r\n  if (upstashUrl && upstashToken) {\r\n    try {\r\n      // Dynamic import to avoid build issues\r\n      const { Redis } = await import('@upstash/redis');\r\n      const redis = new Redis({\r\n        url: upstashUrl,\r\n        token: upstashToken,\r\n      });\r\n\r\n      // Test connection\r\n      await redis.ping();\r\n      \r\n      logger.info('Rate limit store using Upstash Redis');\r\n      storeInstance = new UpstashRedisStore(redis);\r\n      return storeInstance;\r\n    } catch (error) {\r\n      logger.warn({ error }, 'Upstash Redis connection failed, falling back to in-memory');\r\n    }\r\n  }\r\n\r\n  // Legacy support: check for REDIS_URL (ioredis)\r\n  const redisUrl = process.env.REDIS_URL;\r\n  if (redisUrl) {\r\n    try {\r\n      const { Redis } = await import('ioredis');\r\n      const redis = new Redis(redisUrl, {\r\n        maxRetriesPerRequest: 3,\r\n        enableReadyCheck: true,\r\n        connectTimeout: 5000,\r\n        lazyConnect: true,\r\n      });\r\n\r\n      await redis.connect();\r\n      logger.info('Rate limit store using Redis (ioredis)');\r\n      \r\n      // Use a simple wrapper that matches UpstashRedisStore behavior\r\n      storeInstance = {\r\n        async get(key: string): Promise<RateLimitEntry | null> {\r\n          const data = await redis.get(`ratelimit:${key}`);\r\n          if (!data) return null;\r\n          const entry = JSON.parse(data) as RateLimitEntry;\r\n          if (entry.resetAt < Date.now()) return null;\r\n          return entry;\r\n        },\r\n        async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n          const ttlMs = Math.max(entry.resetAt - Date.now(), 1000);\r\n          await redis.set(`ratelimit:${key}`, JSON.stringify(entry), 'PX', ttlMs);\r\n        },\r\n        async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n          const now = Date.now();\r\n          const redisKey = `ratelimit:${key}`;\r\n          const data = await redis.get(redisKey);\r\n          \r\n          let count = 1;\r\n          let resetAt = now + windowMs;\r\n          \r\n          if (data) {\r\n            const entry = JSON.parse(data);\r\n            if (entry.resetAt > now) {\r\n              count = entry.count + 1;\r\n              resetAt = entry.resetAt;\r\n            }\r\n          }\r\n          \r\n          const newEntry = { count, resetAt };\r\n          const ttlMs = resetAt - now;\r\n          await redis.set(redisKey, JSON.stringify(newEntry), 'PX', ttlMs);\r\n          return newEntry;\r\n        }\r\n      };\r\n      return storeInstance;\r\n    } catch (error) {\r\n      logger.warn({ error }, 'Redis connection failed, falling back to in-memory');\r\n    }\r\n  }\r\n\r\n  logger.info('Rate limit store using in-memory (non-distributed)');\r\n  storeInstance = new InMemoryStore();\r\n  return storeInstance;\r\n}\r\n\r\n/**\r\n * Synchronous in-memory store for Edge runtime.\r\n * Edge runtime can use Upstash but requires async initialization.\r\n */\r\nexport function getEdgeRateLimitStore(): RateLimitStore {\r\n  // Edge runtime uses in-memory for sync access\r\n  // For async Edge operations, use getRateLimitStore()\r\n  if (!storeInstance) {\r\n    storeInstance = new InMemoryStore();\r\n  }\r\n  return storeInstance;\r\n}\r\n\r\n/**\r\n * Reset the store singleton (for testing)\r\n */\r\nexport function resetRateLimitStore(): void {\r\n  storeInstance = null;\r\n}\r\n","import nodeCrypto from 'node:crypto';\n\nconst subtle = nodeCrypto.webcrypto?.subtle || {};\nconst randomUUID = () => {\n  return nodeCrypto.randomUUID();\n};\nconst getRandomValues = (array) => {\n  return nodeCrypto.webcrypto.getRandomValues(array);\n};\nconst _crypto = {\n  randomUUID,\n  getRandomValues,\n  subtle\n};\n\nexport { _crypto as default, getRandomValues, randomUUID, subtle };\n","import type { Address, TypedData } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport { type GetAddressErrorType, getAddress } from '../address/getAddress.js'\nimport {\n  type IsAddressEqualErrorType,\n  isAddressEqual,\n} from '../address/isAddressEqual.js'\nimport {\n  type RecoverTypedDataAddressParameters,\n  recoverTypedDataAddress,\n} from './recoverTypedDataAddress.js'\n\nexport type VerifyTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType> & {\n  /** The address to verify the typed data for. */\n  address: Address\n  /** The signature to verify */\n  signature: Hex | ByteArray | Signature\n}\n\nexport type VerifyTypedDataReturnType = boolean\n\nexport type VerifyTypedDataErrorType =\n  | IsAddressEqualErrorType\n  | GetAddressErrorType\n  | RecoverTypedDataAddressParameters\n  | ErrorType\n\n/**\n * Verify that typed data was signed by the provided address.\n *\n * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.\n *        It is highly recommended to use `publicClient.verifyTypedData` instead to ensure\n *        wallet interoperability.\n *\n * - Docs {@link https://viem.sh/docs/utilities/verifyTypedData}\n *\n * @param parameters - {@link VerifyTypedDataParameters}\n * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}\n */\nexport async function verifyTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: VerifyTypedDataParameters<typedData, primaryType>,\n): Promise<VerifyTypedDataReturnType> {\n  const { address, domain, message, primaryType, signature, types } =\n    parameters as unknown as VerifyTypedDataParameters\n  return isAddressEqual(\n    getAddress(address),\n    await recoverTypedDataAddress({\n      domain,\n      message,\n      primaryType,\n      signature,\n      types,\n    } as RecoverTypedDataAddressParameters),\n  )\n}\n","import type { Address, TypedData } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport { type HashTypedDataErrorType, hashTypedData } from './hashTypedData.js'\nimport {\n  type RecoverAddressErrorType,\n  recoverAddress,\n} from './recoverAddress.js'\n\nexport type RecoverTypedDataAddressParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType> & {\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverTypedDataAddressReturnType = Address\n\nexport type RecoverTypedDataAddressErrorType =\n  | RecoverAddressErrorType\n  | HashTypedDataErrorType\n  | ErrorType\n\nexport async function recoverTypedDataAddress<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: RecoverTypedDataAddressParameters<typedData, primaryType>,\n): Promise<RecoverTypedDataAddressReturnType> {\n  const { domain, message, primaryType, signature, types } =\n    parameters as unknown as RecoverTypedDataAddressParameters\n  return recoverAddress({\n    hash: hashTypedData({\n      domain,\n      message,\n      primaryType,\n      types,\n    }),\n    signature,\n  })\n}\n","// =============================================================================\r\n// API Keys Database Layer\r\n// =============================================================================\r\n\r\nimport crypto from 'crypto';\r\nimport { getDb } from './client';\r\n\r\nexport type ApiKeyRole = 'admin' | 'user' | 'read-only';\r\n\r\nexport interface ApiKey {\r\n  id: string;\r\n  keyHash: string;\r\n  name: string;\r\n  role: ApiKeyRole;\r\n  userId?: string;\r\n  rateLimit: number;\r\n  lastUsedAt?: string;\r\n  lastUsedIp?: string; // IP address of last use\r\n  expiresAt?: string;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  revokedAt?: string;\r\n  // x402 demo allowance tracking\r\n  x402DemoCallsUsed?: number;\r\n  x402DemoCallsLimit?: number;\r\n  x402DemoAmountUsed?: string; // Stored as string for precision\r\n  x402DemoAmountLimit?: string; // Stored as string for precision\r\n}\r\n\r\nexport interface CreateApiKeyInput {\r\n  name: string;\r\n  role?: ApiKeyRole;\r\n  userId?: string;\r\n  rateLimit?: number;\r\n  expiresAt?: string;\r\n}\r\n\r\nexport interface ApiKeyWithToken extends Omit<ApiKey, 'keyHash'> {\r\n  token: string; // Only returned on creation\r\n}\r\n\r\n/**\r\n * Generate a secure API key\r\n * \r\n * Security: Uses 32 bytes (256 bits) of cryptographically secure randomness.\r\n * Format: nf_live_<base64url_encoded_random_bytes>\r\n * \r\n * The prefix \"nf_live_\" is just for display/identification; the entropy\r\n * comes from the 32 random bytes, which when base64url encoded gives ~43 chars.\r\n */\r\nexport function generateApiKey(): string {\r\n  // Use 32 bytes (256 bits) of entropy for strong security\r\n  const randomBytes = crypto.randomBytes(32);\r\n  // Base64url encoding of 32 bytes gives ~43 characters (no padding needed)\r\n  const key = randomBytes.toString('base64url');\r\n  return `nf_live_${key}`;\r\n}\r\n\r\n/**\r\n * Hash an API key for storage\r\n */\r\nexport function hashApiKey(key: string): string {\r\n  return crypto.createHash('sha256').update(key).digest('hex');\r\n}\r\n\r\n/**\r\n * Create a new API key\r\n */\r\nexport async function createApiKey(input: CreateApiKeyInput): Promise<ApiKeyWithToken> {\r\n  const db = getDb();\r\n  const id = `key_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n  const token = generateApiKey();\r\n  const keyHash = hashApiKey(token);\r\n  const now = new Date().toISOString();\r\n\r\n  const apiKey: ApiKey = {\r\n    id,\r\n    keyHash,\r\n    name: input.name,\r\n    role: input.role || 'user',\r\n    userId: input.userId,\r\n    rateLimit: input.rateLimit || 1000,\r\n    expiresAt: input.expiresAt,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  };\r\n\r\n  // Use adapter to insert\r\n  await db.createApiKey(apiKey);\r\n\r\n  return {\r\n    ...apiKey,\r\n    token, // Include the plain token only on creation\r\n  };\r\n}\r\n\r\n/**\r\n * Find API key by hash\r\n */\r\nexport async function findApiKeyByHash(keyHash: string): Promise<ApiKey | null> {\r\n  const db = getDb();\r\n  return await db.findApiKeyByHash(keyHash);\r\n}\r\n\r\n/**\r\n * Find API key by token (validates and returns key)\r\n */\r\nexport async function findApiKeyByToken(token: string): Promise<ApiKey | null> {\r\n  const keyHash = hashApiKey(token);\r\n  return await findApiKeyByHash(keyHash);\r\n}\r\n\r\n/**\r\n * Update API key last used timestamp and IP address\r\n */\r\nexport async function updateApiKeyLastUsed(keyId: string, ipAddress?: string): Promise<void> {\r\n  const db = getDb();\r\n  await db.updateApiKeyLastUsed(keyId, ipAddress);\r\n}\r\n\r\n/**\r\n * Revoke an API key (soft delete)\r\n */\r\nexport async function revokeApiKey(keyId: string): Promise<boolean> {\r\n  const db = getDb();\r\n  return await db.revokeApiKey(keyId);\r\n}\r\n\r\n/**\r\n * List API keys for a user\r\n */\r\nexport async function listApiKeys(userId?: string): Promise<ApiKey[]> {\r\n  const db = getDb();\r\n  return await db.listApiKeys(userId);\r\n}\r\n\r\n/**\r\n * Update x402 demo allowance usage\r\n */\r\nexport async function updateApiKeyX402DemoAllowance(\r\n  keyId: string,\r\n  callsUsed: number,\r\n  amountUsed: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  await db.updateApiKeyX402DemoAllowance(keyId, callsUsed, amountUsed);\r\n}\r\n\r\n/**\r\n * Check if API key has remaining x402 demo allowance\r\n */\r\nexport function hasX402DemoAllowance(apiKey: ApiKey): {\r\n  hasAllowance: boolean;\r\n  callsRemaining: number;\r\n  amountRemaining: string;\r\n  reason?: string;\r\n} {\r\n  const callsUsed = apiKey.x402DemoCallsUsed || 0;\r\n  const callsLimit = apiKey.x402DemoCallsLimit || 200;\r\n  const amountUsed = BigInt(apiKey.x402DemoAmountUsed || '0');\r\n  const amountLimit = BigInt(apiKey.x402DemoAmountLimit || '1000000');\r\n  \r\n  if (callsUsed >= callsLimit) {\r\n    return {\r\n      hasAllowance: false,\r\n      callsRemaining: 0,\r\n      amountRemaining: '0',\r\n      reason: 'Calls limit reached',\r\n    };\r\n  }\r\n  \r\n  if (amountUsed >= amountLimit) {\r\n    return {\r\n      hasAllowance: false,\r\n      callsRemaining: callsLimit - callsUsed,\r\n      amountRemaining: '0',\r\n      reason: 'Amount limit reached',\r\n    };\r\n  }\r\n  \r\n  return {\r\n    hasAllowance: true,\r\n    callsRemaining: callsLimit - callsUsed,\r\n    amountRemaining: (amountLimit - amountUsed).toString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Update x402 demo limits for an API key\r\n */\r\nexport async function updateApiKeyX402DemoLimits(\r\n  keyId: string,\r\n  callsLimit?: number,\r\n  amountLimit?: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  await db.updateApiKeyX402DemoLimits(keyId, callsLimit, amountLimit);\r\n}\r\n\r\n/**\r\n * Find API key by ID (not hash)\r\n */\r\nexport async function findApiKeyById(keyId: string): Promise<ApiKey | null> {\r\n  const allKeys = await listApiKeys();\r\n  return allKeys.find(k => k.id === keyId) || null;\r\n}\r\n\r\n","// =============================================================================\r\n// Authentication Middleware\r\n// =============================================================================\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { findApiKeyByToken, updateApiKeyLastUsed, type ApiKey, type ApiKeyRole } from '@/db/api-keys';\r\n\r\nexport interface AuthenticatedRequest extends NextRequest {\r\n  apiKey?: ApiKey;\r\n}\r\n\r\n/**\r\n * Extract API key from request headers\r\n * Supports:\r\n * - Authorization: Bearer <token> or <token>\r\n * - x-api-key: <token>\r\n */\r\nexport function extractApiKey(request: NextRequest): string | null {\r\n  // First try x-api-key header (standard for API keys)\r\n  const apiKeyHeader = request.headers.get('x-api-key');\r\n  if (apiKeyHeader) {\r\n    return apiKeyHeader.trim();\r\n  }\r\n\r\n  // Fall back to Authorization header\r\n  const authHeader = request.headers.get('authorization');\r\n  if (!authHeader) return null;\r\n\r\n  // Support both \"Bearer <token>\" and \"<token>\" formats\r\n  if (authHeader.startsWith('Bearer ')) {\r\n    return authHeader.substring(7).trim();\r\n  }\r\n  return authHeader.trim();\r\n}\r\n\r\n/**\r\n * Authenticate request using API key\r\n */\r\nexport async function authenticateRequest(\r\n  request: NextRequest\r\n): Promise<{ apiKey: ApiKey } | { error: string; status: number }> {\r\n  const token = extractApiKey(request);\r\n\r\n  if (!token) {\r\n    return {\r\n      error: 'Authentication required',\r\n      status: 401,\r\n    };\r\n  }\r\n\r\n  // Validate token format (nf_live_... or nf_test_...)\r\n  if (!token.startsWith('nf_live_') && !token.startsWith('nf_test_')) {\r\n    return {\r\n      error: 'Invalid API key format',\r\n      status: 401,\r\n    };\r\n  }\r\n\r\n  // Find API key in database\r\n  const apiKey = await findApiKeyByToken(token);\r\n\r\n  if (!apiKey) {\r\n    return {\r\n      error: 'Invalid API key',\r\n      status: 401,\r\n    };\r\n  }\r\n\r\n  // Check if key is expired\r\n  if (apiKey.expiresAt && new Date(apiKey.expiresAt) < new Date()) {\r\n    return {\r\n      error: 'API key has expired',\r\n      status: 401,\r\n    };\r\n  }\r\n\r\n  // Extract IP address for tracking\r\n  const ipAddress = request.ip || \r\n    request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || \r\n    request.headers.get('x-real-ip') || \r\n    undefined;\r\n\r\n  // Update last used timestamp and IP (fire and forget)\r\n  updateApiKeyLastUsed(apiKey.id, ipAddress).catch((err) => {\r\n    console.error('[auth] Failed to update last used:', err);\r\n  });\r\n\r\n  return { apiKey };\r\n}\r\n\r\n/**\r\n * Check if API key has required role\r\n */\r\nexport function hasRole(apiKey: ApiKey, requiredRole: ApiKeyRole): boolean {\r\n  const roleHierarchy: Record<ApiKeyRole, number> = {\r\n    'read-only': 1,\r\n    'user': 2,\r\n    'admin': 3,\r\n  };\r\n\r\n  return roleHierarchy[apiKey.role] >= roleHierarchy[requiredRole];\r\n}\r\n\r\n/**\r\n * Require authentication middleware\r\n * Returns authenticated API key or error response\r\n */\r\nexport async function requireAuth(\r\n  request: NextRequest,\r\n  requiredRole: ApiKeyRole = 'user'\r\n): Promise<\r\n  | { apiKey: ApiKey; response?: never }\r\n  | { apiKey?: never; response: NextResponse }\r\n> {\r\n  const authResult = await authenticateRequest(request);\r\n\r\n  if ('error' in authResult) {\r\n    return {\r\n      response: NextResponse.json(\r\n        {\r\n          error: authResult.error,\r\n          code: 'UNAUTHORIZED',\r\n        },\r\n        { status: authResult.status }\r\n      ),\r\n    };\r\n  }\r\n\r\n  // Check role\r\n  if (!hasRole(authResult.apiKey, requiredRole)) {\r\n    return {\r\n      response: NextResponse.json(\r\n        {\r\n          error: 'Insufficient permissions',\r\n          code: 'FORBIDDEN',\r\n          details: `Required role: ${requiredRole}, your role: ${authResult.apiKey.role}`,\r\n        },\r\n        { status: 403 }\r\n      ),\r\n    };\r\n  }\r\n\r\n  return { apiKey: authResult.apiKey };\r\n}\r\n\r\n/**\r\n * Require any of the specified roles\r\n * Useful for routes that allow multiple role levels\r\n */\r\nexport async function requireAnyRole(\r\n  request: NextRequest,\r\n  allowedRoles: ApiKeyRole[]\r\n): Promise<\r\n  | { apiKey: ApiKey; response?: never }\r\n  | { apiKey?: never; response: NextResponse }\r\n> {\r\n  const authResult = await authenticateRequest(request);\r\n\r\n  if ('error' in authResult) {\r\n    return {\r\n      response: NextResponse.json(\r\n        {\r\n          error: authResult.error,\r\n          code: 'UNAUTHORIZED',\r\n        },\r\n        { status: authResult.status }\r\n      ),\r\n    };\r\n  }\r\n\r\n  // Check if API key has any of the allowed roles\r\n  const hasAllowedRole = allowedRoles.some(role => hasRole(authResult.apiKey, role));\r\n  \r\n  if (!hasAllowedRole) {\r\n    return {\r\n      response: NextResponse.json(\r\n        {\r\n          error: 'Insufficient permissions',\r\n          code: 'FORBIDDEN',\r\n          details: `Required one of roles: ${allowedRoles.join(', ')}, your role: ${authResult.apiKey.role}`,\r\n        },\r\n        { status: 403 }\r\n      ),\r\n    };\r\n  }\r\n\r\n  return { apiKey: authResult.apiKey };\r\n}\r\n\r\n","// =============================================================================\r\n// Request ID Tracking\r\n// =============================================================================\r\n// Generates and tracks request IDs for request correlation\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { createLogger, type LogContext } from './logger';\r\n\r\nconst REQUEST_ID_HEADER = 'x-request-id';\r\nconst REQUEST_ID_CONTEXT_KEY = 'requestId';\r\n\r\n/**\r\n * Generate a unique request ID (UUID v4 format)\r\n * Edge-compatible using Web Crypto API\r\n */\r\nexport function generateRequestId(): string {\r\n  // Generate UUID v4 format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\r\n  const array = new Uint8Array(16);\r\n  crypto.getRandomValues(array);\r\n  \r\n  // Set version (4) and variant bits\r\n  array[6] = (array[6] & 0x0f) | 0x40; // Version 4\r\n  array[8] = (array[8] & 0x3f) | 0x80; // Variant 10\r\n  \r\n  // Convert to UUID string format\r\n  const hex = Array.from(array)\r\n    .map(b => b.toString(16).padStart(2, '0'))\r\n    .join('');\r\n  \r\n  return [\r\n    hex.substring(0, 8),\r\n    hex.substring(8, 12),\r\n    hex.substring(12, 16),\r\n    hex.substring(16, 20),\r\n    hex.substring(20, 32),\r\n  ].join('-');\r\n}\r\n\r\n/**\r\n * Extract request ID from headers or generate a new one\r\n * \r\n * Trusts x-request-id from trusted sources (configurable via TRUSTED_REQUEST_ID_SOURCES env var)\r\n * Default: trusts all sources (can be restricted to specific IPs/domains)\r\n */\r\nexport function getOrCreateRequestId(request: NextRequest): string {\r\n  const existingId = request.headers.get(REQUEST_ID_HEADER);\r\n  \r\n  if (existingId) {\r\n    // Check if we should trust this request ID\r\n    const trustedSources = process.env.TRUSTED_REQUEST_ID_SOURCES?.split(',') || [];\r\n    const shouldTrust = trustedSources.length === 0 || \r\n      trustedSources.some(source => {\r\n        const origin = request.headers.get('origin') || '';\r\n        const referer = request.headers.get('referer') || '';\r\n        return origin.includes(source) || referer.includes(source);\r\n      });\r\n    \r\n    if (shouldTrust) {\r\n      return existingId;\r\n    }\r\n  }\r\n  \r\n  return generateRequestId();\r\n}\r\n\r\n/**\r\n * Add request ID to response headers\r\n */\r\nexport function addRequestIdToResponse(\r\n  response: NextResponse,\r\n  requestId: string\r\n): NextResponse {\r\n  response.headers.set(REQUEST_ID_HEADER, requestId);\r\n  return response;\r\n}\r\n\r\n/**\r\n * Get request ID from AsyncLocalStorage (if available)\r\n */\r\nexport function getRequestId(): string | undefined {\r\n  // In Next.js, we'll use headers instead of AsyncLocalStorage\r\n  // This is simpler and works with the serverless model\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Create a logger with request ID context\r\n * Uses full Pino logger for structured logging\r\n * Works in both Node.js and Edge runtime (Pino handles Edge compatibility)\r\n */\r\nexport function createRequestLogger(requestId: string, additionalContext?: Record<string, any>) {\r\n  const context: LogContext = { requestId, ...additionalContext };\r\n  const logger = createLogger(context);\r\n  \r\n  return {\r\n    info: (message: string, meta?: LogContext) => {\r\n      logger.info({ ...context, ...meta }, message);\r\n    },\r\n    warn: (message: string, meta?: LogContext) => {\r\n      logger.warn({ ...context, ...meta }, message);\r\n    },\r\n    error: (message: string, meta?: LogContext) => {\r\n      logger.error({ ...context, ...meta }, message);\r\n    },\r\n    debug: (message: string, meta?: LogContext) => {\r\n      logger.debug({ ...context, ...meta }, message);\r\n    },\r\n  };\r\n}\r\n\r\n","// =============================================================================\r\n// Request Logging Helper\r\n// =============================================================================\r\n// Provides helpers for consistent request logging across all API routes\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { getOrCreateRequestId, createRequestLogger, addRequestIdToResponse } from './request-id';\r\nimport { type LogContext } from './logger';\r\nimport { setSentryContext, captureException } from './sentry';\r\nimport { extractApiKey } from './auth';\r\nimport { findApiKeyByToken } from '@/db/api-keys';\r\n\r\n/**\r\n * Request context extracted from request\r\n */\r\nexport interface RequestContext {\r\n  requestId: string;\r\n  apiKeyId?: string;\r\n  endpoint?: string;\r\n  method: string;\r\n  ip?: string;\r\n  startTime: number;\r\n}\r\n\r\n/**\r\n * Extract request context for logging\r\n */\r\nexport async function extractRequestContext(\r\n  request: NextRequest,\r\n  endpoint?: string\r\n): Promise<RequestContext> {\r\n  const requestId = getOrCreateRequestId(request);\r\n  const ip = request.ip || \r\n    request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || \r\n    request.headers.get('x-real-ip') || \r\n    undefined;\r\n  \r\n  // Try to get API key ID for context\r\n  let apiKeyId: string | undefined;\r\n  try {\r\n    const token = extractApiKey(request);\r\n    if (token) {\r\n      const apiKey = await findApiKeyByToken(token);\r\n      if (apiKey) {\r\n        apiKeyId = apiKey.id;\r\n      }\r\n    }\r\n  } catch {\r\n    // Ignore errors when extracting API key (not critical for logging)\r\n  }\r\n  \r\n  // Set Sentry context\r\n  setSentryContext({\r\n    requestId,\r\n    apiKeyId,\r\n    endpoint: endpoint || request.nextUrl.pathname,\r\n    method: request.method,\r\n  });\r\n  \r\n  return {\r\n    requestId,\r\n    apiKeyId,\r\n    endpoint: endpoint || request.nextUrl.pathname,\r\n    method: request.method,\r\n    ip,\r\n    startTime: Date.now(),\r\n  };\r\n}\r\n\r\n/**\r\n * Log request completion\r\n */\r\nexport function logRequestCompletion(\r\n  ctx: RequestContext,\r\n  statusCode: number,\r\n  error?: Error\r\n) {\r\n  const duration = Date.now() - ctx.startTime;\r\n  const logger = createRequestLogger(ctx.requestId, {\r\n    method: ctx.method,\r\n    endpoint: ctx.endpoint,\r\n    ip: ctx.ip,\r\n  });\r\n  \r\n  const logContext: LogContext = {\r\n    requestId: ctx.requestId,\r\n    apiKeyId: ctx.apiKeyId,\r\n    endpoint: ctx.endpoint,\r\n    method: ctx.method,\r\n    statusCode,\r\n    durationMs: duration,\r\n    ip: ctx.ip,\r\n  };\r\n  \r\n  if (error) {\r\n    logContext.error = error;\r\n    logContext.errorCode = (error as any).code || 'UNKNOWN_ERROR';\r\n    logContext.stack = error.stack;\r\n    \r\n    logger.error(logContext, `Request failed: ${ctx.method} ${ctx.endpoint}`);\r\n    \r\n    // Capture in Sentry\r\n    captureException(error, {\r\n      requestId: ctx.requestId,\r\n      apiKeyId: ctx.apiKeyId,\r\n      endpoint: ctx.endpoint,\r\n    });\r\n  } else {\r\n    logger.info(logContext, `Request completed: ${ctx.method} ${ctx.endpoint}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Wrap response with request ID and logging\r\n */\r\nexport function wrapResponse(\r\n  response: NextResponse,\r\n  ctx: RequestContext,\r\n  error?: Error\r\n): NextResponse {\r\n  // Add request ID to response\r\n  addRequestIdToResponse(response, ctx.requestId);\r\n  \r\n  // Log completion\r\n  logRequestCompletion(ctx, response.status, error);\r\n  \r\n  return response;\r\n}\r\n\r\n/**\r\n * Create error response with logging\r\n */\r\nexport function createErrorResponse(\r\n  ctx: RequestContext,\r\n  error: Error | string,\r\n  statusCode: number = 500,\r\n  code?: string\r\n): NextResponse {\r\n  const errorObj = error instanceof Error ? error : new Error(error);\r\n  const errorCode = code || (errorObj as any).code || 'INTERNAL_ERROR';\r\n  \r\n  const response = NextResponse.json(\r\n    {\r\n      error: errorObj.message,\r\n      code: errorCode,\r\n      requestId: ctx.requestId,\r\n    },\r\n    { status: statusCode }\r\n  );\r\n  \r\n  return wrapResponse(response, ctx, errorObj);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","// =============================================================================\r\n// METERED ENDPOINTS DATABASE\r\n// =============================================================================\r\n// Database layer for metered endpoints, payments, and usage tracking\r\n// Uses adapter pattern: SQLite (dev) or PostgreSQL (prod)\r\n\r\nimport { getDb } from './client';\r\nimport type { DatabaseAdapter } from './adapters/base-adapter';\r\n\r\n// Types\r\nexport interface MeteredEndpoint {\r\n  id: string;\r\n  name: string;\r\n  description?: string;\r\n  upstreamUrl: string;\r\n  price: string; // Price in smallest unit (e.g., 1000000 for 1 USDC)\r\n  network: string; // 'base', 'base-sepolia', etc.\r\n  tokenAddress: string; // USDC address\r\n  tokenSymbol: string; // 'USDC'\r\n  chainId: number;\r\n  recipientAddress: string; // Address that receives payments (must not be blacklisted)\r\n  status: 'active' | 'paused' | 'deleted';\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  createdBy?: string; // User/API key that created it\r\n}\r\n\r\nexport interface Payment {\r\n  id: string;\r\n  endpointId: string;\r\n  txHash: string;\r\n  fromAddress: string;\r\n  toAddress: string;\r\n  amount: string;\r\n  tokenAddress: string;\r\n  network: string;\r\n  verifiedAt: string;\r\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\r\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\r\n  facilitator: string; // 'cdp', 'payai', etc.\r\n}\r\n\r\nexport interface UsageLog {\r\n  id: string;\r\n  endpointId: string;\r\n  paymentId?: string; // Link to payment if payment was required\r\n  timestamp: string;\r\n  method: string; // HTTP method\r\n  path: string;\r\n  statusCode: number;\r\n  responseTime: number; // milliseconds\r\n  units: number; // Usage units (could be 1 per call, or based on response size, etc.)\r\n  ipAddress?: string;\r\n  userAgent?: string;\r\n  // Observability fields\r\n  conversationId?: string; // Conversation/request ID for tracing\r\n  agentId?: string; // Agent ID that made the request\r\n  x402TxHash?: string; // x402 transaction hash\r\n  failureCode?: string; // Error code if request failed\r\n}\r\n\r\n// =============================================================================\r\n// ENDPOINTS CRUD\r\n// =============================================================================\r\n\r\nexport async function createEndpoint(\r\n  endpoint: Omit<MeteredEndpoint, 'id' | 'createdAt' | 'updatedAt'> & { id?: string }\r\n): Promise<MeteredEndpoint> {\r\n  const db = getDb();\r\n  return await db.createEndpoint(endpoint);\r\n}\r\n\r\nexport async function getEndpoint(endpointId: string): Promise<MeteredEndpoint | null> {\r\n  const db = getDb();\r\n  return await db.getEndpoint(endpointId);\r\n}\r\n\r\nexport async function listEndpoints(filters?: { status?: string; createdBy?: string }): Promise<MeteredEndpoint[]> {\r\n  const db = getDb();\r\n  return await db.listEndpoints(filters);\r\n}\r\n\r\nexport async function updateEndpoint(\r\n  endpointId: string,\r\n  updates: Partial<MeteredEndpoint>\r\n): Promise<MeteredEndpoint | null> {\r\n  const db = getDb();\r\n  return await db.updateEndpoint(endpointId, updates);\r\n}\r\n\r\nexport async function deleteEndpoint(endpointId: string): Promise<boolean> {\r\n  const db = getDb();\r\n  return await db.deleteEndpoint(endpointId);\r\n}\r\n\r\n// =============================================================================\r\n// PAYMENTS CRUD\r\n// =============================================================================\r\n\r\nexport async function createPayment(payment: Omit<Payment, 'id' | 'verifiedAt'>): Promise<Payment> {\r\n  const db = getDb();\r\n  return await db.createPayment(payment);\r\n}\r\n\r\nexport async function getPayment(paymentId: string): Promise<Payment | null> {\r\n  const db = getDb();\r\n  return await db.getPayment(paymentId);\r\n}\r\n\r\nexport async function getPaymentByTxHash(txHash: string): Promise<Payment | null> {\r\n  const db = getDb();\r\n  return await db.getPaymentByTxHash(txHash);\r\n}\r\n\r\nexport async function listPayments(filters?: { endpointId?: string; fromAddress?: string }): Promise<Payment[]> {\r\n  const db = getDb();\r\n  return await db.listPayments(filters);\r\n}\r\n\r\nexport async function getPaymentsForEndpoint(endpointId: string, limit: number = 100): Promise<Payment[]> {\r\n  const db = getDb();\r\n  return await db.getPaymentsForEndpoint(endpointId, limit);\r\n}\r\n\r\n// =============================================================================\r\n// USAGE LOGS CRUD\r\n// =============================================================================\r\n\r\nexport async function createUsageLog(log: Omit<UsageLog, 'id' | 'timestamp'>): Promise<UsageLog> {\r\n  const db = getDb();\r\n  return await db.createUsageLog(log);\r\n}\r\n\r\nexport async function listUsageLogs(filters?: { endpointId?: string; paymentId?: string }): Promise<UsageLog[]> {\r\n  const db = getDb();\r\n  return await db.listUsageLogs(filters);\r\n}\r\n\r\nexport async function getUsageStats(\r\n  endpointId: string,\r\n  startDate?: string,\r\n  endDate?: string\r\n): Promise<{\r\n  totalRequests: number;\r\n  totalPayments: number;\r\n  totalRevenue: string;\r\n  averageResponseTime: number;\r\n}> {\r\n  const db = getDb();\r\n  return await db.getUsageStats(endpointId, startDate, endDate);\r\n}\r\n","// =============================================================================\n// X402 CALL LOG\n// =============================================================================\n// Canonical x402 log event interface and logging utilities\n// Maps to UsageLog in database for persistence\n\nimport { createUsageLog, listUsageLogs, type UsageLog } from '@/db/metered-endpoints';\nimport { createLogger } from '@/lib/logger';\n\nconst logger = createLogger({ component: 'X402CallLog' });\n\n/**\n * Canonical x402 call log event\n * This interface represents the complete x402 payment flow for a single API call\n */\nexport interface X402CallLog {\n  id: string;\n  timestamp: string;\n  customerId: string | null;\n  endpointId: string;\n  agentId: string | null;\n  facilitator: string;\n  chainId: string;\n  asset: string;\n  amount: string;\n  status: 'success' | 'failed';\n  errorCode?: string;\n  x402TxHash?: string;\n  latencyMs: number;\n  resource: string;\n}\n\n/**\n * Convert X402CallLog to UsageLog for database persistence\n */\nfunction x402CallLogToUsageLog(x402Log: Omit<X402CallLog, 'id' | 'timestamp'>): Omit<UsageLog, 'id' | 'timestamp'> {\n  return {\n    endpointId: x402Log.endpointId,\n    method: 'POST', // Default for metered endpoints\n    path: new URL(x402Log.resource).pathname,\n    statusCode: x402Log.status === 'success' ? 200 : (x402Log.errorCode === 'PAYMENT_REQUIRED' ? 402 : 400),\n    responseTime: x402Log.latencyMs,\n    units: 1, // 1 unit per call\n    conversationId: x402Log.customerId || undefined,\n    agentId: x402Log.agentId || undefined,\n    x402TxHash: x402Log.x402TxHash || undefined,\n    failureCode: x402Log.status === 'failed' ? (x402Log.errorCode || 'UNKNOWN_ERROR') : undefined,\n  };\n}\n\n/**\n * Convert UsageLog back to X402CallLog for retrieval\n * This reconstructs the X402CallLog from the stored UsageLog\n */\nexport function usageLogToX402CallLog(usageLog: UsageLog, metadata?: {\n  facilitator?: string;\n  chainId?: string;\n  asset?: string;\n  amount?: string;\n  resource?: string;\n}): X402CallLog {\n  // Determine status from statusCode and failureCode\n  const status: 'success' | 'failed' = usageLog.statusCode === 200 && !usageLog.failureCode ? 'success' : 'failed';\n  \n  // Reconstruct resource URL from path\n  const appUrl = process.env.NEXT_PUBLIC_APP_URL;\n  const baseUrl = appUrl || (process.env.NODE_ENV === 'production' ? '' : 'http://localhost:3001');\n  // Ensure path starts with / (fix for paths like \"3001/api/...\" that should be \"/api/...\")\n  const normalizedPath = usageLog.path.startsWith('/') ? usageLog.path : `/${usageLog.path.replace(/^\\d+\\//, '')}`;\n  const resource = metadata?.resource || `${baseUrl}${normalizedPath}`;\n  \n  // Infer facilitator from verify mode if not provided in metadata\n  // This handles cases where facilitator wasn't stored in the database\n  let facilitator = metadata?.facilitator;\n  if (!facilitator) {\n    const verifyMode = process.env.X402_VERIFY_MODE?.toLowerCase();\n    if (verifyMode === 'cdp') {\n      facilitator = 'CDP';\n    } else if (verifyMode === 'test') {\n      facilitator = 'TEST_FACILITATOR';\n    } else {\n      facilitator = 'UNKNOWN';\n    }\n  }\n  \n  return {\n    id: usageLog.id,\n    timestamp: usageLog.timestamp,\n    customerId: usageLog.conversationId || null,\n    endpointId: usageLog.endpointId,\n    agentId: usageLog.agentId || null,\n    facilitator,\n    chainId: metadata?.chainId || 'eip155:8453',\n    asset: metadata?.asset || 'USDC_TEST',\n    amount: metadata?.amount || '10000',\n    status,\n    errorCode: usageLog.failureCode,\n    x402TxHash: usageLog.x402TxHash,\n    latencyMs: usageLog.responseTime,\n    resource,\n  };\n}\n\n/**\n * Query X402CallLog entries from the database\n * Filters by endpointId and optionally limits results\n */\nexport async function getX402CallLogs(\n  endpointId: string,\n  options?: {\n    limit?: number;\n    startDate?: string;\n    endDate?: string;\n  }\n): Promise<X402CallLog[]> {\n  try {\n    const usageLogs = await listUsageLogs({ endpointId });\n    \n    // Sort by timestamp descending (most recent first)\n    usageLogs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n    \n    // Apply date filters if provided\n    let filtered = usageLogs;\n    if (options?.startDate) {\n      filtered = filtered.filter(log => log.timestamp >= options.startDate!);\n    }\n    if (options?.endDate) {\n      filtered = filtered.filter(log => log.timestamp <= options.endDate!);\n    }\n    \n    // Apply limit\n    if (options?.limit) {\n      filtered = filtered.slice(0, options.limit);\n    }\n    \n    // Convert to X402CallLog\n    // Note: We lose some metadata (facilitator, chainId, asset, amount, resource) when converting back\n    // In a production system, we'd store these in the UsageLog or a separate metadata table\n    // For now, we use verify mode and heuristics to reconstruct:\n    // - Infer from X402_VERIFY_MODE first (most reliable) - ALWAYS use this when set\n    // - Test facilitator: if x402TxHash starts with 'TEST_'\n    // - CDP facilitator: if x402TxHash is a real transaction hash (starts with '0x')\n    // - Unknown: only if we can't determine from verify mode or txHash\n    const verifyMode = process.env.X402_VERIFY_MODE?.toLowerCase();\n    return filtered.map(log => {\n      let facilitator: string | undefined;\n      \n      // ALWAYS infer from verify mode first (most reliable)\n      // This ensures that when X402_VERIFY_MODE=cdp, all logs show facilitator: \"CDP\"\n      // even if there's no txHash (e.g., on errors)\n      if (verifyMode === 'cdp') {\n        facilitator = 'CDP';\n      } else if (verifyMode === 'test') {\n        facilitator = 'TEST_FACILITATOR';\n      }\n      \n      // If verify mode didn't set it, use heuristics from txHash as fallback\n      // (This handles cases where verify mode isn't set but we can infer from txHash)\n      if (!facilitator && log.x402TxHash) {\n        if (log.x402TxHash.startsWith('TEST_')) {\n          facilitator = 'TEST_FACILITATOR';\n        } else if (log.x402TxHash.startsWith('0x')) {\n          facilitator = 'CDP';\n        }\n      }\n      \n      // If still not set, usageLogToX402CallLog will infer from verify mode\n      // But we should have set it above if verify mode is configured\n      \n      return usageLogToX402CallLog(log, {\n        facilitator,\n        chainId: 'eip155:8453',\n        asset: 'USDC_TEST',\n        amount: '10000',\n        resource: (() => {\n          const appUrl = process.env.NEXT_PUBLIC_APP_URL;\n          const baseUrl = appUrl || (process.env.NODE_ENV === 'production' ? '' : 'http://localhost:3001');\n          const normalizedPath = log.path.startsWith('/') ? log.path : `/${log.path.replace(/^\\d+\\//, '')}`;\n          return `${baseUrl}${normalizedPath}`;\n        })(),\n      });\n    });\n  } catch (error) {\n    logger.error('Error querying x402 call logs', { error, endpointId });\n    throw error;\n  }\n}\n\n/**\n * Log an x402 call event to the database and structured logger\n * This is the canonical way to record x402 payment flows\n */\nexport async function logX402Call(x402Log: Omit<X402CallLog, 'id' | 'timestamp'>): Promise<X402CallLog> {\n  const timestamp = new Date().toISOString();\n  \n  // Log to structured logger (Pino)\n  logger.info('x402 call', {\n    endpointId: x402Log.endpointId,\n    facilitator: x402Log.facilitator,\n    chainId: x402Log.chainId,\n    asset: x402Log.asset,\n    amount: x402Log.amount,\n    status: x402Log.status,\n    errorCode: x402Log.errorCode,\n    x402TxHash: x402Log.x402TxHash,\n    latencyMs: x402Log.latencyMs,\n    resource: x402Log.resource,\n    customerId: x402Log.customerId,\n    agentId: x402Log.agentId,\n  });\n\n  // Persist to database via UsageLog\n  try {\n    const usageLogData = x402CallLogToUsageLog(x402Log);\n    console.log('X402_LOG_DEBUG', JSON.stringify(usageLogData, null, 2));\n    const usageLog = await createUsageLog(usageLogData);\n    \n    return {\n      id: usageLog.id,\n      timestamp: usageLog.timestamp,\n      customerId: x402Log.customerId,\n      endpointId: x402Log.endpointId,\n      agentId: x402Log.agentId,\n      facilitator: x402Log.facilitator,\n      chainId: x402Log.chainId,\n      asset: x402Log.asset,\n      amount: x402Log.amount,\n      status: x402Log.status,\n      errorCode: x402Log.errorCode,\n      x402TxHash: x402Log.x402TxHash,\n      latencyMs: x402Log.latencyMs,\n      resource: x402Log.resource,\n    };\n  } catch (error) {\n    // Log error but don't fail the request\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const errorDetails = error instanceof Error ? { \n      message: error.message, \n      stack: error.stack,\n      name: error.name \n    } : { error };\n    \n    console.error('X402_LOG_DB_ERROR', {\n      error: errorMessage,\n      errorDetails,\n      x402Log: {\n        endpointId: x402Log.endpointId,\n        status: x402Log.status,\n        facilitator: x402Log.facilitator,\n      }\n    });\n    \n    logger.error('Failed to persist x402 call log', { \n      error: errorMessage,\n      errorDetails,\n      x402Log: {\n        endpointId: x402Log.endpointId,\n        status: x402Log.status,\n        facilitator: x402Log.facilitator,\n      }\n    });\n    \n    // Return log with generated ID (for consistency, even if DB write failed)\n    return {\n      id: `temp-${Date.now()}`,\n      timestamp,\n      ...x402Log,\n    };\n  }\n}\n","import { getCDPFacilitator, type CDPVerifyRequest } from './cdp-facilitator';\r\nimport type { PaymentAuthorization } from './signature-verifier';\r\n\r\n/**\r\n * Parsed x402 payment header structure\r\n */\r\nexport interface ParsedPaymentHeader {\r\n  invoiceId: string;\r\n  txHash?: string;\r\n  signature: string;\r\n  authorization: PaymentAuthorization;\r\n  network?: string;\r\n}\r\n\r\n/**\r\n * Parse x402 payment header from HTTP header value\r\n * \r\n * x402 payment headers are typically base64-encoded JSON containing:\r\n * - signature: EIP-712 signature\r\n * - authorization: Payment authorization object\r\n * - network: Blockchain network identifier\r\n * \r\n * Format: x402 <base64-encoded-json>\r\n */\r\nexport function parseX402Header(headerValue: string): {\r\n  valid: boolean;\r\n  parsed?: ParsedPaymentHeader;\r\n  error?: string;\r\n} {\r\n  try {\r\n    // Validate header is not empty\r\n    if (!headerValue || headerValue.trim().length === 0) {\r\n      return { valid: false, error: 'Payment header is empty' };\r\n    }\r\n\r\n    // Check for placeholder values\r\n    if (headerValue.includes('<your_payment_header>') || headerValue.includes('<placeholder>')) {\r\n      return { valid: false, error: 'Payment header contains placeholder value. Please provide a real x402 payment header.' };\r\n    }\r\n\r\n    // Remove 'x402 ' prefix if present\r\n    const cleanHeader = headerValue.startsWith('x402 ')\r\n      ? headerValue.slice(5).trim()\r\n      : headerValue.trim();\r\n\r\n    if (cleanHeader.length === 0) {\r\n      return { valid: false, error: 'Payment header value is empty after removing prefix' };\r\n    }\r\n\r\n    // Decode base64 (works in both Node.js and browser environments)\r\n    let decoded: string;\r\n    try {\r\n      decoded = typeof window === 'undefined'\r\n        ? Buffer.from(cleanHeader, 'base64').toString('utf-8')\r\n        : atob(cleanHeader);\r\n    } catch (base64Error) {\r\n      return { \r\n        valid: false, \r\n        error: `Invalid base64 encoding: ${base64Error instanceof Error ? base64Error.message : 'Failed to decode base64'}` \r\n      };\r\n    }\r\n\r\n    // Parse JSON\r\n    let payload: {\r\n      signature?: string;\r\n      authorization?: {\r\n        from?: string;\r\n        to?: string;\r\n        value?: string;\r\n        validAfter?: string;\r\n        validBefore?: string;\r\n        nonce?: string;\r\n      };\r\n      network?: string;\r\n      invoiceId?: string;\r\n      txHash?: string;\r\n    };\r\n    \r\n    try {\r\n      payload = JSON.parse(decoded);\r\n    } catch (jsonError) {\r\n      return { \r\n        valid: false, \r\n        error: `Invalid JSON in payment header: ${jsonError instanceof Error ? jsonError.message : 'Failed to parse JSON'}. Decoded value: ${decoded.substring(0, 100)}` \r\n      };\r\n    }\r\n\r\n    // Validate required fields\r\n    if (!payload.signature) {\r\n      return { valid: false, error: 'Missing signature in payment header' };\r\n    }\r\n\r\n    if (!payload.authorization) {\r\n      return { valid: false, error: 'Missing authorization in payment header' };\r\n    }\r\n\r\n    const auth = payload.authorization;\r\n    if (!auth.from || !auth.to || !auth.value || !auth.nonce) {\r\n      return { valid: false, error: 'Incomplete authorization fields' };\r\n    }\r\n\r\n    return {\r\n      valid: true,\r\n      parsed: {\r\n        invoiceId: payload.invoiceId || auth.nonce,\r\n        txHash: payload.txHash,\r\n        signature: payload.signature,\r\n        authorization: {\r\n          from: auth.from as `0x${string}`,\r\n          to: auth.to as `0x${string}`,\r\n          value: auth.value,\r\n          validAfter: auth.validAfter || Math.floor(Date.now() / 1000).toString(),\r\n          validBefore: auth.validBefore || (Math.floor(Date.now() / 1000) + 300).toString(),\r\n          nonce: auth.nonce,\r\n        },\r\n        network: payload.network || 'base',\r\n      },\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      valid: false,\r\n      error: error instanceof Error ? error.message : 'Failed to parse payment header',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Parse and verify x402 payment header with CDP facilitator\r\n * \r\n * This function:\r\n * 1. Parses the payment header\r\n * 2. Verifies the payment with CDP\r\n * 3. Returns the verification result\r\n */\r\nexport async function parseAndVerifyPaymentHeader(\r\n  headerValue: string\r\n): Promise<{\r\n  valid: boolean;\r\n  payment?: ParsedPaymentHeader;\r\n  transactionHash?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Parse the header\r\n    const parseResult = parseX402Header(headerValue);\r\n    if (!parseResult.valid || !parseResult.parsed) {\r\n      return {\r\n        valid: false,\r\n        error: parseResult.error || 'Invalid payment header format',\r\n      };\r\n    }\r\n\r\n    const parsed = parseResult.parsed;\r\n\r\n    // Create CDP verify request\r\n    const verifyRequest: CDPVerifyRequest = {\r\n      payment: headerValue,\r\n      paymentPayload: {\r\n        x402Version: 1,\r\n        scheme: 'x402',\r\n        network: parsed.network || 'base',\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: parsed.authorization,\r\n        },\r\n      },\r\n    };\r\n\r\n    // Verify with CDP\r\n    const cdp = getCDPFacilitator();\r\n    const verifyResult = await cdp.verifyPayment(verifyRequest);\r\n\r\n    if (!verifyResult.valid || !verifyResult.success) {\r\n      return {\r\n        valid: false,\r\n        error: verifyResult.error || 'Payment verification failed',\r\n      };\r\n    }\r\n\r\n    return {\r\n      valid: true,\r\n      payment: parsed,\r\n      transactionHash: verifyResult.transactionHash,\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      valid: false,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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","ignoreList":[3,4,5]}