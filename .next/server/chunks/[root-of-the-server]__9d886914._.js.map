{"version":3,"sources":["turbopack:///[project]/node_modules/thread-stream/package.json","../../../src/lib/auth/validate-api-key.ts","../../../src/types/smf-api.ts","../../../src/services/settlement/load-monitor.ts","../../../src/types/load-management.ts"],"sourcesContent":["{\"name\":\"thread-stream\",\"version\":\"3.1.0\",\"description\":\"A streaming way to send data to a Node.js Worker Thread\",\"main\":\"index.js\",\"types\":\"index.d.ts\",\"dependencies\":{\"real-require\":\"^0.2.0\"},\"devDependencies\":{\"@types/node\":\"^20.1.0\",\"@types/tap\":\"^15.0.0\",\"@yao-pkg/pkg\":\"^5.11.5\",\"desm\":\"^1.3.0\",\"fastbench\":\"^1.0.1\",\"husky\":\"^9.0.6\",\"pino-elasticsearch\":\"^8.0.0\",\"sonic-boom\":\"^4.0.1\",\"standard\":\"^17.0.0\",\"tap\":\"^16.2.0\",\"ts-node\":\"^10.8.0\",\"typescript\":\"^5.3.2\",\"why-is-node-running\":\"^2.2.2\"},\"scripts\":{\"build\":\"tsc --noEmit\",\"test\":\"standard && npm run build && npm run transpile && tap \\\"test/**/*.test.*js\\\" && tap --ts test/*.test.*ts\",\"test:ci\":\"standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts\",\"test:ci:js\":\"tap --no-check-coverage --timeout=120 --coverage-report=lcovonly \\\"test/**/*.test.*js\\\"\",\"test:ci:ts\":\"tap --ts --no-check-coverage --coverage-report=lcovonly \\\"test/**/*.test.*ts\\\"\",\"test:yarn\":\"npm run transpile && tap \\\"test/**/*.test.js\\\" --no-check-coverage\",\"transpile\":\"sh ./test/ts/transpile.sh\",\"prepare\":\"husky install\"},\"standard\":{\"ignore\":[\"test/ts/**/*\",\"test/syntax-error.mjs\"]},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/mcollina/thread-stream.git\"},\"keywords\":[\"worker\",\"thread\",\"threads\",\"stream\"],\"author\":\"Matteo Collina <hello@matteocollina.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/mcollina/thread-stream/issues\"},\"homepage\":\"https://github.com/mcollina/thread-stream#readme\"}","// =============================================================================\r\n// API Key Validation\r\n// =============================================================================\r\n// Validates NexFlow API keys for authentication\r\n// Supports both live (nf_live_*) and test (nf_test_*) keys\r\n\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'ValidateApiKey' });\r\n\r\n/**\r\n * Validated API key result\r\n */\r\nexport interface ValidatedApiKey {\r\n  /** Unique identifier for the API key (first 20 chars or hash) */\r\n  id: string;\r\n  /** Account ID associated with this key (if known) */\r\n  accountId?: string;\r\n  /** Whether this is a live or test key */\r\n  isLive: boolean;\r\n  /** Whether the key is valid */\r\n  valid: boolean;\r\n}\r\n\r\n/**\r\n * API key prefix patterns\r\n */\r\nconst API_KEY_PREFIXES = {\r\n  LIVE: 'nf_live_',\r\n  TEST: 'nf_test_',\r\n} as const;\r\n\r\n/**\r\n * Validate an API key and return key metadata\r\n * \r\n * @param apiKey - The API key to validate\r\n * @returns Validated key info or null if invalid\r\n * \r\n * @example\r\n * ```ts\r\n * const key = await validateApiKey('nf_live_abc123xyz...');\r\n * if (key) {\r\n *   console.log(`Key ${key.id} is valid`);\r\n * }\r\n * ```\r\n */\r\nexport async function validateApiKey(apiKey: string): Promise<ValidatedApiKey | null> {\r\n  if (!apiKey || typeof apiKey !== 'string') {\r\n    logger.debug({ reason: 'empty' }, 'API key validation failed');\r\n    return null;\r\n  }\r\n\r\n  // Check for valid prefix\r\n  const isLive = apiKey.startsWith(API_KEY_PREFIXES.LIVE);\r\n  const isTest = apiKey.startsWith(API_KEY_PREFIXES.TEST);\r\n\r\n  if (!isLive && !isTest) {\r\n    logger.debug({ reason: 'invalid_prefix' }, 'API key validation failed');\r\n    return null;\r\n  }\r\n\r\n  // Extract key body (after prefix)\r\n  const prefix = isLive ? API_KEY_PREFIXES.LIVE : API_KEY_PREFIXES.TEST;\r\n  const keyBody = apiKey.slice(prefix.length);\r\n\r\n  // Basic validation: key body should be at least 16 characters\r\n  if (keyBody.length < 16) {\r\n    logger.debug({ reason: 'too_short' }, 'API key validation failed');\r\n    return null;\r\n  }\r\n\r\n  // Generate a stable ID from the key (first 20 chars of full key)\r\n  const id = apiKey.substring(0, 20);\r\n\r\n  // In a production system, you would:\r\n  // 1. Hash the key and look it up in the database\r\n  // 2. Check expiration, rate limits, permissions\r\n  // 3. Return associated account info\r\n  \r\n  // For now, we accept any well-formed key\r\n  // Real validation should be added when accounts system is integrated\r\n  \r\n  logger.debug({ id, isLive }, 'API key validated');\r\n\r\n  return {\r\n    id,\r\n    isLive,\r\n    valid: true,\r\n  };\r\n}\r\n\r\n/**\r\n * Check if an API key format is valid (without database lookup)\r\n * \r\n * @param apiKey - The API key to check\r\n * @returns true if format is valid\r\n */\r\nexport function isValidApiKeyFormat(apiKey: string): boolean {\r\n  if (!apiKey || typeof apiKey !== 'string') return false;\r\n  \r\n  const isLive = apiKey.startsWith(API_KEY_PREFIXES.LIVE);\r\n  const isTest = apiKey.startsWith(API_KEY_PREFIXES.TEST);\r\n  \r\n  if (!isLive && !isTest) return false;\r\n  \r\n  const prefix = isLive ? API_KEY_PREFIXES.LIVE : API_KEY_PREFIXES.TEST;\r\n  const keyBody = apiKey.slice(prefix.length);\r\n  \r\n  return keyBody.length >= 16;\r\n}\r\n\r\n/**\r\n * Extract key type from API key\r\n */\r\nexport function getApiKeyType(apiKey: string): 'live' | 'test' | 'unknown' {\r\n  if (apiKey?.startsWith(API_KEY_PREFIXES.LIVE)) return 'live';\r\n  if (apiKey?.startsWith(API_KEY_PREFIXES.TEST)) return 'test';\r\n  return 'unknown';\r\n}\r\n\r\n","// =============================================================================\r\n// SMF API TYPES\r\n// =============================================================================\r\n// Shared request/response types for SMF API endpoints\r\n// Used by both server-side API handlers and client SDK\r\n\r\n// =============================================================================\r\n// PROTECTED PAYMENTS - Anomaly Detection Metadata\r\n// =============================================================================\r\n\r\n/**\r\n * Payment protection status from NexFlow's anomaly detection system.\r\n * Every payment routed through SMF is automatically protected.\r\n */\r\nexport interface PaymentProtection {\r\n  /** Protection level - always 'automatic' for SMF */\r\n  level: 'automatic';\r\n  /** Circuit breaker state for the selected facilitator */\r\n  circuit_breaker_state: 'CLOSED' | 'OPEN' | 'HALF_OPEN';\r\n  /** Current health classification based on recent metrics */\r\n  facilitator_health: 'normal' | 'suspect' | 'anomalous';\r\n  /** 7-day rolling success rate (0-1) */\r\n  success_rate_7d: number;\r\n  /** Whether anomaly detection is actively monitoring */\r\n  anomaly_detection_active: boolean;\r\n}\r\n\r\n/**\r\n * Fee breakdown for settlement.\r\n * Single platform fee (0.25%) - no insurance split.\r\n */\r\nexport interface SettlementFeeBreakdown {\r\n  /** Platform fee in wei (0.25% of amount) */\r\n  platform_fee_wei: string;\r\n  /** Total fee in wei (same as platform_fee) */\r\n  total_fee_wei: string;\r\n}\r\n\r\n// =============================================================================\r\n// ROUTE ENDPOINT\r\n// =============================================================================\r\n\r\n/**\r\n * Request body for POST /api/v1/smf/route\r\n * Routes a payment to the best available facilitator\r\n */\r\nexport interface SMFRouteRequest {\r\n  /** Payment amount in wei (e.g., \"1000000\") */\r\n  amount_wei: string;\r\n  /** Token contract address (e.g., \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\") */\r\n  token_address: string;\r\n  /** Chain ID in CAIP-2 format (e.g., \"eip155:8453\") */\r\n  chain_id: string;\r\n  /** Optional recipient address for routing optimization */\r\n  recipient?: string;\r\n  /** Optional idempotency key / correlation ID */\r\n  payment_id?: string;\r\n  /** Optional metadata for routing decisions */\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Response body for POST /api/v1/smf/route\r\n */\r\nexport interface SMFRouteResponse {\r\n  /** Selected facilitator ID (e.g., \"cdp\", \"payai\", \"x402rs\") */\r\n  facilitator_id: string;\r\n  /** Routing decision path (e.g., \"direct\", \"batched\", \"fallback\") */\r\n  path: string;\r\n  /** Expected platform fee in wei (0.25% default) */\r\n  expected_fee_wei: string;\r\n  /** Fee breakdown (single platform fee, no insurance) */\r\n  fee_breakdown?: SettlementFeeBreakdown;\r\n  /** Estimated round-trip latency in milliseconds */\r\n  estimated_latency_ms: number;\r\n  /** Routing confidence score (0-1) */\r\n  confidence: number;\r\n  /** ISO timestamp when this quote expires */\r\n  quote_expires_at: string;\r\n  /** Correlation ID for settlement */\r\n  quote_id?: string;\r\n  /** Protected Payments status - anomaly detection metadata */\r\n  protection?: PaymentProtection;\r\n}\r\n\r\n// =============================================================================\r\n// VERIFY ENDPOINT\r\n// =============================================================================\r\n\r\n/**\r\n * Request body for POST /api/v1/smf/verify\r\n * Verifies an x402 payment intent\r\n */\r\nexport interface SMFVerifyRequest {\r\n  /** x402 payment string/payload */\r\n  payment_intent: string;\r\n  /** Optional amount in wei for verification */\r\n  amount_wei?: string;\r\n  /** Recipient address (must match payment intent) */\r\n  recipient_address: string;\r\n  /** Optional facilitator hint for verification */\r\n  facilitator_id?: string;\r\n}\r\n\r\n/**\r\n * Response body for POST /api/v1/smf/verify\r\n */\r\nexport interface SMFVerifyResponse {\r\n  /** Whether the payment is valid */\r\n  valid: boolean;\r\n  /** If invalid, explanation of why */\r\n  reason?: string;\r\n  /** Facilitator that will process this payment */\r\n  facilitator: string;\r\n  /** Estimated settlement time in milliseconds */\r\n  estimated_settlement_ms: number;\r\n  /** Protected Payments status - anomaly detection metadata */\r\n  protection?: PaymentProtection;\r\n}\r\n\r\n// =============================================================================\r\n// SETTLE ENDPOINT\r\n// =============================================================================\r\n\r\n/**\r\n * Request body for POST /api/v1/smf/settle\r\n * Settles a batch of payments\r\n */\r\nexport interface SMFSettleRequest {\r\n  /** Batch ID from the batch settlement engine */\r\n  batch_id: string;\r\n  /** Facilitator to use for settlement */\r\n  facilitator_id: string;\r\n  /** Force immediate settlement vs wait for batch window */\r\n  force?: boolean;\r\n}\r\n\r\n/**\r\n * Settlement status enum\r\n */\r\nexport type SMFSettlementStatus = 'pending' | 'submitted' | 'confirmed' | 'failed';\r\n\r\n/**\r\n * Response body for POST /api/v1/smf/settle\r\n */\r\nexport interface SMFSettleResponse {\r\n  /** Current settlement status */\r\n  status: SMFSettlementStatus;\r\n  /** On-chain transaction hash (if submitted/confirmed) */\r\n  transaction_hash?: string;\r\n  /** ISO timestamp of settlement completion */\r\n  settled_at?: string;\r\n  /** Fee breakdown for this settlement */\r\n  fee_breakdown?: SettlementFeeBreakdown;\r\n  /** Protected Payments status - anomaly detection metadata */\r\n  protection?: PaymentProtection;\r\n  /** Error message if settlement failed */\r\n  error?: string;\r\n}\r\n\r\n// =============================================================================\r\n// HEALTH ENDPOINT\r\n// =============================================================================\r\n\r\n/**\r\n * Response body for GET /api/v1/smf/health\r\n */\r\nexport interface SMFHealthResponse {\r\n  /** Overall system status */\r\n  status: 'healthy' | 'degraded' | 'down';\r\n  /** Summary counts */\r\n  summary: {\r\n    total: number;\r\n    healthy: number;\r\n    degraded: number;\r\n    down: number;\r\n  };\r\n  /** Per-facilitator health status */\r\n  facilitators: Array<{\r\n    facilitatorId: string;\r\n    name: string;\r\n    status: 'healthy' | 'degraded' | 'down';\r\n    reasons?: string[];\r\n    metrics?: {\r\n      successRate: number;\r\n      p95LatencyMs: number | null;\r\n      errorRate: number;\r\n      lastUpdated: string | null;\r\n    };\r\n  }>;\r\n  /** ISO timestamp of health check */\r\n  timestamp: string;\r\n}\r\n\r\n// =============================================================================\r\n// FACILITATORS ENDPOINT\r\n// =============================================================================\r\n\r\n/**\r\n * Facilitator metadata from GET /api/v1/smf/facilitators\r\n */\r\nexport interface SMFFacilitatorInfo {\r\n  id: string;\r\n  label: string;\r\n  url: string;\r\n  supportedNetworks: string[];\r\n  tokens: string[];\r\n  priority: number;\r\n  feeBps: number;\r\n  enabled: boolean;\r\n  status?: 'healthy' | 'degraded' | 'down' | 'unknown';\r\n}\r\n\r\n// =============================================================================\r\n// RATE LIMITING\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit information extracted from response headers\r\n */\r\nexport interface RateLimitInfo {\r\n  /** Maximum requests allowed per time window */\r\n  limit: number;\r\n  /** Remaining requests in current window */\r\n  remaining: number;\r\n  /** When the rate limit resets */\r\n  resetAt: Date;\r\n}\r\n\r\n// =============================================================================\r\n// ERROR RESPONSES\r\n// =============================================================================\r\n\r\n/**\r\n * Standard API error response\r\n */\r\nexport interface SMFErrorResponse {\r\n  /** Error code (e.g., \"INVALID_REQUEST\", \"UNAUTHORIZED\") */\r\n  error: string;\r\n  /** Human-readable error message */\r\n  message?: string;\r\n  /** Additional error details */\r\n  details?: unknown;\r\n}\r\n\r\n/**\r\n * Error codes used by SMF API\r\n */\r\nexport type SMFErrorCode =\r\n  | 'MISSING_API_KEY'\r\n  | 'INVALID_API_KEY'\r\n  | 'INVALID_REQUEST'\r\n  | 'INVALID_AMOUNT'\r\n  | 'INVALID_CHAIN_ID'\r\n  | 'INVALID_TOKEN'\r\n  | 'MALFORMED_PAYMENT'\r\n  | 'RECIPIENT_MISMATCH'\r\n  | 'BATCH_NOT_FOUND'\r\n  | 'FACILITATOR_NOT_FOUND'\r\n  | 'RATE_LIMITED'\r\n  | 'INTERNAL_ERROR';\r\n\r\n// =============================================================================\r\n// VALIDATION HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Validate SMFRouteRequest\r\n */\r\nexport function isValidRouteRequest(body: unknown): body is SMFRouteRequest {\r\n  if (!body || typeof body !== 'object') return false;\r\n  const req = body as Record<string, unknown>;\r\n  \r\n  if (typeof req.amount_wei !== 'string' || !req.amount_wei) return false;\r\n  if (typeof req.token_address !== 'string' || !req.token_address) return false;\r\n  if (typeof req.chain_id !== 'string' || !req.chain_id) return false;\r\n  \r\n  // Validate amount_wei is a valid positive integer\r\n  try {\r\n    const amount = BigInt(req.amount_wei);\r\n    if (amount <= 0n) return false;\r\n  } catch {\r\n    return false;\r\n  }\r\n  \r\n  return true;\r\n}\r\n\r\n/**\r\n * Validate SMFVerifyRequest\r\n */\r\nexport function isValidVerifyRequest(body: unknown): body is SMFVerifyRequest {\r\n  if (!body || typeof body !== 'object') return false;\r\n  const req = body as Record<string, unknown>;\r\n  \r\n  if (typeof req.payment_intent !== 'string' || !req.payment_intent) return false;\r\n  if (typeof req.recipient_address !== 'string' || !req.recipient_address) return false;\r\n  \r\n  return true;\r\n}\r\n\r\n/**\r\n * Validate SMFSettleRequest\r\n */\r\nexport function isValidSettleRequest(body: unknown): body is SMFSettleRequest {\r\n  if (!body || typeof body !== 'object') return false;\r\n  const req = body as Record<string, unknown>;\r\n  \r\n  if (typeof req.batch_id !== 'string' || !req.batch_id) return false;\r\n  if (typeof req.facilitator_id !== 'string' || !req.facilitator_id) return false;\r\n  \r\n  return true;\r\n}\r\n\r\n","// =============================================================================\r\n// LOAD MONITOR SERVICE\r\n// =============================================================================\r\n// Per-facilitator load tracking with adaptive batch sizing and backpressure.\r\n// Enables graceful degradation when one facilitator is congested while others\r\n// continue operating at full capacity.\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  LoadLevel,\r\n  LoadThresholds,\r\n  AdaptiveBatchConfig,\r\n  FacilitatorLoadMetrics,\r\n  SystemLoadMetrics,\r\n  BackpressureHeaders,\r\n  LoadAcceptanceResult,\r\n  LoadLevelChangeEvent,\r\n  LoadLevelChangeHandler,\r\n} from '@/types/load-management';\r\nimport {\r\n  DEFAULT_LOAD_THRESHOLDS,\r\n  DEFAULT_BATCH_CONFIG,\r\n} from '@/types/load-management';\r\n\r\nconst logger = createLogger({ component: 'LoadMonitor' });\r\n\r\n// =============================================================================\r\n// CONSTANTS\r\n// =============================================================================\r\n\r\n/** Cache TTL for facilitator metrics (milliseconds) */\r\nconst METRICS_CACHE_TTL_MS = 5000;\r\n\r\n/** Default time per batch for wait estimation (seconds) */\r\nconst DEFAULT_TIME_PER_BATCH_SECONDS = 30;\r\n\r\n// =============================================================================\r\n// LOAD MONITOR CLASS\r\n// =============================================================================\r\n\r\n/**\r\n * Monitors load per facilitator and provides adaptive batch sizing.\r\n * \r\n * Key features:\r\n * - Per-facilitator load tracking (isolation)\r\n * - Adaptive batch sizing (100 → 75 → 50 → 25 → 0)\r\n * - Backpressure headers for client signaling\r\n * - 5-second metrics caching to reduce DB load\r\n */\r\nexport class LoadMonitor {\r\n  private db: any;\r\n  private thresholds: LoadThresholds;\r\n  private batchConfig: AdaptiveBatchConfig;\r\n  private facilitatorMetrics: Map<string, FacilitatorLoadMetrics>;\r\n  private changeHandlers: LoadLevelChangeHandler[];\r\n\r\n  constructor(\r\n    db: any,\r\n    thresholds?: Partial<LoadThresholds>,\r\n    batchConfig?: Partial<AdaptiveBatchConfig>\r\n  ) {\r\n    this.db = db;\r\n    this.thresholds = { ...DEFAULT_LOAD_THRESHOLDS, ...thresholds };\r\n    this.batchConfig = { ...DEFAULT_BATCH_CONFIG, ...batchConfig };\r\n    this.facilitatorMetrics = new Map();\r\n    this.changeHandlers = [];\r\n  }\r\n\r\n  // ===========================================================================\r\n  // LOAD METRICS\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get load metrics for a specific facilitator.\r\n   * Results are cached for 5 seconds to reduce DB load.\r\n   */\r\n  async getLoadMetrics(facilitator_id: string): Promise<FacilitatorLoadMetrics> {\r\n    // Check cache\r\n    const cached = this.facilitatorMetrics.get(facilitator_id);\r\n    if (cached && Date.now() - cached.last_updated_at.getTime() < METRICS_CACHE_TTL_MS) {\r\n      return cached;\r\n    }\r\n\r\n    // Query fresh metrics\r\n    const metrics = await this.queryFacilitatorMetrics(facilitator_id);\r\n\r\n    // Check for level change and notify\r\n    if (cached && cached.load_level !== metrics.load_level) {\r\n      await this.notifyLevelChange({\r\n        facilitator_id,\r\n        previous_level: cached.load_level,\r\n        new_level: metrics.load_level,\r\n        metrics,\r\n        timestamp: new Date(),\r\n      });\r\n    }\r\n\r\n    // Update cache\r\n    this.facilitatorMetrics.set(facilitator_id, metrics);\r\n\r\n    return metrics;\r\n  }\r\n\r\n  /**\r\n   * Query fresh metrics from the database.\r\n   */\r\n  private async queryFacilitatorMetrics(facilitator_id: string): Promise<FacilitatorLoadMetrics> {\r\n    let pending_batches = 0;\r\n    let pending_payments = 0;\r\n    let in_flight_settlements = 0;\r\n\r\n    try {\r\n      // Query pending batches (pending or queued status)\r\n      const batchResult = await this.db.query(\r\n        `SELECT COUNT(*) as count FROM batch_settlements \r\n         WHERE facilitator_id = $1 AND status IN ('pending', 'queued')`,\r\n        [facilitator_id]\r\n      );\r\n      pending_batches = parseInt(batchResult.rows[0]?.count || '0', 10);\r\n    } catch (error) {\r\n      logger.debug({ facilitator_id, error }, 'Failed to query pending batches (table may not exist)');\r\n    }\r\n\r\n    try {\r\n      // Query pending payments (in queue, not yet batched)\r\n      const paymentResult = await this.db.query(\r\n        `SELECT COUNT(*) as count FROM batch_queue \r\n         WHERE facilitator_id = $1`,\r\n        [facilitator_id]\r\n      );\r\n      pending_payments = parseInt(paymentResult.rows[0]?.count || '0', 10);\r\n    } catch (error) {\r\n      logger.debug({ facilitator_id, error }, 'Failed to query pending payments (table may not exist)');\r\n    }\r\n\r\n    try {\r\n      // Query in-flight settlements (submitted but not confirmed)\r\n      const inflightResult = await this.db.query(\r\n        `SELECT COUNT(*) as count FROM batch_settlements \r\n         WHERE facilitator_id = $1 AND status = 'submitted'`,\r\n        [facilitator_id]\r\n      );\r\n      in_flight_settlements = parseInt(inflightResult.rows[0]?.count || '0', 10);\r\n    } catch (error) {\r\n      logger.debug({ facilitator_id, error }, 'Failed to query in-flight settlements (table may not exist)');\r\n    }\r\n\r\n    // Calculate load level and percentage\r\n    const load_level = this.calculateLoadLevel(pending_batches, pending_payments, in_flight_settlements);\r\n    const load_percentage = this.calculateLoadPercentage(pending_batches, pending_payments, in_flight_settlements);\r\n\r\n    return {\r\n      facilitator_id,\r\n      pending_batches,\r\n      pending_payments,\r\n      in_flight_settlements,\r\n      load_level,\r\n      load_percentage,\r\n      last_updated_at: new Date(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get aggregate system metrics across all facilitators.\r\n   */\r\n  async getSystemMetrics(): Promise<SystemLoadMetrics> {\r\n    let total_pending_batches = 0;\r\n    let total_pending_payments = 0;\r\n    let total_in_flight = 0;\r\n\r\n    try {\r\n      const batchResult = await this.db.query(\r\n        `SELECT COUNT(*) as count FROM batch_settlements WHERE status IN ('pending', 'queued')`\r\n      );\r\n      total_pending_batches = parseInt(batchResult.rows[0]?.count || '0', 10);\r\n    } catch {\r\n      // Table may not exist\r\n    }\r\n\r\n    try {\r\n      const paymentResult = await this.db.query(\r\n        `SELECT COUNT(*) as count FROM batch_queue`\r\n      );\r\n      total_pending_payments = parseInt(paymentResult.rows[0]?.count || '0', 10);\r\n    } catch {\r\n      // Table may not exist\r\n    }\r\n\r\n    try {\r\n      const inflightResult = await this.db.query(\r\n        `SELECT COUNT(*) as count FROM batch_settlements WHERE status = 'submitted'`\r\n      );\r\n      total_in_flight = parseInt(inflightResult.rows[0]?.count || '0', 10);\r\n    } catch {\r\n      // Table may not exist\r\n    }\r\n\r\n    // Count facilitators by level\r\n    const facilitators_by_level = { normal: 0, high: 0, critical: 0 };\r\n    for (const metrics of this.facilitatorMetrics.values()) {\r\n      const level = metrics.load_level.toLowerCase() as 'normal' | 'high' | 'critical';\r\n      facilitators_by_level[level]++;\r\n    }\r\n\r\n    // System level is worst case across cached facilitators\r\n    let system_level: LoadLevel = 'NORMAL';\r\n    if (facilitators_by_level.critical > 0) {\r\n      system_level = 'CRITICAL';\r\n    } else if (facilitators_by_level.high > 0) {\r\n      system_level = 'HIGH';\r\n    }\r\n\r\n    return {\r\n      total_pending_batches,\r\n      total_pending_payments,\r\n      total_in_flight,\r\n      facilitators_by_level,\r\n      system_level,\r\n      last_updated_at: new Date(),\r\n    };\r\n  }\r\n\r\n  // ===========================================================================\r\n  // LOAD LEVEL CALCULATION\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Calculate load level based on thresholds.\r\n   * CRITICAL if ANY metric exceeds critical threshold.\r\n   * HIGH if ANY metric exceeds high threshold.\r\n   */\r\n  calculateLoadLevel(\r\n    pending_batches: number,\r\n    pending_payments: number,\r\n    in_flight: number\r\n  ): LoadLevel {\r\n    // CRITICAL: any metric exceeds critical threshold\r\n    if (\r\n      pending_batches >= this.thresholds.critical_pending_batches ||\r\n      pending_payments >= this.thresholds.critical_pending_payments ||\r\n      in_flight >= this.thresholds.critical_in_flight\r\n    ) {\r\n      return 'CRITICAL';\r\n    }\r\n\r\n    // HIGH: any metric exceeds high threshold\r\n    if (\r\n      pending_batches >= this.thresholds.high_pending_batches ||\r\n      pending_payments >= this.thresholds.high_pending_payments ||\r\n      in_flight >= this.thresholds.high_in_flight\r\n    ) {\r\n      return 'HIGH';\r\n    }\r\n\r\n    // NORMAL: all below high thresholds\r\n    return 'NORMAL';\r\n  }\r\n\r\n  /**\r\n   * Calculate load percentage (0-100) based on distance to critical.\r\n   * Returns the maximum percentage across all metrics.\r\n   */\r\n  calculateLoadPercentage(\r\n    pending_batches: number,\r\n    pending_payments: number,\r\n    in_flight: number\r\n  ): number {\r\n    const batch_pct = (pending_batches / this.thresholds.critical_pending_batches) * 100;\r\n    const payment_pct = (pending_payments / this.thresholds.critical_pending_payments) * 100;\r\n    const in_flight_pct = (in_flight / this.thresholds.critical_in_flight) * 100;\r\n\r\n    // Return max, capped at 100\r\n    return Math.min(100, Math.max(batch_pct, payment_pct, in_flight_pct));\r\n  }\r\n\r\n  // ===========================================================================\r\n  // ADAPTIVE BATCH SIZING\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get adaptive batch size based on load level and percentage.\r\n   * Gradually reduces from normal_batch_size to critical_batch_size.\r\n   * \r\n   * @example\r\n   * NORMAL (0-49%): 100\r\n   * HIGH (50%): 75\r\n   * HIGH (75%): 50\r\n   * HIGH (99%): 25\r\n   * CRITICAL (100%+): 0 (reject)\r\n   */\r\n  getAdaptiveBatchSize(load_level: LoadLevel, load_percentage: number): number {\r\n    if (load_level === 'CRITICAL') {\r\n      return this.batchConfig.critical_batch_size; // 0 = reject\r\n    }\r\n\r\n    if (load_level === 'HIGH') {\r\n      // Gradual reduction: max → min as load_percentage goes 50 → 100\r\n      const range = this.batchConfig.high_batch_size_max - this.batchConfig.high_batch_size_min;\r\n      const percent_within_high = Math.min(1, Math.max(0, (load_percentage - 50) / 50));\r\n      const adjusted_size = this.batchConfig.high_batch_size_max - (percent_within_high * range);\r\n      return Math.max(this.batchConfig.high_batch_size_min, Math.floor(adjusted_size));\r\n    }\r\n\r\n    // NORMAL\r\n    return this.batchConfig.normal_batch_size;\r\n  }\r\n\r\n  // ===========================================================================\r\n  // QUEUE POSITION & WAIT ESTIMATION\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get queue position for a payment.\r\n   * Returns the number of payments ahead in the queue.\r\n   */\r\n  async getQueuePosition(facilitator_id: string, payment_id: string): Promise<number> {\r\n    try {\r\n      const result = await this.db.query(\r\n        `SELECT COUNT(*) as position FROM batch_queue \r\n         WHERE facilitator_id = $1 \r\n         AND created_at < (SELECT created_at FROM batch_queue WHERE payment_id = $2)`,\r\n        [facilitator_id, payment_id]\r\n      );\r\n      return parseInt(result.rows[0]?.position || '0', 10);\r\n    } catch {\r\n      // If payment not in queue yet or table doesn't exist, return 0\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Estimate time to settlement based on queue position and batch size.\r\n   */\r\n  async estimateWaitTime(facilitator_id: string, payment_id: string): Promise<number> {\r\n    const queuePos = await this.getQueuePosition(facilitator_id, payment_id);\r\n    const metrics = await this.getLoadMetrics(facilitator_id);\r\n    const batch_size = this.getAdaptiveBatchSize(metrics.load_level, metrics.load_percentage);\r\n\r\n    // Avoid division by zero\r\n    if (batch_size <= 0) {\r\n      // CRITICAL: can't estimate, return high value\r\n      return 3600; // 1 hour\r\n    }\r\n\r\n    // Estimate: (position / batch_size) * time_per_batch\r\n    const batches_ahead = Math.ceil((queuePos + 1) / batch_size);\r\n    const estimated_seconds = batches_ahead * DEFAULT_TIME_PER_BATCH_SECONDS;\r\n\r\n    return estimated_seconds;\r\n  }\r\n\r\n  // ===========================================================================\r\n  // BACKPRESSURE HEADERS\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Generate backpressure headers for API response.\r\n   * Includes load level, queue position, and estimated wait time.\r\n   */\r\n  async generateBackpressureHeaders(\r\n    facilitator_id: string,\r\n    payment_id?: string\r\n  ): Promise<BackpressureHeaders> {\r\n    const metrics = await this.getLoadMetrics(facilitator_id);\r\n    const queue_position = payment_id \r\n      ? await this.getQueuePosition(facilitator_id, payment_id)\r\n      : metrics.pending_payments;\r\n    const estimated_wait = payment_id\r\n      ? await this.estimateWaitTime(facilitator_id, payment_id)\r\n      : Math.ceil(metrics.pending_payments / Math.max(1, this.getAdaptiveBatchSize(metrics.load_level, metrics.load_percentage))) * DEFAULT_TIME_PER_BATCH_SECONDS;\r\n\r\n    const headers: BackpressureHeaders = {\r\n      'X-NexFlow-Load': metrics.load_level,\r\n      'X-NexFlow-Queue-Position': queue_position.toString(),\r\n      'X-NexFlow-Estimated-Wait': estimated_wait.toString(),\r\n    };\r\n\r\n    // Add batch-size-reduced indicator for HIGH load\r\n    if (metrics.load_level === 'HIGH') {\r\n      headers['X-NexFlow-Batch-Size-Reduced'] = 'true';\r\n    }\r\n\r\n    // Add retry-after for CRITICAL load\r\n    if (metrics.load_level === 'CRITICAL') {\r\n      headers['X-NexFlow-Retry-After'] = '60';\r\n    }\r\n\r\n    return headers;\r\n  }\r\n\r\n  /**\r\n   * Convert BackpressureHeaders to a plain object for NextResponse.\r\n   */\r\n  headersToRecord(headers: BackpressureHeaders): Record<string, string> {\r\n    const result: Record<string, string> = {};\r\n    for (const [key, value] of Object.entries(headers)) {\r\n      if (value !== undefined) {\r\n        result[key] = value;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // ===========================================================================\r\n  // LOAD ACCEPTANCE\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Check if a new route request should be accepted.\r\n   * Rejects on CRITICAL load.\r\n   */\r\n  shouldAcceptRoute(load_level: LoadLevel): LoadAcceptanceResult {\r\n    if (load_level === 'CRITICAL') {\r\n      return {\r\n        accepted: false,\r\n        reason: 'Facilitator at capacity. Please retry after the suggested delay.',\r\n        retry_after_seconds: 60,\r\n      };\r\n    }\r\n\r\n    return { accepted: true };\r\n  }\r\n\r\n  /**\r\n   * Check if a new settlement request should be accepted.\r\n   * More permissive than route (draining is good during HIGH load).\r\n   */\r\n  shouldAcceptSettlement(load_level: LoadLevel): LoadAcceptanceResult {\r\n    if (load_level === 'CRITICAL') {\r\n      return {\r\n        accepted: false,\r\n        reason: 'System overloaded. Settlement temporarily paused.',\r\n        retry_after_seconds: 60,\r\n      };\r\n    }\r\n\r\n    return { accepted: true };\r\n  }\r\n\r\n  // ===========================================================================\r\n  // EVENT HANDLING\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Register a handler for load level changes.\r\n   */\r\n  onLevelChange(handler: LoadLevelChangeHandler): void {\r\n    this.changeHandlers.push(handler);\r\n  }\r\n\r\n  /**\r\n   * Notify all handlers of a load level change.\r\n   */\r\n  private async notifyLevelChange(event: LoadLevelChangeEvent): Promise<void> {\r\n    logger.info({\r\n      facilitator_id: event.facilitator_id,\r\n      previous_level: event.previous_level,\r\n      new_level: event.new_level,\r\n      load_percentage: event.metrics.load_percentage,\r\n    }, 'Load level changed');\r\n\r\n    for (const handler of this.changeHandlers) {\r\n      try {\r\n        await handler(event);\r\n      } catch (error) {\r\n        logger.error({ error, facilitator_id: event.facilitator_id }, 'Load change handler failed');\r\n      }\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // CACHE MANAGEMENT\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Clear cached metrics for a facilitator.\r\n   */\r\n  clearCache(facilitator_id?: string): void {\r\n    if (facilitator_id) {\r\n      this.facilitatorMetrics.delete(facilitator_id);\r\n    } else {\r\n      this.facilitatorMetrics.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current cache state (for debugging).\r\n   */\r\n  getCacheState(): Map<string, FacilitatorLoadMetrics> {\r\n    return new Map(this.facilitatorMetrics);\r\n  }\r\n\r\n  // ===========================================================================\r\n  // CONFIGURATION\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get current thresholds.\r\n   */\r\n  getThresholds(): LoadThresholds {\r\n    return { ...this.thresholds };\r\n  }\r\n\r\n  /**\r\n   * Get current batch config.\r\n   */\r\n  getBatchConfig(): AdaptiveBatchConfig {\r\n    return { ...this.batchConfig };\r\n  }\r\n\r\n  /**\r\n   * Update thresholds dynamically.\r\n   */\r\n  updateThresholds(updates: Partial<LoadThresholds>): void {\r\n    this.thresholds = { ...this.thresholds, ...updates };\r\n    logger.info({ thresholds: this.thresholds }, 'Load thresholds updated');\r\n  }\r\n\r\n  /**\r\n   * Update batch config dynamically.\r\n   */\r\n  updateBatchConfig(updates: Partial<AdaptiveBatchConfig>): void {\r\n    this.batchConfig = { ...this.batchConfig, ...updates };\r\n    logger.info({ batchConfig: this.batchConfig }, 'Batch config updated');\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// SINGLETON INSTANCE\r\n// =============================================================================\r\n\r\nlet loadMonitorInstance: LoadMonitor | null = null;\r\n\r\n/**\r\n * Get the singleton LoadMonitor instance.\r\n */\r\nexport function getLoadMonitor(db?: any): LoadMonitor {\r\n  if (!loadMonitorInstance) {\r\n    if (!db) {\r\n      // Lazy import to avoid circular dependencies\r\n      const { getDb } = require('@/db/client');\r\n      db = getDb();\r\n    }\r\n    loadMonitorInstance = new LoadMonitor(db);\r\n  }\r\n  return loadMonitorInstance;\r\n}\r\n\r\n/**\r\n * Reset the singleton (for testing).\r\n */\r\nexport function resetLoadMonitor(): void {\r\n  loadMonitorInstance = null;\r\n}\r\n\r\n\r\n\r\n","// =============================================================================\r\n// LOAD MANAGEMENT TYPES\r\n// =============================================================================\r\n// Types for per-facilitator load monitoring, adaptive batch sizing,\r\n// payment prioritization, and backpressure signaling.\r\n\r\n// =============================================================================\r\n// LOAD LEVELS\r\n// =============================================================================\r\n\r\n/**\r\n * System load levels.\r\n * - NORMAL: All metrics below high thresholds\r\n * - HIGH: Some metrics above high thresholds but below critical\r\n * - CRITICAL: Any metric above critical threshold\r\n */\r\nexport type LoadLevel = 'NORMAL' | 'HIGH' | 'CRITICAL';\r\n\r\n// =============================================================================\r\n// LOAD METRICS\r\n// =============================================================================\r\n\r\n/**\r\n * Load metrics for a specific facilitator.\r\n * Tracks queue depth and in-flight operations.\r\n */\r\nexport interface FacilitatorLoadMetrics {\r\n  /** Facilitator identifier */\r\n  facilitator_id: string;\r\n  /** Number of unsettled batches (pending/queued) */\r\n  pending_batches: number;\r\n  /** Number of unsettled individual payments in queue */\r\n  pending_payments: number;\r\n  /** Number of batches currently being settled (submitted) */\r\n  in_flight_settlements: number;\r\n  /** Calculated load level based on thresholds */\r\n  load_level: LoadLevel;\r\n  /** Load percentage (0-100) based on distance to critical */\r\n  load_percentage: number;\r\n  /** When these metrics were last calculated */\r\n  last_updated_at: Date;\r\n}\r\n\r\n/**\r\n * Global system load metrics (aggregate across all facilitators).\r\n */\r\nexport interface SystemLoadMetrics {\r\n  /** Total pending batches across all facilitators */\r\n  total_pending_batches: number;\r\n  /** Total pending payments across all facilitators */\r\n  total_pending_payments: number;\r\n  /** Total in-flight settlements across all facilitators */\r\n  total_in_flight: number;\r\n  /** Number of facilitators at each load level */\r\n  facilitators_by_level: {\r\n    normal: number;\r\n    high: number;\r\n    critical: number;\r\n  };\r\n  /** Overall system health */\r\n  system_level: LoadLevel;\r\n  /** When these metrics were last calculated */\r\n  last_updated_at: Date;\r\n}\r\n\r\n// =============================================================================\r\n// THRESHOLDS\r\n// =============================================================================\r\n\r\n/**\r\n * Thresholds for determining load levels.\r\n * Each metric has a HIGH and CRITICAL threshold.\r\n */\r\nexport interface LoadThresholds {\r\n  /** Pending batches threshold for HIGH level */\r\n  high_pending_batches: number;\r\n  /** Pending batches threshold for CRITICAL level */\r\n  critical_pending_batches: number;\r\n  /** Pending payments threshold for HIGH level */\r\n  high_pending_payments: number;\r\n  /** Pending payments threshold for CRITICAL level */\r\n  critical_pending_payments: number;\r\n  /** In-flight settlements threshold for HIGH level */\r\n  high_in_flight: number;\r\n  /** In-flight settlements threshold for CRITICAL level */\r\n  critical_in_flight: number;\r\n}\r\n\r\n/**\r\n * Default thresholds for load monitoring.\r\n */\r\nexport const DEFAULT_LOAD_THRESHOLDS: LoadThresholds = {\r\n  high_pending_batches: 250,\r\n  critical_pending_batches: 500,\r\n  high_pending_payments: 25_000,\r\n  critical_pending_payments: 50_000,\r\n  high_in_flight: 10,\r\n  critical_in_flight: 25,\r\n};\r\n\r\n// =============================================================================\r\n// ADAPTIVE BATCH SIZING\r\n// =============================================================================\r\n\r\n/**\r\n * Configuration for adaptive batch sizing.\r\n * Batch size reduces as load increases.\r\n */\r\nexport interface AdaptiveBatchConfig {\r\n  /** Batch size when load is NORMAL (default: 100) */\r\n  normal_batch_size: number;\r\n  /** Minimum batch size during HIGH load (default: 25) */\r\n  high_batch_size_min: number;\r\n  /** Maximum batch size during HIGH load (default: 75) */\r\n  high_batch_size_max: number;\r\n  /** Batch size during CRITICAL load (0 = reject) */\r\n  critical_batch_size: number;\r\n}\r\n\r\n/**\r\n * Default adaptive batch sizing configuration.\r\n */\r\nexport const DEFAULT_BATCH_CONFIG: AdaptiveBatchConfig = {\r\n  normal_batch_size: 100,\r\n  high_batch_size_min: 25,\r\n  high_batch_size_max: 75,\r\n  critical_batch_size: 0, // Reject new batches\r\n};\r\n\r\n// =============================================================================\r\n// BACKPRESSURE HEADERS\r\n// =============================================================================\r\n\r\n/**\r\n * Backpressure headers included in API responses.\r\n * Signals load status to clients for retry/backoff decisions.\r\n */\r\nexport interface BackpressureHeaders {\r\n  /** Current load level for the facilitator */\r\n  'X-NexFlow-Load': LoadLevel;\r\n  /** Position in settlement queue */\r\n  'X-NexFlow-Queue-Position': string;\r\n  /** Estimated time to settlement in seconds */\r\n  'X-NexFlow-Estimated-Wait': string;\r\n  /** Seconds to wait before retry (only on 503) */\r\n  'X-NexFlow-Retry-After'?: string;\r\n  /** Whether batch size was reduced due to load */\r\n  'X-NexFlow-Batch-Size-Reduced'?: string;\r\n}\r\n\r\n// =============================================================================\r\n// PAYMENT PRIORITIZATION\r\n// =============================================================================\r\n\r\n/**\r\n * Payment size classification for prioritization.\r\n */\r\nexport type PaymentSizeClass = 'micro' | 'small' | 'medium' | 'large';\r\n\r\n/**\r\n * Payment with amount for prioritization.\r\n */\r\nexport interface PrioritizablePayment {\r\n  id: string;\r\n  amount_wei: string | bigint;\r\n  created_at?: Date;\r\n}\r\n\r\n// =============================================================================\r\n// LOAD ACCEPTANCE\r\n// =============================================================================\r\n\r\n/**\r\n * Result of checking whether to accept a new request.\r\n */\r\nexport interface LoadAcceptanceResult {\r\n  /** Whether the request should be accepted */\r\n  accepted: boolean;\r\n  /** Reason for rejection (if not accepted) */\r\n  reason?: string;\r\n  /** Suggested retry delay in seconds */\r\n  retry_after_seconds?: number;\r\n}\r\n\r\n// =============================================================================\r\n// LOAD EVENTS\r\n// =============================================================================\r\n\r\n/**\r\n * Event emitted when load level changes.\r\n */\r\nexport interface LoadLevelChangeEvent {\r\n  facilitator_id: string;\r\n  previous_level: LoadLevel;\r\n  new_level: LoadLevel;\r\n  metrics: FacilitatorLoadMetrics;\r\n  timestamp: Date;\r\n}\r\n\r\n/**\r\n * Load change event handler type.\r\n */\r\nexport type LoadLevelChangeHandler = (event: LoadLevelChangeEvent) => void | Promise<void>;\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}