{"version":3,"sources":["turbopack:///[project]/node_modules/thread-stream/package.json","../../../src/db/agent-recommendations.ts"],"sourcesContent":["{\"name\":\"thread-stream\",\"version\":\"3.1.0\",\"description\":\"A streaming way to send data to a Node.js Worker Thread\",\"main\":\"index.js\",\"types\":\"index.d.ts\",\"dependencies\":{\"real-require\":\"^0.2.0\"},\"devDependencies\":{\"@types/node\":\"^20.1.0\",\"@types/tap\":\"^15.0.0\",\"@yao-pkg/pkg\":\"^5.11.5\",\"desm\":\"^1.3.0\",\"fastbench\":\"^1.0.1\",\"husky\":\"^9.0.6\",\"pino-elasticsearch\":\"^8.0.0\",\"sonic-boom\":\"^4.0.1\",\"standard\":\"^17.0.0\",\"tap\":\"^16.2.0\",\"ts-node\":\"^10.8.0\",\"typescript\":\"^5.3.2\",\"why-is-node-running\":\"^2.2.2\"},\"scripts\":{\"build\":\"tsc --noEmit\",\"test\":\"standard && npm run build && npm run transpile && tap \\\"test/**/*.test.*js\\\" && tap --ts test/*.test.*ts\",\"test:ci\":\"standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts\",\"test:ci:js\":\"tap --no-check-coverage --timeout=120 --coverage-report=lcovonly \\\"test/**/*.test.*js\\\"\",\"test:ci:ts\":\"tap --ts --no-check-coverage --coverage-report=lcovonly \\\"test/**/*.test.*ts\\\"\",\"test:yarn\":\"npm run transpile && tap \\\"test/**/*.test.js\\\" --no-check-coverage\",\"transpile\":\"sh ./test/ts/transpile.sh\",\"prepare\":\"husky install\"},\"standard\":{\"ignore\":[\"test/ts/**/*\",\"test/syntax-error.mjs\"]},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/mcollina/thread-stream.git\"},\"keywords\":[\"worker\",\"thread\",\"threads\",\"stream\"],\"author\":\"Matteo Collina <hello@matteocollina.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/mcollina/thread-stream/issues\"},\"homepage\":\"https://github.com/mcollina/thread-stream#readme\"}","// =============================================================================\r\n// AGENT RECOMMENDATIONS DATABASE\r\n// =============================================================================\r\n// Persistence layer for agent recommendations\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  AgentRecommendation,\r\n  AgentRecommendationType,\r\n  AgentId,\r\n  RecommendationStatus,\r\n} from '@/agents/types';\r\n\r\nconst logger = createLogger({ component: 'AgentRecommendationsDB' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface RecommendationFilter {\r\n  agent?: AgentId;\r\n  type?: AgentRecommendationType;\r\n  status?: RecommendationStatus;\r\n  facilitatorId?: string;\r\n  priority?: 'low' | 'medium' | 'high' | 'critical';\r\n  since?: Date;\r\n  limit?: number;\r\n}\r\n\r\nexport interface CreateRecommendationInput {\r\n  agent: AgentId;\r\n  type: AgentRecommendationType;\r\n  facilitatorId?: string;\r\n  resourceId?: string;\r\n  priority: 'low' | 'medium' | 'high' | 'critical';\r\n  confidence: number;\r\n  details: Record<string, unknown>;\r\n  reasoning: string;\r\n  expiresAt?: Date;\r\n}\r\n\r\n// =============================================================================\r\n// DATABASE OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Create a new recommendation\r\n */\r\nexport async function createRecommendation(\r\n  input: CreateRecommendationInput\r\n): Promise<AgentRecommendation> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  const recommendation: AgentRecommendation = {\r\n    id,\r\n    createdAt: now,\r\n    agent: input.agent,\r\n    type: input.type,\r\n    facilitatorId: input.facilitatorId,\r\n    resourceId: input.resourceId,\r\n    priority: input.priority,\r\n    confidence: input.confidence,\r\n    details: input.details,\r\n    reasoning: input.reasoning,\r\n    status: 'PENDING',\r\n    expiresAt: input.expiresAt,\r\n  };\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `INSERT INTO agent_recommendations (\r\n        id, created_at, agent, type, facilitator_id, resource_id,\r\n        priority, confidence, details, reasoning, status, expires_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`,\r\n      [\r\n        id,\r\n        now.toISOString(),\r\n        input.agent,\r\n        input.type,\r\n        input.facilitatorId || null,\r\n        input.resourceId || null,\r\n        input.priority,\r\n        input.confidence,\r\n        JSON.stringify(input.details),\r\n        input.reasoning,\r\n        'PENDING',\r\n        input.expiresAt?.toISOString() || null,\r\n      ]\r\n    );\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO agent_recommendations (\r\n        id, created_at, agent, type, facilitator_id, resource_id,\r\n        priority, confidence, details, reasoning, status, expires_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      now.toISOString(),\r\n      input.agent,\r\n      input.type,\r\n      input.facilitatorId || null,\r\n      input.resourceId || null,\r\n      input.priority,\r\n      input.confidence,\r\n      JSON.stringify(input.details),\r\n      input.reasoning,\r\n      'PENDING',\r\n      input.expiresAt?.toISOString() || null\r\n    );\r\n  }\r\n\r\n  logger.info({\r\n    recommendationId: id,\r\n    agent: input.agent,\r\n    type: input.type,\r\n    priority: input.priority,\r\n    msg: 'Created agent recommendation',\r\n  });\r\n\r\n  return recommendation;\r\n}\r\n\r\n/**\r\n * Create multiple recommendations in batch\r\n */\r\nexport async function createRecommendations(\r\n  inputs: CreateRecommendationInput[]\r\n): Promise<AgentRecommendation[]> {\r\n  const results: AgentRecommendation[] = [];\r\n  for (const input of inputs) {\r\n    const rec = await createRecommendation(input);\r\n    results.push(rec);\r\n  }\r\n  return results;\r\n}\r\n\r\n/**\r\n * List recommendations with optional filters\r\n */\r\nexport async function listRecommendations(\r\n  filter: RecommendationFilter = {}\r\n): Promise<AgentRecommendation[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let query = 'SELECT * FROM agent_recommendations WHERE 1=1';\r\n  const params: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (filter.agent) {\r\n    query += isPostgres ? ` AND agent = $${paramIndex++}` : ' AND agent = ?';\r\n    params.push(filter.agent);\r\n  }\r\n\r\n  if (filter.type) {\r\n    query += isPostgres ? ` AND type = $${paramIndex++}` : ' AND type = ?';\r\n    params.push(filter.type);\r\n  }\r\n\r\n  if (filter.status) {\r\n    query += isPostgres ? ` AND status = $${paramIndex++}` : ' AND status = ?';\r\n    params.push(filter.status);\r\n  }\r\n\r\n  if (filter.facilitatorId) {\r\n    query += isPostgres ? ` AND facilitator_id = $${paramIndex++}` : ' AND facilitator_id = ?';\r\n    params.push(filter.facilitatorId);\r\n  }\r\n\r\n  if (filter.priority) {\r\n    query += isPostgres ? ` AND priority = $${paramIndex++}` : ' AND priority = ?';\r\n    params.push(filter.priority);\r\n  }\r\n\r\n  if (filter.since) {\r\n    query += isPostgres ? ` AND created_at >= $${paramIndex++}` : ' AND created_at >= ?';\r\n    params.push(filter.since.toISOString());\r\n  }\r\n\r\n  query += ' ORDER BY created_at DESC';\r\n\r\n  if (filter.limit) {\r\n    query += isPostgres ? ` LIMIT $${paramIndex++}` : ' LIMIT ?';\r\n    params.push(filter.limit);\r\n  }\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, params);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all(...params);\r\n  }\r\n\r\n  return rows.map(rowToRecommendation);\r\n}\r\n\r\n/**\r\n * Get a single recommendation by ID\r\n */\r\nexport async function getRecommendation(id: string): Promise<AgentRecommendation | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let row: any;\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      'SELECT * FROM agent_recommendations WHERE id = $1',\r\n      [id]\r\n    );\r\n    row = result.rows[0];\r\n  } else {\r\n    const stmt = (db as any).prepare('SELECT * FROM agent_recommendations WHERE id = ?');\r\n    row = stmt.get(id);\r\n  }\r\n\r\n  return row ? rowToRecommendation(row) : null;\r\n}\r\n\r\n/**\r\n * Mark a recommendation as applied\r\n */\r\nexport async function markRecommendationApplied(\r\n  id: string,\r\n  reviewedBy: string,\r\n  metadata?: Record<string, unknown>\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE agent_recommendations\r\n       SET status = 'APPLIED', reviewed_by = $1, reviewed_at = $2,\r\n           details = details || $3\r\n       WHERE id = $4`,\r\n      [reviewedBy, now, JSON.stringify(metadata || {}), id]\r\n    );\r\n  } else {\r\n    // SQLite - simpler update\r\n    const stmt = (db as any).prepare(`\r\n      UPDATE agent_recommendations\r\n      SET status = 'APPLIED', reviewed_by = ?, reviewed_at = ?\r\n      WHERE id = ?\r\n    `);\r\n    stmt.run(reviewedBy, now, id);\r\n  }\r\n\r\n  logger.info({ recommendationId: id, reviewedBy, msg: 'Recommendation applied' });\r\n}\r\n\r\n/**\r\n * Mark a recommendation as rejected\r\n */\r\nexport async function markRecommendationRejected(\r\n  id: string,\r\n  reviewedBy: string,\r\n  reason: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE agent_recommendations\r\n       SET status = 'REJECTED', reviewed_by = $1, reviewed_at = $2,\r\n           details = details || $3\r\n       WHERE id = $4`,\r\n      [reviewedBy, now, JSON.stringify({ rejectionReason: reason }), id]\r\n    );\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      UPDATE agent_recommendations\r\n      SET status = 'REJECTED', reviewed_by = ?, reviewed_at = ?\r\n      WHERE id = ?\r\n    `);\r\n    stmt.run(reviewedBy, now, id);\r\n  }\r\n\r\n  logger.info({ recommendationId: id, reviewedBy, reason, msg: 'Recommendation rejected' });\r\n}\r\n\r\n/**\r\n * Expire old pending recommendations\r\n */\r\nexport async function expirePendingRecommendations(): Promise<number> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `UPDATE agent_recommendations\r\n       SET status = 'EXPIRED'\r\n       WHERE status = 'PENDING' AND expires_at IS NOT NULL AND expires_at < $1`,\r\n      [now]\r\n    );\r\n    return result.rowCount || 0;\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      UPDATE agent_recommendations\r\n      SET status = 'EXPIRED'\r\n      WHERE status = 'PENDING' AND expires_at IS NOT NULL AND expires_at < ?\r\n    `);\r\n    const info = stmt.run(now);\r\n    return info.changes || 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Get pending recommendations count by agent\r\n */\r\nexport async function getPendingCountByAgent(): Promise<Record<AgentId, number>> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  const query = `\r\n    SELECT agent, COUNT(*) as count\r\n    FROM agent_recommendations\r\n    WHERE status = 'PENDING'\r\n    GROUP BY agent\r\n  `;\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all();\r\n  }\r\n\r\n  const counts: Record<string, number> = {};\r\n  for (const row of rows) {\r\n    counts[row.agent] = parseInt(row.count, 10);\r\n  }\r\n  return counts as Record<AgentId, number>;\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\nfunction rowToRecommendation(row: any): AgentRecommendation {\r\n  return {\r\n    id: row.id,\r\n    createdAt: new Date(row.created_at),\r\n    agent: row.agent,\r\n    type: row.type,\r\n    facilitatorId: row.facilitator_id || undefined,\r\n    resourceId: row.resource_id || undefined,\r\n    priority: row.priority,\r\n    confidence: parseFloat(row.confidence),\r\n    details: typeof row.details === 'string' ? JSON.parse(row.details) : row.details,\r\n    reasoning: row.reasoning,\r\n    status: row.status,\r\n    reviewedBy: row.reviewed_by || undefined,\r\n    reviewedAt: row.reviewed_at ? new Date(row.reviewed_at) : undefined,\r\n    expiresAt: row.expires_at ? new Date(row.expires_at) : undefined,\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"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"}