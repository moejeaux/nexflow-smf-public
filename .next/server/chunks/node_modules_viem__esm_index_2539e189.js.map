{"version":3,"sources":["../../../node_modules/viem/constants/bytes.ts","../../../node_modules/viem/utils/hash/isHash.ts","../../../node_modules/viem/utils/address/getContractAddress.ts","../../../node_modules/viem/utils/data/isBytes.ts","../../../node_modules/viem/utils/signature/parseErc8010Signature.ts","../../../node_modules/viem/utils/signature/isErc8010Signature.ts","../../../node_modules/viem/utils/signature/serializeErc8010Signature.ts","../../../node_modules/viem/actions/getContract.ts","../../../node_modules/viem/clients/transports/webSocket.ts","../../../node_modules/viem/errors/unit.ts","../../../node_modules/viem/utils/encoding/fromRlp.ts","../../../node_modules/viem/utils/signature/isErc6492Signature.ts","../../../node_modules/viem/utils/signature/parseCompactSignature.ts","../../../node_modules/viem/utils/signature/parseSignature.ts","../../../node_modules/viem/utils/rpc/socket.ts","../../../node_modules/viem/utils/rpc/webSocket.ts","../../../node_modules/viem/utils/signature/recoverTransactionAddress.ts","../../../node_modules/viem/utils/signature/serializeCompactSignature.ts","../../../node_modules/viem/utils/signature/serializeErc6492Signature.ts","../../../node_modules/viem/utils/unit/parseGwei.ts","../../../node_modules/viem/utils/unit/parseEther.ts","../../../node_modules/viem/clients/decorators/test.ts","../../../node_modules/viem/utils/kzg/setupKzg.ts","../../../node_modules/viem/utils/signature/compactSignatureToSignature.ts","../../../node_modules/viem/clients/transports/custom.ts","../../../node_modules/viem/utils/signature/signatureToCompactSignature.ts","../../../node_modules/viem/utils/signature/verifyHash.ts","../../../node_modules/viem/utils/signature/verifyMessage.ts","../../../node_modules/viem/actions/test/setNextBlockBaseFeePerGas.ts","../../../node_modules/viem/actions/test/getTxpoolStatus.ts","../../../node_modules/viem/utils/signature/parseErc6492Signature.ts","../../../node_modules/viem/actions/test/mine.ts","../../../node_modules/viem/actions/test/setBlockGasLimit.ts","../../../node_modules/viem/utils/signature/recoverMessageAddress.ts","../../../node_modules/viem/utils/transaction/parseTransaction.ts","../../../node_modules/viem/actions/test/setNextBlockTimestamp.ts","../../../node_modules/viem/actions/test/setNonce.ts","../../../node_modules/viem/utils/chain/extractChain.ts","../../../node_modules/viem/actions/test/setStorageAt.ts","../../../node_modules/viem/actions/test/setBalance.ts","../../../node_modules/viem/node_modules/abitype/src/human-readable/parseAbiItem.ts","../../../node_modules/viem/actions/test/increaseTime.ts","../../../node_modules/viem/utils/nonceManager.ts","../../../node_modules/viem/actions/test/setMinGasPrice.ts","../../../node_modules/viem/clients/createTestClient.ts","../../../node_modules/viem/utils/ens/toCoinType.ts","../../../node_modules/viem/utils/blob/sidecarsToVersionedHashes.ts","../../../node_modules/viem/node_modules/abitype/src/human-readable/parseAbiParameters.ts","../../../node_modules/viem/utils/unit/parseUnits.ts","../../../node_modules/viem/node_modules/abitype/src/human-readable/parseAbiParameter.ts","../../../node_modules/viem/utils/abi/decodeDeployData.ts","../../../node_modules/viem/types/eip1193.ts","../../../node_modules/viem/utils/hash/ripemd160.ts","../../../node_modules/viem/utils/transaction/getSerializedTransactionType.ts","../../../node_modules/viem/actions/test/sendUnsignedTransaction.ts","../../../node_modules/viem/clients/transports/fallback.ts","../../../node_modules/viem/utils/abi/encodePacked.ts","../../../node_modules/viem/index.ts","../../../node_modules/viem/utils/blob/fromBlobs.ts","../../../node_modules/viem/utils/rpc/compat.ts","../../../node_modules/viem/utils/kzg/defineKzg.ts","../../../node_modules/viem/actions/test/inspectTxpool.ts","../../../node_modules/viem/actions/test/setIntervalMining.ts","../../../node_modules/viem/actions/test/setRpcUrl.ts","../../../node_modules/viem/actions/test/loadState.ts","../../../node_modules/viem/actions/test/reset.ts","../../../node_modules/viem/actions/test/revert.ts","../../../node_modules/viem/actions/test/dumpState.ts","../../../node_modules/viem/actions/test/getAutomine.ts","../../../node_modules/viem/actions/test/getTxpoolContent.ts","../../../node_modules/viem/actions/test/setBlockTimestampInterval.ts","../../../node_modules/viem/actions/test/snapshot.ts","../../../node_modules/viem/actions/test/removeBlockTimestampInterval.ts","../../../node_modules/viem/actions/test/setAutomine.ts","../../../node_modules/viem/actions/test/setLoggingEnabled.ts","../../../node_modules/viem/actions/test/impersonateAccount.ts","../../../node_modules/viem/actions/test/setCoinbase.ts","../../../node_modules/viem/actions/test/setCode.ts","../../../node_modules/viem/actions/test/dropTransaction.ts","../../../node_modules/viem/actions/test/stopImpersonatingAccount.ts"],"sourcesContent":["export const erc6492MagicBytes =\n  '0x6492649264926492649264926492649264926492649264926492649264926492' as const\n\nexport const zeroHash =\n  '0x0000000000000000000000000000000000000000000000000000000000000000' as const\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type SizeErrorType, size } from '../data/size.js'\n\nexport type IsHashErrorType = IsHexErrorType | SizeErrorType | ErrorType\n\nexport function isHash(hash: string): hash is Hex {\n  return isHex(hash) && size(hash) === 32\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { type IsBytesErrorType, isBytes } from '../data/isBytes.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { type GetAddressErrorType, getAddress } from './getAddress.js'\n\nexport type GetCreateAddressOptions = {\n  from: Address\n  nonce: bigint\n}\n\nexport type GetCreate2AddressOptions =\n  | {\n      bytecode: ByteArray | Hex\n      from: Address\n      salt: ByteArray | Hex\n    }\n  | {\n      bytecodeHash: ByteArray | Hex\n      from: Address\n      salt: ByteArray | Hex\n    }\n\nexport type GetContractAddressOptions =\n  | ({\n      opcode?: 'CREATE' | undefined\n    } & GetCreateAddressOptions)\n  | ({ opcode: 'CREATE2' } & GetCreate2AddressOptions)\n\nexport function getContractAddress(opts: GetContractAddressOptions) {\n  if (opts.opcode === 'CREATE2') return getCreate2Address(opts)\n  return getCreateAddress(opts)\n}\n\nexport type GetCreateAddressErrorType =\n  | Keccak256ErrorType\n  | GetAddressErrorType\n  | ToBytesErrorType\n  | ToRlpErrorType\n  | ErrorType\n\nexport function getCreateAddress(opts: GetCreateAddressOptions) {\n  const from = toBytes(getAddress(opts.from))\n\n  let nonce = toBytes(opts.nonce)\n  if (nonce[0] === 0) nonce = new Uint8Array([])\n\n  return getAddress(\n    `0x${keccak256(toRlp([from, nonce], 'bytes')).slice(26)}` as Address,\n  )\n}\n\nexport type GetCreate2AddressErrorType =\n  | ConcatErrorType\n  | Keccak256ErrorType\n  | GetAddressErrorType\n  | IsBytesErrorType\n  | PadErrorType\n  | SliceErrorType\n  | ToBytesErrorType\n  | ToRlpErrorType\n  | ErrorType\n\nexport function getCreate2Address(opts: GetCreate2AddressOptions) {\n  const from = toBytes(getAddress(opts.from))\n  const salt = pad(isBytes(opts.salt) ? opts.salt : toBytes(opts.salt), {\n    size: 32,\n  })\n\n  const bytecodeHash = (() => {\n    if ('bytecodeHash' in opts) {\n      if (isBytes(opts.bytecodeHash)) return opts.bytecodeHash\n      return toBytes(opts.bytecodeHash)\n    }\n    return keccak256(opts.bytecode, 'bytes')\n  })()\n\n  return getAddress(\n    slice(keccak256(concat([toBytes('0xff'), from, salt, bytecodeHash])), 12),\n  )\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray } from '../../types/misc.js'\n\nexport type IsBytesErrorType = ErrorType\n\nexport function isBytes(value: unknown): value is ByteArray {\n  if (!value) return false\n  if (typeof value !== 'object') return false\n  if (!('BYTES_PER_ELEMENT' in value)) return false\n  return (\n    value.BYTES_PER_ELEMENT === 1 && value.constructor.name === 'Uint8Array'\n  )\n}\n","import type { Address } from 'abitype'\nimport { SignatureErc8010 } from 'ox/erc8010'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { SignedAuthorization } from '../../types/authorization.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { OneOf, Prettify } from '../../types/utils.js'\nimport { numberToHex } from '../encoding/toHex.js'\nimport {\n  type IsErc8010SignatureErrorType,\n  isErc8010Signature,\n} from './isErc8010Signature.js'\n\nexport type ParseErc8010SignatureParameters = Hex\n\nexport type ParseErc8010SignatureReturnType = Prettify<\n  OneOf<\n    | {\n        /** Address of the initializer. */\n        address?: Address | undefined\n        /** Authorization signed by the delegatee. */\n        authorization: SignedAuthorization\n        /** Data to initialize the delegation. */\n        data?: Hex | undefined\n        /** The original signature. */\n        signature: Hex\n      }\n    | {\n        /** The original signature. */\n        signature: Hex\n      }\n  >\n>\n\nexport type ParseErc8010SignatureErrorType =\n  | IsErc8010SignatureErrorType\n  | ErrorType\n\n/**\n * @description Parses a hex-formatted ERC-8010 flavoured signature.\n * If the signature is not in ERC-8010 format, then the underlying (original) signature is returned.\n *\n * @param signature ERC-8010 signature in hex format.\n * @returns The parsed ERC-8010 signature.\n */\nexport function parseErc8010Signature(\n  signature: ParseErc8010SignatureParameters,\n): ParseErc8010SignatureReturnType {\n  if (!isErc8010Signature(signature)) return { signature }\n\n  const {\n    authorization: authorization_ox,\n    to,\n    ...rest\n  } = SignatureErc8010.unwrap(signature)\n  return {\n    authorization: {\n      address: authorization_ox.address,\n      chainId: authorization_ox.chainId,\n      nonce: Number(authorization_ox.nonce),\n      r: numberToHex(authorization_ox.r, { size: 32 }),\n      s: numberToHex(authorization_ox.s, { size: 32 }),\n      yParity: authorization_ox.yParity,\n    },\n    ...(to ? { address: to } : {}),\n    ...rest,\n  }\n}\n","import { SignatureErc8010 } from 'ox/erc8010'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type IsErc8010SignatureParameters = Hex\nexport type IsErc8010SignatureReturnType = boolean\nexport type IsErc8010SignatureErrorType = ErrorType\n\n/** Whether or not the signature is an ERC-8010 formatted signature. */\nexport function isErc8010Signature(\n  signature: IsErc8010SignatureParameters,\n): IsErc8010SignatureReturnType {\n  return SignatureErc8010.validate(signature)\n}\n","import type { Address } from 'abitype'\nimport { SignatureErc8010 } from 'ox/erc8010'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { SignedAuthorization } from '../../types/authorization.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { hexToBytes } from '../encoding/toBytes.js'\n\ntype To = 'bytes' | 'hex'\n\nexport type SerializeErc8010SignatureParameters<to extends To = 'hex'> = {\n  /** Address of the initializer. */\n  address?: Address | undefined\n  /** Authorization signed by the delegatee. */\n  authorization: SignedAuthorization\n  /** Data to initialize the delegation. */\n  data?: Hex | undefined\n  /** The original signature. */\n  signature: Hex\n  to?: to | To | undefined\n}\n\nexport type SerializeErc8010SignatureReturnType<to extends To = 'hex'> =\n  | (to extends 'hex' ? Hex : never)\n  | (to extends 'bytes' ? ByteArray : never)\n\nexport type SerializeErc8010SignatureErrorType = ErrorType\n\n/**\n * @description Serializes a ERC-8010 flavoured signature into hex format.\n *\n * @param signature ERC-8010 signature in object format.\n * @returns ERC-8010 signature in hex format.\n */\nexport function serializeErc8010Signature<to extends To = 'hex'>(\n  parameters: SerializeErc8010SignatureParameters<to>,\n): SerializeErc8010SignatureReturnType<to> {\n  const { address, data, signature, to = 'hex' } = parameters\n  const signature_ = SignatureErc8010.wrap({\n    authorization: {\n      address: parameters.authorization.address,\n      chainId: parameters.authorization.chainId,\n      nonce: BigInt(parameters.authorization.nonce),\n      r: BigInt(parameters.authorization.r),\n      s: BigInt(parameters.authorization.s),\n      yParity: parameters.authorization.yParity!,\n    },\n    data,\n    signature,\n    to: address,\n  })\n  if (to === 'hex') return signature_ as SerializeErc8010SignatureReturnType<to>\n  return hexToBytes(signature_) as SerializeErc8010SignatureReturnType<to>\n}\n","import type {\n  Abi,\n  AbiEvent,\n  AbiFunction,\n  AbiParametersToPrimitiveTypes,\n  Address,\n  ExtractAbiEvent,\n  ExtractAbiEventNames,\n  ExtractAbiFunction,\n  ExtractAbiFunctionNames,\n} from 'abitype'\n\nimport type { Account } from '../accounts/types.js'\nimport type { Client } from '../clients/createClient.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Chain } from '../types/chain.js'\nimport type {\n  AbiEventParametersToPrimitiveTypes,\n  ContractEventName,\n  ContractFunctionArgs,\n  ContractFunctionName,\n  MaybeExtractEventArgsFromAbi,\n} from '../types/contract.js'\nimport type {\n  IsNarrowable,\n  IsNever,\n  IsUndefined,\n  Or,\n  Prettify,\n  UnionOmit,\n} from '../types/utils.js'\nimport { getAction } from '../utils/getAction.js'\nimport {\n  type CreateContractEventFilterParameters,\n  type CreateContractEventFilterReturnType,\n  createContractEventFilter,\n} from './public/createContractEventFilter.js'\nimport {\n  type EstimateContractGasParameters,\n  type EstimateContractGasReturnType,\n  estimateContractGas,\n} from './public/estimateContractGas.js'\nimport {\n  type GetContractEventsParameters,\n  type GetContractEventsReturnType,\n  getContractEvents,\n} from './public/getContractEvents.js'\nimport {\n  type ReadContractParameters,\n  type ReadContractReturnType,\n  readContract,\n} from './public/readContract.js'\nimport {\n  type SimulateContractParameters,\n  type SimulateContractReturnType,\n  simulateContract,\n} from './public/simulateContract.js'\nimport {\n  type WatchContractEventParameters,\n  type WatchContractEventReturnType,\n  watchContractEvent,\n} from './public/watchContractEvent.js'\nimport {\n  type WriteContractParameters,\n  type WriteContractReturnType,\n  writeContract,\n} from './wallet/writeContract.js'\n\ntype KeyedClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> =\n  | {\n      public?: Client<transport, chain> | undefined\n      wallet: Client<transport, chain, account>\n    }\n  | {\n      public: Client<transport, chain>\n      wallet?: Client<transport, chain, account> | undefined\n    }\n\nexport type GetContractParameters<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  abi extends Abi | readonly unknown[] = Abi,\n  client extends\n    | Client<transport, chain, account>\n    | KeyedClient<transport, chain, account> =\n    | Client<transport, chain, account>\n    | KeyedClient<transport, chain, account>,\n  address extends Address = Address,\n> = {\n  /** Contract ABI */\n  abi: abi\n  /** Contract address */\n  address: address\n  /** The Client.\n   *\n   * If you pass in a [`publicClient`](https://viem.sh/docs/clients/public), the following methods are available:\n   *\n   * - [`createEventFilter`](https://viem.sh/docs/contract/createContractEventFilter)\n   * - [`estimateGas`](https://viem.sh/docs/contract/estimateContractGas)\n   * - [`getEvents`](https://viem.sh/docs/contract/getContractEvents)\n   * - [`read`](https://viem.sh/docs/contract/readContract)\n   * - [`simulate`](https://viem.sh/docs/contract/simulateContract)\n   * - [`watchEvent`](https://viem.sh/docs/contract/watchContractEvent)\n   *\n   * If you pass in a [`walletClient`](https://viem.sh/docs/clients/wallet), the following methods are available:\n   *\n   * - [`estimateGas`](https://viem.sh/docs/contract/estimateContractGas)\n   * - [`write`](https://viem.sh/docs/contract/writeContract)\n   */\n  client: client\n}\n\nexport type GetContractReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  client extends Client | KeyedClient = Client | KeyedClient,\n  address extends Address = Address,\n  //\n  _eventNames extends string = abi extends Abi\n    ? Abi extends abi\n      ? string\n      : ExtractAbiEventNames<abi>\n    : string,\n  _readFunctionNames extends string = abi extends Abi\n    ? Abi extends abi\n      ? string\n      : ExtractAbiFunctionNames<abi, 'pure' | 'view'>\n    : string,\n  _writeFunctionNames extends string = abi extends Abi\n    ? Abi extends abi\n      ? string\n      : ExtractAbiFunctionNames<abi, 'nonpayable' | 'payable'>\n    : string,\n  _narrowable extends boolean = IsNarrowable<abi, Abi>,\n  _publicClient extends Client | unknown = client extends {\n    public: Client\n  }\n    ? client['public']\n    : client,\n  _walletClient extends Client | unknown = client extends {\n    wallet: Client\n  }\n    ? client['wallet']\n    : client,\n> = Prettify<\n  Prettify<\n    (_publicClient extends Client\n      ? (IsNever<_readFunctionNames> extends true\n          ? unknown\n          : {\n              /**\n               * Calls a read-only function on a contract, and returns the response.\n               *\n               * A \"read-only\" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.\n               *\n               * Internally, `read` uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n               *\n               * @example\n               * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n               * import { mainnet } from 'viem/chains'\n               *\n               * const publicClient = createPublicClient({\n               *   chain: mainnet,\n               *   transport: http(),\n               * })\n               * const contract = getContract({\n               *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n               *   abi: parseAbi([\n               *     'function balanceOf(address owner) view returns (uint256)',\n               *   ]),\n               *   client: publicClient,\n               * })\n               * const result = await contract.read.balanceOf(['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'])\n               * // 424122n\n               */\n              read: {\n                [functionName in _readFunctionNames]: GetReadFunction<\n                  _narrowable,\n                  abi,\n                  functionName extends ContractFunctionName<\n                    abi,\n                    'pure' | 'view'\n                  >\n                    ? functionName\n                    : never\n                >\n              }\n            }) &\n          (IsNever<_writeFunctionNames> extends true\n            ? unknown\n            : {\n                /**\n                 * Estimates the gas necessary to complete a transaction without submitting it to the network.\n                 *\n                 * @example\n                 * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n                 * import { mainnet } from 'viem/chains'\n                 *\n                 * const publicClient = createPublicClient({\n                 *   chain: mainnet,\n                 *   transport: http(),\n                 * })\n                 * const contract = getContract({\n                 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n                 *   abi: parseAbi(['function mint() public']),\n                 *   client: publicClient,\n                 * })\n                 * const gas = await contract.estimateGas.mint({\n                 *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n                 * })\n                 */\n                estimateGas: {\n                  [functionName in _writeFunctionNames]: GetEstimateFunction<\n                    _narrowable,\n                    _publicClient['chain'],\n                    undefined,\n                    abi,\n                    functionName extends ContractFunctionName<\n                      abi,\n                      'nonpayable' | 'payable'\n                    >\n                      ? functionName\n                      : never\n                  >\n                }\n                /**\n                 * Simulates/validates a contract interaction. This is useful for retrieving return data and revert reasons of contract write functions.\n                 *\n                 * This function does not require gas to execute and does not change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract), but also supports contract write functions.\n                 *\n                 * Internally, `simulate` uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n                 *\n                 * @example\n                 * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n                 * import { mainnet } from 'viem/chains'\n                 *\n                 * const publicClient = createPublicClient({\n                 *   chain: mainnet,\n                 *   transport: http(),\n                 * })\n                 * const contract = getContract({\n                 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n                 *   abi: parseAbi(['function mint() public']),\n                 *   client: publicClient,\n                 * })\n                 * const result = await contract.simulate.mint({\n                 *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n                 * })\n                 */\n                simulate: {\n                  [functionName in _writeFunctionNames]: GetSimulateFunction<\n                    _narrowable,\n                    _publicClient['chain'],\n                    _walletClient extends Client\n                      ? _walletClient['account']\n                      : _publicClient['account'],\n                    abi,\n                    functionName extends ContractFunctionName<\n                      abi,\n                      'nonpayable' | 'payable'\n                    >\n                      ? functionName\n                      : never\n                  >\n                }\n              }) &\n          (IsNever<_eventNames> extends true\n            ? unknown\n            : {\n                /**\n                 * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs).\n                 *\n                 * @example\n                 * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n                 * import { mainnet } from 'viem/chains'\n                 *\n                 * const publicClient = createPublicClient({\n                 *   chain: mainnet,\n                 *   transport: http(),\n                 * })\n                 * const contract = getContract({\n                 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n                 *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n                 *   client: publicClient,\n                 * })\n                 * const filter = await contract.createEventFilter.Transfer()\n                 */\n                createEventFilter: {\n                  [EventName in _eventNames]: GetEventFilter<\n                    _narrowable,\n                    abi,\n                    EventName extends ContractEventName<abi> ? EventName : never\n                  >\n                }\n                /**\n                 * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs).\n                 *\n                 * @example\n                 * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n                 * import { mainnet } from 'viem/chains'\n                 *\n                 * const publicClient = createPublicClient({\n                 *   chain: mainnet,\n                 *   transport: http(),\n                 * })\n                 * const contract = getContract({\n                 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n                 *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n                 *   client: publicClient,\n                 * })\n                 * const filter = await contract.createEventFilter.Transfer()\n                 */\n                getEvents: {\n                  [EventName in _eventNames]: GetEventsFunction<\n                    _narrowable,\n                    abi,\n                    EventName extends ContractEventName<abi> ? EventName : never\n                  >\n                }\n                /**\n                 * Watches and returns emitted contract event logs.\n                 *\n                 * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent#onLogs).\n                 *\n                 * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n                 *\n                 * @example\n                 * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n                 * import { mainnet } from 'viem/chains'\n                 *\n                 * const publicClient = createPublicClient({\n                 *   chain: mainnet,\n                 *   transport: http(),\n                 * })\n                 * const contract = getContract({\n                 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n                 *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n                 *   client: publicClient,\n                 * })\n                 * const filter = await contract.createEventFilter.Transfer()\n                 * const unwatch = contract.watchEvent.Transfer(\n                 *   { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n                 *   { onLogs: (logs) => console.log(logs) },\n                 * )\n                 */\n                watchEvent: {\n                  [EventName in _eventNames]: GetWatchEvent<\n                    _narrowable,\n                    abi,\n                    EventName extends ContractEventName<abi> ? EventName : never\n                  >\n                }\n              })\n      : unknown) &\n      (_walletClient extends Client\n        ? IsNever<_writeFunctionNames> extends true\n          ? unknown\n          : {\n              /**\n               * Estimates the gas necessary to complete a transaction without submitting it to the network.\n               *\n               * @example\n               * import { createWalletClient, getContract, http, parseAbi } from 'viem'\n               * import { mainnet } from 'viem/chains'\n               *\n               * const walletClient = createWalletClient({\n               *   chain: mainnet,\n               *   transport: http(),\n               * })\n               * const contract = getContract({\n               *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n               *   abi: parseAbi(['function mint() public']),\n               *   client: walletClient,\n               * })\n               * const gas = await contract.estimateGas.mint({\n               *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n               * })\n               */\n              estimateGas: {\n                [functionName in _writeFunctionNames]: GetEstimateFunction<\n                  _narrowable,\n                  _walletClient['chain'],\n                  _walletClient['account'],\n                  abi,\n                  functionName extends ContractFunctionName<\n                    abi,\n                    'nonpayable' | 'payable'\n                  >\n                    ? functionName\n                    : never\n                >\n              }\n              /**\n               * Executes a write function on a contract.\n               *\n               * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n               *\n               * Internally, `write` uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n               *\n               * __Warning: The `write` internally sends a transaction â€“ it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n               *\n               * @example\n               * import { createWalletClient, getContract, http, parseAbi } from 'viem'\n               * import { mainnet } from 'viem/chains'\n               *\n               * const walletClient = createWalletClient({\n               *   chain: mainnet,\n               *   transport: http(),\n               * })\n               * const contract = getContract({\n               *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n               *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n               *   client: walletClient,\n               * })\n               * const hash = await contract.write.min([69420], {\n               *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n               * })\n               */\n              write: {\n                [functionName in _writeFunctionNames]: GetWriteFunction<\n                  _narrowable,\n                  _walletClient['chain'],\n                  _walletClient['account'],\n                  abi,\n                  functionName extends ContractFunctionName<\n                    abi,\n                    'nonpayable' | 'payable'\n                  >\n                    ? functionName\n                    : never\n                >\n              }\n            }\n        : unknown)\n  > & { address: address; abi: abi }\n>\n\nexport type GetContractErrorType = ErrorType\n\n/**\n * Gets type-safe interface for performing contract-related actions with a specific `abi` and `address`.\n *\n * - Docs https://viem.sh/docs/contract/getContract\n *\n * Using Contract Instances can make it easier to work with contracts if you don't want to pass the `abi` and `address` properties every time you perform contract actions, e.g. [`readContract`](https://viem.sh/docs/contract/readContract), [`writeContract`](https://viem.sh/docs/contract/writeContract), [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas), etc.\n *\n * @example\n * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const publicClient = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const contract = getContract({\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi([\n *     'function balanceOf(address owner) view returns (uint256)',\n *     'function ownerOf(uint256 tokenId) view returns (address)',\n *     'function totalSupply() view returns (uint256)',\n *   ]),\n *   client: publicClient,\n * })\n */\nexport function getContract<\n  transport extends Transport,\n  address extends Address,\n  const abi extends Abi | readonly unknown[],\n  const client extends\n    | Client<transport, chain, account>\n    | KeyedClient<transport, chain, account>,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n>({\n  abi,\n  address,\n  client: client_,\n}: GetContractParameters<\n  transport,\n  chain,\n  account,\n  abi,\n  client,\n  address\n>): GetContractReturnType<abi, client, address> {\n  const client = client_ as\n    | Client<transport, chain, account>\n    | KeyedClient<transport, chain, account>\n\n  const [publicClient, walletClient] = (() => {\n    if (!client) return [undefined, undefined]\n    if ('public' in client && 'wallet' in client)\n      return [client.public as Client, client.wallet as Client]\n    if ('public' in client) return [client.public as Client, undefined]\n    if ('wallet' in client) return [undefined, client.wallet as Client]\n    return [client, client]\n  })()\n\n  const hasPublicClient = publicClient !== undefined && publicClient !== null\n  const hasWalletClient = walletClient !== undefined && walletClient !== null\n\n  const contract: {\n    [_ in\n      | 'abi'\n      | 'address'\n      | 'createEventFilter'\n      | 'estimateGas'\n      | 'getEvents'\n      | 'read'\n      | 'simulate'\n      | 'watchEvent'\n      | 'write']?: unknown\n  } = {}\n\n  let hasReadFunction = false\n  let hasWriteFunction = false\n  let hasEvent = false\n  for (const item of abi as Abi) {\n    if (item.type === 'function')\n      if (item.stateMutability === 'view' || item.stateMutability === 'pure')\n        hasReadFunction = true\n      else hasWriteFunction = true\n    else if (item.type === 'event') hasEvent = true\n    // Exit early if all flags are `true`\n    if (hasReadFunction && hasWriteFunction && hasEvent) break\n  }\n\n  if (hasPublicClient) {\n    if (hasReadFunction)\n      contract.read = new Proxy(\n        {},\n        {\n          get(_, functionName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[] | undefined,\n                options?: UnionOmit<\n                  ReadContractParameters,\n                  'abi' | 'address' | 'functionName' | 'args'\n                >,\n              ]\n            ) => {\n              const { args, options } = getFunctionParameters(parameters)\n              return getAction(\n                publicClient,\n                readContract,\n                'readContract',\n              )({\n                abi,\n                address,\n                functionName,\n                args,\n                ...options,\n              } as ReadContractParameters)\n            }\n          },\n        },\n      )\n\n    if (hasWriteFunction)\n      contract.simulate = new Proxy(\n        {},\n        {\n          get(_, functionName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[],\n                options?: UnionOmit<\n                  SimulateContractParameters,\n                  'abi' | 'address' | 'functionName' | 'args'\n                >,\n              ]\n            ) => {\n              const { args, options } = getFunctionParameters(parameters)\n              return getAction(\n                publicClient,\n                simulateContract,\n                'simulateContract',\n              )({\n                abi,\n                address,\n                functionName,\n                args,\n                ...options,\n              } as SimulateContractParameters)\n            }\n          },\n        },\n      )\n\n    if (hasEvent) {\n      contract.createEventFilter = new Proxy(\n        {},\n        {\n          get(_, eventName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[] | object,\n                options?: Omit<\n                  CreateContractEventFilterParameters,\n                  'abi' | 'address' | 'eventName' | 'args'\n                >,\n              ]\n            ) => {\n              const abiEvent = (abi as readonly AbiEvent[]).find(\n                (x: AbiEvent) => x.type === 'event' && x.name === eventName,\n              )\n              const { args, options } = getEventParameters(\n                parameters,\n                abiEvent!,\n              )\n              return getAction(\n                publicClient,\n                createContractEventFilter,\n                'createContractEventFilter',\n              )({\n                abi,\n                address,\n                eventName,\n                args,\n                ...options,\n              } as CreateContractEventFilterParameters)\n            }\n          },\n        },\n      )\n      contract.getEvents = new Proxy(\n        {},\n        {\n          get(_, eventName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[] | object,\n                options?: Omit<\n                  GetContractEventsParameters,\n                  'abi' | 'address' | 'eventName'\n                >,\n              ]\n            ) => {\n              const abiEvent = (abi as readonly AbiEvent[]).find(\n                (x: AbiEvent) => x.type === 'event' && x.name === eventName,\n              )\n              const { args, options } = getEventParameters(\n                parameters,\n                abiEvent!,\n              )\n              return getAction(\n                publicClient,\n                getContractEvents,\n                'getContractEvents',\n              )({\n                abi,\n                address,\n                eventName,\n                args,\n                ...options,\n              } as unknown as GetContractEventsParameters)\n            }\n          },\n        },\n      )\n      contract.watchEvent = new Proxy(\n        {},\n        {\n          get(_, eventName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[] | object,\n                options?: Omit<\n                  WatchContractEventParameters,\n                  'abi' | 'address' | 'eventName'\n                >,\n              ]\n            ) => {\n              const abiEvent = (abi as readonly AbiEvent[]).find(\n                (x: AbiEvent) => x.type === 'event' && x.name === eventName,\n              )\n              const { args, options } = getEventParameters(\n                parameters,\n                abiEvent!,\n              )\n              return getAction(\n                publicClient,\n                watchContractEvent,\n                'watchContractEvent',\n              )({\n                abi,\n                address,\n                eventName,\n                args,\n                ...options,\n              } as unknown as WatchContractEventParameters)\n            }\n          },\n        },\n      )\n    }\n  }\n\n  if (hasWalletClient) {\n    if (hasWriteFunction)\n      contract.write = new Proxy(\n        {},\n        {\n          get(_, functionName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[],\n                options?: UnionOmit<\n                  WriteContractParameters,\n                  'abi' | 'address' | 'functionName' | 'args'\n                >,\n              ]\n            ) => {\n              const { args, options } = getFunctionParameters(parameters)\n              return getAction(\n                walletClient,\n                writeContract,\n                'writeContract',\n              )({\n                abi,\n                address,\n                functionName,\n                args,\n                ...(options as any),\n              })\n            }\n          },\n        },\n      )\n  }\n\n  if (hasPublicClient || hasWalletClient)\n    if (hasWriteFunction)\n      contract.estimateGas = new Proxy(\n        {},\n        {\n          get(_, functionName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[],\n                options?: UnionOmit<\n                  EstimateContractGasParameters,\n                  'abi' | 'address' | 'functionName' | 'args'\n                >,\n              ]\n            ) => {\n              const { args, options } = getFunctionParameters(parameters)\n              const client = (publicClient ?? walletClient)!\n              return getAction(\n                client,\n                estimateContractGas,\n                'estimateContractGas',\n              )({\n                abi,\n                address,\n                functionName,\n                args,\n                ...options,\n                account:\n                  (options as EstimateContractGasParameters).account ??\n                  (walletClient as unknown as Client).account,\n              } as any)\n            }\n          },\n        },\n      )\n  contract.address = address\n  contract.abi = abi\n\n  return contract as unknown as GetContractReturnType<abi, client, address>\n}\n\n/**\n * @internal exporting for testing only\n */\nexport function getFunctionParameters(\n  values: [args?: readonly unknown[] | undefined, options?: object | undefined],\n) {\n  const hasArgs = values.length && Array.isArray(values[0])\n  const args = hasArgs ? values[0]! : []\n  const options = (hasArgs ? values[1] : values[0]) ?? {}\n  return { args, options }\n}\n\n/**\n * @internal exporting for testing only\n */\nexport function getEventParameters(\n  values: [args?: object | unknown[], options?: object],\n  abiEvent: AbiEvent,\n) {\n  let hasArgs = false\n  // If first item is array, must be `args`\n  if (Array.isArray(values[0])) hasArgs = true\n  // Check if first item is `args` or `options`\n  else if (values.length === 1) {\n    // if event has indexed inputs, must have `args`\n    hasArgs = abiEvent.inputs.some((x) => x.indexed)\n    // If there are two items in array, must have `args`\n  } else if (values.length === 2) {\n    hasArgs = true\n  }\n\n  const args = hasArgs ? values[0]! : undefined\n  const options = (hasArgs ? values[1] : values[0]) ?? {}\n  return { args, options }\n}\n\ntype GetReadFunction<\n  narrowable extends boolean,\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  abiFunction extends AbiFunction = abi extends Abi\n    ? ExtractAbiFunction<abi, functionName>\n    : AbiFunction,\n  //\n  _args = AbiParametersToPrimitiveTypes<abiFunction['inputs'], 'inputs', true>,\n  _options = Prettify<\n    UnionOmit<\n      ReadContractParameters<abi, functionName, args>,\n      'abi' | 'address' | 'args' | 'functionName'\n    >\n  >,\n> = narrowable extends true\n  ? (\n      ...parameters: _args extends readonly []\n        ? [options?: _options]\n        : [args: _args, options?: _options]\n    ) => Promise<ReadContractReturnType<abi, functionName, args>>\n  : (\n      ...parameters:\n        | [options?: _options]\n        | [args: readonly unknown[], options?: _options]\n    ) => Promise<ReadContractReturnType>\n\ntype GetEstimateFunction<\n  narrowable extends boolean,\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  abiFunction extends AbiFunction = abi extends Abi\n    ? ExtractAbiFunction<abi, functionName>\n    : AbiFunction,\n  //\n  _args = AbiParametersToPrimitiveTypes<abiFunction['inputs'], 'inputs', true>,\n  _options = Prettify<\n    UnionOmit<\n      EstimateContractGasParameters<abi, functionName, args, chain>,\n      'abi' | 'address' | 'args' | 'functionName'\n    >\n  >,\n  // For making `options` parameter required if `account`\n  IsOptionsRequired = IsUndefined<account>,\n> = narrowable extends true\n  ? (\n      ...parameters: _args extends readonly []\n        ? IsOptionsRequired extends true\n          ? [options: _options]\n          : [options?: _options]\n        : [\n            args: _args,\n            ...parameters: IsOptionsRequired extends true\n              ? [options: _options]\n              : [options?: _options],\n          ]\n    ) => Promise<EstimateContractGasReturnType>\n  : (\n      ...parameters:\n        | (IsOptionsRequired extends true\n            ? [options: _options]\n            : [options?: _options])\n        | [\n            args: readonly unknown[],\n            ...parameters: IsOptionsRequired extends true\n              ? [options: _options]\n              : [options?: _options],\n          ]\n    ) => Promise<EstimateContractGasReturnType>\n\ntype GetSimulateFunction<\n  narrowable extends boolean,\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  abiFunction extends AbiFunction = abi extends Abi\n    ? ExtractAbiFunction<abi, functionName>\n    : AbiFunction,\n  //\n  _args = AbiParametersToPrimitiveTypes<abiFunction['inputs'], 'inputs', true>,\n> = narrowable extends true\n  ? <\n      chainOverride extends Chain | undefined = undefined,\n      accountOverride extends Account | Address | undefined = undefined,\n    >(\n      ...parameters: _args extends readonly []\n        ? [\n            options?: Omit<\n              SimulateContractParameters<\n                abi,\n                functionName,\n                args,\n                chain,\n                chainOverride,\n                accountOverride\n              >,\n              'abi' | 'address' | 'args' | 'functionName'\n            >,\n          ]\n        : [\n            args: _args,\n            options?: Omit<\n              SimulateContractParameters<\n                abi,\n                functionName,\n                args,\n                chain,\n                chainOverride,\n                accountOverride\n              >,\n              'abi' | 'address' | 'args' | 'functionName'\n            >,\n          ]\n    ) => Promise<\n      SimulateContractReturnType<\n        abi,\n        functionName,\n        args,\n        chain,\n        account,\n        chainOverride,\n        accountOverride\n      >\n    >\n  : <\n      chainOverride extends Chain | undefined = undefined,\n      accountOverride extends Account | Address | undefined = undefined,\n    >(\n      ...parameters:\n        | [\n            options?: Omit<\n              SimulateContractParameters<\n                abi,\n                functionName,\n                args,\n                chain,\n                chainOverride,\n                accountOverride\n              >,\n              'abi' | 'address' | 'args' | 'functionName'\n            >,\n          ]\n        | [\n            args: readonly unknown[],\n            options?: Omit<\n              SimulateContractParameters<\n                abi,\n                functionName,\n                args,\n                chain,\n                chainOverride,\n                accountOverride\n              >,\n              'abi' | 'address' | 'args' | 'functionName'\n            >,\n          ]\n    ) => Promise<SimulateContractReturnType>\n\ntype GetWriteFunction<\n  narrowable extends boolean,\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  abiFunction extends AbiFunction = abi extends Abi\n    ? ExtractAbiFunction<abi, functionName>\n    : AbiFunction,\n  //\n  _args = AbiParametersToPrimitiveTypes<abiFunction['inputs'], 'inputs', true>,\n  // For making `options` parameter required if `account` or `chain` is undefined\n  _isOptionsRequired = Or<[IsUndefined<account>, IsUndefined<chain>]>,\n> = narrowable extends true\n  ? <\n      chainOverride extends Chain | undefined,\n      options extends Prettify<\n        UnionOmit<\n          WriteContractParameters<\n            abi,\n            functionName,\n            args,\n            chain,\n            account,\n            chainOverride\n          >,\n          'abi' | 'address' | 'args' | 'functionName'\n        >\n      >,\n    >(\n      ...parameters: _args extends readonly []\n        ? _isOptionsRequired extends true\n          ? [options: options]\n          : [options?: options]\n        : [\n            args: _args,\n            ...parameters: _isOptionsRequired extends true\n              ? [options: options]\n              : [options?: options],\n          ]\n    ) => Promise<WriteContractReturnType>\n  : <\n      chainOverride extends Chain | undefined,\n      options extends Prettify<\n        UnionOmit<\n          WriteContractParameters<\n            abi,\n            functionName,\n            args,\n            chain,\n            account,\n            chainOverride\n          >,\n          'abi' | 'address' | 'args' | 'functionName'\n        >\n      >,\n      Rest extends unknown[] = _isOptionsRequired extends true\n        ? [options: options]\n        : [options?: options],\n    >(\n      ...parameters: Rest | [args: readonly unknown[], ...parameters: Rest]\n    ) => Promise<WriteContractReturnType>\n\ntype GetEventFilter<\n  narrowable extends boolean,\n  abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi>,\n  abiEvent extends AbiEvent = abi extends Abi\n    ? ExtractAbiEvent<abi, eventName>\n    : AbiEvent,\n  //\n  _args = AbiEventParametersToPrimitiveTypes<abiEvent['inputs']>,\n  _options = Prettify<\n    Omit<\n      CreateContractEventFilterParameters<abi, eventName>,\n      'abi' | 'address' | 'args' | 'eventName' | 'strict'\n    >\n  >,\n  IndexedInputs = Extract<abiEvent['inputs'][number], { indexed: true }>,\n> = narrowable extends true\n  ? <\n      const args extends\n        | MaybeExtractEventArgsFromAbi<abi, eventName>\n        | undefined,\n      strict extends boolean | undefined = undefined,\n    >(\n      ...parameters: IsNever<IndexedInputs> extends true\n        ? [options?: _options & { strict?: strict }]\n        : [\n            args: _args | (_args extends args ? Readonly<args> : never),\n            options?: _options & { strict?: strict },\n          ]\n    ) => Promise<\n      CreateContractEventFilterReturnType<abi, eventName, args, strict>\n    >\n  : <strict extends boolean | undefined = undefined>(\n      ...parameters:\n        | [options?: _options & { strict?: strict }]\n        | [\n            args: readonly unknown[] | CreateContractFilterOptions,\n            options?: _options & { strict?: strict },\n          ]\n    ) => Promise<CreateContractEventFilterReturnType>\n\ntype GetEventsFunction<\n  narrowable extends boolean,\n  abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi>,\n  abiEvent extends AbiEvent = abi extends Abi\n    ? ExtractAbiEvent<abi, eventName>\n    : AbiEvent,\n  //\n  _args = AbiEventParametersToPrimitiveTypes<abiEvent['inputs']>,\n  _options = Prettify<\n    Omit<\n      GetContractEventsParameters<abi, eventName>,\n      'abi' | 'address' | 'args' | 'eventName'\n    >\n  >,\n  IndexedInputs = Extract<abiEvent['inputs'][number], { indexed: true }>,\n> = narrowable extends true\n  ? (\n      ...parameters: IsNever<IndexedInputs> extends true\n        ? [options?: _options]\n        : [args?: _args, options?: _options]\n    ) => Promise<GetContractEventsReturnType<abi, eventName>>\n  : (\n      ...parameters:\n        | [options?: _options]\n        | [\n            args?: readonly unknown[] | WatchContractEventOptions,\n            options?: _options,\n          ]\n    ) => Promise<GetContractEventsReturnType<abi, eventName>>\n\ntype GetWatchEvent<\n  narrowable extends boolean,\n  abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi>,\n  abiEvent extends AbiEvent = abi extends Abi\n    ? ExtractAbiEvent<abi, eventName>\n    : AbiEvent,\n  //\n  _args = AbiEventParametersToPrimitiveTypes<abiEvent['inputs']>,\n  _options = Prettify<\n    Omit<\n      WatchContractEventParameters<abi, eventName>,\n      'abi' | 'address' | 'args' | 'eventName'\n    >\n  >,\n  _indexedInputs = Extract<abiEvent['inputs'][number], { indexed: true }>,\n> = narrowable extends true\n  ? (\n      ...parameters: IsNever<_indexedInputs> extends true\n        ? [options: _options]\n        : [args: _args, options: _options]\n    ) => WatchContractEventReturnType\n  : (\n      ...parameters:\n        | [options?: _options]\n        | [\n            args: readonly unknown[] | WatchContractEventOptions,\n            options?: _options,\n          ]\n    ) => WatchContractEventReturnType\n\ntype CreateContractFilterOptions =\n  RemoveProperties<CreateContractEventFilterParameters>\ntype WatchContractEventOptions = RemoveProperties<WatchContractEventParameters>\n\ntype RemoveProperties<T extends object> = Prettify<\n  {\n    [key: string]: unknown\n  } & {\n    [_ in keyof T]?: never\n  }\n>\n","import type { Address } from 'abitype'\nimport { RpcRequestError } from '../../errors/request.js'\nimport {\n  UrlRequiredError,\n  type UrlRequiredErrorType,\n} from '../../errors/transport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hash, LogTopic } from '../../types/misc.js'\nimport type { RpcResponse } from '../../types/rpc.js'\nimport { getSocket } from '../../utils/rpc/compat.js'\nimport type { SocketRpcClient } from '../../utils/rpc/socket.js'\nimport {\n  type GetWebSocketRpcClientOptions,\n  getWebSocketRpcClient,\n} from '../../utils/rpc/webSocket.js'\nimport {\n  type CreateTransportErrorType,\n  createTransport,\n  type Transport,\n  type TransportConfig,\n} from './createTransport.js'\n\ntype WebSocketTransportSubscribeParameters = {\n  onData: (data: RpcResponse) => void\n  onError?: ((error: any) => void) | undefined\n}\n\ntype WebSocketTransportSubscribeReturnType = {\n  subscriptionId: Hash\n  unsubscribe: () => Promise<RpcResponse<boolean>>\n}\n\ntype WebSocketTransportSubscribe = {\n  subscribe(\n    args: WebSocketTransportSubscribeParameters &\n      (\n        | {\n            params: ['newHeads']\n          }\n        | {\n            params: ['newPendingTransactions']\n          }\n        | {\n            params: [\n              'logs',\n              {\n                address?: Address | Address[]\n                topics?: LogTopic[]\n              },\n            ]\n          }\n        | {\n            params: ['syncing']\n          }\n      ),\n  ): Promise<WebSocketTransportSubscribeReturnType>\n}\n\nexport type WebSocketTransportConfig = {\n  /**\n   * Whether or not to send keep-alive ping messages.\n   * @default true\n   */\n  keepAlive?: GetWebSocketRpcClientOptions['keepAlive'] | undefined\n  /** The key of the WebSocket transport. */\n  key?: TransportConfig['key'] | undefined\n  /** Methods to include or exclude from executing RPC requests. */\n  methods?: TransportConfig['methods'] | undefined\n  /** The name of the WebSocket transport. */\n  name?: TransportConfig['name'] | undefined\n  /**\n   * Whether or not to attempt to reconnect on socket failure.\n   * @default true\n   */\n  reconnect?: GetWebSocketRpcClientOptions['reconnect'] | undefined\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig['retryCount'] | undefined\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig['retryDelay'] | undefined\n  /** The timeout (in ms) for async WebSocket requests. Default: 10_000 */\n  timeout?: TransportConfig['timeout'] | undefined\n}\n\nexport type WebSocketTransport = Transport<\n  'webSocket',\n  {\n    /**\n     * @deprecated use `getRpcClient` instead.\n     */\n    getSocket(): Promise<WebSocket>\n    getRpcClient(): Promise<SocketRpcClient<WebSocket>>\n    subscribe: WebSocketTransportSubscribe['subscribe']\n  }\n>\n\nexport type WebSocketTransportErrorType =\n  | CreateTransportErrorType\n  | UrlRequiredErrorType\n  | ErrorType\n\n/**\n * @description Creates a WebSocket transport that connects to a JSON-RPC API.\n */\nexport function webSocket(\n  /** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */\n  url?: string,\n  config: WebSocketTransportConfig = {},\n): WebSocketTransport {\n  const {\n    keepAlive,\n    key = 'webSocket',\n    methods,\n    name = 'WebSocket JSON-RPC',\n    reconnect,\n    retryDelay,\n  } = config\n  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {\n    const retryCount = config.retryCount ?? retryCount_\n    const timeout = timeout_ ?? config.timeout ?? 10_000\n    const url_ = url || chain?.rpcUrls.default.webSocket?.[0]\n    const wsRpcClientOpts = { keepAlive, reconnect }\n    if (!url_) throw new UrlRequiredError()\n    return createTransport(\n      {\n        key,\n        methods,\n        name,\n        async request({ method, params }) {\n          const body = { method, params }\n          const rpcClient = await getWebSocketRpcClient(url_, wsRpcClientOpts)\n          const { error, result } = await rpcClient.requestAsync({\n            body,\n            timeout,\n          })\n          if (error)\n            throw new RpcRequestError({\n              body,\n              error,\n              url: url_,\n            })\n          return result\n        },\n        retryCount,\n        retryDelay,\n        timeout,\n        type: 'webSocket',\n      },\n      {\n        getSocket() {\n          return getSocket(url_)\n        },\n        getRpcClient() {\n          return getWebSocketRpcClient(url_, wsRpcClientOpts)\n        },\n        async subscribe({ params, onData, onError }: any) {\n          const rpcClient = await getWebSocketRpcClient(url_, wsRpcClientOpts)\n          const { result: subscriptionId } = await new Promise<any>(\n            (resolve, reject) =>\n              rpcClient.request({\n                body: {\n                  method: 'eth_subscribe',\n                  params,\n                },\n                onError(error) {\n                  reject(error)\n                  onError?.(error)\n                  return\n                },\n                onResponse(response) {\n                  if (response.error) {\n                    reject(response.error)\n                    onError?.(response.error)\n                    return\n                  }\n\n                  if (typeof response.id === 'number') {\n                    resolve(response)\n                    return\n                  }\n                  if (response.method !== 'eth_subscription') return\n                  onData(response.params)\n                },\n              }),\n          )\n          return {\n            subscriptionId,\n            async unsubscribe() {\n              return new Promise<any>((resolve) =>\n                rpcClient.request({\n                  body: {\n                    method: 'eth_unsubscribe',\n                    params: [subscriptionId],\n                  },\n                  onResponse: resolve,\n                }),\n              )\n            },\n          }\n        },\n      },\n    )\n  }\n}\n","import { BaseError } from './base.js'\n\nexport type InvalidDecimalNumberErrorType = InvalidDecimalNumberError & {\n  name: 'InvalidDecimalNumberError'\n}\nexport class InvalidDecimalNumberError extends BaseError {\n  constructor({ value }: { value: string }) {\n    super(`Number \\`${value}\\` is not a valid decimal number.`, {\n      name: 'InvalidDecimalNumberError',\n    })\n  }\n}\n","import { BaseError, type BaseErrorType } from '../../errors/base.js'\nimport {\n  InvalidHexValueError,\n  type InvalidHexValueErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nimport type { RecursiveArray } from './toRlp.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type FromRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? RecursiveArray<ByteArray> : never)\n  | (to extends 'hex' ? RecursiveArray<Hex> : never)\n\nexport type FromRlpErrorType =\n  | CreateCursorErrorType\n  | FromRlpCursorErrorType\n  | HexToBytesErrorType\n  | InvalidHexValueErrorType\n  | ErrorType\n\nexport function fromRlp<to extends To = 'hex'>(\n  value: ByteArray | Hex,\n  to: to | To | undefined = 'hex',\n): FromRlpReturnType<to> {\n  const bytes = (() => {\n    if (typeof value === 'string') {\n      if (value.length > 3 && value.length % 2 !== 0)\n        throw new InvalidHexValueError(value)\n      return hexToBytes(value)\n    }\n    return value\n  })()\n\n  const cursor = createCursor(bytes, {\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n  })\n  const result = fromRlpCursor(cursor, to)\n\n  return result as FromRlpReturnType<to>\n}\n\ntype FromRlpCursorErrorType =\n  | BytesToHexErrorType\n  | ReadLengthErrorType\n  | ReadListErrorType\n  | ErrorType\n\nfunction fromRlpCursor<to extends To = 'hex'>(\n  cursor: Cursor,\n  to: to | To | undefined = 'hex',\n): FromRlpReturnType<to> {\n  if (cursor.bytes.length === 0)\n    return (\n      to === 'hex' ? bytesToHex(cursor.bytes) : cursor.bytes\n    ) as FromRlpReturnType<to>\n\n  const prefix = cursor.readByte()\n  if (prefix < 0x80) cursor.decrementPosition(1)\n\n  // bytes\n  if (prefix < 0xc0) {\n    const length = readLength(cursor, prefix, 0x80)\n    const bytes = cursor.readBytes(length)\n    return (to === 'hex' ? bytesToHex(bytes) : bytes) as FromRlpReturnType<to>\n  }\n\n  // list\n  const length = readLength(cursor, prefix, 0xc0)\n  return readList(cursor, length, to) as {} as FromRlpReturnType<to>\n}\n\ntype ReadLengthErrorType = BaseErrorType | ErrorType\n\nfunction readLength(cursor: Cursor, prefix: number, offset: number) {\n  if (offset === 0x80 && prefix < 0x80) return 1\n  if (prefix <= offset + 55) return prefix - offset\n  if (prefix === offset + 55 + 1) return cursor.readUint8()\n  if (prefix === offset + 55 + 2) return cursor.readUint16()\n  if (prefix === offset + 55 + 3) return cursor.readUint24()\n  if (prefix === offset + 55 + 4) return cursor.readUint32()\n  throw new BaseError('Invalid RLP prefix')\n}\n\ntype ReadListErrorType = ErrorType\n\nfunction readList<to extends To>(cursor: Cursor, length: number, to: to | To) {\n  const position = cursor.position\n  const value: FromRlpReturnType<to>[] = []\n  while (cursor.position - position < length)\n    value.push(fromRlpCursor(cursor, to))\n  return value\n}\n","import { erc6492MagicBytes } from '../../constants/bytes.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type SliceHexErrorType, sliceHex } from '../data/slice.js'\n\nexport type IsErc6492SignatureParameters = Hex\nexport type IsErc6492SignatureReturnType = boolean\nexport type IsErc6492SignatureErrorType = SliceHexErrorType | ErrorType\n\n/** Whether or not the signature is an ERC-6492 formatted signature. */\nexport function isErc6492Signature(\n  signature: IsErc6492SignatureParameters,\n): IsErc6492SignatureReturnType {\n  return sliceHex(signature, -32) === erc6492MagicBytes\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { CompactSignature, Hex } from '../../types/misc.js'\nimport { type NumberToHexErrorType, numberToHex } from '../encoding/toHex.js'\n\nexport type ParseCompactSignatureErrorType = NumberToHexErrorType | ErrorType\n\n/**\n * @description Parses a hex formatted compact signature into a structured compact signature.\n *\n * @param signatureHex Signature in hex format.\n * @returns The structured signature.\n *\n * @example\n * parseCompactSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // { r: '0x...', yParityAndS: '0x...' }\n */\nexport function parseCompactSignature(signatureHex: Hex): CompactSignature {\n  const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130))\n  return {\n    r: numberToHex(r, { size: 32 }),\n    yParityAndS: numberToHex(s, { size: 32 }),\n  }\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, Signature } from '../../types/misc.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type ParseSignatureErrorType = NumberToHexErrorType | ErrorType\n\n/**\n * @description Parses a hex formatted signature into a structured signature.\n *\n * @param signatureHex Signature in hex format.\n * @returns The structured signature.\n *\n * @example\n * parseSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // { r: '0x...', s: '0x...', v: 28n }\n */\nexport function parseSignature(signatureHex: Hex) {\n  const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130))\n  const yParityOrV = Number(`0x${signatureHex.slice(130)}`)\n  const [v, yParity] = (() => {\n    if (yParityOrV === 0 || yParityOrV === 1) return [undefined, yParityOrV]\n    if (yParityOrV === 27) return [BigInt(yParityOrV), 0]\n    if (yParityOrV === 28) return [BigInt(yParityOrV), 1]\n    throw new Error('Invalid yParityOrV value')\n  })()\n\n  if (typeof v !== 'undefined')\n    return {\n      r: numberToHex(r, { size: 32 }),\n      s: numberToHex(s, { size: 32 }),\n      v,\n      yParity,\n    } satisfies Signature\n  return {\n    r: numberToHex(r, { size: 32 }),\n    s: numberToHex(s, { size: 32 }),\n    yParity,\n  } satisfies Signature\n}\n","import { SocketClosedError, TimeoutError } from '../../errors/request.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { RpcRequest, RpcResponse } from '../../types/rpc.js'\nimport {\n  type CreateBatchSchedulerErrorType,\n  createBatchScheduler,\n} from '../promise/createBatchScheduler.js'\nimport { withTimeout } from '../promise/withTimeout.js'\nimport { idCache } from './id.js'\n\ntype Id = string | number\ntype CallbackFn = {\n  onResponse: (message: any) => void\n  onError?: ((error?: Error | Event | undefined) => void) | undefined\n  body?: RpcRequest\n}\ntype CallbackMap = Map<Id, CallbackFn>\n\nexport type GetSocketParameters = {\n  onClose: () => void\n  onError: (error?: Error | Event | undefined) => void\n  onOpen: () => void\n  onResponse: (data: RpcResponse) => void\n}\n\nexport type Socket<socket extends {}> = socket & {\n  close(): void\n  ping?: (() => void) | undefined\n  request(params: { body: RpcRequest }): void\n}\n\nexport type SocketRpcClient<socket extends {}> = {\n  close(): void\n  socket: Socket<socket>\n  request(params: {\n    body: RpcRequest\n    onError?: ((error?: Error | Event | undefined) => void) | undefined\n    onResponse: (message: RpcResponse) => void\n  }): void\n  requestAsync(params: {\n    body: RpcRequest\n    timeout?: number | undefined\n  }): Promise<RpcResponse>\n  requests: CallbackMap\n  subscriptions: CallbackMap\n  url: string\n}\n\nexport type GetSocketRpcClientParameters<socket extends {} = {}> = {\n  getSocket(params: GetSocketParameters): Promise<Socket<socket>>\n  /**\n   * Whether or not to send keep-alive messages.\n   * @default true\n   */\n  keepAlive?:\n    | boolean\n    | {\n        /**\n         * The interval (in ms) to send keep-alive messages.\n         * @default 30_000\n         */\n        interval?: number | undefined\n      }\n    | undefined\n  key?: string\n  /**\n   * Whether or not to attempt to reconnect on socket failure or closure.\n   * @default true\n   */\n  reconnect?:\n    | boolean\n    | {\n        /**\n         * The maximum number of reconnection attempts.\n         * @default 5\n         */\n        attempts?: number | undefined\n        /**\n         * The delay (in ms) between reconnection attempts.\n         * @default 2_000\n         */\n        delay?: number | undefined\n      }\n    | undefined\n  url: string\n}\n\nexport type GetSocketRpcClientErrorType =\n  | CreateBatchSchedulerErrorType\n  | ErrorType\n\nexport const socketClientCache = /*#__PURE__*/ new Map<\n  string,\n  SocketRpcClient<Socket<{}>>\n>()\n\nexport async function getSocketRpcClient<socket extends {}>(\n  parameters: GetSocketRpcClientParameters<socket>,\n): Promise<SocketRpcClient<socket>> {\n  const {\n    getSocket,\n    keepAlive = true,\n    key = 'socket',\n    reconnect = true,\n    url,\n  } = parameters\n  const { interval: keepAliveInterval = 30_000 } =\n    typeof keepAlive === 'object' ? keepAlive : {}\n  const { attempts = 5, delay = 2_000 } =\n    typeof reconnect === 'object' ? reconnect : {}\n\n  const id = JSON.stringify({ keepAlive, key, url, reconnect })\n  let socketClient = socketClientCache.get(id)\n\n  // If the socket already exists, return it.\n  if (socketClient) return socketClient as {} as SocketRpcClient<socket>\n\n  let reconnectCount = 0\n  const { schedule } = createBatchScheduler<\n    undefined,\n    [SocketRpcClient<socket>]\n  >({\n    id,\n    fn: async () => {\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map<Id, CallbackFn>()\n\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map<Id, CallbackFn>()\n\n      let error: Error | Event | undefined\n      let socket: Socket<{}>\n      let keepAliveTimer: ReturnType<typeof setInterval> | undefined\n\n      let reconnectInProgress = false\n      function attemptReconnect() {\n        // Attempt to reconnect.\n        if (reconnect && reconnectCount < attempts) {\n          if (reconnectInProgress) return\n          reconnectInProgress = true\n          reconnectCount++\n\n          // Make sure the previous socket is definitely closed.\n          socket?.close()\n\n          setTimeout(async () => {\n            // biome-ignore lint/suspicious/noConsole: _\n            await setup().catch(console.error)\n            reconnectInProgress = false\n          }, delay)\n        }\n        // Otherwise, clear all requests and subscriptions.\n        else {\n          requests.clear()\n          subscriptions.clear()\n        }\n      }\n\n      // Set up socket implementation.\n      async function setup() {\n        const result = await getSocket({\n          onClose() {\n            // Notify all requests and subscriptions of the closure error.\n            for (const request of requests.values())\n              request.onError?.(new SocketClosedError({ url }))\n            for (const subscription of subscriptions.values())\n              subscription.onError?.(new SocketClosedError({ url }))\n\n            attemptReconnect()\n          },\n          onError(error_) {\n            error = error_\n\n            // Notify all requests and subscriptions of the error.\n            for (const request of requests.values()) request.onError?.(error)\n            for (const subscription of subscriptions.values())\n              subscription.onError?.(error)\n\n            attemptReconnect()\n          },\n          onOpen() {\n            error = undefined\n            reconnectCount = 0\n          },\n          onResponse(data) {\n            const isSubscription = data.method === 'eth_subscription'\n            const id = isSubscription ? data.params.subscription : data.id\n            const cache = isSubscription ? subscriptions : requests\n            const callback = cache.get(id)\n            if (callback) callback.onResponse(data)\n            if (!isSubscription) cache.delete(id)\n          },\n        })\n\n        socket = result\n\n        if (keepAlive) {\n          if (keepAliveTimer) clearInterval(keepAliveTimer)\n          keepAliveTimer = setInterval(() => socket.ping?.(), keepAliveInterval)\n        }\n\n        if (reconnect && subscriptions.size > 0) {\n          const subscriptionEntries = subscriptions.entries()\n          for (const [\n            key,\n            { onResponse, body, onError },\n          ] of subscriptionEntries) {\n            if (!body) continue\n\n            subscriptions.delete(key)\n            socketClient?.request({ body, onResponse, onError })\n          }\n        }\n\n        return result\n      }\n      await setup()\n      error = undefined\n\n      // Create a new socket instance.\n      socketClient = {\n        close() {\n          keepAliveTimer && clearInterval(keepAliveTimer)\n          socket.close()\n          socketClientCache.delete(id)\n        },\n        get socket() {\n          return socket\n        },\n        request({ body, onError, onResponse }) {\n          if (error && onError) onError(error)\n\n          const id = body.id ?? idCache.take()\n\n          const callback = (response: RpcResponse) => {\n            if (typeof response.id === 'number' && id !== response.id) return\n\n            // If we are subscribing to a topic, we want to set up a listener for incoming\n            // messages.\n            if (\n              body.method === 'eth_subscribe' &&\n              typeof response.result === 'string'\n            )\n              subscriptions.set(response.result, {\n                onResponse: callback,\n                onError,\n                body,\n              })\n\n            onResponse(response)\n          }\n\n          // If we are unsubscribing from a topic, remove the listener immediately\n          // to prevent it from being re-subscribed on reconnect.\n          if (body.method === 'eth_unsubscribe')\n            subscriptions.delete(body.params?.[0])\n\n          requests.set(id, { onResponse: callback, onError })\n          try {\n            socket.request({\n              body: {\n                jsonrpc: '2.0',\n                id,\n                ...body,\n              },\n            })\n          } catch (error) {\n            onError?.(error as Error)\n          }\n        },\n        requestAsync({ body, timeout = 10_000 }) {\n          return withTimeout(\n            () =>\n              new Promise<RpcResponse>((onResponse, onError) =>\n                this.request({\n                  body,\n                  onError,\n                  onResponse,\n                }),\n              ),\n            {\n              errorInstance: new TimeoutError({ body, url }),\n              timeout,\n            },\n          )\n        },\n        requests,\n        subscriptions,\n        url,\n      }\n      socketClientCache.set(id, socketClient)\n\n      return [socketClient as {} as SocketRpcClient<socket>]\n    },\n  })\n\n  const [_, [socketClient_]] = await schedule()\n  return socketClient_\n}\n","import type { MessageEvent } from 'isows'\n\nimport {\n  SocketClosedError,\n  WebSocketRequestError,\n} from '../../errors/request.js'\nimport type { RpcRequest } from '../../types/rpc.js'\nimport {\n  type GetSocketRpcClientParameters,\n  getSocketRpcClient,\n  type Socket,\n  type SocketRpcClient,\n} from './socket.js'\n\nexport type GetWebSocketRpcClientOptions = Pick<\n  GetSocketRpcClientParameters,\n  'keepAlive' | 'reconnect'\n>\n\nexport async function getWebSocketRpcClient(\n  url: string,\n  options: GetWebSocketRpcClientOptions | undefined = {},\n): Promise<SocketRpcClient<WebSocket>> {\n  const { keepAlive, reconnect } = options\n\n  return getSocketRpcClient({\n    async getSocket({ onClose, onError, onOpen, onResponse }) {\n      const WebSocket = await import('isows').then((module) => module.WebSocket)\n      const socket = new WebSocket(url)\n\n      function onClose_() {\n        socket.removeEventListener('close', onClose_)\n        socket.removeEventListener('message', onMessage)\n        socket.removeEventListener('error', onError)\n        socket.removeEventListener('open', onOpen)\n        onClose()\n      }\n      function onMessage({ data }: MessageEvent) {\n        // ignore empty messages\n        if (typeof data === 'string' && data.trim().length === 0) return\n\n        try {\n          const _data = JSON.parse(data)\n          onResponse(_data)\n        } catch (error) {\n          onError(error as Error)\n        }\n      }\n\n      // Setup event listeners for RPC & subscription responses.\n      socket.addEventListener('close', onClose_)\n      socket.addEventListener('message', onMessage)\n      socket.addEventListener('error', onError)\n      socket.addEventListener('open', onOpen)\n\n      // Wait for the socket to open.\n      if (socket.readyState === WebSocket.CONNECTING) {\n        await new Promise((resolve, reject) => {\n          if (!socket) return\n          socket.onopen = resolve\n          socket.onerror = reject\n        })\n      }\n\n      const { close: close_ } = socket\n\n      return Object.assign(socket, {\n        close() {\n          close_.bind(socket)()\n          onClose_()\n        },\n        ping() {\n          try {\n            if (\n              socket.readyState === socket.CLOSED ||\n              socket.readyState === socket.CLOSING\n            )\n              throw new WebSocketRequestError({\n                url: socket.url,\n                cause: new SocketClosedError({ url: socket.url }),\n              })\n\n            const body: RpcRequest = {\n              jsonrpc: '2.0',\n              id: null,\n              method: 'net_version',\n              params: [],\n            }\n            socket.send(JSON.stringify(body))\n          } catch (error) {\n            onError(error as Error)\n          }\n        },\n        request({ body }) {\n          if (\n            socket.readyState === socket.CLOSED ||\n            socket.readyState === socket.CLOSING\n          )\n            throw new WebSocketRequestError({\n              body,\n              url: socket.url,\n              cause: new SocketClosedError({ url: socket.url }),\n            })\n\n          return socket.send(JSON.stringify(body))\n        },\n      } as Socket<WebSocket>)\n    },\n    keepAlive,\n    reconnect,\n    url,\n  })\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { TransactionSerialized } from '../../types/transaction.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { parseTransaction } from '../transaction/parseTransaction.js'\nimport {\n  type SerializeTransactionErrorType,\n  serializeTransaction,\n} from '../transaction/serializeTransaction.js'\nimport {\n  type RecoverAddressErrorType,\n  recoverAddress,\n} from './recoverAddress.js'\nimport type { SerializeSignatureErrorType } from './serializeSignature.js'\n\nexport type RecoverTransactionAddressParameters = {\n  serializedTransaction: TransactionSerialized\n  signature?: Hex | ByteArray | Signature\n}\n\nexport type RecoverTransactionAddressReturnType = Address\n\nexport type RecoverTransactionAddressErrorType =\n  | SerializeTransactionErrorType\n  | RecoverAddressErrorType\n  | Keccak256ErrorType\n  | SerializeSignatureErrorType\n  | ErrorType\n\nexport async function recoverTransactionAddress(\n  parameters: RecoverTransactionAddressParameters,\n): Promise<RecoverTransactionAddressReturnType> {\n  const { serializedTransaction, signature: signature_ } = parameters\n\n  const transaction = parseTransaction(serializedTransaction)\n\n  const signature = signature_ ?? {\n    r: transaction.r!,\n    s: transaction.s!,\n    v: transaction.v!,\n    yParity: transaction.yParity!,\n  }\n\n  const serialized = serializeTransaction({\n    ...transaction,\n    r: undefined,\n    s: undefined,\n    v: undefined,\n    yParity: undefined,\n    sidecars: undefined,\n  })\n\n  return await recoverAddress({\n    hash: keccak256(serialized),\n    signature,\n  })\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { CompactSignature, Hex } from '../../types/misc.js'\nimport { type HexToBigIntErrorType, hexToBigInt } from '../encoding/fromHex.js'\n\nexport type SerializeCompactSignatureErrorType =\n  | HexToBigIntErrorType\n  | ErrorType\n\n/**\n * @description Converts an [EIP-2098 compact signature](https://eips.ethereum.org/EIPS/eip-2098) into hex format.\n *\n * @param signature The compact signature to convert.\n * @returns The compact signature in hex format.\n *\n * @example\n * serializeCompactSignature({\n *   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   yParityAndS: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * })\n * // \"0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c\"\n */\nexport function serializeCompactSignature({\n  r,\n  yParityAndS,\n}: CompactSignature): Hex {\n  return `0x${new secp256k1.Signature(\n    hexToBigInt(r),\n    hexToBigInt(yParityAndS),\n  ).toCompactHex()}`\n}\n","import type { Address } from 'abitype'\nimport { erc6492MagicBytes } from '../../constants/bytes.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { encodeAbiParameters } from '../abi/encodeAbiParameters.js'\nimport { concatHex } from '../data/concat.js'\nimport { hexToBytes } from '../encoding/toBytes.js'\n\ntype To = 'bytes' | 'hex'\n\nexport type SerializeErc6492SignatureParameters<to extends To = 'hex'> = {\n  /** The ERC-4337 Account Factory address to use for counterfactual verification. */\n  address: Address\n  /** Calldata to pass to deploy account (if not deployed) for counterfactual verification. */\n  data: Hex\n  /** The original signature. */\n  signature: Hex\n  to?: to | To | undefined\n}\n\nexport type SerializeErc6492SignatureReturnType<to extends To = 'hex'> =\n  | (to extends 'hex' ? Hex : never)\n  | (to extends 'bytes' ? ByteArray : never)\n\nexport type SerializeErc6492SignatureErrorType = ErrorType\n\n/**\n * @description Serializes a ERC-6492 flavoured signature into hex format.\n *\n * @param signature ERC-6492 signature in object format.\n * @returns ERC-6492 signature in hex format.\n *\n * @example\n * serializeSignature({ address: '0x...', data: '0x...', signature: '0x...' })\n * // '0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492'\n */\nexport function serializeErc6492Signature<to extends To = 'hex'>(\n  parameters: SerializeErc6492SignatureParameters<to>,\n): SerializeErc6492SignatureReturnType<to> {\n  const { address, data, signature, to = 'hex' } = parameters\n  const signature_ = concatHex([\n    encodeAbiParameters(\n      [{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }],\n      [address, data, signature],\n    ),\n    erc6492MagicBytes,\n  ])\n\n  if (to === 'hex') return signature_ as SerializeErc6492SignatureReturnType<to>\n  return hexToBytes(signature_) as SerializeErc6492SignatureReturnType<to>\n}\n","import { gweiUnits } from '../../constants/unit.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\nimport { type ParseUnitsErrorType, parseUnits } from './parseUnits.js'\n\nexport type ParseGweiErrorType = ParseUnitsErrorType | ErrorType\n\n/**\n * Converts a string representation of gwei to numerical wei.\n *\n * - Docs: https://viem.sh/docs/utilities/parseGwei\n *\n * @example\n * import { parseGwei } from 'viem'\n *\n * parseGwei('420')\n * // 420000000000n\n */\nexport function parseGwei(ether: string, unit: 'wei' = 'wei') {\n  return parseUnits(ether, gweiUnits[unit])\n}\n","import { etherUnits } from '../../constants/unit.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\nimport { type ParseUnitsErrorType, parseUnits } from './parseUnits.js'\n\nexport type ParseEtherErrorType = ParseUnitsErrorType | ErrorType\n\n/**\n * Converts a string representation of ether to numerical wei.\n *\n * - Docs: https://viem.sh/docs/utilities/parseEther\n *\n * @example\n * import { parseEther } from 'viem'\n *\n * parseEther('420')\n * // 420000000000000000000n\n */\nexport function parseEther(ether: string, unit: 'wei' | 'gwei' = 'wei') {\n  return parseUnits(ether, etherUnits[unit])\n}\n","import {\n  type DropTransactionParameters,\n  dropTransaction,\n} from '../../actions/test/dropTransaction.js'\nimport {\n  type DumpStateReturnType,\n  dumpState,\n} from '../../actions/test/dumpState.js'\nimport {\n  type GetAutomineReturnType,\n  getAutomine,\n} from '../../actions/test/getAutomine.js'\nimport {\n  type GetTxpoolContentReturnType,\n  getTxpoolContent,\n} from '../../actions/test/getTxpoolContent.js'\nimport {\n  type GetTxpoolStatusReturnType,\n  getTxpoolStatus,\n} from '../../actions/test/getTxpoolStatus.js'\nimport {\n  type ImpersonateAccountParameters,\n  impersonateAccount,\n} from '../../actions/test/impersonateAccount.js'\nimport {\n  type IncreaseTimeParameters,\n  increaseTime,\n} from '../../actions/test/increaseTime.js'\nimport {\n  type InspectTxpoolReturnType,\n  inspectTxpool,\n} from '../../actions/test/inspectTxpool.js'\nimport {\n  type LoadStateParameters,\n  type LoadStateReturnType,\n  loadState,\n} from '../../actions/test/loadState.js'\nimport { type MineParameters, mine } from '../../actions/test/mine.js'\nimport { removeBlockTimestampInterval } from '../../actions/test/removeBlockTimestampInterval.js'\nimport { type ResetParameters, reset } from '../../actions/test/reset.js'\nimport { type RevertParameters, revert } from '../../actions/test/revert.js'\nimport {\n  type SendUnsignedTransactionParameters,\n  type SendUnsignedTransactionReturnType,\n  sendUnsignedTransaction,\n} from '../../actions/test/sendUnsignedTransaction.js'\nimport { setAutomine } from '../../actions/test/setAutomine.js'\nimport {\n  type SetBalanceParameters,\n  setBalance,\n} from '../../actions/test/setBalance.js'\nimport {\n  type SetBlockGasLimitParameters,\n  setBlockGasLimit,\n} from '../../actions/test/setBlockGasLimit.js'\nimport {\n  type SetBlockTimestampIntervalParameters,\n  setBlockTimestampInterval,\n} from '../../actions/test/setBlockTimestampInterval.js'\nimport { type SetCodeParameters, setCode } from '../../actions/test/setCode.js'\nimport {\n  type SetCoinbaseParameters,\n  setCoinbase,\n} from '../../actions/test/setCoinbase.js'\nimport {\n  type SetIntervalMiningParameters,\n  setIntervalMining,\n} from '../../actions/test/setIntervalMining.js'\nimport { setLoggingEnabled } from '../../actions/test/setLoggingEnabled.js'\nimport {\n  type SetMinGasPriceParameters,\n  setMinGasPrice,\n} from '../../actions/test/setMinGasPrice.js'\nimport {\n  type SetNextBlockBaseFeePerGasParameters,\n  setNextBlockBaseFeePerGas,\n} from '../../actions/test/setNextBlockBaseFeePerGas.js'\nimport {\n  type SetNextBlockTimestampParameters,\n  setNextBlockTimestamp,\n} from '../../actions/test/setNextBlockTimestamp.js'\nimport {\n  type SetNonceParameters,\n  setNonce,\n} from '../../actions/test/setNonce.js'\nimport { setRpcUrl } from '../../actions/test/setRpcUrl.js'\nimport {\n  type SetStorageAtParameters,\n  setStorageAt,\n} from '../../actions/test/setStorageAt.js'\nimport { snapshot } from '../../actions/test/snapshot.js'\nimport {\n  type StopImpersonatingAccountParameters,\n  stopImpersonatingAccount,\n} from '../../actions/test/stopImpersonatingAccount.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Quantity } from '../../types/rpc.js'\nimport type { Client } from '../createClient.js'\nimport type { TestClientMode } from '../createTestClient.js'\nimport type { Transport } from '../transports/createTransport.js'\n\nexport type TestActions = {\n  /**\n   * Removes a transaction from the mempool.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/dropTransaction\n   *\n   * @param args - {@link DropTransactionParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.dropTransaction({\n   *   hash: '0xe58dceb6b20b03965bb678e27d141e151d7d4efc2334c2d6a49b9fac523f7364'\n   * })\n   */\n  dropTransaction: (args: DropTransactionParameters) => Promise<void>\n  /**\n   * Serializes the current state (including contracts code, contract's storage,\n   * accounts properties, etc.) into a savable data blob.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/dumpState\n   *\n   * @param client - Client to use\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.dumpState()\n   */\n  dumpState: () => Promise<DumpStateReturnType>\n  /**\n   * Returns the automatic mining status of the node.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/getAutomine\n   *\n   * @returns Whether or not the node is auto mining. {@link GetAutomineReturnType}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * const isAutomining = await client.getAutomine()\n   */\n  getAutomine: () => Promise<GetAutomineReturnType>\n  /**\n   * Returns the details of all transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/getTxpoolContent\n   *\n   * @returns Transaction pool content. {@link GetTxpoolContentReturnType}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * const content = await client.getTxpoolContent()\n   */\n  getTxpoolContent: () => Promise<GetTxpoolContentReturnType>\n  /**\n   * Returns a summary of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/getTxpoolStatus\n   *\n   * @returns Transaction pool status. {@link GetTxpoolStatusReturnType}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * const status = await client.getTxpoolStatus()\n   */\n  getTxpoolStatus: () => Promise<GetTxpoolStatusReturnType>\n  /**\n   * Impersonate an account or contract address. This lets you send transactions from that account even if you don't have access to its private key.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/impersonateAccount\n   *\n   * @param args - {@link ImpersonateAccountParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.impersonateAccount({\n   *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   */\n  impersonateAccount: (args: ImpersonateAccountParameters) => Promise<void>\n  /**\n   * Jump forward in time by the given amount of time, in seconds.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/increaseTime\n   *\n   * @param args â€“ {@link IncreaseTimeParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.increaseTime({\n   *   seconds: 420,\n   * })\n   */\n  increaseTime: (args: IncreaseTimeParameters) => Promise<Quantity>\n  /**\n   * Returns a summary of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/inspectTxpool\n   *\n   * @returns Transaction pool inspection data. {@link InspectTxpoolReturnType}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * const data = await client.inspectTxpool()\n   */\n  inspectTxpool: () => Promise<InspectTxpoolReturnType>\n  /**\n   * Adds state previously dumped with `dumpState` to the current chain.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/loadState\n   *\n   * @param client - Client to use\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.loadState({ state: '0x...' })\n   */\n  loadState: (args: LoadStateParameters) => Promise<LoadStateReturnType>\n  /**\n   * Mine a specified number of blocks.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/mine\n   *\n   * @param client - Client to use\n   * @param args â€“ {@link MineParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.mine({ blocks: 1 })\n   */\n  mine: (args: MineParameters) => Promise<void>\n  /**\n   * Removes [`setBlockTimestampInterval`](https://viem.sh/docs/actions/test/setBlockTimestampInterval) if it exists.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/removeBlockTimestampInterval\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   * import { removeBlockTimestampInterval } from 'viem/test'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.removeBlockTimestampInterval()\n   */\n  removeBlockTimestampInterval: () => Promise<void>\n  /**\n   * Resets fork back to its original state.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/reset\n   *\n   * @param args â€“ {@link ResetParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.reset({ blockNumber: 69420n })\n   */\n  reset: (args?: ResetParameters | undefined) => Promise<void>\n  /**\n   * Revert the state of the blockchain at the current block.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/revert\n   *\n   * @param args â€“ {@link RevertParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.revert({ id: '0xâ€¦' })\n   */\n  revert: (args: RevertParameters) => Promise<void>\n  /**\n   * Executes a transaction regardless of the signature.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/sendUnsignedTransaction\n   *\n   * @param args â€“ {@link SendUnsignedTransactionParameters}\n   * @returns The transaction hash. {@link SendUnsignedTransactionReturnType}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * const hash = await client.sendUnsignedTransaction({\n   *   from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: 1000000000000000000n,\n   * })\n   */\n  sendUnsignedTransaction: <chain extends Chain | undefined>(\n    args: SendUnsignedTransactionParameters<chain>,\n  ) => Promise<SendUnsignedTransactionReturnType>\n  /**\n   * Enables or disables the automatic mining of new blocks with each new transaction submitted to the network.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setAutomine\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setAutomine()\n   */\n  setAutomine: (args: boolean) => Promise<void>\n  /**\n   * Modifies the balance of an account.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setBalance\n   *\n   * @param args â€“ {@link SetBalanceParameters}\n   *\n   * @example\n   * import { createTestClient, http, parseEther } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setBalance({\n   *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n   *   value: parseEther('1'),\n   * })\n   */\n  setBalance: (args: SetBalanceParameters) => Promise<void>\n  /**\n   * Sets the block's gas limit.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setBlockGasLimit\n   *\n   * @param args â€“ {@link SetBlockGasLimitParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setBlockGasLimit({ gasLimit: 420_000n })\n   */\n  setBlockGasLimit: (args: SetBlockGasLimitParameters) => Promise<void>\n  /**\n   * Similar to [`increaseTime`](https://viem.sh/docs/actions/test/increaseTime), but sets a block timestamp `interval`. The timestamp of future blocks will be computed as `lastBlock_timestamp` + `interval`.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setBlockTimestampInterval\n   *\n   * @param args â€“ {@link SetBlockTimestampIntervalParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setBlockTimestampInterval({ interval: 5 })\n   */\n  setBlockTimestampInterval: (\n    args: SetBlockTimestampIntervalParameters,\n  ) => Promise<void>\n  /**\n   * Modifies the bytecode stored at an account's address.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setCode\n   *\n   * @param args â€“ {@link SetCodeParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setCode({\n   *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',\n   *   bytecode: '0x60806040526000600355600019600955600c80546001600160a01b031916737a250d5630b4cf539739dfâ€¦',\n   * })\n   */\n  setCode: (args: SetCodeParameters) => Promise<void>\n  /**\n   * Sets the coinbase address to be used in new blocks.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setCoinbase\n   *\n   * @param args â€“ {@link SetCoinbaseParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setCoinbase({\n   *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',\n   * })\n   */\n  setCoinbase: (args: SetCoinbaseParameters) => Promise<void>\n  /**\n   * Sets the automatic mining interval (in seconds) of blocks. Setting the interval to 0 will disable automatic mining.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setIntervalMining\n   *\n   * @param args â€“ {@link SetIntervalMiningParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setIntervalMining({ interval: 5 })\n   */\n  setIntervalMining: (args: SetIntervalMiningParameters) => Promise<void>\n  /**\n   * Enable or disable logging on the test node network.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setLoggingEnabled\n   *\n   * @param client - Client to use\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setLoggingEnabled()\n   */\n  setLoggingEnabled: (args: boolean) => Promise<void>\n  /**\n   * Change the minimum gas price accepted by the network (in wei).\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setMinGasPrice\n   *\n   * Note: `setMinGasPrice` can only be used on clients that do not have EIP-1559 enabled.\n   *\n   * @param args â€“ {@link SetBlockGasLimitParameters}\n   *\n   * @example\n   * import { createTestClient, http, parseGwei } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setMinGasPrice({\n   *   gasPrice: parseGwei('20'),\n   * })\n   */\n  setMinGasPrice: (args: SetMinGasPriceParameters) => Promise<void>\n  /**\n   * Sets the next block's base fee per gas.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setNextBlockBaseFeePerGas\n   *\n   * @param args â€“ {@link SetNextBlockBaseFeePerGasParameters}\n   *\n   * @example\n   * import { createTestClient, http, parseGwei } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setNextBlockBaseFeePerGas({\n   *   baseFeePerGas: parseGwei('20'),\n   * })\n   */\n  setNextBlockBaseFeePerGas: (\n    args: SetNextBlockBaseFeePerGasParameters,\n  ) => Promise<void>\n  /**\n   * Sets the next block's timestamp.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setNextBlockTimestamp\n   *\n   * @param args â€“ {@link SetNextBlockTimestampParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setNextBlockTimestamp({ timestamp: 1671744314n })\n   */\n  setNextBlockTimestamp: (\n    args: SetNextBlockTimestampParameters,\n  ) => Promise<void>\n  /**\n   * Modifies (overrides) the nonce of an account.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setNonce\n   *\n   * @param args â€“ {@link SetNonceParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setNonce({\n   *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n   *   nonce: 420,\n   * })\n   */\n  setNonce: (args: SetNonceParameters) => Promise<void>\n  /**\n   * Sets the backend RPC URL.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setRpcUrl\n   *\n   * @param jsonRpcUrl â€“ RPC URL\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setRpcUrl('https://eth-mainnet.g.alchemy.com/v2')\n   */\n  setRpcUrl: (args: string) => Promise<void>\n  /**\n   * Writes to a slot of an account's storage.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/setStorageAt\n   *\n   * @param args â€“ {@link SetStorageAtParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.setStorageAt({\n   *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',\n   *   index: 2,\n   *   value: '0x0000000000000000000000000000000000000000000000000000000000000069',\n   * })\n   */\n  setStorageAt: (args: SetStorageAtParameters) => Promise<void>\n  /**\n   * Snapshot the state of the blockchain at the current block.\n   *\n   * - Docs: https://viem.sh/docs/actions/test/snapshot\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   * import { snapshot } from 'viem/test'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.snapshot()\n   */\n  snapshot: () => Promise<Quantity>\n  /**\n   * Stop impersonating an account after having previously used [`impersonateAccount`](https://viem.sh/docs/actions/test/impersonateAccount).\n   *\n   * - Docs: https://viem.sh/docs/actions/test/stopImpersonatingAccount\n   *\n   * @param args â€“ {@link StopImpersonatingAccountParameters}\n   *\n   * @example\n   * import { createTestClient, http } from 'viem'\n   * import { foundry } from 'viem/chains'\n   * import { stopImpersonatingAccount } from 'viem/test'\n   *\n   * const client = createTestClient({\n   *   mode: 'anvil',\n   *   chain: 'foundry',\n   *   transport: http(),\n   * })\n   * await client.stopImpersonatingAccount({\n   *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n   * })\n   */\n  stopImpersonatingAccount: (\n    args: StopImpersonatingAccountParameters,\n  ) => Promise<void>\n}\n\nexport function testActions<mode extends TestClientMode>({\n  mode,\n}: {\n  mode: mode\n}): <\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n>(\n  client: Client<transport, chain, account>,\n) => TestActions {\n  return <\n    transport extends Transport = Transport,\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  >(\n    client_: Client<transport, chain, account>,\n  ): TestActions => {\n    const client = client_.extend(() => ({\n      mode,\n    }))\n    return {\n      dropTransaction: (args) => dropTransaction(client, args),\n      dumpState: () => dumpState(client),\n      getAutomine: () => getAutomine(client),\n      getTxpoolContent: () => getTxpoolContent(client),\n      getTxpoolStatus: () => getTxpoolStatus(client),\n      impersonateAccount: (args) => impersonateAccount(client, args),\n      increaseTime: (args) => increaseTime(client, args),\n      inspectTxpool: () => inspectTxpool(client),\n      loadState: (args) => loadState(client, args),\n      mine: (args) => mine(client, args),\n      removeBlockTimestampInterval: () => removeBlockTimestampInterval(client),\n      reset: (args) => reset(client, args),\n      revert: (args) => revert(client, args),\n      sendUnsignedTransaction: (args) =>\n        sendUnsignedTransaction(client, args as any),\n      setAutomine: (args) => setAutomine(client, args),\n      setBalance: (args) => setBalance(client, args),\n      setBlockGasLimit: (args) => setBlockGasLimit(client, args),\n      setBlockTimestampInterval: (args) =>\n        setBlockTimestampInterval(client, args),\n      setCode: (args) => setCode(client, args),\n      setCoinbase: (args) => setCoinbase(client, args),\n      setIntervalMining: (args) => setIntervalMining(client, args),\n      setLoggingEnabled: (args) => setLoggingEnabled(client, args),\n      setMinGasPrice: (args) => setMinGasPrice(client, args),\n      setNextBlockBaseFeePerGas: (args) =>\n        setNextBlockBaseFeePerGas(client, args),\n      setNextBlockTimestamp: (args) => setNextBlockTimestamp(client, args),\n      setNonce: (args) => setNonce(client, args),\n      setRpcUrl: (args) => setRpcUrl(client, args),\n      setStorageAt: (args) => setStorageAt(client, args),\n      snapshot: () => snapshot(client),\n      stopImpersonatingAccount: (args) =>\n        stopImpersonatingAccount(client, args),\n    }\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type DefineKzgErrorType,\n  type DefineKzgParameters,\n  type DefineKzgReturnType,\n  defineKzg,\n} from './defineKzg.js'\n\nexport type SetupKzgParameters = DefineKzgParameters & {\n  loadTrustedSetup(path: string): void\n}\nexport type SetupKzgReturnType = DefineKzgReturnType\nexport type SetupKzgErrorType = DefineKzgErrorType | ErrorType\n\n/**\n * Sets up and returns a KZG interface.\n *\n * @example\n * ```ts\n * import * as cKzg from 'c-kzg'\n * import { setupKzg } from 'viem'\n * import { mainnetTrustedSetupPath } from 'viem/node'\n *\n * const kzg = setupKzg(cKzg, mainnetTrustedSetupPath)\n * ```\n */\nexport function setupKzg(\n  parameters: SetupKzgParameters,\n  path: string,\n): SetupKzgReturnType {\n  try {\n    parameters.loadTrustedSetup(path)\n  } catch (e) {\n    const error = e as Error\n    if (!error.message.includes('trusted setup is already loaded')) throw error\n  }\n  return defineKzg(parameters)\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { CompactSignature, Signature } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\nexport type CompactSignatureToSignatureErrorType =\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * @description Converts an [EIP-2098 compact signature](https://eips.ethereum.org/EIPS/eip-2098) into signature format.\n *\n * @param signature The compact signature to convert.\n * @returns The compact signature in signature format.\n *\n * @example\n * compactSignatureToSignature({\n *   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   yParityAndS: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * })\n * // {\n * //   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n * //   s: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * //   v: 27n\n * // }\n */\nexport function compactSignatureToSignature({\n  r,\n  yParityAndS,\n}: CompactSignature): Signature {\n  const yParityAndS_bytes = hexToBytes(yParityAndS)\n  const yParity = yParityAndS_bytes[0] & 0x80 ? 1 : 0\n  const s = yParityAndS_bytes\n  if (yParity === 1) s[0] &= 0x7f\n  return { r, s: bytesToHex(s), yParity }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type CreateTransportErrorType,\n  createTransport,\n  type Transport,\n  type TransportConfig,\n} from './createTransport.js'\n\ntype EthereumProvider = { request(...args: any): Promise<any> }\n\nexport type CustomTransportConfig = {\n  /** The key of the transport. */\n  key?: TransportConfig['key'] | undefined\n  /** Methods to include or exclude from executing RPC requests. */\n  methods?: TransportConfig['methods'] | undefined\n  /** The name of the transport. */\n  name?: TransportConfig['name'] | undefined\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig['retryCount'] | undefined\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig['retryDelay'] | undefined\n}\n\nexport type CustomTransport = Transport<\n  'custom',\n  {},\n  EthereumProvider['request']\n>\n\nexport type CustomTransportErrorType = CreateTransportErrorType | ErrorType\n\n/**\n * @description Creates a custom transport given an EIP-1193 compliant `request` attribute.\n */\nexport function custom<provider extends EthereumProvider>(\n  provider: provider,\n  config: CustomTransportConfig = {},\n): CustomTransport {\n  const {\n    key = 'custom',\n    methods,\n    name = 'Custom Provider',\n    retryDelay,\n  } = config\n  return ({ retryCount: defaultRetryCount }) =>\n    createTransport({\n      key,\n      methods,\n      name,\n      request: provider.request.bind(provider),\n      retryCount: config.retryCount ?? defaultRetryCount,\n      retryDelay,\n      type: 'custom',\n    })\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { CompactSignature, Signature } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\nexport type SignatureToCompactSignatureErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * @description Converts a signature into an [EIP-2098 compact signature](https://eips.ethereum.org/EIPS/eip-2098).\n *\n * @param signature The signature to convert.\n * @returns The signature in compact format.\n *\n * @example\n * signatureToCompactSignature({\n *   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   s: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n *   yParity: 0\n * })\n * // {\n * //   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n * //   yParityAndS: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'\n * // }\n */\nexport function signatureToCompactSignature(\n  signature: Signature,\n): CompactSignature {\n  const { r, s, v, yParity } = signature\n  const yParity_ = Number(yParity ?? v! - 27n)\n  let yParityAndS = s\n  if (yParity_ === 1) {\n    const bytes = hexToBytes(s)\n    bytes[0] |= 0x80\n    yParityAndS = bytesToHex(bytes)\n  }\n  return { r, yParityAndS }\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hash, Hex, Signature } from '../../types/misc.js'\nimport { type GetAddressErrorType, getAddress } from '../address/getAddress.js'\nimport {\n  type IsAddressEqualErrorType,\n  isAddressEqual,\n} from '../address/isAddressEqual.js'\nimport {\n  type RecoverAddressErrorType,\n  recoverAddress,\n} from './recoverAddress.js'\n\nexport type VerifyHashParameters = {\n  /** The address that signed the original message. */\n  address: Address\n  /** The hash to be verified. */\n  hash: Hash\n  /** The signature that was generated by signing the message with the address's private key. */\n  signature: Hex | ByteArray | Signature\n}\n\nexport type VerifyHashReturnType = boolean\n\nexport type VerifyHashErrorType =\n  | IsAddressEqualErrorType\n  | GetAddressErrorType\n  | RecoverAddressErrorType\n  | ErrorType\n\n/**\n * Verify that a message was signed by the provided address.\n *\n * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.\n *        It is highly recommended to use `publicClient.verifyHash` instead to ensure\n *        wallet interoperability.\n *\n * - Docs {@link https://viem.sh/docs/utilities/verifyHash}\n *\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash({\n  address,\n  hash,\n  signature,\n}: VerifyHashParameters): Promise<VerifyHashReturnType> {\n  return isAddressEqual(\n    getAddress(address),\n    await recoverAddress({ hash, signature }),\n  )\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ByteArray,\n  Hex,\n  SignableMessage,\n  Signature,\n} from '../../types/misc.js'\nimport { type GetAddressErrorType, getAddress } from '../address/getAddress.js'\nimport {\n  type IsAddressEqualErrorType,\n  isAddressEqual,\n} from '../address/isAddressEqual.js'\nimport {\n  type RecoverMessageAddressErrorType,\n  recoverMessageAddress,\n} from './recoverMessageAddress.js'\n\nexport type VerifyMessageParameters = {\n  /** The address that signed the original message. */\n  address: Address\n  /** The message to be verified. */\n  message: SignableMessage\n  /** The signature that was generated by signing the message with the address's private key. */\n  signature: Hex | ByteArray | Signature\n}\n\nexport type VerifyMessageReturnType = boolean\n\nexport type VerifyMessageErrorType =\n  | IsAddressEqualErrorType\n  | GetAddressErrorType\n  | RecoverMessageAddressErrorType\n  | ErrorType\n\n/**\n * Verify that a message was signed by the provided address.\n *\n * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.\n *        It is highly recommended to use `publicClient.verifyMessage` instead to ensure\n *        wallet interoperability.\n *\n * - Docs {@link https://viem.sh/docs/utilities/verifyMessage}\n *\n * @param parameters - {@link VerifyMessageParameters}\n * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}\n */\nexport async function verifyMessage({\n  address,\n  message,\n  signature,\n}: VerifyMessageParameters): Promise<VerifyMessageReturnType> {\n  return isAddressEqual(\n    getAddress(address),\n    await recoverMessageAddress({ message, signature }),\n  )\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type SetNextBlockBaseFeePerGasParameters = {\n  /** Base fee per gas (in wei). */\n  baseFeePerGas: bigint\n}\n\nexport type SetNextBlockBaseFeePerGasErrorType = RequestErrorType | ErrorType\n\n/**\n * Sets the next block's base fee per gas.\n *\n * - Docs: https://viem.sh/docs/actions/test/setNextBlockBaseFeePerGas\n *\n * @param client - Client to use\n * @param parameters â€“ {@link SetNextBlockBaseFeePerGasParameters}\n *\n * @example\n * import { createTestClient, http, parseGwei } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setNextBlockBaseFeePerGas } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setNextBlockBaseFeePerGas(client, {\n *   baseFeePerGas: parseGwei('20'),\n * })\n */\nexport async function setNextBlockBaseFeePerGas<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { baseFeePerGas }: SetNextBlockBaseFeePerGasParameters,\n) {\n  await client.request({\n    method: `${client.mode}_setNextBlockBaseFeePerGas`,\n    params: [numberToHex(baseFeePerGas)],\n  })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { hexToNumber } from '../../utils/encoding/fromHex.js'\n\nexport type GetTxpoolStatusReturnType = {\n  pending: number\n  queued: number\n}\n\nexport type GetTxpoolStatusErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns a summary of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.\n *\n * - Docs: https://viem.sh/docs/actions/test/getTxpoolStatus\n *\n * @param client - Client to use\n * @returns Transaction pool status. {@link GetTxpoolStatusReturnType}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { getTxpoolStatus } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * const status = await getTxpoolStatus(client)\n */\nexport async function getTxpoolStatus<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n): Promise<GetTxpoolStatusReturnType> {\n  const { pending, queued } = await client.request({\n    method: 'txpool_status',\n  })\n  return {\n    pending: hexToNumber(pending),\n    queued: hexToNumber(queued),\n  }\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { OneOf, Prettify } from '../../types/utils.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from '../abi/decodeAbiParameters.js'\nimport {\n  type IsErc6492SignatureErrorType,\n  isErc6492Signature,\n} from './isErc6492Signature.js'\n\nexport type ParseErc6492SignatureParameters = Hex\n\nexport type ParseErc6492SignatureReturnType = Prettify<\n  OneOf<\n    | {\n        /**\n         * The ERC-4337 Account Factory or preparation address to use for counterfactual verification.\n         * `undefined` if the signature is not in ERC-6492 format.\n         */\n        address: Address\n        /**\n         * Calldata to pass to deploy account (if not deployed) for counterfactual verification.\n         * `undefined` if the signature is not in ERC-6492 format.\n         */\n        data: Hex\n        /** The original signature. */\n        signature: Hex\n      }\n    | {\n        /** The original signature. */\n        signature: Hex\n      }\n  >\n>\n\nexport type ParseErc6492SignatureErrorType =\n  | IsErc6492SignatureErrorType\n  | DecodeAbiParametersErrorType\n  | ErrorType\n\n/**\n * @description Parses a hex-formatted ERC-6492 flavoured signature.\n * If the signature is not in ERC-6492 format, then the underlying (original) signature is returned.\n *\n * @param signature ERC-6492 signature in hex format.\n * @returns The parsed ERC-6492 signature.\n *\n * @example\n * parseSignature('0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492')\n * // { address: '0x...', data: '0x...', signature: '0x...' }\n */\nexport function parseErc6492Signature(\n  signature: ParseErc6492SignatureParameters,\n): ParseErc6492SignatureReturnType {\n  if (!isErc6492Signature(signature)) return { signature }\n\n  const [address, data, signature_] = decodeAbiParameters(\n    [{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }],\n    signature,\n  )\n  return { address, data, signature: signature_ }\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type MineParameters = {\n  /** Number of blocks to mine. */\n  blocks: number\n  /** Interval between each block in seconds. */\n  interval?: number | undefined\n}\n\nexport type MineErrorType = RequestErrorType | ErrorType\n\n/**\n * Mine a specified number of blocks.\n *\n * - Docs: https://viem.sh/docs/actions/test/mine\n *\n * @param client - Client to use\n * @param parameters â€“ {@link MineParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { mine } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await mine(client, { blocks: 1 })\n */\nexport async function mine<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { blocks, interval }: MineParameters,\n) {\n  if (client.mode === 'ganache')\n    await client.request({\n      method: 'evm_mine',\n      params: [{ blocks: numberToHex(blocks) }],\n    })\n  else\n    await client.request({\n      method: `${client.mode}_mine`,\n      params: [numberToHex(blocks), numberToHex(interval || 0)],\n    })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type SetBlockGasLimitParameters = {\n  /** Gas limit (in wei). */\n  gasLimit: bigint\n}\n\nexport type SetBlockGasLimitErrorType = RequestErrorType | ErrorType\n\n/**\n * Sets the block's gas limit.\n *\n * - Docs: https://viem.sh/docs/actions/test/setBlockGasLimit\n *\n * @param client - Client to use\n * @param parameters â€“ {@link SetBlockGasLimitParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setBlockGasLimit } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setBlockGasLimit(client, { gasLimit: 420_000n })\n */\nexport async function setBlockGasLimit<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { gasLimit }: SetBlockGasLimitParameters,\n) {\n  await client.request({\n    method: 'evm_setBlockGasLimit',\n    params: [numberToHex(gasLimit)],\n  })\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ByteArray,\n  Hex,\n  SignableMessage,\n  Signature,\n} from '../../types/misc.js'\nimport { type HashMessageErrorType, hashMessage } from './hashMessage.js'\nimport {\n  type RecoverAddressErrorType,\n  recoverAddress,\n} from './recoverAddress.js'\n\nexport type RecoverMessageAddressParameters = {\n  message: SignableMessage\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverMessageAddressReturnType = Address\n\nexport type RecoverMessageAddressErrorType =\n  | HashMessageErrorType\n  | RecoverAddressErrorType\n  | ErrorType\n\nexport async function recoverMessageAddress({\n  message,\n  signature,\n}: RecoverMessageAddressParameters): Promise<RecoverMessageAddressReturnType> {\n  return recoverAddress({ hash: hashMessage(message), signature })\n}\n","import {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport {\n  InvalidLegacyVError,\n  type InvalidLegacyVErrorType,\n  InvalidSerializedTransactionError,\n  type InvalidSerializedTransactionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  SerializedAuthorizationList,\n  SignedAuthorizationList,\n} from '../../types/authorization.js'\nimport type { Hex, Signature } from '../../types/misc.js'\nimport type {\n  AccessList,\n  TransactionRequestEIP2930,\n  TransactionRequestLegacy,\n  TransactionSerializable,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableEIP7702,\n  TransactionSerializableLegacy,\n  TransactionSerialized,\n  TransactionSerializedEIP1559,\n  TransactionSerializedEIP2930,\n  TransactionSerializedEIP4844,\n  TransactionSerializedEIP7702,\n  TransactionSerializedGeneric,\n  TransactionType,\n} from '../../types/transaction.js'\nimport type { IsNarrowable, Mutable } from '../../types/utils.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { toBlobSidecars } from '../blob/toBlobSidecars.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadHexErrorType, padHex } from '../data/pad.js'\nimport { trim } from '../data/trim.js'\nimport {\n  type HexToBigIntErrorType,\n  type HexToNumberErrorType,\n  hexToBigInt,\n  hexToNumber,\n} from '../encoding/fromHex.js'\nimport { type FromRlpErrorType, fromRlp } from '../encoding/fromRlp.js'\nimport type { RecursiveArray } from '../encoding/toRlp.js'\nimport { isHash } from '../hash/isHash.js'\n\nimport {\n  type AssertTransactionEIP1559ErrorType,\n  type AssertTransactionEIP2930ErrorType,\n  type AssertTransactionEIP4844ErrorType,\n  type AssertTransactionEIP7702ErrorType,\n  type AssertTransactionLegacyErrorType,\n  assertTransactionEIP1559,\n  assertTransactionEIP2930,\n  assertTransactionEIP4844,\n  assertTransactionEIP7702,\n  assertTransactionLegacy,\n} from './assertTransaction.js'\nimport {\n  type GetSerializedTransactionType,\n  type GetSerializedTransactionTypeErrorType,\n  getSerializedTransactionType,\n} from './getSerializedTransactionType.js'\n\nexport type ParseTransactionReturnType<\n  serialized extends TransactionSerializedGeneric = TransactionSerialized,\n  type extends TransactionType = GetSerializedTransactionType<serialized>,\n> = IsNarrowable<serialized, Hex> extends true\n  ?\n      | (type extends 'eip1559' ? TransactionSerializableEIP1559 : never)\n      | (type extends 'eip2930' ? TransactionSerializableEIP2930 : never)\n      | (type extends 'eip4844'\n          ? TransactionSerializableEIP4844<bigint, number, false>\n          : never)\n      | (type extends 'eip7702' ? TransactionSerializableEIP7702 : never)\n      | (type extends 'legacy' ? TransactionSerializableLegacy : never)\n  : TransactionSerializable\n\nexport type ParseTransactionErrorType =\n  | GetSerializedTransactionTypeErrorType\n  | ParseTransactionEIP1559ErrorType\n  | ParseTransactionEIP2930ErrorType\n  | ParseTransactionEIP4844ErrorType\n  | ParseTransactionEIP7702ErrorType\n  | ParseTransactionLegacyErrorType\n\nexport function parseTransaction<\n  const serialized extends TransactionSerializedGeneric,\n>(serializedTransaction: serialized): ParseTransactionReturnType<serialized> {\n  const type = getSerializedTransactionType(serializedTransaction)\n\n  if (type === 'eip1559')\n    return parseTransactionEIP1559(\n      serializedTransaction as TransactionSerializedEIP1559,\n    ) as ParseTransactionReturnType<serialized>\n\n  if (type === 'eip2930')\n    return parseTransactionEIP2930(\n      serializedTransaction as TransactionSerializedEIP2930,\n    ) as ParseTransactionReturnType<serialized>\n\n  if (type === 'eip4844')\n    return parseTransactionEIP4844(\n      serializedTransaction as TransactionSerializedEIP4844,\n    ) as ParseTransactionReturnType<serialized>\n\n  if (type === 'eip7702')\n    return parseTransactionEIP7702(\n      serializedTransaction as TransactionSerializedEIP7702,\n    ) as ParseTransactionReturnType<serialized>\n\n  return parseTransactionLegacy(\n    serializedTransaction,\n  ) as ParseTransactionReturnType<serialized>\n}\n\ntype ParseTransactionEIP7702ErrorType =\n  | ToTransactionArrayErrorType\n  | AssertTransactionEIP7702ErrorType\n  | ToTransactionArrayErrorType\n  | HexToBigIntErrorType\n  | HexToNumberErrorType\n  | InvalidLegacyVErrorType\n  | InvalidSerializedTransactionErrorType\n  | IsHexErrorType\n  | ParseAuthorizationListErrorType\n  | ParseEIP155SignatureErrorType\n  | ErrorType\n\nfunction parseTransactionEIP7702(\n  serializedTransaction: TransactionSerializedEIP7702,\n): TransactionSerializableEIP7702 {\n  const transactionArray = toTransactionArray(serializedTransaction)\n\n  const [\n    chainId,\n    nonce,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    gas,\n    to,\n    value,\n    data,\n    accessList,\n    authorizationList,\n    v,\n    r,\n    s,\n  ] = transactionArray\n\n  if (transactionArray.length !== 10 && transactionArray.length !== 13)\n    throw new InvalidSerializedTransactionError({\n      attributes: {\n        chainId,\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gas,\n        to,\n        value,\n        data,\n        accessList,\n        authorizationList,\n        ...(transactionArray.length > 9\n          ? {\n              v,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serializedTransaction,\n      type: 'eip7702',\n    })\n\n  const transaction = {\n    chainId: hexToNumber(chainId as Hex),\n    type: 'eip7702',\n  } as TransactionSerializableEIP7702\n  if (isHex(to) && to !== '0x') transaction.to = to\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)\n  if (isHex(data) && data !== '0x') transaction.data = data\n  if (isHex(nonce)) transaction.nonce = nonce === '0x' ? 0 : hexToNumber(nonce)\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)\n  if (isHex(maxFeePerGas) && maxFeePerGas !== '0x')\n    transaction.maxFeePerGas = hexToBigInt(maxFeePerGas)\n  if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n    transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas)\n  if (accessList.length !== 0 && accessList !== '0x')\n    transaction.accessList = parseAccessList(accessList as RecursiveArray<Hex>)\n  if (authorizationList.length !== 0 && authorizationList !== '0x')\n    transaction.authorizationList = parseAuthorizationList(\n      authorizationList as SerializedAuthorizationList,\n    )\n\n  assertTransactionEIP7702(transaction)\n\n  const signature =\n    transactionArray.length === 13\n      ? parseEIP155Signature(transactionArray as RecursiveArray<Hex>)\n      : undefined\n\n  return { ...signature, ...transaction }\n}\n\ntype ParseTransactionEIP4844ErrorType =\n  | ToTransactionArrayErrorType\n  | AssertTransactionEIP4844ErrorType\n  | ToTransactionArrayErrorType\n  | HexToBigIntErrorType\n  | HexToNumberErrorType\n  | InvalidLegacyVErrorType\n  | InvalidSerializedTransactionErrorType\n  | IsHexErrorType\n  | ParseEIP155SignatureErrorType\n  | ErrorType\n\nfunction parseTransactionEIP4844(\n  serializedTransaction: TransactionSerializedEIP4844,\n): TransactionSerializableEIP4844 {\n  const transactionOrWrapperArray = toTransactionArray(serializedTransaction)\n\n  const hasNetworkWrapper = transactionOrWrapperArray.length === 4\n\n  const transactionArray = hasNetworkWrapper\n    ? transactionOrWrapperArray[0]\n    : transactionOrWrapperArray\n  const wrapperArray = hasNetworkWrapper\n    ? transactionOrWrapperArray.slice(1)\n    : []\n\n  const [\n    chainId,\n    nonce,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    gas,\n    to,\n    value,\n    data,\n    accessList,\n    maxFeePerBlobGas,\n    blobVersionedHashes,\n    v,\n    r,\n    s,\n  ] = transactionArray\n  const [blobs, commitments, proofs] = wrapperArray\n\n  if (!(transactionArray.length === 11 || transactionArray.length === 14))\n    throw new InvalidSerializedTransactionError({\n      attributes: {\n        chainId,\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gas,\n        to,\n        value,\n        data,\n        accessList,\n        ...(transactionArray.length > 9\n          ? {\n              v,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serializedTransaction,\n      type: 'eip4844',\n    })\n\n  const transaction = {\n    blobVersionedHashes: blobVersionedHashes as Hex[],\n    chainId: hexToNumber(chainId as Hex),\n    to,\n    type: 'eip4844',\n  } as TransactionSerializableEIP4844\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)\n  if (isHex(data) && data !== '0x') transaction.data = data\n  if (isHex(nonce)) transaction.nonce = nonce === '0x' ? 0 : hexToNumber(nonce)\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)\n  if (isHex(maxFeePerBlobGas) && maxFeePerBlobGas !== '0x')\n    transaction.maxFeePerBlobGas = hexToBigInt(maxFeePerBlobGas)\n  if (isHex(maxFeePerGas) && maxFeePerGas !== '0x')\n    transaction.maxFeePerGas = hexToBigInt(maxFeePerGas)\n  if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n    transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas)\n  if (accessList.length !== 0 && accessList !== '0x')\n    transaction.accessList = parseAccessList(accessList as RecursiveArray<Hex>)\n  if (blobs && commitments && proofs)\n    transaction.sidecars = toBlobSidecars({\n      blobs: blobs as Hex[],\n      commitments: commitments as Hex[],\n      proofs: proofs as Hex[],\n    })\n\n  assertTransactionEIP4844(transaction)\n\n  const signature =\n    transactionArray.length === 14\n      ? parseEIP155Signature(transactionArray as RecursiveArray<Hex>)\n      : undefined\n\n  return { ...signature, ...transaction }\n}\n\ntype ParseTransactionEIP1559ErrorType =\n  | ToTransactionArrayErrorType\n  | AssertTransactionEIP1559ErrorType\n  | ToTransactionArrayErrorType\n  | HexToBigIntErrorType\n  | HexToNumberErrorType\n  | InvalidLegacyVErrorType\n  | InvalidSerializedTransactionErrorType\n  | IsHexErrorType\n  | ParseEIP155SignatureErrorType\n  | ParseAccessListErrorType\n  | ErrorType\n\nfunction parseTransactionEIP1559(\n  serializedTransaction: TransactionSerializedEIP1559,\n): TransactionSerializableEIP1559 {\n  const transactionArray = toTransactionArray(serializedTransaction)\n\n  const [\n    chainId,\n    nonce,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    gas,\n    to,\n    value,\n    data,\n    accessList,\n    v,\n    r,\n    s,\n  ] = transactionArray\n\n  if (!(transactionArray.length === 9 || transactionArray.length === 12))\n    throw new InvalidSerializedTransactionError({\n      attributes: {\n        chainId,\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gas,\n        to,\n        value,\n        data,\n        accessList,\n        ...(transactionArray.length > 9\n          ? {\n              v,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serializedTransaction,\n      type: 'eip1559',\n    })\n\n  const transaction: TransactionSerializableEIP1559 = {\n    chainId: hexToNumber(chainId as Hex),\n    type: 'eip1559',\n  }\n  if (isHex(to) && to !== '0x') transaction.to = to\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)\n  if (isHex(data) && data !== '0x') transaction.data = data\n  if (isHex(nonce)) transaction.nonce = nonce === '0x' ? 0 : hexToNumber(nonce)\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)\n  if (isHex(maxFeePerGas) && maxFeePerGas !== '0x')\n    transaction.maxFeePerGas = hexToBigInt(maxFeePerGas)\n  if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n    transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas)\n  if (accessList.length !== 0 && accessList !== '0x')\n    transaction.accessList = parseAccessList(accessList as RecursiveArray<Hex>)\n\n  assertTransactionEIP1559(transaction)\n\n  const signature =\n    transactionArray.length === 12\n      ? parseEIP155Signature(transactionArray)\n      : undefined\n\n  return { ...signature, ...transaction }\n}\n\ntype ParseTransactionEIP2930ErrorType =\n  | ToTransactionArrayErrorType\n  | AssertTransactionEIP2930ErrorType\n  | ToTransactionArrayErrorType\n  | HexToBigIntErrorType\n  | HexToNumberErrorType\n  | InvalidLegacyVErrorType\n  | InvalidSerializedTransactionErrorType\n  | IsHexErrorType\n  | ParseEIP155SignatureErrorType\n  | ParseAccessListErrorType\n  | ErrorType\n\nfunction parseTransactionEIP2930(\n  serializedTransaction: TransactionSerializedEIP2930,\n): Omit<TransactionRequestEIP2930, 'from'> &\n  ({ chainId: number } | ({ chainId: number } & Signature)) {\n  const transactionArray = toTransactionArray(serializedTransaction)\n\n  const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] =\n    transactionArray\n\n  if (!(transactionArray.length === 8 || transactionArray.length === 11))\n    throw new InvalidSerializedTransactionError({\n      attributes: {\n        chainId,\n        nonce,\n        gasPrice,\n        gas,\n        to,\n        value,\n        data,\n        accessList,\n        ...(transactionArray.length > 8\n          ? {\n              v,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serializedTransaction,\n      type: 'eip2930',\n    })\n\n  const transaction: TransactionSerializableEIP2930 = {\n    chainId: hexToNumber(chainId as Hex),\n    type: 'eip2930',\n  }\n  if (isHex(to) && to !== '0x') transaction.to = to\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)\n  if (isHex(data) && data !== '0x') transaction.data = data\n  if (isHex(nonce)) transaction.nonce = nonce === '0x' ? 0 : hexToNumber(nonce)\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)\n  if (isHex(gasPrice) && gasPrice !== '0x')\n    transaction.gasPrice = hexToBigInt(gasPrice)\n  if (accessList.length !== 0 && accessList !== '0x')\n    transaction.accessList = parseAccessList(accessList as RecursiveArray<Hex>)\n\n  assertTransactionEIP2930(transaction)\n\n  const signature =\n    transactionArray.length === 11\n      ? parseEIP155Signature(transactionArray)\n      : undefined\n\n  return { ...signature, ...transaction }\n}\n\ntype ParseTransactionLegacyErrorType =\n  | AssertTransactionLegacyErrorType\n  | FromRlpErrorType\n  | HexToBigIntErrorType\n  | HexToNumberErrorType\n  | InvalidLegacyVErrorType\n  | InvalidSerializedTransactionErrorType\n  | IsHexErrorType\n  | ErrorType\n\nfunction parseTransactionLegacy(\n  serializedTransaction: Hex,\n): Omit<TransactionRequestLegacy, 'from'> &\n  ({ chainId?: number | undefined } | ({ chainId: number } & Signature)) {\n  const transactionArray = fromRlp(serializedTransaction, 'hex')\n\n  const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] =\n    transactionArray\n\n  if (!(transactionArray.length === 6 || transactionArray.length === 9))\n    throw new InvalidSerializedTransactionError({\n      attributes: {\n        nonce,\n        gasPrice,\n        gas,\n        to,\n        value,\n        data,\n        ...(transactionArray.length > 6\n          ? {\n              v: chainIdOrV_,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serializedTransaction,\n      type: 'legacy',\n    })\n\n  const transaction: TransactionSerializableLegacy = {\n    type: 'legacy',\n  }\n  if (isHex(to) && to !== '0x') transaction.to = to\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)\n  if (isHex(data) && data !== '0x') transaction.data = data\n  if (isHex(nonce)) transaction.nonce = nonce === '0x' ? 0 : hexToNumber(nonce)\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)\n  if (isHex(gasPrice) && gasPrice !== '0x')\n    transaction.gasPrice = hexToBigInt(gasPrice)\n\n  assertTransactionLegacy(transaction)\n\n  if (transactionArray.length === 6) return transaction\n\n  const chainIdOrV =\n    isHex(chainIdOrV_) && chainIdOrV_ !== '0x'\n      ? hexToBigInt(chainIdOrV_ as Hex)\n      : 0n\n\n  if (s === '0x' && r === '0x') {\n    if (chainIdOrV > 0) transaction.chainId = Number(chainIdOrV)\n    return transaction\n  }\n\n  const v = chainIdOrV\n\n  const chainId: number | undefined = Number((v - 35n) / 2n)\n  if (chainId > 0) transaction.chainId = chainId\n  else if (v !== 27n && v !== 28n) throw new InvalidLegacyVError({ v })\n\n  transaction.v = v\n  transaction.s = s as Hex\n  transaction.r = r as Hex\n  transaction.yParity = v % 2n === 0n ? 1 : 0\n\n  return transaction\n}\n\ntype ToTransactionArrayErrorType = FromRlpErrorType | ErrorType\n\nexport function toTransactionArray(serializedTransaction: string) {\n  return fromRlp(`0x${serializedTransaction.slice(4)}` as Hex, 'hex')\n}\n\ntype ParseAccessListErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function parseAccessList(accessList_: RecursiveArray<Hex>): AccessList {\n  const accessList: Mutable<AccessList> = []\n  for (let i = 0; i < accessList_.length; i++) {\n    const [address, storageKeys] = accessList_[i] as [Hex, Hex[]]\n\n    if (!isAddress(address, { strict: false }))\n      throw new InvalidAddressError({ address })\n\n    accessList.push({\n      address: address,\n      storageKeys: storageKeys.map((key) => (isHash(key) ? key : trim(key))),\n    })\n  }\n  return accessList\n}\n\ntype ParseAuthorizationListErrorType =\n  | HexToNumberErrorType\n  | ParseEIP155SignatureErrorType\n  | ErrorType\n\nfunction parseAuthorizationList(\n  serializedAuthorizationList: SerializedAuthorizationList,\n): SignedAuthorizationList {\n  const authorizationList: Mutable<SignedAuthorizationList> = []\n  for (let i = 0; i < serializedAuthorizationList.length; i++) {\n    const [chainId, address, nonce, yParity, r, s] =\n      serializedAuthorizationList[i]\n\n    authorizationList.push({\n      address,\n      chainId: chainId === '0x' ? 0 : hexToNumber(chainId),\n      nonce: nonce === '0x' ? 0 : hexToNumber(nonce),\n      ...parseEIP155Signature([yParity, r, s]),\n    })\n  }\n  return authorizationList\n}\n\ntype ParseEIP155SignatureErrorType =\n  | HexToBigIntErrorType\n  | PadHexErrorType\n  | ErrorType\n\nfunction parseEIP155Signature(\n  transactionArray: RecursiveArray<Hex>,\n): Signature & { yParity: number } {\n  const signature = transactionArray.slice(-3)\n  const v =\n    signature[0] === '0x' || hexToBigInt(signature[0] as Hex) === 0n ? 27n : 28n\n  return {\n    r: padHex(signature[1] as Hex, { size: 32 }),\n    s: padHex(signature[2] as Hex, { size: 32 }),\n    v,\n    yParity: v === 27n ? 0 : 1,\n  }\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type SetNextBlockTimestampParameters = {\n  /** The timestamp (in seconds). */\n  timestamp: bigint\n}\n\nexport type SetNextBlockTimestampErrorType = RequestErrorType | ErrorType\n\n/**\n * Sets the next block's timestamp.\n *\n * - Docs: https://viem.sh/docs/actions/test/setNextBlockTimestamp\n *\n * @param client - Client to use\n * @param parameters â€“ {@link SetNextBlockTimestampParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setNextBlockTimestamp } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setNextBlockTimestamp(client, { timestamp: 1671744314n })\n */\nexport async function setNextBlockTimestamp<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { timestamp }: SetNextBlockTimestampParameters,\n) {\n  await client.request({\n    method: 'evm_setNextBlockTimestamp',\n    params: [numberToHex(timestamp)],\n  })\n}\n","import type { Address } from 'abitype'\n\nimport type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type SetNonceParameters = {\n  /** The account address. */\n  address: Address\n  /** The nonce to set. */\n  nonce: number\n}\n\nexport type SetNonceErrorType = RequestErrorType | ErrorType\n\n/**\n * Modifies (overrides) the nonce of an account.\n *\n * - Docs: https://viem.sh/docs/actions/test/setNonce\n *\n * @param client - Client to use\n * @param parameters â€“ {@link SetNonceParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setNonce } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setNonce(client, {\n *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *   nonce: 420,\n * })\n */\nexport async function setNonce<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { address, nonce }: SetNonceParameters,\n) {\n  await client.request({\n    method: `${client.mode}_setNonce`,\n    params: [address, numberToHex(nonce)],\n  })\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\n\nexport type ExtractChainParameters<\n  chains extends readonly Chain[],\n  chainId extends chains[number]['id'],\n> = {\n  chains: chains\n  id: chainId | chains[number]['id']\n}\n\nexport type ExtractChainReturnType<\n  chains extends readonly Chain[],\n  chainId extends chains[number]['id'],\n> = Extract<chains[number], { id: chainId }>\n\nexport type ExtractChainErrorType = ErrorType\n\nexport function extractChain<\n  const chains extends readonly Chain[],\n  chainId extends chains[number]['id'],\n>({\n  chains,\n  id,\n}: ExtractChainParameters<chains, chainId>): ExtractChainReturnType<\n  chains,\n  chainId\n> {\n  return chains.find((chain) => chain.id === id) as ExtractChainReturnType<\n    chains,\n    chainId\n  >\n}\n","import type { Address } from 'abitype'\n\nimport type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash, Hex } from '../../types/misc.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type SetStorageAtParameters = {\n  /** The account address. */\n  address: Address\n  /** The storage slot (index). Can either be a number or hash value. */\n  index: number | Hash\n  /** The value to store as a 32 byte hex string. */\n  value: Hex\n}\n\nexport type SetStorageAtErrorType = RequestErrorType | ErrorType\n\n/**\n * Writes to a slot of an account's storage.\n *\n * - Docs: https://viem.sh/docs/actions/test/setStorageAt\n *\n * @param client - Client to use\n * @param parameters â€“ {@link SetStorageAtParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setStorageAt } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setStorageAt(client, {\n *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',\n *   index: 2,\n *   value: '0x0000000000000000000000000000000000000000000000000000000000000069',\n * })\n */\nexport async function setStorageAt<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { address, index, value }: SetStorageAtParameters,\n) {\n  await client.request({\n    method: `${client.mode}_setStorageAt`,\n    params: [\n      address,\n      typeof index === 'number' ? numberToHex(index) : index,\n      value,\n    ],\n  })\n}\n","import type { Address } from 'abitype'\n\nimport type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type SetBalanceParameters = {\n  /** The account address. */\n  address: Address\n  /** Amount (in wei) to set */\n  value: bigint\n}\n\nexport type SetBalanceErrorType = RequestErrorType | ErrorType\n\n/**\n * Modifies the balance of an account.\n *\n * - Docs: https://viem.sh/docs/actions/test/setBalance\n *\n * @param client - Client to use\n * @param parameters â€“ {@link SetBalanceParameters}\n *\n * @example\n * import { createTestClient, http, parseEther } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setBalance } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setBalance(client, {\n *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *   value: parseEther('1'),\n * })\n */\nexport async function setBalance<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { address, value }: SetBalanceParameters,\n) {\n  if (client.mode === 'ganache')\n    await client.request({\n      method: 'evm_setAccountBalance',\n      params: [address, numberToHex(value)],\n    })\n  else\n    await client.request({\n      method: `${client.mode}_setBalance`,\n      params: [address, numberToHex(value)],\n    })\n}\n","import type { Abi } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiItemError } from './errors/abiItem.js'\nimport { isStructSignature } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseSignature } from './runtime/utils.js'\nimport type { Signature, Signatures } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseSignature } from './types/utils.js'\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * type Result = ParseAbiItem<'function balanceOf(address owner) view returns (uint256)'>\n * //   ^? type Result = { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * type Result = ParseAbiItem<\n *   // ^? type Result = { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   ['function foo(Baz bar) view returns (string)', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n> =\n  | (signature extends string\n      ? string extends signature\n        ? Abi[number]\n        : signature extends Signature<signature> // Validate signature\n          ? ParseSignature<signature>\n          : never\n      : never)\n  | (signature extends readonly string[]\n      ? string[] extends signature\n        ? Abi[number] // Return generic Abi item since type was no inferrable\n        : signature extends Signatures<signature> // Validate signature\n          ? ParseStructs<signature> extends infer structs\n            ? {\n                [key in keyof signature]: ParseSignature<\n                  signature[key] extends string ? signature[key] : never,\n                  structs\n                >\n              } extends infer mapped extends readonly unknown[]\n              ? // Filter out `never` since those are structs\n                Filter<mapped, never>[0] extends infer result\n                ? result extends undefined // convert `undefined` to `never` (e.g. `ParseAbiItem<['struct Foo { string name; }']>`)\n                  ? never\n                  : result\n                : never\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n>(\n  signature: Narrow<signature> &\n    (\n      | (signature extends string\n          ? string extends signature\n            ? unknown\n            : Signature<signature>\n          : never)\n      | (signature extends readonly string[]\n          ? signature extends readonly [] // empty array\n            ? Error<'At least one signature required.'>\n            : string[] extends signature\n              ? unknown\n              : Signatures<signature>\n          : never)\n    ),\n): ParseAbiItem<signature> {\n  let abiItem: ParseAbiItem<signature> | undefined\n  if (typeof signature === 'string')\n    abiItem = parseSignature(signature) as ParseAbiItem<signature>\n  else {\n    const structs = parseStructs(signature as readonly string[])\n    const length = signature.length as number\n    for (let i = 0; i < length; i++) {\n      const signature_ = (signature as readonly string[])[i]!\n      if (isStructSignature(signature_)) continue\n      abiItem = parseSignature(signature_, structs) as ParseAbiItem<signature>\n      break\n    }\n  }\n\n  if (!abiItem) throw new InvalidAbiItemError({ signature })\n  return abiItem as ParseAbiItem<signature>\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type IncreaseTimeParameters = {\n  /** The amount of seconds to jump forward in time. */\n  seconds: number\n}\n\nexport type IncreaseTimeErrorType = RequestErrorType | ErrorType\n\n/**\n * Jump forward in time by the given amount of time, in seconds.\n *\n * - Docs: https://viem.sh/docs/actions/test/increaseTime\n *\n * @param client - Client to use\n * @param parameters â€“ {@link IncreaseTimeParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { increaseTime } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await increaseTime(client, {\n *   seconds: 420,\n * })\n */\nexport async function increaseTime<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { seconds }: IncreaseTimeParameters,\n) {\n  return await client.request({\n    method: 'evm_increaseTime',\n    params: [numberToHex(seconds)],\n  })\n}\n","import type { Address } from 'abitype'\n\nimport { getTransactionCount } from '../actions/public/getTransactionCount.js'\nimport type { Client } from '../clients/createClient.js'\nimport type { MaybePromise } from '../types/utils.js'\nimport { LruMap } from './lru.js'\n\nexport type CreateNonceManagerParameters = {\n  source: NonceManagerSource\n}\n\ntype FunctionParameters = {\n  address: Address\n  chainId: number\n}\n\nexport type NonceManager = {\n  /** Get and increment a nonce. */\n  consume: (\n    parameters: FunctionParameters & { client: Client },\n  ) => Promise<number>\n  /** Increment a nonce. */\n  increment: (chainId: FunctionParameters) => void\n  /** Get a nonce. */\n  get: (chainId: FunctionParameters & { client: Client }) => Promise<number>\n  /** Reset a nonce. */\n  reset: (chainId: FunctionParameters) => void\n}\n\n/**\n * Creates a nonce manager for auto-incrementing transaction nonces.\n *\n * - Docs: https://viem.sh/docs/accounts/createNonceManager\n *\n * @example\n * ```ts\n * const nonceManager = createNonceManager({\n *   source: jsonRpc(),\n * })\n * ```\n */\nexport function createNonceManager(\n  parameters: CreateNonceManagerParameters,\n): NonceManager {\n  const { source } = parameters\n\n  const deltaMap = new Map()\n  const nonceMap = new LruMap<number>(8192)\n  const promiseMap = new Map<string, Promise<number>>()\n\n  const getKey = ({ address, chainId }: FunctionParameters) =>\n    `${address}.${chainId}`\n\n  return {\n    async consume({ address, chainId, client }) {\n      const key = getKey({ address, chainId })\n      const promise = this.get({ address, chainId, client })\n\n      this.increment({ address, chainId })\n      const nonce = await promise\n\n      await source.set({ address, chainId }, nonce)\n      nonceMap.set(key, nonce)\n\n      return nonce\n    },\n    async increment({ address, chainId }) {\n      const key = getKey({ address, chainId })\n      const delta = deltaMap.get(key) ?? 0\n      deltaMap.set(key, delta + 1)\n    },\n    async get({ address, chainId, client }) {\n      const key = getKey({ address, chainId })\n\n      let promise = promiseMap.get(key)\n      if (!promise) {\n        promise = (async () => {\n          try {\n            const nonce = await source.get({ address, chainId, client })\n            const previousNonce = nonceMap.get(key) ?? 0\n            if (previousNonce > 0 && nonce <= previousNonce)\n              return previousNonce + 1\n            nonceMap.delete(key)\n            return nonce\n          } finally {\n            this.reset({ address, chainId })\n          }\n        })()\n        promiseMap.set(key, promise)\n      }\n\n      const delta = deltaMap.get(key) ?? 0\n      return delta + (await promise)\n    },\n    reset({ address, chainId }) {\n      const key = getKey({ address, chainId })\n      deltaMap.delete(key)\n      promiseMap.delete(key)\n    },\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// Sources\n\nexport type NonceManagerSource = {\n  /** Get a nonce. */\n  get(parameters: FunctionParameters & { client: Client }): MaybePromise<number>\n  /** Set a nonce. */\n  set(parameters: FunctionParameters, nonce: number): MaybePromise<void>\n}\n\n/** JSON-RPC source for a nonce manager. */\nexport function jsonRpc(): NonceManagerSource {\n  return {\n    async get(parameters) {\n      const { address, client } = parameters\n      return getTransactionCount(client, {\n        address,\n        blockTag: 'pending',\n      })\n    },\n    set() {},\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// Default\n\n/** Default Nonce Manager with a JSON-RPC source. */\nexport const nonceManager = /*#__PURE__*/ createNonceManager({\n  source: jsonRpc(),\n})\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type SetMinGasPriceParameters = {\n  /** The gas price. */\n  gasPrice: bigint\n}\n\nexport type SetMinGasPriceErrorType = RequestErrorType | ErrorType\n\n/**\n * Change the minimum gas price accepted by the network (in wei).\n *\n * - Docs: https://viem.sh/docs/actions/test/setMinGasPrice\n *\n * Note: `setMinGasPrice` can only be used on clients that do not have EIP-1559 enabled.\n *\n * @param client - Client to use\n * @param parameters â€“ {@link SetBlockGasLimitParameters}\n *\n * @example\n * import { createTestClient, http, parseGwei } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setMinGasPrice } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setMinGasPrice(client, {\n *   gasPrice: parseGwei('20'),\n * })\n */\nexport async function setMinGasPrice<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { gasPrice }: SetMinGasPriceParameters,\n) {\n  await client.request({\n    method: `${client.mode}_setMinGasPrice`,\n    params: [numberToHex(gasPrice)],\n  })\n}\n","import type { Address } from 'abitype'\n\nimport type { Account } from '../accounts/types.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { ParseAccount } from '../types/account.js'\nimport type { Chain } from '../types/chain.js'\nimport type { RpcSchema, TestRpcSchema } from '../types/eip1193.js'\nimport type { Prettify } from '../types/utils.js'\nimport {\n  type Client,\n  type ClientConfig,\n  type CreateClientErrorType,\n  createClient,\n} from './createClient.js'\nimport { type TestActions, testActions } from './decorators/test.js'\nimport type { Transport } from './transports/createTransport.js'\n\nexport type TestClientMode = 'anvil' | 'hardhat' | 'ganache'\n\nexport type TestClientConfig<\n  mode extends TestClientMode = TestClientMode,\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  accountOrAddress extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Pick<\n    ClientConfig<transport, chain, accountOrAddress, rpcSchema>,\n    | 'account'\n    | 'cacheTime'\n    | 'chain'\n    | 'key'\n    | 'name'\n    | 'pollingInterval'\n    | 'rpcSchema'\n    | 'transport'\n  > & {\n    /** Mode of the test client. */\n    mode: mode | ('anvil' | 'hardhat' | 'ganache') // TODO: Type utility that expands `TestClientMode`\n  }\n>\n\nexport type TestClient<\n  mode extends TestClientMode = TestClientMode,\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  includeActions extends boolean = true,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  { mode: mode } & Client<\n    transport,\n    chain,\n    account,\n    rpcSchema extends RpcSchema\n      ? [...TestRpcSchema<mode>, ...rpcSchema]\n      : TestRpcSchema<mode>,\n    { mode: mode } & (includeActions extends true\n      ? TestActions\n      : Record<string, unknown>)\n  >\n>\n\nexport type CreateTestClientErrorType = CreateClientErrorType | ErrorType\n\n/**\n * @description Creates a test client with a given transport.\n */\n/**\n * Creates a Test Client with a given [Transport](https://viem.sh/docs/clients/intro) configured for a [Chain](https://viem.sh/docs/clients/chains).\n *\n * - Docs: https://viem.sh/docs/clients/test\n *\n * A Test Client is an interface to \"test\" JSON-RPC API methods accessible through a local Ethereum test node such as [Anvil](https://book.getfoundry.sh/anvil/) or [Hardhat](https://hardhat.org/) such as mining blocks, impersonating accounts, setting fees, etc through [Test Actions](https://viem.sh/docs/actions/test/introduction).\n *\n * @param config - {@link TestClientConfig}\n * @returns A Test Client. {@link TestClient}\n *\n * @example\n * import { createTestClient, custom } from 'viem'\n * import { foundry } from 'viem/chains'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: foundry,\n *   transport: http(),\n * })\n */\nexport function createTestClient<\n  mode extends 'anvil' | 'hardhat' | 'ganache', // TODO: Type utility that expands `TestClientMode`\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  accountOrAddress extends Account | Address | undefined = undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n>(\n  parameters: TestClientConfig<\n    mode,\n    transport,\n    chain,\n    accountOrAddress,\n    rpcSchema\n  >,\n): TestClient<\n  mode,\n  transport,\n  chain,\n  ParseAccount<accountOrAddress>,\n  true,\n  rpcSchema\n>\n\nexport function createTestClient(parameters: TestClientConfig): TestClient {\n  const { key = 'test', name = 'Test Client', mode } = parameters\n  const client = createClient({\n    ...parameters,\n    key,\n    name,\n    type: 'testClient',\n  })\n  return client.extend((config) => ({\n    mode,\n    ...testActions({ mode })(config),\n  }))\n}\n","import {\n  EnsInvalidChainIdError,\n  type EnsInvalidChainIdErrorType,\n} from '../../errors/ens.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\nexport type ToCoinTypeError = EnsInvalidChainIdErrorType | ErrorType\n\nconst SLIP44_MSB = 0x80000000\n\n/**\n * @description Converts a chainId to a ENSIP-9 compliant coinType\n *\n * @example\n * toCoinType(10)\n * 2147483658n\n */\nexport function toCoinType(chainId: number): bigint {\n  if (chainId === 1) return 60n\n  if (chainId >= SLIP44_MSB || chainId < 0)\n    throw new EnsInvalidChainIdError({ chainId })\n  return BigInt((0x80000000 | chainId) >>> 0)\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { BlobSidecars } from '../../types/eip4844.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CommitmentToVersionedHashErrorType,\n  commitmentToVersionedHash,\n} from './commitmentToVersionedHash.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type SidecarsToVersionedHashesParameters<\n  sidecars extends BlobSidecars = BlobSidecars,\n  to extends To | undefined = undefined,\n> = {\n  /** Sidecars from blobs. */\n  sidecars: sidecars | BlobSidecars\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hashes. */\n  version?: number | undefined\n}\n\nexport type SidecarsToVersionedHashesReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type SidecarsToVersionedHashesErrorType =\n  | CommitmentToVersionedHashErrorType\n  | ErrorType\n\n/**\n * Transforms a list of sidecars to their versioned hashes.\n *\n * @example\n * ```ts\n * import { toBlobSidecars, sidecarsToVersionedHashes, stringToHex } from 'viem'\n *\n * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })\n * const versionedHashes = sidecarsToVersionedHashes({ sidecars })\n * ```\n */\nexport function sidecarsToVersionedHashes<\n  const sidecars extends BlobSidecars,\n  to extends To =\n    | (sidecars extends BlobSidecars<Hex> ? 'hex' : never)\n    | (sidecars extends BlobSidecars<ByteArray> ? 'bytes' : never),\n>(\n  parameters: SidecarsToVersionedHashesParameters<sidecars, to>,\n): SidecarsToVersionedHashesReturnType<to> {\n  const { sidecars, version } = parameters\n\n  const to =\n    parameters.to ?? (typeof sidecars[0].blob === 'string' ? 'hex' : 'bytes')\n\n  const hashes: Uint8Array[] | Hex[] = []\n  for (const { commitment } of sidecars) {\n    hashes.push(\n      commitmentToVersionedHash({\n        commitment,\n        to,\n        version,\n      }) as any,\n    )\n  }\n  return hashes as any\n}\n","import type { AbiParameter } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiParametersError } from './errors/abiParameter.js'\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { splitParameters } from './runtime/utils.js'\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { SplitParameters } from './types/utils.js'\nimport type { ParseAbiParameters as ParseAbiParameters_ } from './types/utils.js'\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * type Result = ParseAbiParameters('address from, address to, uint256 amount')\n * //   ^? type Result: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * type Result = ParseAbiParameters<\n *   // ^? type Result: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   ['Baz bar', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n> =\n  | (params extends string\n      ? params extends ''\n        ? never\n        : string extends params\n          ? readonly AbiParameter[]\n          : ParseAbiParameters_<SplitParameters<params>, { modifier: Modifier }>\n      : never)\n  | (params extends readonly string[]\n      ? string[] extends params\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\n        : ParseStructs<params> extends infer structs\n          ? {\n              [key in keyof params]: params[key] extends string\n                ? IsStructSignature<params[key]> extends true\n                  ? never\n                  : ParseAbiParameters_<\n                      SplitParameters<params[key]>,\n                      { modifier: Modifier; structs: structs }\n                    >\n                : never\n            } extends infer mapped extends readonly unknown[]\n            ? Filter<mapped, never> extends readonly [...infer content]\n              ? content['length'] extends 0\n                ? never\n                : DeepFlatten<content>\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Flatten all members of {@link T}\n *\n * @param T - List of items to flatten\n * @param Acc - The accumulator used while recursing\n * @returns The flattened array\n *\n * @example\n * type Result = DeepFlatten<[['a', 'b'], [['c']]]>\n * //   ^? type Result = ['a', 'b', 'c']\n */\ntype DeepFlatten<\n  T extends readonly unknown[],\n  Acc extends readonly unknown[] = readonly [],\n> = T extends readonly [infer head, ...infer tail]\n  ? tail extends undefined\n    ? never\n    : head extends readonly unknown[]\n      ? DeepFlatten<tail, readonly [...Acc, ...DeepFlatten<head>]>\n      : DeepFlatten<tail, readonly [...Acc, head]>\n  : Acc\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n>(\n  params: Narrow<params> &\n    (\n      | (params extends string\n          ? params extends ''\n            ? Error<'Empty string is not allowed.'>\n            : unknown\n          : never)\n      | (params extends readonly string[]\n          ? params extends readonly [] // empty array\n            ? Error<'At least one parameter required.'>\n            : string[] extends params\n              ? unknown\n              : unknown // TODO: Validate param string\n          : never)\n    ),\n): ParseAbiParameters<params> {\n  const abiParameters: AbiParameter[] = []\n  if (typeof params === 'string') {\n    const parameters = splitParameters(params)\n    const length = parameters.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter_(parameters[i]!, { modifiers }))\n    }\n  } else {\n    const structs = parseStructs(params as readonly string[])\n    const length = params.length as number\n    for (let i = 0; i < length; i++) {\n      const signature = (params as readonly string[])[i]!\n      if (isStructSignature(signature)) continue\n      const parameters = splitParameters(signature)\n      const length = parameters.length\n      for (let k = 0; k < length; k++) {\n        abiParameters.push(\n          parseAbiParameter_(parameters[k]!, { modifiers, structs }),\n        )\n      }\n    }\n  }\n\n  if (abiParameters.length === 0)\n    throw new InvalidAbiParametersError({ params })\n\n  return abiParameters as ParseAbiParameters<params>\n}\n","import { InvalidDecimalNumberError } from '../../errors/unit.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\nexport type ParseUnitsErrorType = ErrorType\n\n/**\n * Multiplies a string representation of a number by a given exponent of base 10 (10exponent).\n *\n * - Docs: https://viem.sh/docs/utilities/parseUnits\n *\n * @example\n * import { parseUnits } from 'viem'\n *\n * parseUnits('420', 9)\n * // 420000000000n\n */\nexport function parseUnits(value: string, decimals: number) {\n  if (!/^(-?)([0-9]*)\\.?([0-9]*)$/.test(value))\n    throw new InvalidDecimalNumberError({ value })\n\n  let [integer, fraction = '0'] = value.split('.')\n\n  const negative = integer.startsWith('-')\n  if (negative) integer = integer.slice(1)\n\n  // trim trailing zeros.\n  fraction = fraction.replace(/(0+)$/, '')\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    if (Math.round(Number(`.${fraction}`)) === 1)\n      integer = `${BigInt(integer) + 1n}`\n    fraction = ''\n  } else if (fraction.length > decimals) {\n    const [left, unit, right] = [\n      fraction.slice(0, decimals - 1),\n      fraction.slice(decimals - 1, decimals),\n      fraction.slice(decimals),\n    ]\n\n    const rounded = Math.round(Number(`${unit}.${right}`))\n    if (rounded > 9)\n      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0')\n    else fraction = `${left}${rounded}`\n\n    if (fraction.length > decimals) {\n      fraction = fraction.slice(1)\n      integer = `${BigInt(integer) + 1n}`\n    }\n\n    fraction = fraction.slice(0, decimals)\n  } else {\n    fraction = fraction.padEnd(decimals, '0')\n  }\n\n  return BigInt(`${negative ? '-' : ''}${integer}${fraction}`)\n}\n","import type { AbiParameter } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiParameterError } from './errors/abiParameter.js'\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseAbiParameter as ParseAbiParameter_ } from './types/utils.js'\n\n/**\n * Parses human-readable ABI parameter into {@link AbiParameter}\n *\n * @param param - Human-readable ABI parameter\n * @returns Parsed {@link AbiParameter}\n *\n * @example\n * type Result = ParseAbiParameter<'address from'>\n * //   ^? type Result = { type: \"address\"; name: \"from\"; }\n *\n * @example\n * type Result = ParseAbiParameter<\n *   // ^? type Result = { type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   ['Baz bar', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiParameter<\n  param extends string | readonly string[] | readonly unknown[],\n> =\n  | (param extends string\n      ? param extends ''\n        ? never\n        : string extends param\n          ? AbiParameter\n          : ParseAbiParameter_<param, { modifier: Modifier }>\n      : never)\n  | (param extends readonly string[]\n      ? string[] extends param\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\n        : ParseStructs<param> extends infer structs\n          ? {\n              [key in keyof param]: param[key] extends string\n                ? IsStructSignature<param[key]> extends true\n                  ? never\n                  : ParseAbiParameter_<\n                      param[key],\n                      { modifier: Modifier; structs: structs }\n                    >\n                : never\n            } extends infer mapped extends readonly unknown[]\n            ? Filter<mapped, never>[0] extends infer result\n              ? result extends undefined\n                ? never\n                : result\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Parses human-readable ABI parameter into {@link AbiParameter}\n *\n * @param param - Human-readable ABI parameter\n * @returns Parsed {@link AbiParameter}\n *\n * @example\n * const abiParameter = parseAbiParameter('address from')\n * //    ^? const abiParameter: { type: \"address\"; name: \"from\"; }\n *\n * @example\n * const abiParameter = parseAbiParameter([\n *   //  ^? const abiParameter: { type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameter<\n  param extends string | readonly string[] | readonly unknown[],\n>(\n  param: Narrow<param> &\n    (\n      | (param extends string\n          ? param extends ''\n            ? Error<'Empty string is not allowed.'>\n            : unknown\n          : never)\n      | (param extends readonly string[]\n          ? param extends readonly [] // empty array\n            ? Error<'At least one parameter required.'>\n            : string[] extends param\n              ? unknown\n              : unknown // TODO: Validate param string\n          : never)\n    ),\n): ParseAbiParameter<param> {\n  let abiParameter: AbiParameter | undefined\n  if (typeof param === 'string')\n    abiParameter = parseAbiParameter_(param, {\n      modifiers,\n    }) as ParseAbiParameter<param>\n  else {\n    const structs = parseStructs(param as readonly string[])\n    const length = param.length as number\n    for (let i = 0; i < length; i++) {\n      const signature = (param as readonly string[])[i]!\n      if (isStructSignature(signature)) continue\n      abiParameter = parseAbiParameter_(signature, { modifiers, structs })\n      break\n    }\n  }\n\n  if (!abiParameter) throw new InvalidAbiParameterError({ param })\n\n  return abiParameter as ParseAbiParameter<param>\n}\n","import type { Abi } from 'abitype'\n\nimport {\n  AbiConstructorNotFoundError,\n  type AbiConstructorNotFoundErrorType,\n  AbiConstructorParamsNotFoundError,\n  type AbiConstructorParamsNotFoundErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ContractConstructorArgs } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\n\nconst docsPath = '/docs/contract/decodeDeployData'\n\nexport type DecodeDeployDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n> = {\n  abi: abi\n  bytecode: Hex\n  data: Hex\n}\n\nexport type DecodeDeployDataReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  ///\n  allArgs = ContractConstructorArgs<abi>,\n> = {\n  bytecode: Hex\n  args: allArgs\n}\n\nexport type DecodeDeployDataErrorType =\n  | AbiConstructorNotFoundErrorType\n  | AbiConstructorParamsNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | ErrorType\n\nexport function decodeDeployData<const abi extends Abi | readonly unknown[]>(\n  parameters: DecodeDeployDataParameters<abi>,\n): DecodeDeployDataReturnType<abi> {\n  const { abi, bytecode, data } = parameters as DecodeDeployDataParameters\n  if (data === bytecode) return { bytecode } as DecodeDeployDataReturnType<abi>\n\n  const description = abi.find((x) => 'type' in x && x.type === 'constructor')\n  if (!description) throw new AbiConstructorNotFoundError({ docsPath })\n  if (!('inputs' in description))\n    throw new AbiConstructorParamsNotFoundError({ docsPath })\n  if (!description.inputs || description.inputs.length === 0)\n    throw new AbiConstructorParamsNotFoundError({ docsPath })\n\n  const args = decodeAbiParameters(\n    description.inputs,\n    `0x${data.replace(bytecode, '')}`,\n  )\n  return { args, bytecode } as unknown as DecodeDeployDataReturnType<abi>\n}\n","import type { Address } from 'abitype'\n\nimport type * as BlockOverrides from 'ox/BlockOverrides'\nimport type * as Rpc from 'ox/RpcResponse'\nimport type {\n  RpcEstimateUserOperationGasReturnType,\n  RpcGetUserOperationByHashReturnType,\n  RpcUserOperation,\n  RpcUserOperationReceipt,\n} from '../account-abstraction/types/rpc.js'\nimport type { BlockTag } from './block.js'\nimport type { Capabilities, ChainIdToCapabilities } from './capabilities.js'\nimport type { Hash, Hex, LogTopic } from './misc.js'\nimport type {\n  RpcBlock as Block,\n  RpcBlockIdentifier as BlockIdentifier,\n  RpcBlockNumber as BlockNumber,\n  RpcFeeHistory as FeeHistory,\n  RpcLog as Log,\n  RpcProof as Proof,\n  Quantity,\n  RpcStateOverride,\n  RpcTransaction as Transaction,\n  RpcTransactionReceipt as TransactionReceipt,\n  RpcTransactionRequest as TransactionRequest,\n  RpcUncle as Uncle,\n} from './rpc.js'\nimport type { AccessList } from './transaction.js'\nimport type { ExactPartial, OneOf, PartialBy, Prettify } from './utils.js'\n\n//////////////////////////////////////////////////\n// Provider\n\nexport type EIP1474Methods = [\n  ...PublicRpcSchema,\n  ...WalletRpcSchema,\n  ...BundlerRpcSchema,\n  ...PaymasterRpcSchema,\n]\n\nexport type EIP1193Provider = Prettify<\n  EIP1193Events & {\n    request: EIP1193RequestFn<EIP1474Methods>\n  }\n>\n\n//////////////////////////////////////////////////\n// Errors\n\nexport type ProviderRpcErrorType = ProviderRpcError & {\n  name: 'ProviderRpcError'\n}\nexport class ProviderRpcError extends Error {\n  code: number\n  details: string\n\n  constructor(code: number, message: string) {\n    super(message)\n    this.code = code\n    this.details = message\n  }\n}\n\n//////////////////////////////////////////////////\n// Provider Events\n\nexport type ProviderConnectInfo = {\n  chainId: string\n}\n\nexport type ProviderMessage = {\n  type: string\n  data: unknown\n}\n\nexport type EIP1193EventMap = {\n  accountsChanged(accounts: Address[]): void\n  chainChanged(chainId: string): void\n  connect(connectInfo: ProviderConnectInfo): void\n  disconnect(error: ProviderRpcError): void\n  message(message: ProviderMessage): void\n}\n\nexport type EIP1193Events = {\n  on<event extends keyof EIP1193EventMap>(\n    event: event,\n    listener: EIP1193EventMap[event],\n  ): void\n  removeListener<event extends keyof EIP1193EventMap>(\n    event: event,\n    listener: EIP1193EventMap[event],\n  ): void\n}\n\n//////////////////////////////////////////////////\n// Provider Requests\n\nexport type AddEthereumChainParameter = {\n  /** A 0x-prefixed hexadecimal string */\n  chainId: string\n  /** The chain name. */\n  chainName: string\n  /** Native currency for the chain. */\n  nativeCurrency?:\n    | {\n        name: string\n        symbol: string\n        decimals: number\n      }\n    | undefined\n  rpcUrls: readonly string[]\n  blockExplorerUrls?: string[] | undefined\n  iconUrls?: string[] | undefined\n}\n\nexport type NetworkSync = {\n  /** The current block number */\n  currentBlock: Quantity\n  /** Number of latest block on the network */\n  highestBlock: Quantity\n  /** Block number at which syncing started */\n  startingBlock: Quantity\n}\n\nexport type WalletCallReceipt<quantity = Hex, status = Hex> = {\n  logs: {\n    address: Hex\n    data: Hex\n    topics: Hex[]\n  }[]\n  status: status\n  blockHash: Hex\n  blockNumber: quantity\n  gasUsed: quantity\n  transactionHash: Hex\n}\n\nexport type WalletGrantPermissionsParameters = {\n  signer?:\n    | {\n        type: string\n        data?: unknown | undefined\n      }\n    | undefined\n  permissions: readonly {\n    data: unknown\n    policies: readonly {\n      data: unknown\n      type: string\n    }[]\n    required?: boolean | undefined\n    type: string\n  }[]\n  expiry: number\n}\n\nexport type WalletGrantPermissionsReturnType = {\n  expiry: number\n  factory?: `0x${string}` | undefined\n  factoryData?: string | undefined\n  grantedPermissions: readonly {\n    data: unknown\n    policies: readonly {\n      data: unknown\n      type: string\n    }[]\n    required?: boolean | undefined\n    type: string\n  }[]\n  permissionsContext: string\n  signerData?:\n    | {\n        userOpBuilder?: `0x${string}` | undefined\n        submitToAddress?: `0x${string}` | undefined\n      }\n    | undefined\n}\n\nexport type WalletGetAssetsParameters = {\n  account: Address\n  assetFilter?:\n    | {\n        [chainId: Hex]: readonly {\n          address: Address\n          type: 'native' | 'erc20' | 'erc721' | (string & {})\n        }[]\n      }\n    | undefined\n  assetTypeFilter?:\n    | readonly ('native' | 'erc20' | 'erc721' | (string & {}))[]\n    | undefined\n  chainFilter?: readonly Hex[] | undefined\n}\n\nexport type WalletGetAssetsReturnType = {\n  [chainId: Hex]: readonly {\n    address: Address | 'native'\n    balance: Hex\n    metadata?: unknown | undefined\n    type: 'native' | 'erc20' | 'erc721' | (string & {})\n  }[]\n}\n\nexport type WalletGetCallsStatusReturnType<\n  capabilities extends Capabilities = Capabilities,\n  numberType = Hex,\n  bigintType = Hex,\n  receiptStatus = Hex,\n> = {\n  atomic: boolean\n  capabilities?: capabilities | Capabilities | undefined\n  chainId: numberType\n  id: string\n  receipts?: WalletCallReceipt<bigintType, receiptStatus>[] | undefined\n  status: number\n  version: string\n}\n\nexport type WalletPermissionCaveat = {\n  type: string\n  value: any\n}\n\nexport type WalletPermission = {\n  caveats: WalletPermissionCaveat[]\n  date: number\n  id: string\n  invoker: `http://${string}` | `https://${string}`\n  parentCapability: 'eth_accounts' | string\n}\n\nexport type WalletSendCallsParameters<\n  capabilities extends Capabilities = Capabilities,\n  chainId extends Hex | number = Hex,\n  quantity extends Quantity | bigint = Quantity,\n> = [\n  {\n    atomicRequired: boolean\n    calls: readonly {\n      capabilities?: capabilities | Capabilities | undefined\n      to?: Address | undefined\n      data?: Hex | undefined\n      value?: quantity | undefined\n    }[]\n    capabilities?: capabilities | Capabilities | undefined\n    chainId?: chainId | undefined\n    id?: string | undefined\n    from?: Address | undefined\n    version: string\n  },\n]\n\nexport type WalletSendCallsReturnType<\n  capabilities extends Capabilities = Capabilities,\n> = {\n  capabilities?: capabilities | undefined\n  id: string\n}\n\nexport type WatchAssetParams = {\n  /** Token type. */\n  type: 'ERC20'\n  options: {\n    /** The address of the token contract */\n    address: string\n    /** A ticker symbol or shorthand, up to 11 characters */\n    symbol: string\n    /** The number of token decimals */\n    decimals: number\n    /** A string url of the token logo */\n    image?: string | undefined\n  }\n}\n\nexport type BundlerRpcSchema = [\n  /**\n   * @description Returns the chain ID associated with the current network\n   *\n   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_chainid\n   */\n  {\n    Method: 'eth_chainId'\n    Parameters?: undefined\n    ReturnType: Hex\n  },\n  /**\n   * @description Estimate the gas values for a UserOperation.\n   *\n   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_estimateuseroperationgas\n   *\n   * @example\n   * provider.request({\n   *  method: 'eth_estimateUserOperationGas',\n   *  params: [{ ... }]\n   * })\n   * // => { ... }\n   */\n  {\n    Method: 'eth_estimateUserOperationGas'\n    Parameters:\n      | [userOperation: RpcUserOperation, entrypoint: Address]\n      | [\n          userOperation: RpcUserOperation,\n          entrypoint: Address,\n          stateOverrideSet: RpcStateOverride,\n        ]\n    ReturnType: RpcEstimateUserOperationGasReturnType\n  },\n  /**\n   * @description Return a UserOperation based on a hash.\n   *\n   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_getuseroperationbyhash\n   *\n   * @example\n   * provider.request({\n   *  method: 'eth_getUserOperationByHash',\n   *  params: ['0x...']\n   * })\n   * // => { ... }\n   */\n  {\n    Method: 'eth_getUserOperationByHash'\n    Parameters: [hash: Hash]\n    ReturnType: RpcGetUserOperationByHashReturnType | null\n  },\n  /**\n   * @description Return a UserOperation receipt based on a hash.\n   *\n   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_getuseroperationreceipt\n   *\n   * @example\n   * provider.request({\n   *  method: 'eth_getUserOperationReceipt',\n   *  params: ['0x...']\n   * })\n   * // => { ... }\n   */\n  {\n    Method: 'eth_getUserOperationReceipt'\n    Parameters: [hash: Hash]\n    ReturnType: RpcUserOperationReceipt | null\n  },\n  /**\n   * @description Submits a User Operation object to the User Operation pool of the client.\n   *\n   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_senduseroperation\n   *\n   * @example\n   * provider.request({\n   *  method: 'eth_sendUserOperation',\n   *  params: [{ ... }]\n   * })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_sendUserOperation'\n    Parameters: [userOperation: RpcUserOperation, entrypoint: Address]\n    ReturnType: Hash\n  },\n  /**\n   * @description Return the list of supported entry points by the client.\n   *\n   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_supportedentrypoints\n   */\n  {\n    Method: 'eth_supportedEntryPoints'\n    Parameters?: undefined\n    ReturnType: readonly Address[]\n  },\n]\n\nexport type DebugBundlerRpcSchema = [\n  /**\n   * @description Clears the bundler mempool and reputation data of paymasters/accounts/factories/aggregators.\n   *\n   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L1\n   */\n  {\n    Method: 'debug_bundler_clearState'\n    Parameters?: undefined\n    ReturnType: undefined\n  },\n  /**\n   * @description Returns the current mempool\n   *\n   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L8\n   */\n  {\n    Method: 'debug_bundler_dumpMempool'\n    Parameters: [entryPoint: Address]\n    ReturnType: readonly { userOp: RpcUserOperation }[]\n  },\n  /**\n   * @description Forces the bundler to execute the entire current mempool.\n   *\n   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L19\n   */\n  {\n    Method: 'debug_bundler_sendBundleNow'\n    Parameters?: undefined\n    ReturnType: Hash\n  },\n  /**\n   * @description Toggles bundling mode between 'auto' and 'manual'\n   *\n   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L26\n   */\n  {\n    Method: 'debug_bundler_setBundlingMode'\n    Parameters: [mode: 'auto' | 'manual']\n    ReturnType: undefined\n  },\n  /**\n   * @description Sets reputation of given addresses.\n   *\n   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L37\n   */\n  {\n    Method: 'debug_bundler_setReputation'\n    Parameters: [\n      reputations: readonly {\n        address: Address\n        opsSeen: Hex\n        opsIncluded: Hex\n      }[],\n      entryPoint: Address,\n    ]\n    ReturnType: undefined\n  },\n  /**\n   * @description Returns the reputation data of all observed addresses.\n   *\n   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L52\n   */\n  {\n    Method: 'debug_bundler_dumpReputation'\n    Parameters: [entryPoint: Address]\n    ReturnType: readonly {\n      address: Address\n      opsSeen: Hex\n      opsIncluded: Hex\n    }[]\n  },\n  /**\n   * @description Add a bulk of UserOps into the mempool\n   *\n   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L64\n   */\n  {\n    Method: 'debug_bundler_addUserOps'\n    Parameters: [userOps: readonly RpcUserOperation[], entryPoint: Address]\n    ReturnType: undefined\n  },\n]\n\nexport type PaymasterRpcSchema = [\n  /**\n   * @description Returns the chain ID associated with the current network\n   *\n   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_chainid\n   */\n  {\n    Method: 'pm_getPaymasterStubData'\n    Parameters?: [\n      userOperation: OneOf<\n        | PartialBy<\n            Pick<\n              RpcUserOperation<'0.6'>,\n              | 'callData'\n              | 'callGasLimit'\n              | 'initCode'\n              | 'maxFeePerGas'\n              | 'maxPriorityFeePerGas'\n              | 'nonce'\n              | 'sender'\n              | 'preVerificationGas'\n              | 'verificationGasLimit'\n            >,\n            | 'callGasLimit'\n            | 'initCode'\n            | 'maxFeePerGas'\n            | 'maxPriorityFeePerGas'\n            | 'preVerificationGas'\n            | 'verificationGasLimit'\n          >\n        | PartialBy<\n            Pick<\n              RpcUserOperation<'0.7'>,\n              | 'callData'\n              | 'callGasLimit'\n              | 'factory'\n              | 'factoryData'\n              | 'maxFeePerGas'\n              | 'maxPriorityFeePerGas'\n              | 'nonce'\n              | 'sender'\n              | 'preVerificationGas'\n              | 'verificationGasLimit'\n            >,\n            | 'callGasLimit'\n            | 'factory'\n            | 'factoryData'\n            | 'maxFeePerGas'\n            | 'maxPriorityFeePerGas'\n            | 'preVerificationGas'\n            | 'verificationGasLimit'\n          >\n      >,\n      entrypoint: Address,\n      chainId: Hex,\n      context: unknown,\n    ]\n    ReturnType: OneOf<\n      | { paymasterAndData: Hex }\n      | {\n          paymaster: Address\n          paymasterData: Hex\n          paymasterVerificationGasLimit: Hex\n          paymasterPostOpGasLimit: Hex\n        }\n    > & {\n      sponsor?: { name: string; icon?: string | undefined } | undefined\n      isFinal?: boolean | undefined\n    }\n  },\n  /**\n   * @description Returns values to be used in paymaster-related fields of a signed user operation.\n   *\n   * @link https://github.com/ethereum/ERCs/blob/master/ERCS/erc-7677.md#pm_getpaymasterdata\n   */\n  {\n    Method: 'pm_getPaymasterData'\n    Parameters?: [\n      userOperation:\n        | Pick<\n            RpcUserOperation<'0.6'>,\n            | 'callData'\n            | 'callGasLimit'\n            | 'initCode'\n            | 'maxFeePerGas'\n            | 'maxPriorityFeePerGas'\n            | 'nonce'\n            | 'sender'\n            | 'preVerificationGas'\n            | 'verificationGasLimit'\n          >\n        | Pick<\n            RpcUserOperation<'0.7'>,\n            | 'callData'\n            | 'callGasLimit'\n            | 'factory'\n            | 'factoryData'\n            | 'maxFeePerGas'\n            | 'maxPriorityFeePerGas'\n            | 'nonce'\n            | 'sender'\n            | 'preVerificationGas'\n            | 'verificationGasLimit'\n          >,\n      entrypoint: Address,\n      chainId: Hex,\n      context: unknown,\n    ]\n    ReturnType: OneOf<\n      | { paymasterAndData: Hex }\n      | {\n          paymaster: Address\n          paymasterData: Hex\n          paymasterVerificationGasLimit: Hex\n          paymasterPostOpGasLimit: Hex\n        }\n    >\n  },\n]\n\nexport type PublicRpcSchema = [\n  /**\n   * @description Returns the version of the current client\n   *\n   * @example\n   * provider.request({ method: 'web3_clientVersion' })\n   * // => 'MetaMask/v1.0.0'\n   */\n  {\n    Method: 'web3_clientVersion'\n    Parameters?: undefined\n    ReturnType: string\n  },\n  /**\n   * @description Hashes data using the Keccak-256 algorithm\n   *\n   * @example\n   * provider.request({ method: 'web3_sha3', params: ['0x68656c6c6f20776f726c64'] })\n   * // => '0xc94770007dda54cF92009BFF0dE90c06F603a09f'\n   */\n  {\n    Method: 'web3_sha3'\n    Parameters: [data: Hash]\n    ReturnType: string\n  },\n  /**\n   * @description Determines if this client is listening for new network connections\n   *\n   * @example\n   * provider.request({ method: 'net_listening' })\n   * // => true\n   */\n  {\n    Method: 'net_listening'\n    Parameters?: undefined\n    ReturnType: boolean\n  },\n  /**\n   * @description Returns the number of peers currently connected to this client\n   *\n   * @example\n   * provider.request({ method: 'net_peerCount' })\n   * // => '0x1'\n   */\n  {\n    Method: 'net_peerCount'\n    Parameters?: undefined\n    ReturnType: Quantity\n  },\n  /**\n   * @description Returns the chain ID associated with the current network\n   *\n   * @example\n   * provider.request({ method: 'net_version' })\n   * // => '1'\n   */\n  {\n    Method: 'net_version'\n    Parameters?: undefined\n    ReturnType: Quantity\n  },\n  /**\n   * @description Returns the base fee per blob gas in wei.\n   *\n   * @example\n   * provider.request({ method: 'eth_blobBaseFee' })\n   * // => '0x09184e72a000'\n   */\n  {\n    Method: 'eth_blobBaseFee'\n    Parameters?: undefined\n    ReturnType: Quantity\n  },\n  /**\n   * @description Returns the number of the most recent block seen by this client\n   *\n   * @example\n   * provider.request({ method: 'eth_blockNumber' })\n   * // => '0x1b4'\n   */\n  {\n    Method: 'eth_blockNumber'\n    Parameters?: undefined\n    ReturnType: Quantity\n  },\n  /**\n   * @description Executes a new message call immediately without submitting a transaction to the network\n   *\n   * @example\n   * provider.request({ method: 'eth_call', params: [{ to: '0x...', data: '0x...' }] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_call'\n    Parameters:\n      | readonly [transaction: ExactPartial<TransactionRequest>]\n      | readonly [\n          transaction: ExactPartial<TransactionRequest>,\n          block: BlockNumber | BlockTag | BlockIdentifier,\n        ]\n      | readonly [\n          transaction: ExactPartial<TransactionRequest>,\n          block: BlockNumber | BlockTag | BlockIdentifier,\n          stateOverrideSet: RpcStateOverride,\n        ]\n      | readonly [\n          transaction: ExactPartial<TransactionRequest>,\n          block: BlockNumber | BlockTag | BlockIdentifier,\n          stateOverrideSet: RpcStateOverride,\n          blockOverrides: BlockOverrides.Rpc,\n        ]\n    ReturnType: Hex\n  },\n  /**\n   * @description Creates an EIP-2930 access list that can be included in a transaction.\n   *\n   * @example\n   * provider.request({ method: 'eth_createAccessList', params: [{ to: '0x...', data: '0x...' }] })\n   * // => {\n   * //   accessList: ['0x...', '0x...'],\n   * //   gasUsed: '0x123',\n   * // }\n   */\n  {\n    Method: 'eth_createAccessList'\n    Parameters:\n      | [transaction: ExactPartial<TransactionRequest>]\n      | [\n          transaction: ExactPartial<TransactionRequest>,\n          block: BlockNumber | BlockTag | BlockIdentifier,\n        ]\n    ReturnType: {\n      accessList: AccessList\n      gasUsed: Quantity\n    }\n  },\n  /**\n   * @description Returns the chain ID associated with the current network\n   * @example\n   * provider.request({ method: 'eth_chainId' })\n   * // => '1'\n   */\n  {\n    Method: 'eth_chainId'\n    Parameters?: undefined\n    ReturnType: Quantity\n  },\n  /**\n   * @description Returns the client coinbase address.\n   * @example\n   * provider.request({ method: 'eth_coinbase' })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_coinbase'\n    Parameters?: undefined\n    ReturnType: Address\n  },\n  /**\n   * @description Estimates the gas necessary to complete a transaction without submitting it to the network\n   *\n   * @example\n   * provider.request({\n   *  method: 'eth_estimateGas',\n   *  params: [{ from: '0x...', to: '0x...', value: '0x...' }]\n   * })\n   * // => '0x5208'\n   */\n  {\n    Method: 'eth_estimateGas'\n    Parameters:\n      | [transaction: TransactionRequest]\n      | [transaction: TransactionRequest, block: BlockNumber | BlockTag]\n      | [\n          transaction: TransactionRequest,\n          block: BlockNumber | BlockTag,\n          stateOverride: RpcStateOverride,\n        ]\n    ReturnType: Quantity\n  },\n  /**\n   * @description Fills a transaction with the necessary data to be signed.\n   *\n   * @example\n   * provider.request({ method: 'eth_fillTransaction', params: [{ from: '0x...', to: '0x...', value: '0x...' }] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_fillTransaction'\n    Parameters: [transaction: TransactionRequest]\n    ReturnType: {\n      raw: Hex\n      tx: Transaction\n    }\n  },\n  /**\n   * @description Returns a collection of historical gas information\n   *\n   * @example\n   * provider.request({\n   *  method: 'eth_feeHistory',\n   *  params: ['4', 'latest', ['25', '75']]\n   * })\n   * // => {\n   * //   oldestBlock: '0x1',\n   * //   baseFeePerGas: ['0x1', '0x2', '0x3', '0x4'],\n   * //   gasUsedRatio: ['0x1', '0x2', '0x3', '0x4'],\n   * //   reward: [['0x1', '0x2'], ['0x3', '0x4'], ['0x5', '0x6'], ['0x7', '0x8']]\n   * // }\n   * */\n  {\n    Method: 'eth_feeHistory'\n    Parameters: [\n      /** Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available. */\n      blockCount: Quantity,\n      /** Highest number block of the requested range. */\n      newestBlock: BlockNumber | BlockTag,\n      /** A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used. */\n      rewardPercentiles: number[] | undefined,\n    ]\n    ReturnType: FeeHistory\n  },\n  /**\n   * @description Returns the current price of gas expressed in wei\n   *\n   * @example\n   * provider.request({ method: 'eth_gasPrice' })\n   * // => '0x09184e72a000'\n   */\n  {\n    Method: 'eth_gasPrice'\n    Parameters?: undefined\n    ReturnType: Quantity\n  },\n  /**\n   * @description Returns the balance of an address in wei\n   *\n   * @example\n   * provider.request({ method: 'eth_getBalance', params: ['0x...', 'latest'] })\n   * // => '0x12a05...'\n   */\n  {\n    Method: 'eth_getBalance'\n    Parameters: [\n      address: Address,\n      block: BlockNumber | BlockTag | BlockIdentifier,\n    ]\n    ReturnType: Quantity\n  },\n  /**\n   * @description Returns information about a block specified by hash\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getBlockByHash', params: ['0x...', true] })\n   * // => {\n   * //   number: '0x1b4',\n   * //   hash: '0x...',\n   * //   parentHash: '0x...',\n   * //   ...\n   * // }\n   */\n  {\n    Method: 'eth_getBlockByHash'\n    Parameters: [\n      /** hash of a block */\n      hash: Hash,\n      /** true will pull full transaction objects, false will pull transaction hashes */\n      includeTransactionObjects: boolean,\n    ]\n    ReturnType: Block | null\n  },\n  /**\n   * @description Returns information about a block specified by number\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getBlockByNumber', params: ['0x1b4', true] })\n   * // => {\n   * //   number: '0x1b4',\n   * //   hash: '0x...',\n   * //   parentHash: '0x...',\n   * //   ...\n   * // }\n   */\n  {\n    Method: 'eth_getBlockByNumber'\n    Parameters: [\n      /** block number, or one of \"latest\", \"safe\", \"finalized\", \"earliest\" or \"pending\" */\n      block: BlockNumber | BlockTag,\n      /** true will pull full transaction objects, false will pull transaction hashes */\n      includeTransactionObjects: boolean,\n    ]\n    ReturnType: Block | null\n  },\n  /**\n   * @description Returns the number of transactions in a block specified by block hash\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getBlockTransactionCountByHash', params: ['0x...'] })\n   * // => '0x1'\n   */\n  {\n    Method: 'eth_getBlockTransactionCountByHash'\n    Parameters: [hash: Hash]\n    ReturnType: Quantity\n  },\n  /**\n   * @description Returns the number of transactions in a block specified by block number\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getBlockTransactionCountByNumber', params: ['0x1b4'] })\n   * // => '0x1'\n   */\n  {\n    Method: 'eth_getBlockTransactionCountByNumber'\n    Parameters: [block: BlockNumber | BlockTag]\n    ReturnType: Quantity\n  },\n  /**\n   * @description Returns the contract code stored at a given address\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getCode', params: ['0x...', 'latest'] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_getCode'\n    Parameters: [\n      address: Address,\n      block: BlockNumber | BlockTag | BlockIdentifier,\n    ]\n    ReturnType: Hex\n  },\n  /**\n   * @description Returns a list of all logs based on filter ID since the last log retrieval\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getFilterChanges', params: ['0x...'] })\n   * // => [{ ... }, { ... }]\n   */\n  {\n    Method: 'eth_getFilterChanges'\n    Parameters: [filterId: Quantity]\n    ReturnType: Log[] | Hex[]\n  },\n  /**\n   * @description Returns a list of all logs based on filter ID\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getFilterLogs', params: ['0x...'] })\n   * // => [{ ... }, { ... }]\n   */\n  {\n    Method: 'eth_getFilterLogs'\n    Parameters: [filterId: Quantity]\n    ReturnType: Log[]\n  },\n  /**\n   * @description Returns a list of all logs based on a filter object\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getLogs', params: [{ fromBlock: '0x...', toBlock: '0x...', address: '0x...', topics: ['0x...'] }] })\n   * // => [{ ... }, { ... }]\n   */\n  {\n    Method: 'eth_getLogs'\n    Parameters: [\n      {\n        address?: Address | Address[] | undefined\n        topics?: LogTopic[] | undefined\n      } & (\n        | {\n            fromBlock?: BlockNumber | BlockTag | undefined\n            toBlock?: BlockNumber | BlockTag | undefined\n            blockHash?: undefined\n          }\n        | {\n            fromBlock?: undefined\n            toBlock?: undefined\n            blockHash?: Hash | undefined\n          }\n      ),\n    ]\n    ReturnType: Log[]\n  },\n  /**\n   * @description Returns the account and storage values of the specified account including the Merkle-proof.\n   * @link https://eips.ethereum.org/EIPS/eip-1186\n   * @example\n   * provider.request({ method: 'eth_getProof', params: ['0x...', ['0x...'], 'latest'] })\n   * // => {\n   * //   ...\n   * // }\n   */\n  {\n    Method: 'eth_getProof'\n    Parameters: [\n      /** Address of the account. */\n      address: Address,\n      /** An array of storage-keys that should be proofed and included. */\n      storageKeys: Hash[],\n      block: BlockNumber | BlockTag,\n    ]\n    ReturnType: Proof\n  },\n  /**\n   * @description Returns the value from a storage position at an address\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getStorageAt', params: ['0x...', '0x...', 'latest'] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_getStorageAt'\n    Parameters: [\n      address: Address,\n      index: Quantity,\n      block: BlockNumber | BlockTag | BlockIdentifier,\n    ]\n    ReturnType: Hex\n  },\n  /**\n   * @description Returns information about a transaction specified by block hash and transaction index\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getTransactionByBlockHashAndIndex', params: ['0x...', '0x...'] })\n   * // => { ... }\n   */\n  {\n    Method: 'eth_getTransactionByBlockHashAndIndex'\n    Parameters: [hash: Hash, index: Quantity]\n    ReturnType: Transaction | null\n  },\n  /**\n   * @description Returns information about a transaction specified by block number and transaction index\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getTransactionByBlockNumberAndIndex', params: ['0x...', '0x...'] })\n   * // => { ... }\n   */\n  {\n    Method: 'eth_getTransactionByBlockNumberAndIndex'\n    Parameters: [block: BlockNumber | BlockTag, index: Quantity]\n    ReturnType: Transaction | null\n  },\n  /**\n   * @description Returns information about a transaction specified by hash\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getTransactionByHash', params: ['0x...'] })\n   * // => { ... }\n   */\n  {\n    Method: 'eth_getTransactionByHash'\n    Parameters: [hash: Hash]\n    ReturnType: Transaction | null\n  },\n  /**\n   * @description Returns information about a transaction specified by sender and nonce\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getTransactionBySenderAndNonce', params: ['0x...', '0x...'] })\n   * // => { ... }\n   */\n  {\n    Method: 'eth_getTransactionBySenderAndNonce'\n    Parameters: [sender: Address, nonce: Quantity]\n    ReturnType: Transaction | null\n  },\n  /**\n   * @description Returns the number of transactions sent from an address\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getTransactionCount', params: ['0x...', 'latest'] })\n   * // => '0x1'\n   */\n  {\n    Method: 'eth_getTransactionCount'\n    Parameters: [\n      address: Address,\n      block: BlockNumber | BlockTag | BlockIdentifier,\n    ]\n    ReturnType: Quantity\n  },\n  /**\n   * @description Returns the receipt of a transaction specified by hash\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getTransactionReceipt', params: ['0x...'] })\n   * // => { ... }\n   */\n  {\n    Method: 'eth_getTransactionReceipt'\n    Parameters: [hash: Hash]\n    ReturnType: TransactionReceipt | null\n  },\n  /**\n   * @description Returns information about an uncle specified by block hash and uncle index position\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getUncleByBlockHashAndIndex', params: ['0x...', '0x...'] })\n   * // => { ... }\n   */\n  {\n    Method: 'eth_getUncleByBlockHashAndIndex'\n    Parameters: [hash: Hash, index: Quantity]\n    ReturnType: Uncle | null\n  },\n  /**\n   * @description Returns information about an uncle specified by block number and uncle index position\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getUncleByBlockNumberAndIndex', params: ['0x...', '0x...'] })\n   * // => { ... }\n   */\n  {\n    Method: 'eth_getUncleByBlockNumberAndIndex'\n    Parameters: [block: BlockNumber | BlockTag, index: Quantity]\n    ReturnType: Uncle | null\n  },\n  /**\n   * @description Returns the number of uncles in a block specified by block hash\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getUncleCountByBlockHash', params: ['0x...'] })\n   * // => '0x1'\n   */\n  {\n    Method: 'eth_getUncleCountByBlockHash'\n    Parameters: [hash: Hash]\n    ReturnType: Quantity\n  },\n  /**\n   * @description Returns the number of uncles in a block specified by block number\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_getUncleCountByBlockNumber', params: ['0x...'] })\n   * // => '0x1'\n   */\n  {\n    Method: 'eth_getUncleCountByBlockNumber'\n    Parameters: [block: BlockNumber | BlockTag]\n    ReturnType: Quantity\n  },\n  /**\n   * @description Returns the current maxPriorityFeePerGas in wei.\n   * @link https://ethereum.github.io/execution-apis/api-documentation/\n   * @example\n   * provider.request({ method: 'eth_maxPriorityFeePerGas' })\n   * // => '0x5f5e100'\n   */\n  {\n    Method: 'eth_maxPriorityFeePerGas'\n    Parameters?: undefined\n    ReturnType: Quantity\n  },\n  /**\n   * @description Creates a filter to listen for new blocks that can be used with `eth_getFilterChanges`\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_newBlockFilter' })\n   * // => '0x1'\n   */\n  {\n    Method: 'eth_newBlockFilter'\n    Parameters?: undefined\n    ReturnType: Quantity\n  },\n  /**\n   * @description Creates a filter to listen for specific state changes that can then be used with `eth_getFilterChanges`\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_newFilter', params: [{ fromBlock: '0x...', toBlock: '0x...', address: '0x...', topics: ['0x...'] }] })\n   * // => '0x1'\n   */\n  {\n    Method: 'eth_newFilter'\n    Parameters: [\n      filter: {\n        fromBlock?: BlockNumber | BlockTag | undefined\n        toBlock?: BlockNumber | BlockTag | undefined\n        address?: Address | Address[] | undefined\n        topics?: LogTopic[] | undefined\n      },\n    ]\n    ReturnType: Quantity\n  },\n  /**\n   * @description Creates a filter to listen for new pending transactions that can be used with `eth_getFilterChanges`\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_newPendingTransactionFilter' })\n   * // => '0x1'\n   */\n  {\n    Method: 'eth_newPendingTransactionFilter'\n    Parameters?: undefined\n    ReturnType: Quantity\n  },\n  /**\n   * @description Returns the current Ethereum protocol version\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_protocolVersion' })\n   * // => '54'\n   */\n  {\n    Method: 'eth_protocolVersion'\n    Parameters?: undefined\n    ReturnType: string\n  },\n  /**\n   * @description Sends a **signed** transaction to the network\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_sendRawTransaction', params: ['0x...'] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_sendRawTransaction'\n    Parameters: [signedTransaction: Hex]\n    ReturnType: Hash\n  },\n  /**\n   * @description Sends a **signed** transaction to the network synchronously\n   * @link https://eips.ethereum.org/EIPS/eip-7966\n   * @example\n   * provider.request({ method: 'eth_sendRawTransactionSync', params: ['0x...'] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_sendRawTransactionSync'\n    Parameters:\n      | [signedTransaction: Hex]\n      | [signedTransaction: Hex, timeout: Hex]\n    ReturnType: TransactionReceipt\n  },\n  /**\n   * @description Simulates execution of a set of calls with optional block and state overrides.\n   * @example\n   * provider.request({ method: 'eth_simulateV1', params: [{ blockStateCalls: [{ calls: [{ from: '0x...', to: '0x...', value: '0x...', data: '0x...' }] }] }, 'latest'] })\n   * // => { ... }\n   */\n  {\n    Method: 'eth_simulateV1'\n    Parameters: [\n      {\n        blockStateCalls: readonly {\n          blockOverrides?: BlockOverrides.Rpc | undefined\n          calls?: readonly ExactPartial<TransactionRequest>[] | undefined\n          stateOverrides?: RpcStateOverride | undefined\n        }[]\n        returnFullTransactions?: boolean | undefined\n        traceTransfers?: boolean | undefined\n        validation?: boolean | undefined\n      },\n      BlockNumber | BlockTag,\n    ]\n    ReturnType: readonly (Block & {\n      calls: readonly {\n        error?:\n          | {\n              data?: Hex | undefined\n              code: number\n              message: string\n            }\n          | undefined\n        logs?: readonly Log[] | undefined\n        gasUsed: Hex\n        returnData: Hex\n        status: Hex\n      }[]\n    })[]\n  },\n  /**\n   * @description Destroys a filter based on filter ID\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_uninstallFilter', params: ['0x1'] })\n   * // => true\n   */\n  {\n    Method: 'eth_uninstallFilter'\n    Parameters: [filterId: Quantity]\n    ReturnType: boolean\n  },\n]\n\nexport type TestRpcSchema<mode extends string> = [\n  /**\n   * @description Add information about compiled contracts\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_addcompilationresult\n   */\n  {\n    Method: `${mode}_addCompilationResult`\n    Parameters: any[]\n    ReturnType: any\n  },\n  /**\n   * @description Remove a transaction from the mempool\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_droptransaction\n   */\n  {\n    Method: `${mode}_dropTransaction`\n    Parameters: [hash: Hash]\n    ReturnType: void\n  },\n  /**\n   * @description Serializes the current state (including contracts code, contract's storage, accounts properties, etc.) into a savable data blob.\n   */\n  {\n    Method: `${mode}_dumpState`\n    Parameters?: undefined\n    ReturnType: Hex\n  },\n  /**\n   * @description Turn on call traces for transactions that are returned to the user when they execute a transaction (instead of just txhash/receipt).\n   */\n  {\n    Method: `${mode}_enableTraces`\n    Parameters?: undefined\n    ReturnType: void\n  },\n  /**\n   * @description Impersonate an account or contract address.\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_impersonateaccount\n   */\n  {\n    Method: `${mode}_impersonateAccount`\n    Parameters: [address: Address]\n    ReturnType: void\n  },\n  /**\n   * @description Returns true if automatic mining is enabled, and false otherwise. See [Mining Modes](https://hardhat.org/hardhat-network/explanation/mining-modes) to learn more.\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_getautomine\n   */\n  {\n    Method: `${mode}_getAutomine`\n    Parameters?: undefined\n    ReturnType: boolean\n  },\n  /**\n   * @description Adds state previously dumped with `dumpState` to the current chain.\n   */\n  {\n    Method: `${mode}_loadState`\n    Parameters?: [Hex] | undefined\n    ReturnType: void\n  },\n  /**\n   * @description Advance the block number of the network by a certain number of blocks\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_mine\n   */\n  {\n    Method: `${mode}_mine`\n    Parameters: [\n      /** Number of blocks to mine. */\n      count: Hex,\n      /** Interval between each block in seconds. */\n      interval: Hex | undefined,\n    ]\n    ReturnType: void\n  },\n  /**\n   * @description Resets the fork.\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_reset\n   */\n  {\n    Method: `${mode}_reset`\n    Parameters: any[]\n    ReturnType: void\n  },\n  /**\n   * @description Modifies the balance of an account.\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setbalance\n   */\n  {\n    Method: `${mode}_setBalance`\n    Parameters: [\n      /** The address of the target account. */\n      address: Address,\n      /** Amount to send in wei. */\n      balance: Quantity,\n    ]\n    ReturnType: void\n  },\n  /**\n   * @description Modifies the bytecode stored at an account's address.\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setcode\n   */\n  {\n    Method: `${mode}_setCode`\n    Parameters: [\n      /** The address of the contract. */\n      address: Address,\n      /** Data bytecode. */\n      data: string,\n    ]\n    ReturnType: void\n  },\n  /**\n   * @description Sets the coinbase address to be used in new blocks.\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setcoinbase\n   */\n  {\n    Method: `${mode}_setCoinbase`\n    Parameters: [\n      /** The address to set as the coinbase address. */\n      address: Address,\n    ]\n    ReturnType: void\n  },\n  /**\n   * @description Enable or disable logging on the test node network.\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setcoinbase\n   */\n  {\n    Method: `${mode}_setLoggingEnabled`\n    Parameters: [enabled: boolean]\n    ReturnType: void\n  },\n  /**\n   * @description Change the minimum gas price accepted by the network (in wei).\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setmingasprice\n   */\n  {\n    Method: `${mode}_setMinGasPrice`\n    Parameters: [gasPrice: Quantity]\n    ReturnType: void\n  },\n  /**\n   * @description Sets the base fee of the next block.\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setnextblockbasefeepergas\n   */\n  {\n    Method: `${mode}_setNextBlockBaseFeePerGas`\n    Parameters: [baseFeePerGas: Quantity]\n    ReturnType: void\n  },\n  /**\n   * @description Modifies an account's nonce by overwriting it.\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setnonce\n   */\n  {\n    Method: `${mode}_setNonce`\n    Parameters: [\n      /** The account address. */\n      address: Address,\n      /** The new nonce. */\n      nonce: Quantity,\n    ]\n    ReturnType: void\n  },\n  /**\n   * @description Sets the backend RPC URL.\n   */\n  {\n    Method: `${mode}_setRpcUrl`\n    Parameters: [url: string]\n    ReturnType: void\n  },\n  /**\n   * @description Writes a single position of an account's storage.\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setstorageat\n   */\n  {\n    Method: `${mode}_setStorageAt`\n    Parameters: [\n      /** The account address. */\n      address: Address,\n      /** The storage position index. */\n      index: Quantity,\n      /** The storage value. */\n      value: Quantity,\n    ]\n    ReturnType: void\n  },\n  /**\n   * @description Use this method to stop impersonating an account after having previously used impersonateAccount.\n   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_stopimpersonatingaccount\n   */\n  {\n    Method: `${mode}_stopImpersonatingAccount`\n    Parameters: [\n      /** The address to stop impersonating. */\n      address: Address,\n    ]\n    ReturnType: void\n  },\n  /**\n   * @description Jump forward in time by the given amount of time, in seconds.\n   * @link https://github.com/trufflesuite/ganache/blob/ef1858d5d6f27e4baeb75cccd57fb3dc77a45ae8/src/chains/ethereum/ethereum/RPC-METHODS.md#evm_increasetime\n   */\n  {\n    Method: `${mode}_increaseTime`\n    Parameters: [seconds: number]\n    ReturnType: Quantity\n  },\n  /**\n   * @description Modifies the balance of an account.\n   * @link https://ganache.dev/#evm_setAccountBalance\n   */\n  {\n    Method: 'evm_setAccountBalance'\n    Parameters: [\n      /** The address of the target account. */\n      address: Address,\n      /** Amount to send in wei. */\n      value: Quantity,\n    ]\n    ReturnType: void\n  },\n  /**\n   * @description Modifies the bytecode stored at an account's address.\n   * @link https://ganache.dev/#evm_setAccountCode\n   */\n  {\n    Method: 'evm_setAccountCode'\n    Parameters: [\n      /** The address of the contract. */\n      address: Address,\n      /** Data bytecode. */\n      data: string,\n    ]\n    ReturnType: void\n  },\n  /**\n   * @description Enables or disables, based on the single boolean argument, the automatic mining of new blocks with each new transaction submitted to the network.\n   * @link https://hardhat.org/hardhat-network/docs/reference#evm_setautomine\n   */\n  {\n    Method: 'evm_setAutomine'\n    Parameters: [boolean]\n    ReturnType: void\n  },\n  /**\n   * @description Sets the block's gas limit.\n   * @link https://hardhat.org/hardhat-network/docs/reference#evm_setblockgaslimit\n   */\n  {\n    Method: 'evm_setBlockGasLimit'\n    Parameters: [gasLimit: Quantity]\n    ReturnType: void\n  },\n  /**\n   * @description Jump forward in time by the given amount of time, in seconds.\n   * @link https://github.com/trufflesuite/ganache/blob/ef1858d5d6f27e4baeb75cccd57fb3dc77a45ae8/src/chains/ethereum/ethereum/RPC-METHODS.md#evm_increasetime\n   */\n  {\n    Method: 'evm_increaseTime'\n    Parameters: [seconds: Quantity]\n    ReturnType: Quantity\n  },\n  /**\n   * @description Similar to `evm_increaseTime` but sets a block timestamp `interval`.\n   * The timestamp of the next block will be computed as `lastBlock_timestamp` + `interval`\n   */\n  {\n    Method: `${mode}_setBlockTimestampInterval`\n    Parameters: [seconds: number]\n    ReturnType: void\n  },\n  /**\n   * @description Removes `setBlockTimestampInterval` if it exists\n   */\n  {\n    Method: `${mode}_removeBlockTimestampInterval`\n    Parameters?: undefined\n    ReturnType: void\n  },\n  /**\n   * @description Enables (with a numeric argument greater than 0) or disables (with a numeric argument equal to 0), the automatic mining of blocks at a regular interval of milliseconds, each of which will include all pending transactions.\n   * @link https://hardhat.org/hardhat-network/docs/reference#evm_setintervalmining\n   */\n  {\n    Method: 'evm_setIntervalMining'\n    Parameters: [number]\n    ReturnType: void\n  },\n  /**\n   * @description Set the timestamp of the next block.\n   * @link https://hardhat.org/hardhat-network/docs/reference#evm_setnextblocktimestamp\n   */\n  {\n    Method: 'evm_setNextBlockTimestamp'\n    Parameters: [Quantity]\n    ReturnType: void\n  },\n  /**\n   * @description Snapshot the state of the blockchain at the current block. Takes no parameters. Returns the id of the snapshot that was created.\n   * @link https://hardhat.org/hardhat-network/docs/reference#evm_snapshot\n   */\n  {\n    Method: 'evm_snapshot'\n    Parameters?: undefined\n    ReturnType: Quantity\n  },\n  /**\n   * @description Revert the state of the blockchain to a previous snapshot. Takes a single parameter, which is the snapshot id to revert to.\n   */\n  {\n    Method: 'evm_revert'\n    Parameters?: [id: Quantity] | undefined\n    ReturnType: void\n  },\n  /**\n   * @description Enables the automatic mining of new blocks with each new transaction submitted to the network.\n   * @link https://ganache.dev/#miner_start\n   */\n  {\n    Method: 'miner_start'\n    Parameters?: undefined\n    ReturnType: void\n  },\n  /**\n   * @description Disables the automatic mining of new blocks with each new transaction submitted to the network.\n   * @link https://ganache.dev/#miner_stop\n   */\n  {\n    Method: 'miner_stop'\n    Parameters?: undefined\n    ReturnType: void\n  },\n  /**\n   * @link https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-txpool#txpool-content\n   */\n  {\n    Method: 'txpool_content'\n    Parameters?: undefined\n    ReturnType: {\n      pending: Record<Address, Record<string, Transaction>>\n      queued: Record<Address, Record<string, Transaction>>\n    }\n  },\n  /**\n   * @link https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-txpool#txpool-inspect\n   */\n  {\n    Method: 'txpool_inspect'\n    Parameters?: undefined\n    ReturnType: {\n      pending: Record<Address, Record<string, string>>\n      queued: Record<Address, Record<string, string>>\n    }\n  },\n  /**\n   * @link https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-txpool#txpool-inspect\n   */\n  {\n    Method: 'txpool_status'\n    Parameters?: undefined\n    ReturnType: {\n      pending: Quantity\n      queued: Quantity\n    }\n  },\n  /**\n   * @description Returns whether the client is actively mining new blocks.\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_mining' })\n   * // => true\n   */\n  {\n    Method: 'eth_mining'\n    Parameters?: undefined\n    ReturnType: boolean\n  },\n  /**\n   * @description Advance the block number of the network by a certain number of blocks.\n   * @link https://ganache.dev/#evm_mine\n   */\n  {\n    Method: 'evm_mine'\n    Parameters?:\n      | [\n          {\n            /** Number of blocks to mine. */\n            blocks: Hex\n          },\n        ]\n      | undefined\n    ReturnType: void\n  },\n  /**\n   * @description Creates, signs, and sends a new transaction to the network regardless of the signature.\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_sendTransaction', params: [{ from: '0x...', to: '0x...', value: '0x...' }] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_sendUnsignedTransaction'\n    Parameters: [transaction: TransactionRequest]\n    ReturnType: Hash\n  },\n]\n\nexport type WalletRpcSchema = [\n  /**\n   * @description Returns a list of addresses owned by this client\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_accounts' })\n   * // => ['0x0fB69...']\n   */\n  {\n    Method: 'eth_accounts'\n    Parameters?: undefined\n    ReturnType: Address[]\n  },\n  /**\n   * @description Returns the current chain ID associated with the wallet.\n   * @example\n   * provider.request({ method: 'eth_chainId' })\n   * // => '1'\n   */\n  {\n    Method: 'eth_chainId'\n    Parameters?: undefined\n    ReturnType: Quantity\n  },\n  /**\n   * @description Estimates the gas necessary to complete a transaction without submitting it to the network\n   *\n   * @example\n   * provider.request({\n   *  method: 'eth_estimateGas',\n   *  params: [{ from: '0x...', to: '0x...', value: '0x...' }]\n   * })\n   * // => '0x5208'\n   */\n  {\n    Method: 'eth_estimateGas'\n    Parameters:\n      | [transaction: TransactionRequest]\n      | [transaction: TransactionRequest, block: BlockNumber | BlockTag]\n      | [\n          transaction: TransactionRequest,\n          block: BlockNumber | BlockTag,\n          stateOverride: RpcStateOverride,\n        ]\n    ReturnType: Quantity\n  },\n  /**\n   * @description Fills a transaction with the necessary data to be signed.\n   *\n   * @example\n   * provider.request({ method: 'eth_fillTransaction', params: [{ from: '0x...', to: '0x...', value: '0x...' }] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_fillTransaction'\n    Parameters: [transaction: TransactionRequest]\n    ReturnType: {\n      raw: Hex\n      tx: Transaction\n    }\n  },\n  /**\n   * @description Requests that the user provides an Ethereum address to be identified by. Typically causes a browser extension popup to appear.\n   * @link https://eips.ethereum.org/EIPS/eip-1102\n   * @example\n   * provider.request({ method: 'eth_requestAccounts' }] })\n   * // => ['0x...', '0x...']\n   */\n  {\n    Method: 'eth_requestAccounts'\n    Parameters?: undefined\n    ReturnType: Address[]\n  },\n  /**\n   * @description Creates, signs, and sends a new transaction to the network\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_sendTransaction', params: [{ from: '0x...', to: '0x...', value: '0x...' }] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_sendTransaction'\n    Parameters: [transaction: TransactionRequest]\n    ReturnType: Hash\n  },\n  /**\n   * @description Sends and already-signed transaction to the network\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_sendRawTransaction', params: ['0x...'] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_sendRawTransaction'\n    Parameters: [signedTransaction: Hex]\n    ReturnType: Hash\n  },\n  /**\n   * @description Sends and already-signed transaction to the network synchronously\n   * @link https://eips.ethereum.org/EIPS/eip-7966\n   * @example\n   * provider.request({ method: 'eth_sendRawTransactionSync', params: ['0x...'] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_sendRawTransactionSync'\n    Parameters:\n      | [signedTransaction: Hex]\n      | [signedTransaction: Hex, timeout: Hex]\n    ReturnType: TransactionReceipt\n  },\n  /**\n   * @description Calculates an Ethereum-specific signature in the form of `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_sign', params: ['0x...', '0x...'] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_sign'\n    Parameters: [\n      /** Address to use for signing */\n      address: Address,\n      /** Data to sign */\n      data: Hex,\n    ]\n    ReturnType: Hex\n  },\n  /**\n   * @description Signs a transaction that can be submitted to the network at a later time using with `eth_sendRawTransaction`\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_signTransaction', params: [{ from: '0x...', to: '0x...', value: '0x...' }] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_signTransaction'\n    Parameters: [request: TransactionRequest]\n    ReturnType: Hex\n  },\n  /**\n   * @description Calculates an Ethereum-specific signature in the form of `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_signTypedData_v4', params: [{ from: '0x...', data: [{ type: 'string', name: 'message', value: 'hello world' }] }] })\n   * // => '0x...'\n   */\n  {\n    Method: 'eth_signTypedData_v4'\n    Parameters: [\n      /** Address to use for signing */\n      address: Address,\n      /** Message to sign containing type information, a domain separator, and data */\n      message: string,\n    ]\n    ReturnType: Hex\n  },\n  /**\n   * @description Returns information about the status of this clientâ€™s network synchronization\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'eth_syncing' })\n   * // => { startingBlock: '0x...', currentBlock: '0x...', highestBlock: '0x...' }\n   */\n  {\n    Method: 'eth_syncing'\n    Parameters?: undefined\n    ReturnType: NetworkSync | false\n  },\n  /**\n   * @description Calculates an Ethereum-specific signature in the form of `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'personal_sign', params: ['0x...', '0x...'] })\n   * // => '0x...'\n   */\n  {\n    Method: 'personal_sign'\n    Parameters: [\n      /** Data to sign */\n      data: Hex,\n      /** Address to use for signing */\n      address: Address,\n    ]\n    ReturnType: Hex\n  },\n  /**\n   * @description Add an Ethereum chain to the wallet.\n   * @link https://eips.ethereum.org/EIPS/eip-3085\n   * @example\n   * provider.request({ method: 'wallet_addEthereumChain', params: [{ chainId: 1, rpcUrl: 'https://mainnet.infura.io/v3/...' }] })\n   * // => { ... }\n   */\n  {\n    Method: 'wallet_addEthereumChain'\n    Parameters: [chain: AddEthereumChainParameter]\n    ReturnType: null\n  },\n  /**\n   *\n   */\n  {\n    Method: 'wallet_addSubAccount'\n    Parameters: [\n      {\n        account: OneOf<\n          | {\n              keys: readonly {\n                publicKey: Hex\n                type: 'address' | 'p256' | 'webcrypto-p256' | 'webauthn-p256'\n              }[]\n              type: 'create'\n            }\n          | {\n              address: Address\n              chainId?: number | undefined\n              type: 'deployed'\n            }\n          | {\n              address: Address\n              chainId?: number | undefined\n              factory: Address\n              factoryData: Hex\n              type: 'undeployed'\n            }\n        >\n        version: string\n      },\n    ]\n    ReturnType: {\n      address: Address\n      factory?: Address | undefined\n      factoryData?: Hex | undefined\n    }\n  },\n  /**\n   * @description Requests to connect account(s).\n   * @link https://github.com/ethereum/ERCs/blob/abd1c9f4eda2d6ad06ade0e3af314637a27d1ee7/ERCS/erc-7846.md\n   * @example\n   * provider.request({ method: 'wallet_connect' })\n   * // => { ... }\n   */\n  {\n    Method: 'wallet_connect'\n    Parameters: [\n      {\n        capabilities?: Capabilities | undefined\n        version: string\n      },\n    ]\n    ReturnType: {\n      accounts: readonly {\n        address: Address\n        capabilities?: Capabilities | undefined\n      }[]\n    }\n  },\n  /**\n   * @description Disconnects connected account(s).\n   * @link https://github.com/ethereum/ERCs/blob/abd1c9f4eda2d6ad06ade0e3af314637a27d1ee7/ERCS/erc-7846.md\n   * @example\n   * provider.request({ method: 'wallet_disconnect' })\n   */\n  {\n    Method: 'wallet_disconnect'\n    Parameters?: undefined\n    ReturnType: void\n  },\n  /**\n   * @description Returns the assets owned by the wallet.\n   * @link https://github.com/ethereum/ERCs/blob/master/ERCS/erc-7811.md\n   * @example\n   * provider.request({ method: 'wallet_getAssets', params: [...] })\n   * // => { ... }\n   */\n  {\n    Method: 'wallet_getAssets'\n    Parameters?: [WalletGetAssetsParameters]\n    ReturnType: WalletGetAssetsReturnType\n  },\n  /**\n   * @description Returns the status of a call batch that was sent via `wallet_sendCalls`.\n   * @link https://eips.ethereum.org/EIPS/eip-5792\n   * @example\n   * provider.request({ method: 'wallet_getCallsStatus' })\n   * // => { ... }\n   */\n  {\n    Method: 'wallet_getCallsStatus'\n    Parameters?: [string]\n    ReturnType: WalletGetCallsStatusReturnType\n  },\n  /**\n   * @description Gets the connected wallet's capabilities.\n   * @link https://eips.ethereum.org/EIPS/eip-5792\n   * @example\n   * provider.request({ method: 'wallet_getCapabilities' })\n   * // => { ... }\n   */\n  {\n    Method: 'wallet_getCapabilities'\n    Parameters?:\n      | readonly []\n      | readonly [Address | undefined]\n      | readonly [Address | undefined, readonly Hex[] | undefined]\n      | undefined\n    ReturnType: Prettify<ChainIdToCapabilities>\n  },\n  /**\n   * @description Gets the wallets current permissions.\n   * @link https://eips.ethereum.org/EIPS/eip-2255\n   * @example\n   * provider.request({ method: 'wallet_getPermissions' })\n   * // => { ... }\n   */\n  {\n    Method: 'wallet_getPermissions'\n    Parameters?: undefined\n    ReturnType: WalletPermission[]\n  },\n  /**\n   * @description Requests permissions from a wallet\n   * @link https://eips.ethereum.org/EIPS/eip-7715\n   * @example\n   * provider.request({ method: 'wallet_grantPermissions', params: [{ ... }] })\n   * // => { ... }\n   */\n  {\n    Method: 'wallet_grantPermissions'\n    Parameters?: [WalletGrantPermissionsParameters]\n    ReturnType: Prettify<WalletGrantPermissionsReturnType>\n  },\n  /**\n   * @description Requests the given permissions from the user.\n   * @link https://eips.ethereum.org/EIPS/eip-2255\n   * @example\n   * provider.request({ method: 'wallet_requestPermissions', params: [{ eth_accounts: {} }] })\n   * // => { ... }\n   */\n  {\n    Method: 'wallet_requestPermissions'\n    Parameters: [permissions: { eth_accounts: Record<string, any> }]\n    ReturnType: WalletPermission[]\n  },\n  /**\n   * @description Revokes the given permissions from the user.\n   * @link https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-2.md\n   * @example\n   * provider.request({ method: 'wallet_revokePermissions', params: [{ eth_accounts: {} }] })\n   * // => { ... }\n   */\n  {\n    Method: 'wallet_revokePermissions'\n    Parameters: [permissions: { eth_accounts: Record<string, any> }]\n    ReturnType: null\n  },\n  /**\n   * @description Requests the connected wallet to send a batch of calls.\n   * @link https://eips.ethereum.org/EIPS/eip-5792\n   * @example\n   * provider.request({ method: 'wallet_sendCalls' })\n   * // => { ... }\n   */\n  {\n    Method: 'wallet_sendCalls'\n    Parameters?: WalletSendCallsParameters\n    ReturnType: WalletSendCallsReturnType\n  },\n  /**\n   * @description Creates, signs, and sends a new transaction to the network\n   * @link https://eips.ethereum.org/EIPS/eip-1474\n   * @example\n   * provider.request({ method: 'wallet_sendTransaction', params: [{ from: '0x...', to: '0x...', value: '0x...' }] })\n   * // => '0x...'\n   */\n  {\n    Method: 'wallet_sendTransaction'\n    Parameters: [transaction: TransactionRequest]\n    ReturnType: Hash\n  },\n  /**\n   * @description Requests for the wallet to show information about a call batch\n   * that was sent via `wallet_sendCalls`.\n   * @link https://eips.ethereum.org/EIPS/eip-5792\n   * @example\n   * provider.request({ method: 'wallet_showCallsStatus', params: ['...'] })\n   */\n  {\n    Method: 'wallet_showCallsStatus'\n    Parameters?: [string]\n    ReturnType: void\n  },\n  /**\n   * @description Switch the wallet to the given Ethereum chain.\n   * @link https://eips.ethereum.org/EIPS/eip-3326\n   * @example\n   * provider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0xf00' }] })\n   * // => { ... }\n   */\n  {\n    Method: 'wallet_switchEthereumChain'\n    Parameters: [chain: { chainId: string }]\n    ReturnType: null\n  },\n  /**\n   * @description Requests that the user tracks the token in their wallet. Returns a boolean indicating if the token was successfully added.\n   * @link https://eips.ethereum.org/EIPS/eip-747\n   * @example\n   * provider.request({ method: 'wallet_watchAsset' }] })\n   * // => true\n   */\n  {\n    Method: 'wallet_watchAsset'\n    Parameters: WatchAssetParams\n    ReturnType: boolean\n  },\n]\n\n///////////////////////////////////////////////////////////////////////////\n// Utils\n\nexport type RpcSchema = readonly {\n  Method: string\n  Parameters?: unknown | undefined\n  ReturnType: unknown\n}[]\n\nexport type RpcSchemaOverride = Omit<RpcSchema[number], 'Method'>\n\nexport type EIP1193Parameters<\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = rpcSchema extends RpcSchema\n  ? {\n      [K in keyof rpcSchema]: Prettify<\n        {\n          method: rpcSchema[K] extends rpcSchema[number]\n            ? rpcSchema[K]['Method']\n            : never\n        } & (rpcSchema[K] extends rpcSchema[number]\n          ? rpcSchema[K]['Parameters'] extends undefined\n            ? { params?: undefined }\n            : { params: rpcSchema[K]['Parameters'] }\n          : never)\n      >\n    }[number]\n  : {\n      method: string\n      params?: unknown | undefined\n    }\n\nexport type EIP1193RequestOptions = {\n  /** Deduplicate in-flight requests. */\n  dedupe?: boolean | undefined\n  /** Methods to include or exclude from executing RPC requests. */\n  methods?:\n    | OneOf<\n        | {\n            include?: string[] | undefined\n          }\n        | {\n            exclude?: string[] | undefined\n          }\n      >\n    | undefined\n  /** The base delay (in ms) between retries. */\n  retryDelay?: number | undefined\n  /** The max number of times to retry. */\n  retryCount?: number | undefined\n  /** Unique identifier for the request. */\n  uid?: string | undefined\n}\n\ntype DerivedRpcSchema<\n  rpcSchema extends RpcSchema | undefined,\n  rpcSchemaOverride extends RpcSchemaOverride | undefined,\n> = rpcSchemaOverride extends RpcSchemaOverride\n  ? [rpcSchemaOverride & { Method: string }]\n  : rpcSchema\n\nexport type EIP1193RequestFn<\n  rpcSchema extends RpcSchema | undefined = undefined,\n  raw extends boolean = false,\n> = <\n  rpcSchemaOverride extends RpcSchemaOverride | undefined = undefined,\n  _parameters extends EIP1193Parameters<\n    DerivedRpcSchema<rpcSchema, rpcSchemaOverride>\n  > = EIP1193Parameters<DerivedRpcSchema<rpcSchema, rpcSchemaOverride>>,\n  _returnType = DerivedRpcSchema<rpcSchema, rpcSchemaOverride> extends RpcSchema\n    ? raw extends true\n      ? OneOf<\n          | {\n              result: Extract<\n                DerivedRpcSchema<rpcSchema, rpcSchemaOverride>[number],\n                { Method: _parameters['method'] }\n              >['ReturnType']\n            }\n          | { error: Rpc.ErrorObject }\n        >\n      : Extract<\n          DerivedRpcSchema<rpcSchema, rpcSchemaOverride>[number],\n          { Method: _parameters['method'] }\n        >['ReturnType']\n    : raw extends true\n      ? OneOf<\n          | {\n              result: unknown\n            }\n          | {\n              error: Rpc.ErrorObject\n            }\n        >\n      : unknown,\n>(\n  args: _parameters,\n  options?: EIP1193RequestOptions | undefined,\n) => Promise<_returnType>\n","import { ripemd160 as noble_ripemd160 } from '@noble/hashes/ripemd160'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Ripemd160Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Ripemd160ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function ripemd160<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Ripemd160Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = noble_ripemd160(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Ripemd160Hash<to>\n  return toHex(bytes) as Ripemd160Hash<to>\n}\n","import {\n  InvalidSerializedTransactionTypeError,\n  type InvalidSerializedTransactionTypeErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../index.js'\nimport type {\n  TransactionSerialized,\n  TransactionSerializedEIP1559,\n  TransactionSerializedEIP2930,\n  TransactionSerializedEIP4844,\n  TransactionSerializedEIP7702,\n  TransactionSerializedGeneric,\n  TransactionSerializedLegacy,\n  TransactionType,\n} from '../../types/transaction.js'\nimport type { IsNarrowable, IsNever } from '../../types/utils.js'\nimport { type SliceHexErrorType, sliceHex } from '../data/slice.js'\nimport { type HexToNumberErrorType, hexToNumber } from '../encoding/fromHex.js'\n\nexport type GetSerializedTransactionType<\n  serializedTransaction extends\n    TransactionSerializedGeneric = TransactionSerialized,\n  result =\n    | (serializedTransaction extends TransactionSerializedEIP1559\n        ? 'eip1559'\n        : never)\n    | (serializedTransaction extends TransactionSerializedEIP2930\n        ? 'eip2930'\n        : never)\n    | (serializedTransaction extends TransactionSerializedEIP4844\n        ? 'eip4844'\n        : never)\n    | (serializedTransaction extends TransactionSerializedEIP7702\n        ? 'eip7702'\n        : never)\n    | (serializedTransaction extends TransactionSerializedLegacy\n        ? 'legacy'\n        : never),\n> = IsNarrowable<serializedTransaction, Hex> extends true\n  ? IsNever<result> extends false\n    ? result\n    : 'legacy'\n  : TransactionType\n\nexport type GetSerializedTransactionTypeErrorType =\n  | HexToNumberErrorType\n  | InvalidSerializedTransactionTypeErrorType\n  | SliceHexErrorType\n  | ErrorType\n\nexport function getSerializedTransactionType<\n  const serializedTransaction extends TransactionSerializedGeneric,\n>(\n  serializedTransaction: serializedTransaction,\n): GetSerializedTransactionType<serializedTransaction> {\n  const serializedType = sliceHex(serializedTransaction, 0, 1)\n\n  if (serializedType === '0x04')\n    return 'eip7702' as GetSerializedTransactionType<serializedTransaction>\n\n  if (serializedType === '0x03')\n    return 'eip4844' as GetSerializedTransactionType<serializedTransaction>\n\n  if (serializedType === '0x02')\n    return 'eip1559' as GetSerializedTransactionType<serializedTransaction>\n\n  if (serializedType === '0x01')\n    return 'eip2930' as GetSerializedTransactionType<serializedTransaction>\n\n  if (serializedType !== '0x' && hexToNumber(serializedType) >= 0xc0)\n    return 'legacy' as GetSerializedTransactionType<serializedTransaction>\n\n  throw new InvalidSerializedTransactionTypeError({ serializedType })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\n\nexport type SendUnsignedTransactionParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = FormattedTransactionRequest<chain>\n\nexport type SendUnsignedTransactionReturnType = Hash\n\nexport type SendUnsignedTransactionErrorType = RequestErrorType | ErrorType\n\n/**\n * Executes a transaction regardless of the signature.\n *\n * - Docs: https://viem.sh/docs/actions/test/sendUnsignedTransaction#sendunsignedtransaction\n *\n * @param client - Client to use\n * @param parameters â€“ {@link SendUnsignedTransactionParameters}\n * @returns The transaction hash. {@link SendUnsignedTransactionReturnType}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { sendUnsignedTransaction } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * const hash = await sendUnsignedTransaction(client, {\n *   from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendUnsignedTransaction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  args: SendUnsignedTransactionParameters<chain>,\n): Promise<SendUnsignedTransactionReturnType> {\n  const {\n    accessList,\n    data,\n    from,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    ...rest\n  } = args\n\n  const chainFormat = client.chain?.formatters?.transactionRequest?.format\n  const format = chainFormat || formatTransactionRequest\n\n  const request = format(\n    {\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, { format: chainFormat }),\n      accessList,\n      data,\n      from,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    } as TransactionRequest,\n    'sendUnsignedTransaction',\n  )\n  const hash = await client.request({\n    method: 'eth_sendUnsignedTransaction',\n    params: [request],\n  })\n  return hash\n}\n","import { ExecutionRevertedError } from '../../errors/node.js'\nimport {\n  TransactionRejectedRpcError,\n  UserRejectedRequestError,\n} from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport { wait } from '../../utils/wait.js'\n\nimport {\n  type CreateTransportErrorType,\n  createTransport,\n  type Transport,\n  type TransportConfig,\n} from './createTransport.js'\n// TODO: Narrow `method` & `params` types.\nexport type OnResponseFn = (\n  args: {\n    method: string\n    params: unknown[]\n    transport: ReturnType<Transport>\n  } & (\n    | {\n        error?: undefined\n        response: unknown\n        status: 'success'\n      }\n    | {\n        error: Error\n        response?: undefined\n        status: 'error'\n      }\n  ),\n) => void\n\ntype RankOptions = {\n  /**\n   * The polling interval (in ms) at which the ranker should ping the RPC URL.\n   * @default client.pollingInterval\n   */\n  interval?: number | undefined\n  /**\n   * Ping method to determine latency.\n   */\n  ping?: (parameters: {\n    transport: ReturnType<Transport>\n  }) => Promise<unknown> | undefined\n  /**\n   * The number of previous samples to perform ranking on.\n   * @default 10\n   */\n  sampleCount?: number | undefined\n  /**\n   * Timeout when sampling transports.\n   * @default 1_000\n   */\n  timeout?: number | undefined\n  /**\n   * Weights to apply to the scores. Weight values are proportional.\n   */\n  weights?:\n    | {\n        /**\n         * The weight to apply to the latency score.\n         * @default 0.3\n         */\n        latency?: number | undefined\n        /**\n         * The weight to apply to the stability score.\n         * @default 0.7\n         */\n        stability?: number | undefined\n      }\n    | undefined\n}\n\nexport type FallbackTransportConfig = {\n  /** The key of the Fallback transport. */\n  key?: TransportConfig['key'] | undefined\n  /** The name of the Fallback transport. */\n  name?: TransportConfig['name'] | undefined\n  /** Toggle to enable ranking, or rank options. */\n  rank?: boolean | RankOptions | undefined\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig['retryCount'] | undefined\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig['retryDelay'] | undefined\n  /** Callback on whether an error should throw or try the next transport in the fallback. */\n  shouldThrow?: (error: Error) => boolean | undefined\n}\n\nexport type FallbackTransport<\n  transports extends readonly Transport[] = readonly Transport[],\n> = Transport<\n  'fallback',\n  {\n    onResponse: (fn: OnResponseFn) => void\n    transports: {\n      [key in keyof transports]: ReturnType<transports[key]>\n    }\n  }\n>\n\nexport type FallbackTransportErrorType = CreateTransportErrorType | ErrorType\n\nexport function fallback<const transports extends readonly Transport[]>(\n  transports_: transports,\n  config: FallbackTransportConfig = {},\n): FallbackTransport<transports> {\n  const {\n    key = 'fallback',\n    name = 'Fallback',\n    rank = false,\n    shouldThrow: shouldThrow_ = shouldThrow,\n    retryCount,\n    retryDelay,\n  } = config\n  return (({ chain, pollingInterval = 4_000, timeout, ...rest }) => {\n    let transports = transports_\n\n    let onResponse: OnResponseFn = () => {}\n\n    const transport = createTransport(\n      {\n        key,\n        name,\n        async request({ method, params }) {\n          let includes: boolean | undefined\n\n          const fetch = async (i = 0): Promise<any> => {\n            const transport = transports[i]({\n              ...rest,\n              chain,\n              retryCount: 0,\n              timeout,\n            })\n            try {\n              const response = await transport.request({\n                method,\n                params,\n              } as any)\n\n              onResponse({\n                method,\n                params: params as unknown[],\n                response,\n                transport,\n                status: 'success',\n              })\n\n              return response\n            } catch (err) {\n              onResponse({\n                error: err as Error,\n                method,\n                params: params as unknown[],\n                transport,\n                status: 'error',\n              })\n\n              if (shouldThrow_(err as Error)) throw err\n\n              // If we've reached the end of the fallbacks, throw the error.\n              if (i === transports.length - 1) throw err\n\n              // Check if at least one other transport includes the method\n              includes ??= transports.slice(i + 1).some((transport) => {\n                const { include, exclude } =\n                  transport({ chain }).config.methods || {}\n                if (include) return include.includes(method)\n                if (exclude) return !exclude.includes(method)\n                return true\n              })\n              if (!includes) throw err\n\n              // Otherwise, try the next fallback.\n              return fetch(i + 1)\n            }\n          }\n          return fetch()\n        },\n        retryCount,\n        retryDelay,\n        type: 'fallback',\n      },\n      {\n        onResponse: (fn: OnResponseFn) => (onResponse = fn),\n        transports: transports.map((fn) => fn({ chain, retryCount: 0 })),\n      },\n    )\n\n    if (rank) {\n      const rankOptions = (typeof rank === 'object' ? rank : {}) as RankOptions\n      rankTransports({\n        chain,\n        interval: rankOptions.interval ?? pollingInterval,\n        onTransports: (transports_) => (transports = transports_ as transports),\n        ping: rankOptions.ping,\n        sampleCount: rankOptions.sampleCount,\n        timeout: rankOptions.timeout,\n        transports,\n        weights: rankOptions.weights,\n      })\n    }\n    return transport\n  }) as FallbackTransport<transports>\n}\n\nexport function shouldThrow(error: Error) {\n  if ('code' in error && typeof error.code === 'number') {\n    if (\n      error.code === TransactionRejectedRpcError.code ||\n      error.code === UserRejectedRequestError.code ||\n      ExecutionRevertedError.nodeMessage.test(error.message) ||\n      error.code === 5000 // CAIP UserRejectedRequestError\n    )\n      return true\n  }\n  return false\n}\n\n/** @internal */\nexport function rankTransports({\n  chain,\n  interval = 4_000,\n  onTransports,\n  ping,\n  sampleCount = 10,\n  timeout = 1_000,\n  transports,\n  weights = {},\n}: {\n  chain?: Chain | undefined\n  interval: RankOptions['interval']\n  onTransports: (transports: readonly Transport[]) => void\n  ping?: RankOptions['ping'] | undefined\n  sampleCount?: RankOptions['sampleCount'] | undefined\n  timeout?: RankOptions['timeout'] | undefined\n  transports: readonly Transport[]\n  weights?: RankOptions['weights'] | undefined\n}) {\n  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } =\n    weights\n\n  type SampleData = { latency: number; success: number }\n  type Sample = SampleData[]\n  const samples: Sample[] = []\n\n  const rankTransports_ = async () => {\n    // 1. Take a sample from each Transport.\n    const sample: Sample = await Promise.all(\n      transports.map(async (transport) => {\n        const transport_ = transport({ chain, retryCount: 0, timeout })\n\n        const start = Date.now()\n        let end: number\n        let success: number\n        try {\n          await (ping\n            ? ping({ transport: transport_ })\n            : transport_.request({ method: 'net_listening' }))\n          success = 1\n        } catch {\n          success = 0\n        } finally {\n          end = Date.now()\n        }\n        const latency = end - start\n        return { latency, success }\n      }),\n    )\n\n    // 2. Store the sample. If we have more than `sampleCount` samples, remove\n    // the oldest sample.\n    samples.push(sample)\n    if (samples.length > sampleCount) samples.shift()\n\n    // 3. Calculate the max latency from samples.\n    const maxLatency = Math.max(\n      ...samples.map((sample) =>\n        Math.max(...sample.map(({ latency }) => latency)),\n      ),\n    )\n\n    // 4. Calculate the score for each Transport.\n    const scores = transports\n      .map((_, i) => {\n        const latencies = samples.map((sample) => sample[i].latency)\n        const meanLatency =\n          latencies.reduce((acc, latency) => acc + latency, 0) /\n          latencies.length\n        const latencyScore = 1 - meanLatency / maxLatency\n\n        const successes = samples.map((sample) => sample[i].success)\n        const stabilityScore =\n          successes.reduce((acc, success) => acc + success, 0) /\n          successes.length\n\n        if (stabilityScore === 0) return [0, i]\n        return [\n          latencyWeight * latencyScore + stabilityWeight * stabilityScore,\n          i,\n        ]\n      })\n      .sort((a, b) => b[0] - a[0])\n\n    // 5. Sort the Transports by score.\n    onTransports(scores.map(([, i]) => transports[i]))\n\n    // 6. Wait, and then rank again.\n    await wait(interval)\n    rankTransports_()\n  }\n  rankTransports_()\n}\n","import type {\n  AbiParameterToPrimitiveType,\n  AbiType,\n  Address,\n  SolidityAddress,\n  SolidityArrayWithoutTuple,\n  SolidityBool,\n  SolidityBytes,\n  SolidityInt,\n  SolidityString,\n} from 'abitype'\n\nimport {\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  BytesSizeMismatchError,\n  type BytesSizeMismatchErrorType,\n  UnsupportedPackedAbiType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\nimport {\n  type BoolToHexErrorType,\n  boolToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js'\n\ntype PackedAbiType =\n  | SolidityAddress\n  | SolidityBool\n  | SolidityBytes\n  | SolidityInt\n  | SolidityString\n  | SolidityArrayWithoutTuple\n\ntype EncodePackedValues<\n  packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n> = {\n  [K in keyof packedAbiTypes]: packedAbiTypes[K] extends AbiType\n    ? AbiParameterToPrimitiveType<{ type: packedAbiTypes[K] }>\n    : unknown\n}\n\nexport type EncodePackedErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | ConcatHexErrorType\n  | EncodeErrorType\n  | ErrorType\n\nexport function encodePacked<\n  const packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n>(types: packedAbiTypes, values: EncodePackedValues<packedAbiTypes>): Hex {\n  if (types.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: types.length as number,\n      givenLength: values.length as number,\n    })\n\n  const data: Hex[] = []\n  for (let i = 0; i < (types as unknown[]).length; i++) {\n    const type = types[i]\n    const value = values[i]\n    data.push(encode(type, value))\n  }\n  return concatHex(data)\n}\n\ntype EncodeErrorType =\n  | BoolToHexErrorType\n  | BytesSizeMismatchErrorType\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | PadErrorType\n  | StringToHexErrorType\n  | UnsupportedPackedAbiType\n  | ErrorType\n\nfunction encode<const packedAbiType extends PackedAbiType | unknown>(\n  type: packedAbiType,\n  value: EncodePackedValues<[packedAbiType]>[0],\n  isArray = false,\n): Hex {\n  if (type === 'address') {\n    const address = value as Address\n    if (!isAddress(address)) throw new InvalidAddressError({ address })\n    return pad(address.toLowerCase() as Hex, {\n      size: isArray ? 32 : null,\n    }) as Address\n  }\n  if (type === 'string') return stringToHex(value as string)\n  if (type === 'bytes') return value as Hex\n  if (type === 'bool')\n    return pad(boolToHex(value as boolean), { size: isArray ? 32 : 1 })\n\n  const intMatch = (type as string).match(integerRegex)\n  if (intMatch) {\n    const [_type, baseType, bits = '256'] = intMatch\n    const size = Number.parseInt(bits, 10) / 8\n    return numberToHex(value as number, {\n      size: isArray ? 32 : size,\n      signed: baseType === 'int',\n    })\n  }\n\n  const bytesMatch = (type as string).match(bytesRegex)\n  if (bytesMatch) {\n    const [_type, size] = bytesMatch\n    if (Number.parseInt(size, 10) !== ((value as Hex).length - 2) / 2)\n      throw new BytesSizeMismatchError({\n        expectedSize: Number.parseInt(size, 10),\n        givenSize: ((value as Hex).length - 2) / 2,\n      })\n    return pad(value as Hex, { dir: 'right', size: isArray ? 32 : null }) as Hex\n  }\n\n  const arrayMatch = (type as string).match(arrayRegex)\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch\n    const data: Hex[] = []\n    for (let i = 0; i < value.length; i++) {\n      data.push(encode(childType, value[i], true))\n    }\n    if (data.length === 0) return '0x'\n    return concatHex(data)\n  }\n\n  throw new UnsupportedPackedAbiType(type)\n}\n","// biome-ignore lint/performance/noBarrelFile: entrypoint module\nexport {\n  type Abi,\n  type AbiEvent,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParameterKind,\n  type AbiParameterToPrimitiveType,\n  type AbiStateMutability,\n  type Address,\n  CircularReferenceError,\n  InvalidAbiItemError,\n  InvalidAbiParameterError,\n  InvalidAbiParametersError,\n  InvalidAbiTypeParameterError,\n  InvalidFunctionModifierError,\n  InvalidModifierError,\n  InvalidParameterError,\n  InvalidParenthesisError,\n  InvalidSignatureError,\n  InvalidStructSignatureError,\n  type Narrow,\n  type ParseAbi,\n  type ParseAbiItem,\n  type ParseAbiParameter,\n  type ParseAbiParameters,\n  parseAbi,\n  parseAbiItem,\n  parseAbiParameter,\n  parseAbiParameters,\n  SolidityProtectedKeywordError,\n  type TypedData,\n  type TypedDataDomain,\n  type TypedDataParameter,\n  UnknownSignatureError,\n  UnknownTypeError,\n} from 'abitype'\nexport type {\n  BlockOverrides,\n  Rpc as RpcBlockOverrides,\n} from 'ox/BlockOverrides'\nexport type {\n  RpcEstimateUserOperationGasReturnType,\n  RpcGetUserOperationByHashReturnType,\n  RpcUserOperation,\n  RpcUserOperationReceipt,\n  RpcUserOperationRequest,\n} from './account-abstraction/types/rpc.js'\nexport type {\n  Account,\n  AccountSource,\n  CustomSource,\n  HDAccount,\n  HDOptions,\n  JsonRpcAccount,\n  LocalAccount,\n  PrivateKeyAccount,\n} from './accounts/types.js'\nexport type {\n  GetEnsAddressErrorType,\n  GetEnsAddressParameters,\n  GetEnsAddressReturnType,\n} from './actions/ens/getEnsAddress.js'\nexport type {\n  GetEnsAvatarErrorType,\n  GetEnsAvatarParameters,\n  GetEnsAvatarReturnType,\n} from './actions/ens/getEnsAvatar.js'\nexport type {\n  GetEnsNameErrorType,\n  GetEnsNameParameters,\n  GetEnsNameReturnType,\n} from './actions/ens/getEnsName.js'\nexport type {\n  GetEnsResolverErrorType,\n  GetEnsResolverParameters,\n  GetEnsResolverReturnType,\n} from './actions/ens/getEnsResolver.js'\nexport type {\n  GetEnsTextErrorType,\n  GetEnsTextParameters,\n  GetEnsTextReturnType,\n} from './actions/ens/getEnsText.js'\nexport {\n  type GetContractErrorType,\n  type GetContractParameters,\n  type GetContractReturnType,\n  getContract,\n} from './actions/getContract.js'\nexport type {\n  CallErrorType,\n  CallParameters,\n  CallReturnType,\n} from './actions/public/call.js'\nexport type {\n  CreateAccessListErrorType,\n  CreateAccessListParameters,\n  CreateAccessListReturnType,\n} from './actions/public/createAccessList.js'\nexport type {\n  CreateBlockFilterErrorType,\n  CreateBlockFilterReturnType,\n} from './actions/public/createBlockFilter.js'\nexport type {\n  CreateContractEventFilterErrorType,\n  CreateContractEventFilterParameters,\n  CreateContractEventFilterReturnType,\n} from './actions/public/createContractEventFilter.js'\nexport type {\n  CreateEventFilterErrorType,\n  CreateEventFilterParameters,\n  CreateEventFilterReturnType,\n} from './actions/public/createEventFilter.js'\nexport type {\n  CreatePendingTransactionFilterErrorType,\n  CreatePendingTransactionFilterReturnType,\n} from './actions/public/createPendingTransactionFilter.js'\nexport type {\n  EstimateContractGasErrorType,\n  EstimateContractGasParameters,\n  EstimateContractGasReturnType,\n} from './actions/public/estimateContractGas.js'\nexport type {\n  EstimateFeesPerGasErrorType,\n  EstimateFeesPerGasParameters,\n  EstimateFeesPerGasReturnType,\n} from './actions/public/estimateFeesPerGas.js'\nexport type {\n  EstimateGasErrorType,\n  EstimateGasParameters,\n  EstimateGasReturnType,\n} from './actions/public/estimateGas.js'\nexport type {\n  EstimateMaxPriorityFeePerGasErrorType,\n  EstimateMaxPriorityFeePerGasParameters,\n  EstimateMaxPriorityFeePerGasReturnType,\n} from './actions/public/estimateMaxPriorityFeePerGas.js'\nexport type {\n  FillTransactionErrorType,\n  FillTransactionParameters,\n  FillTransactionReturnType,\n} from './actions/public/fillTransaction.js'\nexport type {\n  GetBalanceErrorType,\n  GetBalanceParameters,\n  GetBalanceReturnType,\n} from './actions/public/getBalance.js'\nexport type {\n  GetBlobBaseFeeErrorType,\n  GetBlobBaseFeeReturnType,\n} from './actions/public/getBlobBaseFee.js'\nexport type {\n  GetBlockErrorType,\n  GetBlockParameters,\n  GetBlockReturnType,\n} from './actions/public/getBlock.js'\nexport type {\n  GetBlockNumberErrorType,\n  GetBlockNumberParameters,\n  GetBlockNumberReturnType,\n} from './actions/public/getBlockNumber.js'\nexport type {\n  GetBlockTransactionCountErrorType,\n  GetBlockTransactionCountParameters,\n  GetBlockTransactionCountReturnType,\n} from './actions/public/getBlockTransactionCount.js'\nexport type {\n  GetChainIdErrorType,\n  GetChainIdReturnType,\n} from './actions/public/getChainId.js'\nexport type {\n  /** @deprecated Use `GetCodeErrorType` instead */\n  GetCodeErrorType as GetBytecodeErrorType,\n  GetCodeErrorType,\n  /** @deprecated Use `GetCodeParameters` instead */\n  GetCodeParameters as GetBytecodeParameters,\n  GetCodeParameters,\n  /** @deprecated Use `GetCodeReturnType` instead  */\n  GetCodeReturnType as GetBytecodeReturnType,\n  GetCodeReturnType,\n} from './actions/public/getCode.js'\nexport type {\n  GetContractEventsErrorType,\n  GetContractEventsParameters,\n  GetContractEventsReturnType,\n} from './actions/public/getContractEvents.js'\nexport type {\n  GetEip712DomainErrorType,\n  GetEip712DomainParameters,\n  GetEip712DomainReturnType,\n} from './actions/public/getEip712Domain.js'\nexport type {\n  GetFeeHistoryErrorType,\n  GetFeeHistoryParameters,\n  GetFeeHistoryReturnType,\n} from './actions/public/getFeeHistory.js'\nexport type {\n  GetFilterChangesErrorType,\n  GetFilterChangesParameters,\n  GetFilterChangesReturnType,\n} from './actions/public/getFilterChanges.js'\nexport type {\n  GetFilterLogsErrorType,\n  GetFilterLogsParameters,\n  GetFilterLogsReturnType,\n} from './actions/public/getFilterLogs.js'\nexport type {\n  GetGasPriceErrorType,\n  GetGasPriceReturnType,\n} from './actions/public/getGasPrice.js'\nexport type {\n  GetLogsErrorType,\n  GetLogsParameters,\n  GetLogsReturnType,\n} from './actions/public/getLogs.js'\nexport type {\n  GetProofErrorType,\n  GetProofParameters,\n  GetProofReturnType,\n} from './actions/public/getProof.js'\nexport type {\n  GetStorageAtErrorType,\n  GetStorageAtParameters,\n  GetStorageAtReturnType,\n} from './actions/public/getStorageAt.js'\nexport type {\n  GetTransactionErrorType,\n  GetTransactionParameters,\n  GetTransactionReturnType,\n} from './actions/public/getTransaction.js'\nexport type {\n  GetTransactionConfirmationsErrorType,\n  GetTransactionConfirmationsParameters,\n  GetTransactionConfirmationsReturnType,\n} from './actions/public/getTransactionConfirmations.js'\nexport type {\n  GetTransactionCountErrorType,\n  GetTransactionCountParameters,\n  GetTransactionCountReturnType,\n} from './actions/public/getTransactionCount.js'\nexport type {\n  GetTransactionReceiptErrorType,\n  GetTransactionReceiptParameters,\n  GetTransactionReceiptReturnType,\n} from './actions/public/getTransactionReceipt.js'\nexport type {\n  MulticallErrorType,\n  MulticallParameters,\n  MulticallReturnType,\n} from './actions/public/multicall.js'\nexport type {\n  ReadContractErrorType,\n  ReadContractParameters,\n  ReadContractReturnType,\n} from './actions/public/readContract.js'\nexport type {\n  SimulateBlocksErrorType,\n  SimulateBlocksParameters,\n  SimulateBlocksReturnType,\n} from './actions/public/simulateBlocks.js'\nexport type {\n  SimulateCallsErrorType,\n  SimulateCallsParameters,\n  SimulateCallsReturnType,\n} from './actions/public/simulateCalls.js'\nexport type {\n  GetMutabilityAwareValue,\n  SimulateContractErrorType,\n  SimulateContractParameters,\n  SimulateContractReturnType,\n} from './actions/public/simulateContract.js'\nexport type {\n  UninstallFilterErrorType,\n  UninstallFilterParameters,\n  UninstallFilterReturnType,\n} from './actions/public/uninstallFilter.js'\nexport type {\n  VerifyHashErrorType as VerifyHashActionErrorType,\n  VerifyHashParameters as VerifyHashActionParameters,\n  VerifyHashReturnType as VerifyHashActionReturnType,\n} from './actions/public/verifyHash.js'\nexport type {\n  VerifyMessageErrorType as VerifyMessageActionErrorType,\n  VerifyMessageParameters as VerifyMessageActionParameters,\n  VerifyMessageReturnType as VerifyMessageActionReturnType,\n} from './actions/public/verifyMessage.js'\nexport type {\n  VerifyTypedDataErrorType as VerifyTypedDataActionErrorType,\n  VerifyTypedDataParameters as VerifyTypedDataActionParameters,\n  VerifyTypedDataReturnType as VerifyTypedDataActionReturnType,\n} from './actions/public/verifyTypedData.js'\nexport type {\n  ReplacementReason,\n  ReplacementReturnType,\n  WaitForTransactionReceiptErrorType,\n  WaitForTransactionReceiptParameters,\n  WaitForTransactionReceiptReturnType,\n} from './actions/public/waitForTransactionReceipt.js'\nexport type {\n  OnBlockNumberFn,\n  OnBlockNumberParameter,\n  WatchBlockNumberErrorType,\n  WatchBlockNumberParameters,\n  WatchBlockNumberReturnType,\n} from './actions/public/watchBlockNumber.js'\nexport type {\n  OnBlock,\n  OnBlockParameter,\n  WatchBlocksErrorType,\n  WatchBlocksParameters,\n  WatchBlocksReturnType,\n} from './actions/public/watchBlocks.js'\nexport type {\n  WatchContractEventErrorType,\n  WatchContractEventOnLogsFn,\n  WatchContractEventOnLogsParameter,\n  WatchContractEventParameters,\n  WatchContractEventReturnType,\n} from './actions/public/watchContractEvent.js'\nexport type {\n  WatchEventErrorType,\n  WatchEventOnLogsFn,\n  WatchEventOnLogsParameter,\n  WatchEventParameters,\n  WatchEventReturnType,\n} from './actions/public/watchEvent.js'\nexport type {\n  OnTransactionsFn,\n  OnTransactionsParameter,\n  WatchPendingTransactionsErrorType,\n  WatchPendingTransactionsParameters,\n  WatchPendingTransactionsReturnType,\n} from './actions/public/watchPendingTransactions.js'\nexport type {\n  DropTransactionErrorType,\n  DropTransactionParameters,\n} from './actions/test/dropTransaction.js'\nexport type {\n  DumpStateErrorType,\n  DumpStateReturnType,\n} from './actions/test/dumpState.js'\nexport type {\n  GetAutomineErrorType,\n  GetAutomineReturnType,\n} from './actions/test/getAutomine.js'\nexport type {\n  GetTxpoolContentErrorType,\n  GetTxpoolContentReturnType,\n} from './actions/test/getTxpoolContent.js'\nexport type {\n  GetTxpoolStatusErrorType,\n  GetTxpoolStatusReturnType,\n} from './actions/test/getTxpoolStatus.js'\nexport type {\n  ImpersonateAccountErrorType,\n  ImpersonateAccountParameters,\n} from './actions/test/impersonateAccount.js'\nexport type {\n  IncreaseTimeErrorType,\n  IncreaseTimeParameters,\n} from './actions/test/increaseTime.js'\nexport type {\n  InspectTxpoolErrorType,\n  InspectTxpoolReturnType,\n} from './actions/test/inspectTxpool.js'\nexport type {\n  LoadStateErrorType,\n  LoadStateParameters,\n  LoadStateReturnType,\n} from './actions/test/loadState.js'\nexport type { MineErrorType, MineParameters } from './actions/test/mine.js'\nexport type { RemoveBlockTimestampIntervalErrorType } from './actions/test/removeBlockTimestampInterval.js'\nexport type { ResetErrorType, ResetParameters } from './actions/test/reset.js'\nexport type {\n  RevertErrorType,\n  RevertParameters,\n} from './actions/test/revert.js'\nexport type {\n  SendUnsignedTransactionErrorType,\n  SendUnsignedTransactionParameters,\n  SendUnsignedTransactionReturnType,\n} from './actions/test/sendUnsignedTransaction.js'\nexport type { SetAutomineErrorType } from './actions/test/setAutomine.js'\nexport type {\n  SetBalanceErrorType,\n  SetBalanceParameters,\n} from './actions/test/setBalance.js'\nexport type {\n  SetBlockGasLimitErrorType,\n  SetBlockGasLimitParameters,\n} from './actions/test/setBlockGasLimit.js'\nexport type {\n  SetBlockTimestampIntervalErrorType,\n  SetBlockTimestampIntervalParameters,\n} from './actions/test/setBlockTimestampInterval.js'\nexport type {\n  SetCodeErrorType,\n  SetCodeParameters,\n} from './actions/test/setCode.js'\nexport type {\n  SetCoinbaseErrorType,\n  SetCoinbaseParameters,\n} from './actions/test/setCoinbase.js'\nexport type {\n  SetIntervalMiningErrorType,\n  SetIntervalMiningParameters,\n} from './actions/test/setIntervalMining.js'\nexport type { SetLoggingEnabledErrorType } from './actions/test/setLoggingEnabled.js'\nexport type {\n  SetMinGasPriceErrorType,\n  SetMinGasPriceParameters,\n} from './actions/test/setMinGasPrice.js'\nexport type {\n  SetNextBlockBaseFeePerGasErrorType,\n  SetNextBlockBaseFeePerGasParameters,\n} from './actions/test/setNextBlockBaseFeePerGas.js'\nexport type {\n  SetNextBlockTimestampErrorType,\n  SetNextBlockTimestampParameters,\n} from './actions/test/setNextBlockTimestamp.js'\nexport type {\n  SetNonceErrorType,\n  SetNonceParameters,\n} from './actions/test/setNonce.js'\nexport type { SetRpcUrlErrorType } from './actions/test/setRpcUrl.js'\nexport type {\n  SetStorageAtErrorType,\n  SetStorageAtParameters,\n} from './actions/test/setStorageAt.js'\nexport type { SnapshotErrorType } from './actions/test/snapshot.js'\nexport type {\n  StopImpersonatingAccountErrorType,\n  StopImpersonatingAccountParameters,\n} from './actions/test/stopImpersonatingAccount.js'\nexport type {\n  AddChainErrorType,\n  AddChainParameters,\n} from './actions/wallet/addChain.js'\nexport type {\n  DeployContractErrorType,\n  DeployContractParameters,\n  DeployContractReturnType,\n} from './actions/wallet/deployContract.js'\nexport type {\n  GetAddressesErrorType,\n  GetAddressesReturnType,\n} from './actions/wallet/getAddresses.js'\nexport type {\n  GetCallsStatusErrorType,\n  GetCallsStatusParameters,\n  GetCallsStatusReturnType,\n} from './actions/wallet/getCallsStatus.js'\nexport type {\n  GetCapabilitiesErrorType,\n  GetCapabilitiesParameters,\n  GetCapabilitiesReturnType,\n} from './actions/wallet/getCapabilities.js'\nexport type {\n  GetPermissionsErrorType,\n  GetPermissionsReturnType,\n} from './actions/wallet/getPermissions.js'\nexport type {\n  PrepareAuthorizationErrorType,\n  PrepareAuthorizationParameters,\n  PrepareAuthorizationReturnType,\n} from './actions/wallet/prepareAuthorization.js'\nexport type {\n  PrepareTransactionRequestErrorType,\n  PrepareTransactionRequestParameters,\n  PrepareTransactionRequestParameterType,\n  PrepareTransactionRequestRequest,\n  PrepareTransactionRequestReturnType,\n} from './actions/wallet/prepareTransactionRequest.js'\nexport type {\n  RequestAddressesErrorType,\n  RequestAddressesReturnType,\n} from './actions/wallet/requestAddresses.js'\nexport type {\n  RequestPermissionsErrorType,\n  RequestPermissionsParameters,\n  RequestPermissionsReturnType,\n} from './actions/wallet/requestPermissions.js'\nexport type {\n  SendCallsErrorType,\n  SendCallsParameters,\n  SendCallsReturnType,\n} from './actions/wallet/sendCalls.js'\nexport type {\n  SendCallsSyncErrorType,\n  SendCallsSyncParameters,\n  SendCallsSyncReturnType,\n} from './actions/wallet/sendCallsSync.js'\nexport type {\n  SendRawTransactionErrorType,\n  SendRawTransactionParameters,\n  SendRawTransactionReturnType,\n} from './actions/wallet/sendRawTransaction.js'\nexport type {\n  SendRawTransactionSyncErrorType,\n  SendRawTransactionSyncParameters,\n  SendRawTransactionSyncReturnType,\n} from './actions/wallet/sendRawTransactionSync.js'\nexport type {\n  SendTransactionErrorType,\n  SendTransactionParameters,\n  SendTransactionRequest,\n  SendTransactionReturnType,\n} from './actions/wallet/sendTransaction.js'\nexport type {\n  SendTransactionSyncErrorType,\n  SendTransactionSyncParameters,\n  SendTransactionSyncRequest,\n  SendTransactionSyncReturnType,\n} from './actions/wallet/sendTransactionSync.js'\nexport type {\n  ShowCallsStatusErrorType,\n  ShowCallsStatusParameters,\n  ShowCallsStatusReturnType,\n} from './actions/wallet/showCallsStatus.js'\nexport type {\n  SignAuthorizationErrorType,\n  SignAuthorizationParameters,\n  SignAuthorizationReturnType,\n} from './actions/wallet/signAuthorization.js'\nexport type {\n  SignMessageErrorType,\n  SignMessageParameters,\n  SignMessageReturnType,\n} from './actions/wallet/signMessage.js'\nexport type {\n  SignTransactionErrorType,\n  SignTransactionParameters,\n  SignTransactionReturnType,\n} from './actions/wallet/signTransaction.js'\nexport type {\n  SignTypedDataErrorType,\n  SignTypedDataParameters,\n  SignTypedDataReturnType,\n} from './actions/wallet/signTypedData.js'\nexport type {\n  SwitchChainErrorType,\n  SwitchChainParameters,\n} from './actions/wallet/switchChain.js'\nexport type {\n  WaitForCallsStatusErrorType,\n  WaitForCallsStatusParameters,\n  WaitForCallsStatusReturnType,\n  WaitForCallsStatusTimeoutErrorType,\n} from './actions/wallet/waitForCallsStatus.js'\nexport { WaitForCallsStatusTimeoutError } from './actions/wallet/waitForCallsStatus.js'\nexport type {\n  WatchAssetErrorType,\n  WatchAssetParameters,\n  WatchAssetReturnType,\n} from './actions/wallet/watchAsset.js'\nexport type {\n  WriteContractErrorType,\n  WriteContractParameters,\n  WriteContractReturnType,\n} from './actions/wallet/writeContract.js'\nexport type {\n  WriteContractSyncErrorType,\n  WriteContractSyncParameters,\n  WriteContractSyncReturnType,\n} from './actions/wallet/writeContractSync.js'\nexport {\n  type Client,\n  type ClientConfig,\n  type CreateClientErrorType,\n  createClient,\n  type MulticallBatchOptions,\n  rpcSchema,\n} from './clients/createClient.js'\nexport {\n  type CreatePublicClientErrorType,\n  createPublicClient,\n  type PublicClient,\n  type PublicClientConfig,\n} from './clients/createPublicClient.js'\nexport {\n  type CreateTestClientErrorType,\n  createTestClient,\n  type TestClient,\n  type TestClientConfig,\n} from './clients/createTestClient.js'\nexport {\n  type CreateWalletClientErrorType,\n  createWalletClient,\n  type WalletClient,\n  type WalletClientConfig,\n} from './clients/createWalletClient.js'\nexport {\n  type PublicActions,\n  publicActions,\n} from './clients/decorators/public.js'\nexport {\n  type TestActions,\n  testActions,\n} from './clients/decorators/test.js'\nexport {\n  type WalletActions,\n  walletActions,\n} from './clients/decorators/wallet.js'\nexport {\n  type CreateTransportErrorType,\n  createTransport,\n  type Transport,\n  type TransportConfig,\n} from './clients/transports/createTransport.js'\nexport {\n  type CustomTransport,\n  type CustomTransportConfig,\n  type CustomTransportErrorType,\n  custom,\n} from './clients/transports/custom.js'\nexport {\n  type FallbackTransport,\n  type FallbackTransportConfig,\n  type FallbackTransportErrorType,\n  fallback,\n  shouldThrow,\n} from './clients/transports/fallback.js'\nexport {\n  type HttpTransport,\n  type HttpTransportConfig,\n  type HttpTransportErrorType,\n  http,\n} from './clients/transports/http.js'\nexport {\n  type WebSocketTransport,\n  type WebSocketTransportConfig,\n  type WebSocketTransportErrorType,\n  webSocket,\n} from './clients/transports/webSocket.js'\nexport {\n  erc20Abi,\n  erc20Abi_bytes32,\n  erc721Abi,\n  erc1155Abi,\n  erc4626Abi,\n  erc6492SignatureValidatorAbi,\n  /** @deprecated use `erc6492SignatureValidatorAbi` instead. */\n  erc6492SignatureValidatorAbi as universalSignatureValidatorAbi,\n  multicall3Abi,\n} from './constants/abis.js'\nexport { ethAddress, zeroAddress } from './constants/address.js'\nexport { zeroHash } from './constants/bytes.js'\nexport {\n  deploylessCallViaBytecodeBytecode,\n  deploylessCallViaFactoryBytecode,\n  erc6492SignatureValidatorByteCode,\n  /** @deprecated use `erc6492SignatureValidatorByteCode` instead. */\n  erc6492SignatureValidatorByteCode as universalSignatureValidatorByteCode,\n} from './constants/contracts.js'\nexport {\n  maxInt8,\n  maxInt16,\n  maxInt24,\n  maxInt32,\n  maxInt40,\n  maxInt48,\n  maxInt56,\n  maxInt64,\n  maxInt72,\n  maxInt80,\n  maxInt88,\n  maxInt96,\n  maxInt104,\n  maxInt112,\n  maxInt120,\n  maxInt128,\n  maxInt136,\n  maxInt144,\n  maxInt152,\n  maxInt160,\n  maxInt168,\n  maxInt176,\n  maxInt184,\n  maxInt192,\n  maxInt200,\n  maxInt208,\n  maxInt216,\n  maxInt224,\n  maxInt232,\n  maxInt240,\n  maxInt248,\n  maxInt256,\n  maxUint8,\n  maxUint16,\n  maxUint24,\n  maxUint32,\n  maxUint40,\n  maxUint48,\n  maxUint56,\n  maxUint64,\n  maxUint72,\n  maxUint80,\n  maxUint88,\n  maxUint96,\n  maxUint104,\n  maxUint112,\n  maxUint120,\n  maxUint128,\n  maxUint136,\n  maxUint144,\n  maxUint152,\n  maxUint160,\n  maxUint168,\n  maxUint176,\n  maxUint184,\n  maxUint192,\n  maxUint200,\n  maxUint208,\n  maxUint216,\n  maxUint224,\n  maxUint232,\n  maxUint240,\n  maxUint248,\n  maxUint256,\n  minInt8,\n  minInt16,\n  minInt24,\n  minInt32,\n  minInt40,\n  minInt48,\n  minInt56,\n  minInt64,\n  minInt72,\n  minInt80,\n  minInt88,\n  minInt96,\n  minInt104,\n  minInt112,\n  minInt120,\n  minInt128,\n  minInt136,\n  minInt144,\n  minInt152,\n  minInt160,\n  minInt168,\n  minInt176,\n  minInt184,\n  minInt192,\n  minInt200,\n  minInt208,\n  minInt216,\n  minInt224,\n  minInt232,\n  minInt240,\n  minInt248,\n  minInt256,\n} from './constants/number.js'\nexport { presignMessagePrefix } from './constants/strings.js'\nexport { etherUnits, gweiUnits, weiUnits } from './constants/unit.js'\nexport {\n  AbiConstructorNotFoundError,\n  type AbiConstructorNotFoundErrorType,\n  AbiConstructorParamsNotFoundError,\n  type AbiConstructorParamsNotFoundErrorType,\n  AbiDecodingDataSizeInvalidError,\n  type AbiDecodingDataSizeInvalidErrorType,\n  AbiDecodingDataSizeTooSmallError,\n  type AbiDecodingDataSizeTooSmallErrorType,\n  AbiDecodingZeroDataError,\n  type AbiDecodingZeroDataErrorType,\n  AbiEncodingArrayLengthMismatchError,\n  type AbiEncodingArrayLengthMismatchErrorType,\n  AbiEncodingBytesSizeMismatchError,\n  type AbiEncodingBytesSizeMismatchErrorType,\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  AbiErrorInputsNotFoundError,\n  type AbiErrorInputsNotFoundErrorType,\n  AbiErrorNotFoundError,\n  type AbiErrorNotFoundErrorType,\n  AbiErrorSignatureNotFoundError,\n  type AbiErrorSignatureNotFoundErrorType,\n  AbiEventNotFoundError,\n  type AbiEventNotFoundErrorType,\n  AbiEventSignatureEmptyTopicsError,\n  type AbiEventSignatureEmptyTopicsErrorType,\n  AbiEventSignatureNotFoundError,\n  type AbiEventSignatureNotFoundErrorType,\n  AbiFunctionNotFoundError,\n  type AbiFunctionNotFoundErrorType,\n  AbiFunctionOutputsNotFoundError,\n  type AbiFunctionOutputsNotFoundErrorType,\n  AbiFunctionSignatureNotFoundError,\n  type AbiFunctionSignatureNotFoundErrorType,\n  BytesSizeMismatchError,\n  type BytesSizeMismatchErrorType,\n  DecodeLogDataMismatch,\n  type DecodeLogDataMismatchErrorType,\n  DecodeLogTopicsMismatch,\n  type DecodeLogTopicsMismatchErrorType,\n  InvalidAbiDecodingTypeError,\n  type InvalidAbiDecodingTypeErrorType,\n  InvalidAbiEncodingTypeError,\n  type InvalidAbiEncodingTypeErrorType,\n  InvalidArrayError,\n  type InvalidArrayErrorType,\n  InvalidDefinitionTypeError,\n  type InvalidDefinitionTypeErrorType,\n  UnsupportedPackedAbiType,\n  type UnsupportedPackedAbiTypeErrorType,\n} from './errors/abi.js'\nexport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from './errors/address.js'\nexport { BaseError, type BaseErrorType, setErrorConfig } from './errors/base.js'\nexport {\n  BlockNotFoundError,\n  type BlockNotFoundErrorType,\n} from './errors/block.js'\nexport {\n  BundleFailedError,\n  type BundleFailedErrorType,\n} from './errors/calls.js'\nexport {\n  ChainDoesNotSupportContract,\n  type ChainDoesNotSupportContractErrorType,\n  ChainMismatchError,\n  type ChainMismatchErrorType,\n  ChainNotFoundError,\n  type ChainNotFoundErrorType,\n  ClientChainNotConfiguredError,\n  type ClientChainNotConfiguredErrorType,\n  InvalidChainIdError,\n  type InvalidChainIdErrorType,\n} from './errors/chain.js'\nexport {\n  CallExecutionError,\n  type CallExecutionErrorType,\n  ContractFunctionExecutionError,\n  type ContractFunctionExecutionErrorType,\n  ContractFunctionRevertedError,\n  type ContractFunctionRevertedErrorType,\n  ContractFunctionZeroDataError,\n  type ContractFunctionZeroDataErrorType,\n  CounterfactualDeploymentFailedError,\n  type CounterfactualDeploymentFailedErrorType,\n  RawContractError,\n  type RawContractErrorType,\n} from './errors/contract.js'\nexport {\n  SizeExceedsPaddingSizeError,\n  type SizeExceedsPaddingSizeErrorType,\n  SliceOffsetOutOfBoundsError,\n  type SliceOffsetOutOfBoundsErrorType,\n} from './errors/data.js'\nexport {\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n  InvalidBytesBooleanError,\n  type InvalidBytesBooleanErrorType,\n  InvalidHexBooleanError,\n  type InvalidHexBooleanErrorType,\n  InvalidHexValueError,\n  type InvalidHexValueErrorType,\n  SizeOverflowError,\n  type SizeOverflowErrorType,\n} from './errors/encoding.js'\nexport {\n  type EnsAvatarInvalidMetadataError,\n  type EnsAvatarInvalidMetadataErrorType,\n  EnsAvatarInvalidNftUriError,\n  type EnsAvatarInvalidNftUriErrorType,\n  EnsAvatarUnsupportedNamespaceError,\n  type EnsAvatarUnsupportedNamespaceErrorType,\n  EnsAvatarUriResolutionError,\n  type EnsAvatarUriResolutionErrorType,\n  EnsInvalidChainIdError,\n  type EnsInvalidChainIdErrorType,\n} from './errors/ens.js'\nexport {\n  EstimateGasExecutionError,\n  type EstimateGasExecutionErrorType,\n} from './errors/estimateGas.js'\nexport {\n  BaseFeeScalarError,\n  type BaseFeeScalarErrorType,\n  Eip1559FeesNotSupportedError,\n  type Eip1559FeesNotSupportedErrorType,\n  MaxFeePerGasTooLowError,\n  type MaxFeePerGasTooLowErrorType,\n} from './errors/fee.js'\nexport {\n  FilterTypeNotSupportedError,\n  type FilterTypeNotSupportedErrorType,\n} from './errors/log.js'\nexport {\n  ExecutionRevertedError,\n  type ExecutionRevertedErrorType,\n  FeeCapTooHighError,\n  type FeeCapTooHighErrorType,\n  FeeCapTooLowError,\n  type FeeCapTooLowErrorType,\n  InsufficientFundsError,\n  type InsufficientFundsErrorType,\n  IntrinsicGasTooHighError,\n  type IntrinsicGasTooHighErrorType,\n  IntrinsicGasTooLowError,\n  type IntrinsicGasTooLowErrorType,\n  NonceMaxValueError,\n  type NonceMaxValueErrorType,\n  NonceTooHighError,\n  type NonceTooHighErrorType,\n  NonceTooLowError,\n  type NonceTooLowErrorType,\n  TipAboveFeeCapError,\n  type TipAboveFeeCapErrorType,\n  TransactionTypeNotSupportedError,\n  type TransactionTypeNotSupportedErrorType,\n  UnknownNodeError,\n  type UnknownNodeErrorType,\n} from './errors/node.js'\nexport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n  RpcRequestError,\n  type RpcRequestErrorType,\n  SocketClosedError,\n  type SocketClosedErrorType,\n  TimeoutError,\n  type TimeoutErrorType,\n  WebSocketRequestError,\n  type WebSocketRequestErrorType,\n} from './errors/request.js'\nexport {\n  AtomicityNotSupportedError,\n  type AtomicityNotSupportedErrorType,\n  AtomicReadyWalletRejectedUpgradeError,\n  type AtomicReadyWalletRejectedUpgradeErrorType,\n  BundleTooLargeError,\n  type BundleTooLargeErrorType,\n  ChainDisconnectedError,\n  type ChainDisconnectedErrorType,\n  DuplicateIdError,\n  type DuplicateIdErrorType,\n  InternalRpcError,\n  type InternalRpcErrorType,\n  InvalidInputRpcError,\n  type InvalidInputRpcErrorType,\n  InvalidParamsRpcError,\n  type InvalidParamsRpcErrorType,\n  InvalidRequestRpcError,\n  type InvalidRequestRpcErrorType,\n  JsonRpcVersionUnsupportedError,\n  type JsonRpcVersionUnsupportedErrorType,\n  LimitExceededRpcError,\n  type LimitExceededRpcErrorType,\n  MethodNotFoundRpcError,\n  type MethodNotFoundRpcErrorType,\n  MethodNotSupportedRpcError,\n  type MethodNotSupportedRpcErrorType,\n  ParseRpcError,\n  type ParseRpcErrorType,\n  ProviderDisconnectedError,\n  type ProviderDisconnectedErrorType,\n  ProviderRpcError,\n  type ProviderRpcErrorCode,\n  type ProviderRpcErrorType,\n  ResourceNotFoundRpcError,\n  type ResourceNotFoundRpcErrorType,\n  ResourceUnavailableRpcError,\n  type ResourceUnavailableRpcErrorType,\n  RpcError,\n  type RpcErrorCode,\n  type RpcErrorType,\n  SwitchChainError,\n  TransactionRejectedRpcError,\n  type TransactionRejectedRpcErrorType,\n  UnauthorizedProviderError,\n  type UnauthorizedProviderErrorType,\n  UnknownBundleIdError,\n  type UnknownBundleIdErrorType,\n  UnknownRpcError,\n  type UnknownRpcErrorType,\n  UnsupportedChainIdError,\n  type UnsupportedChainIdErrorType,\n  UnsupportedNonOptionalCapabilityError,\n  type UnsupportedNonOptionalCapabilityErrorType,\n  UnsupportedProviderMethodError,\n  type UnsupportedProviderMethodErrorType,\n  UserRejectedRequestError,\n  type UserRejectedRequestErrorType,\n} from './errors/rpc.js'\nexport {\n  AccountStateConflictError,\n  type AccountStateConflictErrorType,\n  StateAssignmentConflictError,\n  type StateAssignmentConflictErrorType,\n} from './errors/stateOverride.js'\nexport {\n  FeeConflictError,\n  type FeeConflictErrorType,\n  InvalidLegacyVError,\n  type InvalidLegacyVErrorType,\n  InvalidSerializableTransactionError,\n  type InvalidSerializableTransactionErrorType,\n  InvalidSerializedTransactionError,\n  type InvalidSerializedTransactionErrorType,\n  InvalidSerializedTransactionTypeError,\n  type InvalidSerializedTransactionTypeErrorType,\n  InvalidStorageKeySizeError,\n  type InvalidStorageKeySizeErrorType,\n  TransactionExecutionError,\n  type TransactionExecutionErrorType,\n  TransactionNotFoundError,\n  type TransactionNotFoundErrorType,\n  TransactionReceiptNotFoundError,\n  type TransactionReceiptNotFoundErrorType,\n  WaitForTransactionReceiptTimeoutError,\n  type WaitForTransactionReceiptTimeoutErrorType,\n} from './errors/transaction.js'\nexport {\n  UrlRequiredError,\n  type UrlRequiredErrorType,\n} from './errors/transport.js'\nexport {\n  InvalidDomainError,\n  type InvalidDomainErrorType,\n  InvalidPrimaryTypeError,\n  type InvalidPrimaryTypeErrorType,\n  InvalidStructTypeError,\n  type InvalidStructTypeErrorType,\n} from './errors/typedData.js'\nexport {\n  InvalidDecimalNumberError,\n  type InvalidDecimalNumberErrorType,\n} from './errors/unit.js'\nexport type {\n  DeriveAccount,\n  HDKey,\n  ParseAccount,\n} from './types/account.js'\nexport type {\n  Authorization,\n  AuthorizationList,\n  AuthorizationRequest,\n  SerializedAuthorization,\n  SerializedAuthorizationList,\n  SignedAuthorization,\n  SignedAuthorizationList,\n} from './types/authorization.js'\nexport type {\n  Block,\n  BlockIdentifier,\n  BlockNumber,\n  BlockTag,\n  Uncle,\n} from './types/block.js'\nexport type { Call, Calls } from './types/calls.js'\nexport type {\n  Capabilities,\n  /** @deprecated Use `Capabilities` instead. */\n  Capabilities as WalletCapabilities,\n  CapabilitiesSchema,\n  /** @deprecated Use `ChainIdToCapabilities` instead. */\n  ChainIdToCapabilities as WalletCapabilitiesRecord,\n  ChainIdToCapabilities,\n  ExtractCapabilities,\n} from './types/capabilities.js'\nexport type {\n  Chain,\n  ChainConfig,\n  ChainContract,\n  ChainEstimateFeesPerGasFn,\n  ChainEstimateFeesPerGasFnParameters,\n  ChainFees,\n  ChainFeesFnParameters,\n  ChainFormatter,\n  ChainFormatters,\n  ChainMaxPriorityFeePerGasFn,\n  ChainSerializers,\n  DeriveChain,\n  ExtractChainFormatterExclude,\n  ExtractChainFormatterParameters,\n  ExtractChainFormatterReturnType,\n  GetChainParameter,\n} from './types/chain.js'\nexport type {\n  AbiEventParametersToPrimitiveTypes,\n  AbiEventParameterToPrimitiveType,\n  AbiEventTopicToPrimitiveType,\n  AbiItem,\n  AbiItemArgs,\n  AbiItemName,\n  ContractConstructorArgs,\n  ContractErrorArgs,\n  ContractErrorName,\n  ContractEventArgs,\n  ContractEventArgsFromTopics,\n  ContractEventName,\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  ContractFunctionReturnType,\n  EventDefinition,\n  ExtractAbiFunctionForArgs,\n  ExtractAbiItem,\n  ExtractAbiItemForArgs,\n  ExtractAbiItemNames,\n  GetEventArgs,\n  GetValue,\n  LogTopicType,\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n  UnionWiden,\n  Widen,\n} from './types/contract.js'\nexport type {\n  AddEthereumChainParameter,\n  BundlerRpcSchema,\n  DebugBundlerRpcSchema,\n  EIP1193EventMap,\n  EIP1193Events,\n  EIP1193Parameters,\n  EIP1193Provider,\n  EIP1193RequestFn,\n  EIP1474Methods,\n  NetworkSync,\n  PaymasterRpcSchema,\n  ProviderConnectInfo,\n  ProviderMessage,\n  ProviderRpcErrorType as EIP1193ProviderRpcErrorType,\n  PublicRpcSchema,\n  RpcSchema,\n  RpcSchemaOverride,\n  TestRpcSchema,\n  WalletCallReceipt,\n  WalletGetAssetsParameters,\n  WalletGetAssetsReturnType,\n  WalletGetCallsStatusReturnType,\n  WalletGrantPermissionsParameters,\n  WalletGrantPermissionsReturnType,\n  WalletPermission,\n  WalletPermissionCaveat,\n  WalletRpcSchema,\n  WalletSendCallsParameters,\n  WalletSendCallsReturnType,\n  WatchAssetParams,\n} from './types/eip1193.js'\nexport { ProviderRpcError as EIP1193ProviderRpcError } from './types/eip1193.js'\nexport type { BlobSidecar, BlobSidecars } from './types/eip4844.js'\nexport type { AssetGateway, AssetGatewayUrls } from './types/ens.js'\nexport type {\n  FeeHistory,\n  FeeValues,\n  FeeValuesEIP1559,\n  FeeValuesEIP4844,\n  FeeValuesLegacy,\n  FeeValuesType,\n} from './types/fee.js'\nexport type { Filter, FilterType } from './types/filter.js'\nexport type { GetTransactionRequestKzgParameter, Kzg } from './types/kzg.js'\nexport type { Log } from './types/log.js'\nexport type {\n  ByteArray,\n  CompactSignature,\n  Hash,\n  Hex,\n  LogTopic,\n  SignableMessage,\n  Signature,\n} from './types/misc.js'\nexport type {\n  MulticallContracts,\n  MulticallResponse,\n  MulticallResults,\n} from './types/multicall.js'\nexport type { Register, ResolvedRegister } from './types/register.js'\nexport type {\n  Index,\n  Quantity,\n  RpcAccountStateOverride,\n  RpcAuthorization,\n  RpcAuthorizationList,\n  RpcBlock,\n  RpcBlockIdentifier,\n  RpcBlockNumber,\n  RpcFeeHistory,\n  RpcFeeValues,\n  RpcLog,\n  RpcProof,\n  RpcStateMapping,\n  RpcStateOverride,\n  RpcTransaction,\n  RpcTransactionReceipt,\n  RpcTransactionRequest,\n  RpcUncle,\n  Status,\n} from './types/rpc.js'\nexport type {\n  StateMapping,\n  StateOverride,\n} from './types/stateOverride.js'\nexport type {\n  AccessList,\n  Transaction,\n  TransactionBase,\n  TransactionEIP1559,\n  TransactionEIP2930,\n  TransactionEIP4844,\n  TransactionEIP7702,\n  TransactionLegacy,\n  TransactionReceipt,\n  TransactionRequest,\n  TransactionRequestBase,\n  TransactionRequestEIP1559,\n  TransactionRequestEIP2930,\n  TransactionRequestEIP4844,\n  TransactionRequestEIP7702,\n  TransactionRequestGeneric,\n  TransactionRequestLegacy,\n  TransactionSerializable,\n  TransactionSerializableBase,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableEIP7702,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n  TransactionSerialized,\n  TransactionSerializedEIP1559,\n  TransactionSerializedEIP2930,\n  TransactionSerializedEIP4844,\n  TransactionSerializedEIP7702,\n  TransactionSerializedGeneric,\n  TransactionSerializedLegacy,\n  TransactionType,\n} from './types/transaction.js'\nexport type { GetPollOptions, GetTransportConfig } from './types/transport.js'\nexport type {\n  EIP712DomainDefinition,\n  MessageDefinition,\n  TypedDataDefinition,\n} from './types/typedData.js'\nexport type {\n  Assign,\n  Branded,\n  Evaluate,\n  ExactPartial,\n  ExactRequired,\n  IsNarrowable,\n  IsNever,\n  IsUndefined,\n  IsUnion,\n  LooseOmit,\n  MaybePartial,\n  MaybePromise,\n  MaybeRequired,\n  Mutable,\n  NoInfer,\n  NoUndefined,\n  Omit,\n  OneOf,\n  Or,\n  PartialBy,\n  Prettify,\n  RequiredBy,\n  Some,\n  UnionEvaluate,\n  UnionLooseOmit,\n  UnionOmit,\n  UnionPartialBy,\n  UnionPick,\n  UnionRequiredBy,\n  UnionToTuple,\n  ValueOf,\n} from './types/utils.js'\nexport type { Withdrawal } from './types/withdrawal.js'\nexport {\n  type DecodeAbiParametersErrorType,\n  type DecodeAbiParametersReturnType,\n  decodeAbiParameters,\n} from './utils/abi/decodeAbiParameters.js'\nexport {\n  type DecodeDeployDataErrorType,\n  type DecodeDeployDataParameters,\n  type DecodeDeployDataReturnType,\n  decodeDeployData,\n} from './utils/abi/decodeDeployData.js'\nexport {\n  type DecodeErrorResultErrorType,\n  type DecodeErrorResultParameters,\n  type DecodeErrorResultReturnType,\n  decodeErrorResult,\n} from './utils/abi/decodeErrorResult.js'\nexport {\n  type DecodeEventLogErrorType,\n  type DecodeEventLogParameters,\n  type DecodeEventLogReturnType,\n  decodeEventLog,\n} from './utils/abi/decodeEventLog.js'\nexport {\n  type DecodeFunctionDataErrorType,\n  type DecodeFunctionDataParameters,\n  type DecodeFunctionDataReturnType,\n  decodeFunctionData,\n} from './utils/abi/decodeFunctionData.js'\nexport {\n  type DecodeFunctionResultErrorType,\n  type DecodeFunctionResultParameters,\n  type DecodeFunctionResultReturnType,\n  decodeFunctionResult,\n} from './utils/abi/decodeFunctionResult.js'\nexport {\n  type EncodeAbiParametersErrorType,\n  type EncodeAbiParametersReturnType,\n  encodeAbiParameters,\n} from './utils/abi/encodeAbiParameters.js'\nexport {\n  type EncodeDeployDataErrorType,\n  type EncodeDeployDataParameters,\n  type EncodeDeployDataReturnType,\n  encodeDeployData,\n} from './utils/abi/encodeDeployData.js'\nexport {\n  type EncodeErrorResultErrorType,\n  type EncodeErrorResultParameters,\n  type EncodeErrorResultReturnType,\n  encodeErrorResult,\n} from './utils/abi/encodeErrorResult.js'\nexport {\n  type EncodeEventTopicsErrorType,\n  type EncodeEventTopicsParameters,\n  type EncodeEventTopicsReturnType,\n  encodeEventTopics,\n} from './utils/abi/encodeEventTopics.js'\nexport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  type EncodeFunctionDataReturnType,\n  encodeFunctionData,\n} from './utils/abi/encodeFunctionData.js'\nexport {\n  type EncodeFunctionResultErrorType,\n  type EncodeFunctionResultParameters,\n  type EncodeFunctionResultReturnType,\n  encodeFunctionResult,\n} from './utils/abi/encodeFunctionResult.js'\nexport {\n  type EncodePackedErrorType,\n  encodePacked,\n} from './utils/abi/encodePacked.js'\nexport {\n  type GetAbiItemErrorType,\n  type GetAbiItemParameters,\n  type GetAbiItemReturnType,\n  getAbiItem,\n} from './utils/abi/getAbiItem.js'\nexport {\n  type ParseEventLogsErrorType,\n  type ParseEventLogsParameters,\n  type ParseEventLogsReturnType,\n  parseEventLogs,\n} from './utils/abi/parseEventLogs.js'\nexport {\n  type PrepareEncodeFunctionDataErrorType,\n  type PrepareEncodeFunctionDataParameters,\n  type PrepareEncodeFunctionDataReturnType,\n  prepareEncodeFunctionData,\n} from './utils/abi/prepareEncodeFunctionData.js'\nexport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n  type GetAddressErrorType,\n  getAddress,\n} from './utils/address/getAddress.js'\nexport {\n  type GetContractAddressOptions,\n  type GetCreate2AddressErrorType,\n  type GetCreate2AddressOptions,\n  type GetCreateAddressErrorType,\n  type GetCreateAddressOptions,\n  getContractAddress,\n  getCreate2Address,\n  getCreateAddress,\n} from './utils/address/getContractAddress.js'\nexport {\n  type IsAddressErrorType,\n  type IsAddressOptions,\n  isAddress,\n} from './utils/address/isAddress.js'\nexport {\n  type IsAddressEqualErrorType,\n  type IsAddressEqualReturnType,\n  isAddressEqual,\n} from './utils/address/isAddressEqual.js'\nexport {\n  type BlobsToCommitmentsErrorType,\n  type BlobsToCommitmentsParameters,\n  type BlobsToCommitmentsReturnType,\n  blobsToCommitments,\n} from './utils/blob/blobsToCommitments.js'\nexport {\n  blobsToProofs,\n  type blobsToProofsErrorType,\n  type blobsToProofsParameters,\n  type blobsToProofsReturnType,\n} from './utils/blob/blobsToProofs.js'\nexport {\n  type CommitmentsToVersionedHashesErrorType,\n  type CommitmentsToVersionedHashesParameters,\n  type CommitmentsToVersionedHashesReturnType,\n  commitmentsToVersionedHashes,\n} from './utils/blob/commitmentsToVersionedHashes.js'\nexport {\n  type CommitmentToVersionedHashErrorType,\n  type CommitmentToVersionedHashParameters,\n  type CommitmentToVersionedHashReturnType,\n  commitmentToVersionedHash,\n} from './utils/blob/commitmentToVersionedHash.js'\nexport {\n  type FromBlobsErrorType,\n  type FromBlobsParameters,\n  type FromBlobsReturnType,\n  fromBlobs,\n} from './utils/blob/fromBlobs.js'\nexport {\n  type SidecarsToVersionedHashesErrorType,\n  type SidecarsToVersionedHashesParameters,\n  type SidecarsToVersionedHashesReturnType,\n  sidecarsToVersionedHashes,\n} from './utils/blob/sidecarsToVersionedHashes.js'\nexport {\n  type ToBlobSidecarsErrorType,\n  type ToBlobSidecarsParameters,\n  type ToBlobSidecarsReturnType,\n  toBlobSidecars,\n} from './utils/blob/toBlobSidecars.js'\nexport {\n  type ToBlobsErrorType,\n  type ToBlobsParameters,\n  type ToBlobsReturnType,\n  toBlobs,\n} from './utils/blob/toBlobs.js'\nexport {\n  type CcipRequestErrorType,\n  type CcipRequestParameters,\n  ccipRequest,\n  /** @deprecated Use `ccipRequest`. */\n  ccipRequest as ccipFetch,\n  type OffchainLookupErrorType,\n  offchainLookup,\n  offchainLookupAbiItem,\n  offchainLookupSignature,\n} from './utils/ccip.js'\nexport {\n  type AssertCurrentChainErrorType,\n  type AssertCurrentChainParameters,\n  assertCurrentChain,\n} from './utils/chain/assertCurrentChain.js'\nexport {\n  type DefineChainReturnType,\n  defineChain,\n  extendSchema,\n} from './utils/chain/defineChain.js'\nexport {\n  type ExtractChainErrorType,\n  type ExtractChainParameters,\n  type ExtractChainReturnType,\n  extractChain,\n} from './utils/chain/extractChain.js'\nexport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from './utils/chain/getChainContractAddress.js'\nexport {\n  type ConcatBytesErrorType,\n  type ConcatErrorType,\n  type ConcatHexErrorType,\n  type ConcatReturnType,\n  concat,\n  concatBytes,\n  concatHex,\n} from './utils/data/concat.js'\nexport { type IsBytesErrorType, isBytes } from './utils/data/isBytes.js'\nexport { type IsHexErrorType, isHex } from './utils/data/isHex.js'\nexport {\n  type PadBytesErrorType,\n  type PadErrorType,\n  type PadHexErrorType,\n  type PadReturnType,\n  pad,\n  padBytes,\n  padHex,\n} from './utils/data/pad.js'\nexport { type SizeErrorType, size } from './utils/data/size.js'\nexport {\n  type SliceBytesErrorType,\n  type SliceErrorType,\n  type SliceHexErrorType,\n  slice,\n  sliceBytes,\n  sliceHex,\n} from './utils/data/slice.js'\nexport {\n  type TrimErrorType,\n  type TrimReturnType,\n  trim,\n} from './utils/data/trim.js'\nexport {\n  type BytesToBigIntErrorType,\n  type BytesToBigIntOpts,\n  type BytesToBoolErrorType,\n  type BytesToBoolOpts,\n  type BytesToNumberErrorType,\n  type BytesToNumberOpts,\n  type BytesToStringErrorType,\n  type BytesToStringOpts,\n  bytesToBigInt,\n  bytesToBool,\n  bytesToNumber,\n  bytesToString,\n  type FromBytesErrorType,\n  type FromBytesParameters,\n  fromBytes,\n} from './utils/encoding/fromBytes.js'\nexport {\n  type FromHexErrorType,\n  fromHex,\n  type HexToBigIntErrorType,\n  type HexToBoolErrorType,\n  type HexToNumberErrorType,\n  type HexToStringErrorType,\n  hexToBigInt,\n  hexToBool,\n  hexToNumber,\n  hexToString,\n} from './utils/encoding/fromHex.js'\nexport {\n  type FromRlpErrorType,\n  type FromRlpReturnType,\n  fromRlp,\n} from './utils/encoding/fromRlp.js'\nexport {\n  type BoolToBytesErrorType,\n  type BoolToBytesOpts,\n  boolToBytes,\n  type HexToBytesErrorType,\n  type HexToBytesOpts,\n  hexToBytes,\n  type NumberToBytesErrorType,\n  numberToBytes,\n  type StringToBytesErrorType,\n  type StringToBytesOpts,\n  stringToBytes,\n  type ToBytesErrorType,\n  type ToBytesParameters,\n  toBytes,\n} from './utils/encoding/toBytes.js'\nexport {\n  type BoolToHexErrorType,\n  type BoolToHexOpts,\n  type BytesToHexErrorType,\n  type BytesToHexOpts,\n  boolToHex,\n  bytesToHex,\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n  type StringToHexErrorType,\n  type StringToHexOpts,\n  stringToHex,\n  type ToHexErrorType,\n  type ToHexParameters,\n  toHex,\n} from './utils/encoding/toHex.js'\nexport {\n  type BytesToRlpErrorType,\n  bytesToRlp,\n  type HexToRlpErrorType,\n  hexToRlp,\n  type ToRlpErrorType,\n  type ToRlpReturnType,\n  toRlp,\n} from './utils/encoding/toRlp.js'\nexport { type LabelhashErrorType, labelhash } from './utils/ens/labelhash.js'\nexport { type NamehashErrorType, namehash } from './utils/ens/namehash.js'\nexport {\n  type ToCoinTypeError,\n  toCoinType,\n} from './utils/ens/toCoinType.js'\nexport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from './utils/errors/getContractError.js'\nexport {\n  type DefineBlockErrorType,\n  defineBlock,\n  type FormatBlockErrorType,\n  type FormattedBlock,\n  formatBlock,\n} from './utils/formatters/block.js'\nexport { type FormatLogErrorType, formatLog } from './utils/formatters/log.js'\nexport {\n  type DefineTransactionErrorType,\n  defineTransaction,\n  type FormatTransactionErrorType,\n  type FormattedTransaction,\n  formatTransaction,\n  transactionType,\n} from './utils/formatters/transaction.js'\nexport {\n  type DefineTransactionReceiptErrorType,\n  defineTransactionReceipt,\n  type FormatTransactionReceiptErrorType,\n  type FormattedTransactionReceipt,\n  formatTransactionReceipt,\n} from './utils/formatters/transactionReceipt.js'\nexport {\n  type DefineTransactionRequestErrorType,\n  defineTransactionRequest,\n  type FormatTransactionRequestErrorType,\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n  rpcTransactionType,\n} from './utils/formatters/transactionRequest.js'\nexport { type IsHashErrorType, isHash } from './utils/hash/isHash.js'\nexport {\n  type Keccak256ErrorType,\n  type Keccak256Hash,\n  keccak256,\n} from './utils/hash/keccak256.js'\nexport {\n  type Ripemd160ErrorType,\n  type Ripemd160Hash,\n  ripemd160,\n} from './utils/hash/ripemd160.js'\nexport {\n  type Sha256ErrorType,\n  type Sha256Hash,\n  sha256,\n} from './utils/hash/sha256.js'\nexport {\n  type ToEventHashErrorType,\n  toEventHash,\n} from './utils/hash/toEventHash.js'\nexport {\n  type ToEventSelectorErrorType,\n  /** @deprecated use `ToEventSelectorErrorType`. */\n  type ToEventSelectorErrorType as GetEventSelectorErrorType,\n  toEventSelector,\n  /** @deprecated use `toEventSelector`. */\n  toEventSelector as getEventSelector,\n} from './utils/hash/toEventSelector.js'\nexport {\n  type ToEventSignatureErrorType,\n  /** @deprecated use `ToEventSignatureErrorType`. */\n  type ToEventSignatureErrorType as GetEventSignatureErrorType,\n  toEventSignature,\n  /** @deprecated use `toEventSignature`. */\n  toEventSignature as getEventSignature,\n} from './utils/hash/toEventSignature.js'\nexport {\n  type ToFunctionHashErrorType,\n  toFunctionHash,\n} from './utils/hash/toFunctionHash.js'\nexport {\n  type ToFunctionSelectorErrorType,\n  /** @deprecated use `ToFunctionSelectorErrorType`. */\n  type ToFunctionSelectorErrorType as GetFunctionSelectorErrorType,\n  toFunctionSelector,\n  /** @deprecated use `toFunctionSelector`. */\n  toFunctionSelector as getFunctionSelector,\n} from './utils/hash/toFunctionSelector.js'\nexport {\n  type ToFunctionSignatureErrorType,\n  /** @deprecated use `ToFunctionSignatureErrorType`. */\n  type ToFunctionSignatureErrorType as GetFunctionSignatureErrorType,\n  toFunctionSignature,\n  /** @deprecated use `toFunctionSignature`. */\n  toFunctionSignature as getFunctionSignature,\n} from './utils/hash/toFunctionSignature.js'\nexport {\n  type DefineKzgErrorType,\n  type DefineKzgParameters,\n  type DefineKzgReturnType,\n  defineKzg,\n} from './utils/kzg/defineKzg.js'\nexport {\n  type SetupKzgErrorType,\n  type SetupKzgParameters,\n  type SetupKzgReturnType,\n  setupKzg,\n} from './utils/kzg/setupKzg.js'\nexport {\n  type CreateNonceManagerParameters,\n  createNonceManager,\n  type NonceManager,\n  type NonceManagerSource,\n  nonceManager,\n} from './utils/nonceManager.js'\nexport { withCache } from './utils/promise/withCache.js'\nexport {\n  type WithRetryErrorType,\n  withRetry,\n} from './utils/promise/withRetry.js'\nexport {\n  type WithTimeoutErrorType,\n  withTimeout,\n} from './utils/promise/withTimeout.js'\nexport {\n  type CompactSignatureToSignatureErrorType,\n  compactSignatureToSignature,\n} from './utils/signature/compactSignatureToSignature.js'\nexport {\n  type HashMessageErrorType,\n  hashMessage,\n} from './utils/signature/hashMessage.js'\nexport {\n  type HashDomainErrorType,\n  type HashStructErrorType,\n  type HashTypedDataErrorType,\n  type HashTypedDataParameters,\n  type HashTypedDataReturnType,\n  hashDomain,\n  hashStruct,\n  hashTypedData,\n} from './utils/signature/hashTypedData.js'\nexport {\n  type IsErc6492SignatureErrorType,\n  type IsErc6492SignatureParameters,\n  type IsErc6492SignatureReturnType,\n  isErc6492Signature,\n} from './utils/signature/isErc6492Signature.js'\nexport {\n  type IsErc8010SignatureErrorType,\n  type IsErc8010SignatureParameters,\n  type IsErc8010SignatureReturnType,\n  isErc8010Signature,\n} from './utils/signature/isErc8010Signature.js'\nexport {\n  /** @deprecated Use `ParseCompactSignatureErrorType`. */\n  type ParseCompactSignatureErrorType as HexToCompactSignatureErrorType,\n  type ParseCompactSignatureErrorType,\n  /** @deprecated Use `parseCompactSignature`. */\n  parseCompactSignature as hexToCompactSignature,\n  parseCompactSignature,\n} from './utils/signature/parseCompactSignature.js'\nexport {\n  type ParseErc6492SignatureErrorType,\n  type ParseErc6492SignatureParameters,\n  type ParseErc6492SignatureReturnType,\n  parseErc6492Signature,\n} from './utils/signature/parseErc6492Signature.js'\nexport {\n  type ParseErc8010SignatureErrorType,\n  type ParseErc8010SignatureParameters,\n  type ParseErc8010SignatureReturnType,\n  parseErc8010Signature,\n} from './utils/signature/parseErc8010Signature.js'\nexport {\n  /** @deprecated Use `ParseSignatureErrorType`. */\n  type ParseSignatureErrorType as HexToSignatureErrorType,\n  type ParseSignatureErrorType,\n  /** @deprecated Use `parseSignature`. */\n  parseSignature as hexToSignature,\n  parseSignature,\n} from './utils/signature/parseSignature.js'\nexport {\n  type RecoverAddressErrorType,\n  type RecoverAddressParameters,\n  type RecoverAddressReturnType,\n  recoverAddress,\n} from './utils/signature/recoverAddress.js'\nexport {\n  type RecoverMessageAddressErrorType,\n  type RecoverMessageAddressParameters,\n  type RecoverMessageAddressReturnType,\n  recoverMessageAddress,\n} from './utils/signature/recoverMessageAddress.js'\nexport {\n  type RecoverPublicKeyErrorType,\n  type RecoverPublicKeyParameters,\n  type RecoverPublicKeyReturnType,\n  recoverPublicKey,\n} from './utils/signature/recoverPublicKey.js'\nexport {\n  type RecoverTransactionAddressErrorType,\n  type RecoverTransactionAddressParameters,\n  type RecoverTransactionAddressReturnType,\n  recoverTransactionAddress,\n} from './utils/signature/recoverTransactionAddress.js'\nexport {\n  type RecoverTypedDataAddressErrorType,\n  type RecoverTypedDataAddressParameters,\n  type RecoverTypedDataAddressReturnType,\n  recoverTypedDataAddress,\n} from './utils/signature/recoverTypedDataAddress.js'\nexport {\n  /** @deprecated Use `SignatureToHexErrorType` instead. */\n  type SerializeCompactSignatureErrorType as CompactSignatureToHexErrorType,\n  type SerializeCompactSignatureErrorType,\n  /** @deprecated Use `serializeCompactSignature` instead. */\n  serializeCompactSignature as compactSignatureToHex,\n  serializeCompactSignature,\n} from './utils/signature/serializeCompactSignature.js'\nexport {\n  type SerializeErc6492SignatureErrorType,\n  type SerializeErc6492SignatureParameters,\n  type SerializeErc6492SignatureReturnType,\n  serializeErc6492Signature,\n} from './utils/signature/serializeErc6492Signature.js'\nexport {\n  type SerializeErc8010SignatureErrorType,\n  type SerializeErc8010SignatureParameters,\n  type SerializeErc8010SignatureReturnType,\n  serializeErc8010Signature,\n} from './utils/signature/serializeErc8010Signature.js'\nexport {\n  /** @deprecated Use `SignatureToHexErrorType` instead. */\n  type SerializeSignatureErrorType as SignatureToHexErrorType,\n  type SerializeSignatureErrorType,\n  type SerializeSignatureParameters,\n  type SerializeSignatureReturnType,\n  /** @deprecated Use `serializeSignature` instead. */\n  serializeSignature as signatureToHex,\n  serializeSignature,\n} from './utils/signature/serializeSignature.js'\nexport {\n  type SignatureToCompactSignatureErrorType,\n  signatureToCompactSignature,\n} from './utils/signature/signatureToCompactSignature.js'\nexport {\n  type ToPrefixedMessageErrorType,\n  toPrefixedMessage,\n} from './utils/signature/toPrefixedMessage.js'\nexport {\n  type VerifyHashErrorType,\n  type VerifyHashParameters,\n  type VerifyHashReturnType,\n  verifyHash,\n} from './utils/signature/verifyHash.js'\nexport {\n  type VerifyMessageErrorType,\n  type VerifyMessageParameters,\n  type VerifyMessageReturnType,\n  verifyMessage,\n} from './utils/signature/verifyMessage.js'\nexport {\n  type VerifyTypedDataErrorType,\n  type VerifyTypedDataParameters,\n  type VerifyTypedDataReturnType,\n  verifyTypedData,\n} from './utils/signature/verifyTypedData.js'\nexport { type StringifyErrorType, stringify } from './utils/stringify.js'\nexport {\n  type AssertRequestErrorType,\n  assertRequest,\n} from './utils/transaction/assertRequest.js'\nexport {\n  type AssertTransactionEIP1559ErrorType,\n  type AssertTransactionEIP2930ErrorType,\n  type AssertTransactionLegacyErrorType,\n  assertTransactionEIP1559,\n  assertTransactionEIP2930,\n  assertTransactionLegacy,\n} from './utils/transaction/assertTransaction.js'\nexport {\n  type GetSerializedTransactionType,\n  type GetSerializedTransactionTypeErrorType,\n  getSerializedTransactionType,\n} from './utils/transaction/getSerializedTransactionType.js'\nexport {\n  type GetTransactionType,\n  type GetTransactionTypeErrorType,\n  getTransactionType,\n} from './utils/transaction/getTransactionType.js'\nexport {\n  type ParseTransactionErrorType,\n  type ParseTransactionReturnType,\n  parseTransaction,\n} from './utils/transaction/parseTransaction.js'\nexport {\n  type SerializeAccessListErrorType,\n  serializeAccessList,\n} from './utils/transaction/serializeAccessList.js'\nexport {\n  type SerializedTransactionReturnType,\n  type SerializeTransactionErrorType,\n  type SerializeTransactionFn,\n  serializeTransaction,\n} from './utils/transaction/serializeTransaction.js'\nexport {\n  type DomainSeparatorErrorType,\n  domainSeparator,\n  type GetTypesForEIP712DomainErrorType,\n  getTypesForEIP712Domain,\n  type SerializeTypedDataErrorType,\n  serializeTypedData,\n  type ValidateTypedDataErrorType,\n  validateTypedData,\n} from './utils/typedData.js'\nexport {\n  type FormatEtherErrorType,\n  formatEther,\n} from './utils/unit/formatEther.js'\nexport {\n  type FormatGweiErrorType,\n  formatGwei,\n} from './utils/unit/formatGwei.js'\nexport {\n  type FormatUnitsErrorType,\n  formatUnits,\n} from './utils/unit/formatUnits.js'\nexport {\n  type ParseEtherErrorType,\n  parseEther,\n} from './utils/unit/parseEther.js'\nexport { type ParseGweiErrorType, parseGwei } from './utils/unit/parseGwei.js'\nexport {\n  type ParseUnitsErrorType,\n  parseUnits,\n} from './utils/unit/parseUnits.js'\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type CreateCursorErrorType, createCursor } from '../cursor.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type FromBlobsParameters<\n  blobs extends readonly Hex[] | readonly ByteArray[] =\n    | readonly Hex[]\n    | readonly ByteArray[],\n  to extends To | undefined = undefined,\n> = {\n  /** Blobs to transform to data. */\n  blobs: blobs | readonly Hex[] | readonly ByteArray[]\n  to?: to | To | undefined\n}\n\nexport type FromBlobsReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type FromBlobsErrorType =\n  | BytesToHexErrorType\n  | CreateCursorErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function fromBlobs<\n  const blobs extends readonly Hex[] | readonly ByteArray[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(parameters: FromBlobsParameters<blobs, to>): FromBlobsReturnType<to> {\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as Hex))\n      : parameters.blobs\n  ) as ByteArray[]\n\n  const length = blobs.reduce((length, blob) => length + blob.length, 0)\n  const data = createCursor(new Uint8Array(length))\n  let active = true\n\n  for (const blob of blobs) {\n    const cursor = createCursor(blob)\n    while (active && cursor.position < blob.length) {\n      // First byte will be a zero 0x00 byte â€“ we can skip.\n      cursor.incrementPosition(1)\n\n      let consume = 31\n      if (blob.length - cursor.position < 31)\n        consume = blob.length - cursor.position\n\n      for (const _ in Array.from({ length: consume })) {\n        const byte = cursor.readByte()\n        const isTerminator =\n          byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80)\n        if (isTerminator) {\n          active = false\n          break\n        }\n        data.pushByte(byte)\n      }\n    }\n  }\n\n  const trimmedData = data.bytes.slice(0, data.position)\n  return (\n    to === 'hex' ? bytesToHex(trimmedData) : trimmedData\n  ) as FromBlobsReturnType<to>\n}\n","// TODO(v3): This file is here for backwards compatibility, and to prevent breaking changes.\n// These APIs will be removed in v3.\n\n/* c8 ignore start */\nimport type {\n  TimeoutErrorType,\n  WebSocketRequestError,\n} from '../../errors/request.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { RpcResponse } from '../../types/rpc.js'\nimport type { WithTimeoutErrorType } from '../promise/withTimeout.js'\nimport { getHttpRpcClient, type HttpRequestParameters } from './http.js'\nimport type { SocketRpcClient } from './socket.js'\nimport { getWebSocketRpcClient } from './webSocket.js'\n\nexport type WebSocketOptions = Parameters<\n  SocketRpcClient<WebSocket>['request']\n>[0]\nexport type WebSocketReturnType = SocketRpcClient<WebSocket>\nexport type WebSocketErrorType = WebSocketRequestError | ErrorType\n\nfunction webSocket(\n  socketClient: SocketRpcClient<WebSocket>,\n  { body, onError, onResponse }: WebSocketOptions,\n): WebSocketReturnType {\n  socketClient.request({\n    body,\n    onError,\n    onResponse,\n  })\n  return socketClient\n}\n\nexport type WebSocketAsyncOptions = Parameters<\n  SocketRpcClient<WebSocket>['requestAsync']\n>[0]\nexport type WebSocketAsyncReturnType = RpcResponse\nexport type WebSocketAsyncErrorType =\n  | WebSocketErrorType\n  | TimeoutErrorType\n  | WithTimeoutErrorType\n  | ErrorType\n\nasync function webSocketAsync(\n  socketClient: SocketRpcClient<WebSocket>,\n  { body, timeout = 10_000 }: WebSocketAsyncOptions,\n): Promise<WebSocketAsyncReturnType> {\n  return socketClient.requestAsync({\n    body,\n    timeout,\n  })\n}\n\n/**\n * @deprecated use `getSocketClient` instead.\n *\n * ```diff\n * -import { getSocket } from 'viem/utils'\n * +import { getSocketClient } from 'viem/utils'\n *\n * -const socket = await getSocket(url)\n * +const socketClient = await getSocketClient(url)\n * +const socket = socketClient.socket\n * ```\n */\nexport async function getSocket(url: string) {\n  const client = await getWebSocketRpcClient(url)\n  return Object.assign(client.socket, {\n    requests: client.requests,\n    subscriptions: client.subscriptions,\n  })\n}\n\nexport const rpc = {\n  /**\n   * @deprecated use `getHttpRpcClient` instead.\n   *\n   * ```diff\n   * -import { rpc } from 'viem/utils'\n   * +import { getHttpRpcClient } from 'viem/utils'\n   *\n   * -rpc.http(url, params)\n   * +const httpClient = getHttpRpcClient(url)\n   * +httpClient.request(params)\n   * ```\n   */\n  http(url: string, params: HttpRequestParameters) {\n    return getHttpRpcClient(url).request(params)\n  },\n  /**\n   * @deprecated use `getWebSocketRpcClient` instead.\n   *\n   * ```diff\n   * -import { rpc } from 'viem/utils'\n   * +import { getWebSocketRpcClient } from 'viem/utils'\n   *\n   * -rpc.webSocket(url, params)\n   * +const webSocketClient = getWebSocketRpcClient(url)\n   * +webSocketClient.request(params)\n   * ```\n   */\n  webSocket,\n  /**\n   * @deprecated use `getWebSocketRpcClient` instead.\n   *\n   * ```diff\n   * -import { rpc } from 'viem/utils'\n   * +import { getWebSocketRpcClient } from 'viem/utils'\n   *\n   * -const response = await rpc.webSocketAsync(url, params)\n   * +const webSocketClient = getWebSocketRpcClient(url)\n   * +const response = await webSocketClient.requestAsync(params)\n   * ```\n   */\n  webSocketAsync,\n}\n/* c8 ignore end */\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\n\nexport type DefineKzgParameters = Kzg\nexport type DefineKzgReturnType = Kzg\nexport type DefineKzgErrorType = ErrorType\n\n/**\n * Defines a KZG interface.\n *\n * @example\n * ```ts\n * import * as cKzg from 'c-kzg'\n * import { defineKzg } from 'viem'\n * import { mainnetTrustedSetupPath } from 'viem/node'\n *\n * cKzg.loadTrustedSetup(mainnetTrustedSetupPath)\n *\n * const kzg = defineKzg(cKzg)\n * ```\n */\nexport function defineKzg({\n  blobToKzgCommitment,\n  computeBlobKzgProof,\n}: DefineKzgParameters): DefineKzgReturnType {\n  return {\n    blobToKzgCommitment,\n    computeBlobKzgProof,\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type InspectTxpoolReturnType = {\n  pending: Record<Address, Record<string, string>>\n  queued: Record<Address, Record<string, string>>\n}\n\nexport type InspectTxpoolErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns a summary of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.\n *\n * - Docs: https://viem.sh/docs/actions/test/inspectTxpool\n *\n * @param client - Client to use\n * @returns Transaction pool inspection data. {@link InspectTxpoolReturnType}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { inspectTxpool } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * const data = await inspectTxpool(client)\n */\nexport async function inspectTxpool<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n): Promise<InspectTxpoolReturnType> {\n  return await client.request({\n    method: 'txpool_inspect',\n  })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type SetIntervalMiningParameters = {\n  /** The mining interval. */\n  interval: number\n}\n\nexport type SetIntervalMiningErrorType = RequestErrorType | ErrorType\n\n/**\n * Sets the automatic mining interval (in seconds) of blocks. Setting the interval to 0 will disable automatic mining.\n *\n * - Docs: https://viem.sh/docs/actions/test/setIntervalMining\n *\n * @param client - Client to use\n * @param parameters â€“ {@link SetIntervalMiningParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setIntervalMining } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setIntervalMining(client, { interval: 5 })\n */\nexport async function setIntervalMining<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { interval }: SetIntervalMiningParameters,\n) {\n  const interval_ = (() => {\n    if (client.mode === 'hardhat') return interval * 1000\n    return interval\n  })()\n\n  await client.request({\n    method: 'evm_setIntervalMining',\n    params: [interval_],\n  })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type SetRpcUrlErrorType = RequestErrorType | ErrorType\n\n/**\n * Sets the backend RPC URL.\n *\n * - Docs: https://viem.sh/docs/actions/test/setRpcUrl\n *\n * @param client - Client to use\n * @param jsonRpcUrl â€“ RPC URL\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setRpcUrl } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setRpcUrl(client, 'https://eth-mainnet.g.alchemy.com/v2')\n */\nexport async function setRpcUrl<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  jsonRpcUrl: string,\n) {\n  await client.request({\n    method: `${client.mode}_setRpcUrl`,\n    params: [jsonRpcUrl],\n  })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type LoadStateParameters = { state: Hex }\nexport type LoadStateReturnType = void\nexport type LoadStateErrorType = RequestErrorType | ErrorType\n\n/**\n * Adds state previously dumped with `dumpState` to the current chain.\n *\n * - Docs: https://viem.sh/docs/actions/test/loadState\n *\n * @param client - Client to use\n * @param parameters - {@link LoadStateParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { loadState } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await loadState(client, { state: '0x...' })\n */\nexport async function loadState<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { state }: LoadStateParameters,\n): Promise<LoadStateReturnType> {\n  await client.request({\n    method: `${client.mode}_loadState`,\n    params: [state],\n  })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type ResetParameters = {\n  /** The block number to reset from. */\n  blockNumber?: bigint | undefined\n  /** The JSON RPC URL. */\n  jsonRpcUrl?: string | undefined\n}\n\nexport type ResetErrorType = RequestErrorType | ErrorType\n\n/**\n * Resets fork back to its original state.\n *\n * - Docs: https://viem.sh/docs/actions/test/reset\n *\n * @param client - Client to use\n * @param parameters â€“ {@link ResetParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { reset } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await reset(client, { blockNumber: 69420n })\n */\nexport async function reset<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { blockNumber, jsonRpcUrl }: ResetParameters = {},\n) {\n  await client.request({\n    method: `${client.mode}_reset`,\n    params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }],\n  })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Quantity } from '../../types/rpc.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type RevertParameters = {\n  /** The snapshot ID to revert to. */\n  id: Quantity\n}\n\nexport type RevertErrorType = RequestErrorType | ErrorType\n\n/**\n * Revert the state of the blockchain at the current block.\n *\n * - Docs: https://viem.sh/docs/actions/test/revert\n *\n * @param client - Client to use\n * @param parameters â€“ {@link RevertParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { revert } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await revert(client, { id: '0xâ€¦' })\n */\nexport async function revert<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { id }: RevertParameters,\n) {\n  await client.request({\n    method: 'evm_revert',\n    params: [id],\n  })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type DumpStateReturnType = Hex\nexport type DumpStateErrorType = RequestErrorType | ErrorType\n\n/**\n * Serializes the current state (including contracts code, contract's storage,\n * accounts properties, etc.) into a savable data blob.\n *\n * - Docs: https://viem.sh/docs/actions/test/dumpState\n *\n * @param client - Client to use\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { dumpState } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await dumpState(client)\n */\nexport async function dumpState<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n): Promise<DumpStateReturnType> {\n  return client.request({\n    method: `${client.mode}_dumpState`,\n  })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type GetAutomineReturnType = boolean\n\nexport type GetAutomineErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the automatic mining status of the node.\n *\n * - Docs: https://viem.sh/docs/actions/test/getAutomine\n *\n * @param client - Client to use\n * @returns Whether or not the node is auto mining. {@link GetAutomineReturnType}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { getAutomine } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * const isAutomining = await getAutomine(client)\n */\nexport async function getAutomine<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n): Promise<GetAutomineReturnType> {\n  if (client.mode === 'ganache')\n    return await client.request({\n      method: 'eth_mining',\n    })\n  return await client.request({\n    method: `${client.mode}_getAutomine`,\n  })\n}\n","import type { Address } from 'abitype'\n\nimport type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RpcTransaction } from '../../types/rpc.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type GetTxpoolContentReturnType = {\n  /** Pending transactions in the pool */\n  pending: Record<Address, Record<string, RpcTransaction>>\n  /** Queued transactions in the pool */\n  queued: Record<Address, Record<string, RpcTransaction>>\n}\n\nexport type GetTxpoolContentErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the details of all transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.\n *\n * - Docs: https://viem.sh/docs/actions/test/getTxpoolContent\n *\n * @param client - Client to use\n * @returns Transaction pool content. {@link GetTxpoolContentReturnType}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { getTxpoolContent } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * const content = await getTxpoolContent(client)\n */\nexport async function getTxpoolContent<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n): Promise<GetTxpoolContentReturnType> {\n  return await client.request({\n    method: 'txpool_content',\n  })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type SetBlockTimestampIntervalParameters = {\n  /** The interval (in seconds). */\n  interval: number\n}\n\nexport type SetBlockTimestampIntervalErrorType = RequestErrorType | ErrorType\n\n/**\n * Similar to [`increaseTime`](https://viem.sh/docs/actions/test/increaseTime), but sets a block timestamp `interval`. The timestamp of future blocks will be computed as `lastBlock_timestamp` + `interval`.\n *\n * - Docs: https://viem.sh/docs/actions/test/setBlockTimestampInterval\n *\n * @param client - Client to use\n * @param parameters â€“ {@link SetBlockTimestampIntervalParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setBlockTimestampInterval } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setBlockTimestampInterval(client, { interval: 5 })\n */\nexport async function setBlockTimestampInterval<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { interval }: SetBlockTimestampIntervalParameters,\n) {\n  const interval_ = (() => {\n    if (client.mode === 'hardhat') return interval * 1000\n    return interval\n  })()\n\n  await client.request({\n    method: `${client.mode}_setBlockTimestampInterval`,\n    params: [interval_],\n  })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type SnapshotErrorType = RequestErrorType | ErrorType\n\n/**\n * Snapshot the state of the blockchain at the current block.\n *\n * - Docs: https://viem.sh/docs/actions/test/snapshot\n *\n * @param client - Client to use\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { snapshot } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await snapshot(client)\n */\nexport async function snapshot<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: TestClient<TestClientMode, Transport, chain, account, false>) {\n  return await client.request({\n    method: 'evm_snapshot',\n  })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type RemoveBlockTimestampIntervalErrorType = RequestErrorType | ErrorType\n\n/**\n * Removes [`setBlockTimestampInterval`](https://viem.sh/docs/actions/test/setBlockTimestampInterval) if it exists.\n *\n * - Docs: https://viem.sh/docs/actions/test/removeBlockTimestampInterval\n *\n * @param client - Client to use\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { removeBlockTimestampInterval } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await removeBlockTimestampInterval(client)\n */\nexport async function removeBlockTimestampInterval<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: TestClient<TestClientMode, Transport, chain, account, false>) {\n  await client.request({\n    method: `${client.mode}_removeBlockTimestampInterval`,\n  })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type SetAutomineErrorType = RequestErrorType | ErrorType\n\n/**\n * Enables or disables the automatic mining of new blocks with each new transaction submitted to the network.\n *\n * - Docs: https://viem.sh/docs/actions/test/setAutomine\n *\n * @param client - Client to use\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setAutomine } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setAutomine(client)\n */\nexport async function setAutomine<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  enabled: boolean,\n) {\n  if (client.mode === 'ganache') {\n    if (enabled) await client.request({ method: 'miner_start' })\n    else await client.request({ method: 'miner_stop' })\n  } else\n    await client.request({\n      method: 'evm_setAutomine',\n      params: [enabled],\n    })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type SetLoggingEnabledErrorType = RequestErrorType | ErrorType\n\n/**\n * Enable or disable logging on the test node network.\n *\n * - Docs: https://viem.sh/docs/actions/test/setLoggingEnabled\n *\n * @param client - Client to use\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setLoggingEnabled } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setLoggingEnabled(client)\n */\nexport async function setLoggingEnabled<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  enabled: boolean,\n) {\n  await client.request({\n    method: `${client.mode}_setLoggingEnabled`,\n    params: [enabled],\n  })\n}\n","import type { Address } from 'abitype'\n\nimport type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type ImpersonateAccountParameters = {\n  /** The account to impersonate. */\n  address: Address\n}\n\nexport type ImpersonateAccountErrorType = RequestErrorType | ErrorType\n\n/**\n * Impersonate an account or contract address. This lets you send transactions from that account even if you don't have access to its private key.\n *\n * - Docs: https://viem.sh/docs/actions/test/impersonateAccount\n *\n * @param client - Client to use\n * @param parameters - {@link ImpersonateAccountParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { impersonateAccount } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * const content = await impersonateAccount(client, {\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function impersonateAccount<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { address }: ImpersonateAccountParameters,\n) {\n  await client.request({\n    method: `${client.mode}_impersonateAccount`,\n    params: [address],\n  })\n}\n","import type { Address } from 'abitype'\n\nimport type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type SetCoinbaseParameters = {\n  /** The coinbase address. */\n  address: Address\n}\n\nexport type SetCoinbaseErrorType = RequestErrorType | ErrorType\n\n/**\n * Sets the coinbase address to be used in new blocks.\n *\n * - Docs: https://viem.sh/docs/actions/test/setCoinbase\n *\n * @param client - Client to use\n * @param parameters â€“ {@link SetCoinbaseParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setCoinbase } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setCoinbase(client, {\n *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',\n * })\n */\nexport async function setCoinbase<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { address }: SetCoinbaseParameters,\n) {\n  await client.request({\n    method: `${client.mode}_setCoinbase`,\n    params: [address],\n  })\n}\n","import type { Address } from 'abitype'\n\nimport type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type SetCodeParameters = {\n  /** The account address. */\n  address: Address\n  /** The bytecode to set */\n  bytecode: Hex\n}\n\nexport type SetCodeErrorType = RequestErrorType | ErrorType\n\n/**\n * Modifies the bytecode stored at an account's address.\n *\n * - Docs: https://viem.sh/docs/actions/test/setCode\n *\n * @param client - Client to use\n * @param parameters â€“ {@link SetCodeParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { setCode } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await setCode(client, {\n *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',\n *   bytecode: '0x60806040526000600355600019600955600c80546001600160a01b031916737a250d5630b4cf539739dfâ€¦',\n * })\n */\nexport async function setCode<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { address, bytecode }: SetCodeParameters,\n) {\n  if (client.mode === 'ganache')\n    await client.request({\n      method: 'evm_setAccountCode',\n      params: [address, bytecode],\n    })\n  else\n    await client.request({\n      method: `${client.mode}_setCode`,\n      params: [address, bytecode],\n    })\n}\n","import type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type DropTransactionParameters = {\n  /** The hash of the transaction to drop. */\n  hash: Hash\n}\n\nexport type DropTransactionErrorType = RequestErrorType | ErrorType\n\n/**\n * Removes a transaction from the mempool.\n *\n * - Docs: https://viem.sh/docs/actions/test/dropTransaction\n *\n * @param client - Client to use\n * @param parameters - {@link DropTransactionParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { dropTransaction } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await dropTransaction(client, {\n *   hash: '0xe58dceb6b20b03965bb678e27d141e151d7d4efc2334c2d6a49b9fac523f7364'\n * })\n */\nexport async function dropTransaction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { hash }: DropTransactionParameters,\n) {\n  await client.request({\n    method: `${client.mode}_dropTransaction`,\n    params: [hash],\n  })\n}\n","import type { Address } from 'abitype'\n\nimport type {\n  TestClient,\n  TestClientMode,\n} from '../../clients/createTestClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type StopImpersonatingAccountParameters = {\n  /** The account to impersonate. */\n  address: Address\n}\n\nexport type StopImpersonatingAccountErrorType = RequestErrorType | ErrorType\n\n/**\n * Stop impersonating an account after having previously used [`impersonateAccount`](https://viem.sh/docs/actions/test/impersonateAccount).\n *\n * - Docs: https://viem.sh/docs/actions/test/stopImpersonatingAccount\n *\n * @param client - Client to use\n * @param parameters â€“ {@link StopImpersonatingAccountParameters}\n *\n * @example\n * import { createTestClient, http } from 'viem'\n * import { foundry } from 'viem/chains'\n * import { stopImpersonatingAccount } from 'viem/test'\n *\n * const client = createTestClient({\n *   mode: 'anvil',\n *   chain: 'foundry',\n *   transport: http(),\n * })\n * await stopImpersonatingAccount(client, {\n *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n * })\n */\nexport async function stopImpersonatingAccount<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: TestClient<TestClientMode, Transport, chain, account, false>,\n  { address }: StopImpersonatingAccountParameters,\n) {\n  await client.request({\n    method: `${client.mode}_stopImpersonatingAccount`,\n    params: [address],\n  })\n}\n"],"names":[],"mappings":"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L4C,IAKxC,AAET,C2CgzCL,C3ChzCmB,A2CyxCb,A3C3xCU,C2CyyCV,CAbX,CAcA,A3C3yCkC,CAAC,EAGL,CAAC,GAAG,AACxB,CADyB,CAAA,CACX,E2CyxCX,CAsBqB,CAAA,CAOxB,EAEV,A3CxzC+B,CAAC,C2CwzCnB,A3CxzCS,KAAY,C2C2zClC,G3C3zCsC,SAAE,Q2C2zC3B,EAGb,A3C9zCkD,AAAE,K2C8zC7C,E3C9zCoD,KAI9C,CACT,CAAC,C2Cq1C4C,G3Ct1C9B,CAAA,EAEf,MAAM,C2Cw1CA,EvB1yCC,CuB2yCZ,A3Cx1CK,CADW,CACX,KAAA,EAGA,EAAe,CACb,IoB6CE,CpB7CG,AoB6CF,GpB5CD,GAAkB,cAAc,KACzB,E2C42CS,GACzB,A3C72CgB,GACP,CAF8C,CAAC,C2Cu3CZ,A3Cv3CY,A2C82ClD,M3C52C2B,CAAC,E2Cq3CkC,A3Cr3ChC,AAC7B,CyC2BoC,AEy1CyB,A3Cr3C/B,AAC7B,CAD6B,aAG5B,GyC6BiB,CEo2CpB,AFp2CoB,GzC7BV,MAAM,CAAA,I2Cy2C0B,CAAA,K3Cv2C/B,CoB6CG,AqBhBA,GEk2CU,CAAA,K3C/3CP,CAAO,YAAE,CPkZG,AOlZO,CAAE,EAC/B,EyC6BI,CzC7BK,GyC6BO,EAAA,GzC3BpB,GyC6BO,CAAA,EzC7BI,EAAK,EAAE,AAAH,EAAO,EP4Z2B,CAAA,OO5ZpB,CAAC,IAAI,EP6ZZ,AO7Zc,CAE9B,EAAW,KACY,EPiaX,QOjaZ,OAAO,E2C44CgB,A3C54CP,EAAE,EAAiB,EAAE,EAAK,EAAS,E2C64C1B,I3Cz4C7B,AoB4CwD,kBpB5CxD,EACO,MAAM,EoB2C2C,ApB1C3B,AoB0C0B,AuBw2CxB,CvBx2CyB,CAAA,MpB1CnB,EoB0CmB,OpB1C/C,CoB2Ca,CpB3CJ,MAAM,EAAa,EAErB,GAAA,CAAI,EAAS,MAAD,AAAO,CAAE,CACjC,KyCwBiB,MzCxBL,E2Cw5C3B,MAAM,A3Cx5C6B,EACpB,CoBwC6B,MpBvC7B,IAGJ,E2Cu6Cc,AvBj4CG,CqBbN,CAAC,CAAA,CrBaI,AuBi5C3B,AFz5CK,CrBQuB,AqBRvB,iBEq3CsC,C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,A0BeI,E1BfF,CAAC,QAAlB,EAAE,GACZ,AiDoqCqB,CAAA,EjDjqCP,W0Bee,UAAlC,EAAA,M1Bfc,GiD6sC9B,CjD5sCkB,CMML,AyCMM,CAAA,M/CZc,CAAC,AACzB,CAAC,AADwB,UAIxB,kBAEC,YAAN,SACS,C0BkCW,G1BlCP,QAAa,AAAC,CMGU,ENFjC,EAAU,EADoB,GiD4uCvB,EACrB,AjD5uCuB,AAAQ,CAAC,MACV,C0BmCS,CqBzBL,AEuuCrB,MANkB,AjD1uCG,CDuXO,EkDo3BlC,MAAM,gBjD1uCqB,CAAC,AiD0uCL,CAAA,CjD1uCoB,KiD0vCN,CAAA,OjDxvCR,EiDqwC7B,GjDhwCO,CAAC,AiD4wCwB,EAAE,sCzDl9CtB,CCEsB,CCCE,CFFnC,C6CED,AlCHiC,AqCAA,ADGA,ADEP,A5BJO,C+BEC,CPDC,AMFA,AEGP,AHAO,APAA,oW/BEvB,C2CDsB,AjDEvB,CuCDG,AzCFoB,SQEY,EcF4B,AcyB5B,AtBhB3B,AUTuD,CbCE,AaDF,AmBWP,AXFxC,AlBAR,AQTuD,AnBGzB,AiCyB/C,COjBiE,AcXS,A9CCA,ANC1B,A+B0BhD,AjCzB+C,CsDH2B,AzCAE,AwCQ1D,AnDN8B,CWF4B,AgBSnD,CwBA1B,AxBA0B,KxBP4B,CACtD,E+BFyD,C3BGrB,A2BHqB,AnBGnB,CRAF,ALFJ,AaEM,ASIR,CyBRN,AzBQM,A0BWA,AhDjBE,AkBEG,ACKA,COLF,AsBeH,ANRC,AxBPI,ACKA,CuBEJ,AxCVA,C6CAhC,A7CAgC,CwBKhC,ChBLkE,CAAA,CFCE,APCnE,CODmE,A+BDC,AEAA,AxCEpE,CsCFoE,A1CIC,A4CJD,AMA/D,CrBKA,EpBHoC,CAAA,CLAzC,CAAA,CgDMwB,AhDNgB,CiBKzC,C+BEC,ElDwB4C,CAAA,EE9BrC,CAAA,CAAA,C6CQ4C,CAAA,GtDX0B,AuDAnD,CvDAmD,AuDAnD,G9CGnB,EAAA,EAAA,CyBE2B,CAAA,GuBIT,EACzB,0BhDPO,CAAA,CgDOqB,AhDPrB,EgDQP,IhDPU,wBgDOkB,EAC5B,oBAAoB,EACpB,ANmCoC,qBMnCf,EACrB,KNuCO,CAAA,GAJP,CC/C4B,AtCErB,A2C6hBA,AjDxhBP,AgCPO,AeKP,ANLO,A1CwCP,A2BVO,AhC9BqB,AsDoBI,AnCZhC,AsCDO,A3CDP,ANAiC,AqCN1B,A7BAA,MAAA,OuCYgB,EACvB,KvCbO,CAAA,IAAA,CAAA,OAAA,GuCac,EACrB,2BAA2B,EAM3B,QAAQ,EACR,YAAY,EACZ,iBAAiB,EACjB,kBAAkB,EAClB,6BAA6B,EAI7B,qBAAqB,EACrB,MNuBM,CAAC,IAAA,CAAA,IMvBS,GACjB,MAAM,CNuBS,CAAA,OMvBA,CAAA,oBPpBC,+CA0B4B,qBAE9B,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,2BACmB,+BAEmB,AAAW,CAAV,iBAAC,C3CoBrB,CAAA,E2CpByB,6DACS,CAAE,CAAC,AOsiBlC,CPtiBkC,AnCjBnB,A0CujBf,C1CvjBgB,CDgFO,AChFP,6BmCoBM,0BADjD,IAAA,GAAA,iCAAA,CAAA,UAAwC,C1C8D1C,C0C9DkD,CAAE,CAAC,CAAA,OAEd,CO4iBC,CAAA,4BP1iBd,EAAA,EAClB,MAAA,CAAA,CAAA,EAAA,EACP,C7BVsD,CAAA,A6BUjD,OAAO,CAAC,EJJ4C,AIIlC,CJJmC,CAAC,EIIpC,CAAK,CAClC,CAAA,6NMGa,CrDlDP,EAAA,CAAA,CAAA,CAAA,kBqDqDqB,MAAM,CAAA,MAAA,IACtB,GAAA,8BAAA,CAAA,gBACQ,EAAA,MAAA,aACH,EAAA,MAAuB,4CAKhC,EAAA,CAAA,CAAA,EAAA,6DAyBD,GAAA,SAAA,KAAA,MAA0B,IAAA,GAAA,mBAAA,CAAA,gEAKjC,CT0BC,C1B+kBG,AsC7oBA,CHoCS,AGpCT,CVuCQ,AlCpDF,ALqBE,AqBlBF,U4BUN,E5BVM,MAAA,CAAA,EAAA,EAAA,WAAA,EAAA,MyB+CG,YAAA,OAAgB,iCAEhB,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,GAAA,QAAqC,EAAE,AC8uBtC,CD9uByC,AAAF,CAAG,ACgvBlE,ADhvBgE,OAE1D,EAAA,EAAA,KAAA,CAAkC,GAAA,YAAA,WAEhC,CAAC,EAAA,EAAiB,EAAO,KAAK,CAAC,CAAG,CnC0nBD,CAAC,CPllBL,CAAA,AP4VS,IiDpYI,ATyBF,CU6uBpB,AV7uBqB,ASzBC,CTyBD,CU+uBjD,uBAAuB,GAExB,MAAM,WDxwBiC,MCwwBhB,CAAA,oDDlwB8B,QAElD,CC+4BF,EAAA,CD/4BS,EAAO,EAAK,CAAA,YACR,QAAQ,CAAC,CCigCK,AfpiCR,ArB4pBE,CAAA,MmCznBe,CAAE,EAAc,CnCynBV,EoCwYQ,EAAE,CDjgCM,CAAG,CAAC,CAAC,ACigCL,CDjgCQ,CAAC,CAAA,MAAA,IAAA,GCigCW,CAAA,CAAA,oBAAA,CAAA,cD//B1D,ChDkCG,CawlBC,Ad3OI,CAAA,IiD/YD,QAAA,CAAA,EAAA,cACV,CAAA,EAAA,MAAsB,EAAG,EAAK,CAAC,oBAEnC,EAAA,KAAqB,E1CwCf,M0CxCwB,KAAA,EAAgB,GAAA,WAGrD,EAAc,EAAA,KAAA,CAAA,GAAA,UAAgC,C9C5Bb,A8C4Bc,CAAA,AnC0nBf,AXtpBC,uB8C6BC,CAAC,IAChC,EAAA,EAAiB,CAAG,CnC0nBD,AbvlBA,AOhFR,CPgFS,A+CSJ,AC3CjB,CnCynBsB,AbvlBD,CaslBqB,Ad5OlB,AiD5YxB,CnCynBwB,Ad7OA,CiD5YxB,SACG,CAAC,AtBsDE,C3BsV4B,A2BtV3B,CQzFH,AnC+a8B,CAAA,EAAA,EiD5Yd,MAAM,CAAE,CAAC,CnC0nBD,CmC1nBG,CnC0nBD,AmC1nBG,CnC0nBD,AmC1nBE,CACjC,EtBqDoC,EAAA,CAAA,EAAA,EAAA,CAAA,CsBrDP,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAA,ItBsDnB,GsBpDJ,EnCynBiC,CmCznB/C,CD4CF,AhD+VmD,CkDszBlD,AvB7oCmB,IAAA,CsBpDJ,QAChB,GtBoDsC,CAAA,QAAA,EAAA,asBjDrC,GAAA,wBAAA,CAAyB,CjD6Y3B,CiD5YV,CAAC,aAhEQ,CAAA,EAAA,GAAA,SAAA,EAAU,0ErDtEK,CCJC,AEAA,ADDA,AwBSG,CfTF,AKAA,AJGP,ACCgC,ACJzB,ATCA,ACDA,ACAoB,AHgCpB,AIhCA,AEAA,ADAA,AMCA,CSO2B,AFNA,AnBD1B,AcDA,AMG0B,AHDA,AFCpD,ACGM,AEAN,AnBN0B,ADCA,CgCUC,AzBXA,A6BGA,AGMA,AfAA,AaAA,ATAA,AFHP,ASKO,AzBXA,AqBSA,AESA,AtBd1B,AuBQ0B,ATHA,AEAA,AbRA,AwBCA,ATM2B,ACPlC,M/BKf,CAAA,aAC2B,CADZ,kCAIW,EAFI,C+B8ByB,A/B9BxB,C+B8BwB,ApB0DrB,qBXtFwB,eAA3B,CYkBE,AmCmBK,C/CrCD,WAAW,CAAC,IAAA,iFD0BjC,cAAX,MAAA,CAAW,GAAA,GACb,GAAA,qCAWa,EAAA,CAAA,EAAA,GAAA,UAAA,EAAA,EAAA,IAAA,oBAEA,EAAA,KAAA,0DAGH,EAAA,CAAA,EAAA,EAAA,CAAA,EACV,CuD4kBqB,C5CxmBL,C6C6BH,AhBPM,SAAA,AxCMV,EAAA,CAAA,EAAA,GAAA,KAAA,EAAA,CAAQ,EwDCY,AxDDN,EAAM,CAAE,IuD4kBwB,EAC9D,CvD7kB6C,GAAG,KAAK,CAAC,EAAE,CAAC,AuD6kB5C,CAAA,CvD7kByD,CuD8kBvE,AvD7kBE,CAAA,KuD6kBI,IvD/jBS,GAAA,CAAA,auD+jBY,CAAA,2BvD9jBM,EAAA,IAAA,GAC1B,EAAA,CAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAwB,IAAI,CAAC,CAAA,EAAA,IAAA,CAAA,CAAA,EAAA,GAAA,OAAA,AAAsB,EAAC,EAAK,IAAI,CQPvC,AROwC,CAAE,WAIhE,sCAE2B,EAAA,EAAA,YAAA,gBACd,EAAK,CmBeA,WAAA,KnBbf,GAAA,SAAA,AAAS,EAAA,EAAA,QAAc,C+CyBsB,AnCkC3B,6FZvDO,QAAS,EAAM,EAAM,AAAR,EAAM,AAAe,CAAC,CAAC,AuDgvBzC,CAAA,IvD9uB/B,C2ExBC,AvCEA,ApCsBA,EAFoE,kGwDlDzB,YAE3B,C/CvBU,AIYA,C2CWN,CAAgC,AAAhC,CLoByC,AKpBzC,GDwhBa,CAAA,GCxhB2B,ArCjBf,CqCiBgB,ArCjBhB,CqCiBiB,AAA1C,OAAA,EAAA,KAAA,CAAA,EAAA,CAA2C,CX7BY,CAAA,GW6BP,CAAC,AAAE,CAAD,MAAC,CAAO,CAAC,CAAA,CAElD,UAA1B,CFNF,MAAA,EAAA,KAAA,CEM0B,EAAE,CAAA,EAAA,KAAA,CACL,CRMsD,AO2hB9E,EAAA,CCjiB4B,GAAA,CAAA,EAAO,GAAA,UAAA,AAAU,EAAA,IAAA,EAAA,KACtB,GAGP,EAAA,MAAA,CAAA,CAAA,EAAA,IAA+B,EAAS,C5CkErC,AOzEoB,CAAA,AqCOqB,EDuiBtB,ACviBsB,IAAO,CAAE,CAAC,A5CkEtC,C4ClEuC,A5CkEtC,CAAC,A4ClEqC,4CAEzD,MAER,IAAA,KAAA,EAAqB,CFmBH,AEnBI,wBACE,EAAA,wDAKzB,IAAA,EAAA,OAIK,IAAA,yCAFqB,EAAO,QAAA,EAEjB,MAAM,IAAA,CAAA,oCAIhB,WADuB,YAAY,CAAA,EAAQ,SAAS,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,AACpE,CADoE,GD8kB7C,EC3kBzB,QAEG,QAAA,CAAA,kBAKmB,CAAA,KAAM,CAAA,EAAA,EAAA,QAAiB,iCAE1B,EAAA,GAAA,yCZvBF,CAAA,CAAA,IAGvB,EAAA,EAAA,GAAyC,UAAvB,CJXY,MAAA,CAAA,CAAA,EAAA,CAAA,IIWW,CAAgB,MAAQ,GIIvC,IAAA,CJJ8C,CIIzC,AJJ0C,CAAA,6GAYpE,uFT3CP,CGlB4B,AEDA,AEWvB,A5CbuB,A0CEA,OAAA,CLoBtB,IACN,CQpBK,A5CDsD,AaFrB,CuBwBE,C/BvBG,ADDA,ADCA,AgDDA,C/CAA,AgDCN,AjDAM,A6BO4B,A3BP5B,A+B2B3C,CJpBuE,CjBJA,ANJL,AIApB,C8BatB,A5BT+C,ADAlD,AR4B0B,A8C7BhD,A3CHmE,CkCa1C,ArCmBuB,CKhCE,ACAA,AIAA,AME0B,AEAA,ANF1B,CME0B,ANF1B,APAA,AQAC,ALKnD,AFLkD,AUE0B,ANF1B,CSG4B,ACKA,APR3B,AiB4B3C,CXzBsE,ACKA,C0BLxE,A7BGsB,AasBpB,CbtBoB,ChBL4B,AgCEA,CAAA,AhCFA,AOIlD,CuBOoD,ACDA,AeAA,AtBFA,AIEA,ARFA,AeAA,ARAA,AJAA,AMmBlD,AInBkD,CEAA,AZAA,ACAA,AGAA,ACEA,AlBVC,AoCUD,A3CXC,A4BWD,ADCA,AVHA,AaAA,AJmBlD,AAAa,C1BzB2B,AHA/B,AqCAU,AhBMiC,AlBTD,A4CAC,ArCCD,AmCgBX,ArCZxB,CuCLoC,ARInC,AlBKmC,AKN7B,AWAJ,AlBS3B,ADLA,AuBHyB,AhBQzB,AORyB,CgBWF,AtBZQ,A5BEL,AwBKP,ALPiC,ANAA,ACAA,ALMjC,ACJO,AKEpB,AEJ8C,AmCAA,AtDGzB,C4CNoC,ASAA,AVIpC,AEAA,ALUkB,AYMzB,A5ChBkC,AsBClC,AgBQA,A1CRpB,ASFsD,ACC3B,AsBAA,ApCEA,C4CNoC,AQiB9D,AnBWoC,CexBuB,CHDM,AZyB3B,CUzB4B,AEAD,AtCAA,AJkC5D,A8CpB4D,AvBV7B,CXJgC,AkCcH,AnDbA,AkBDG,ATAH,AmBI7B,AiBJ8B,C7CCD,A+CAtB,AFAA,A5BDyB,ACAA,AlBCH,AkDJG,CFKnC,AELmC,C/BGxB,CPH2B,AOG3B,CPH2B,AoCOxE,CJDsC,CAAA,EJJuC,CAAA,CQKvE,GnCFyB,CsCFI,AtCEJ,CsCFI,IGcV,uF9CiBT,QACQ,C+C2iBxB,kBAAA,C/C1iBK,C8C2BK,EAAA,EAAA,M9C3BW,CKNC,AwC0FiB,CAAA,E7CpFV,EAAA,MAAA,CAAA,GAAqB,CAAC,CAAA,MAAA,IAAA,GAAA,oBAAA,CAAA,SAEvC,CAAA,EAAA,GAAA,UAAA,AAAU,EAAC,C+CojBjB,CbheuB,A1CtF2B,8BQqBhD,EAAA,CAAA,CAAA,EAAA,KAAA,gIAaM,IAAA,qBAEG,EAAA,SAAA,CAAiB,mBACR,CAAA,EAAA,EAAA,UAAA,EAAA,GAAoB,wBAsBtC,IAAA,IAAwD,CiDRlC,AFkrCxB,C/C1qCqE,MACpE,EAAW,EAAA,QAAA,CACX,EAAiC,EAAE,MAClC,EAAA,QAAA,CAAA,EAAA,GAAA,EAAA,IACK,CAAA,EAAA,EAAuB,CgCPD,ChCOG,AgCPH,ShCQ3B,mDAtD8B,EAGvC,CAAC,AkDpBA,A1D2BA,E4DpBE,ACLA,ACGA,ACIA,ACDA,ACJA,ACAA,ACQA,ACLA,ATEA,UnD6CiB,CAAA,CAAgB,CAAA,CAAA,CAAA,6BAElC,G+CkyBK,G/ClyBS,EAAS,GAAI,C+CuyB3B,M/CvyBkC,EAAA,EAClC,G+C+zBK,IAAA,EAAA,GAAA,EAAA,O/C/zBkC,CsCpC7B,CQ8DA,CAAA,Q9C1B6C,GACvD,CsCpCC,ESy6BI,IAAA,EAAA,GAAA,EAAA,OAAA,EAAA,UAAA,M/Cp4BD,C+Ci6BJ,AlDpgBI,GAAA,EAAA,GAAA,EAAA,OG7ZmC,EAAA,UAAiB,eAC3B,EAAA,OAAU,EAAO,AIsErC,COilBC,Ad3OJ,AAXQ,AiDnYF,SjD8YN,SG3aA,IAAI,C4CKC,EAAA,SAAA,CAAA,qB5CJb,C4CKC,A5CLA,gFmCxEgB,Ca6BD,A5CmEE,AJ3EF,AwCWE,GAAA,EAAA,EAAA,MAAA,IAAA,GAAA,sBAAA,CAAA,2BL9BF,CAAA,WAAA,CAAA,IAAA,0F5CdmB,CMkCd,AOlCO,AuCW2B,CJb1B,AjCGP,AKGf,AmBNsB,AOAA,AUmFtB,C/C7EA,AiBIgB,AvBLtB,CGgCA,CqCwE+B,AlBvGzB,AVFN,gBfDc,IAAA,KAAA,CAAA,EAAA,GAAA,IAAA,EAAA,iCmDab,CAAsB,CAAA,CAAA,4BAKpB,GAAA,KAAA,EAAA,EAAA,wCAES,qBAAA,oJQNQ,CAAA,oBAAA,CACA,Cd6BqC,AAAC,8GxBlBlD,A0BXc,CFoCb,CAAA,OAAA,CAAA,QxBzBqB,CAAA,mCAAA,M0BXR,0ENqBP,CAAA,CAAA,cAGG,IAAA,GAAA,MAAA,CAAA,MACX,EAAA,IAAA,IAEA,EAAA,CAAU,CAAA,QAAA,CAAA,CAAA,QAAA,CAAA,CAAA,GACd,CAAA,EAAA,EAAA,CAAA,EAAc,EAAA,CAAS,CpBjBsC,AoBiBtC,CpBjBuC,YoBoBxD,QAAA,CAAA,QAAA,CAAA,CAAA,QAAA,CAAA,CAAA,OAAA,CAAA,CAAA,qDAEuB,UAAS,4BAErB,mBAAW,8CAGP,aAAoB,gEAMpB,CckCkC,kCdjClB,CAAC,qBAGhC,IAAA,CAAA,QAAA,CAAA,CAAA,QAAA,CAAA,CAAA,OAAA,CAA8B,CAAA,MAC5B,CnCuaG,AG5ZI,CgCXD,CckCiB,CAAA,mBdlCC,CAAO,AK4DN,CL5DQ,CAAC,CAAA,AAEpC,CrB0pBsC,CqB1pBtC,EAAA,GAAA,CAAyB,GAkB7B,4BAdM,Cew0BM,A/Ch0BK,AKtBJ,AyC+CA,CAAC,AjDmYsB,EAAA,EmCpahB,CrB2pBO,EAAE,GqB3pBH,EAAO,GAAG,CAAC,SAAE,GrB2pBS,OqB3pBA,EAAS,Eeg1B7D,Wf/0BgC,CM7BQ,CN6BC,ArB2pBD,GqB3pBI,CAAC,ErB2pBQ,CAAC,AqB3pBN,CAAC,AAAI,CAAC,CAAA,Keq1BjB,EAErC,Cft1BmC,GAAS,CrB2pBC,CqB3pBL,ArB2pBM,AoCsPzC,IAFuB,GAE7B,Afh5BoB,ElCoEU,A+CWwB,C/CXvB,A+CWuB,AxC5F3B,C2BehB,AAH+C,CnCuapC,A2B1UR,CuBozBmB,AA3Db,CA2Da,AA4Bd,CArFlB,Gft1BU,ChCMW,A+Ci6BL,ApC5QC,CAAE,C2BzrBE,AQgEc,AnCynBhB,KqB3pBM,CAAC,GACT,Oeq1BK,EAEtB,Mfr1Be,KAAK,CAAA,Ieq1BJ,EAEhB,gBAAgB,EAEhB,Cfv1BO,GACD,EAAA,GAAA,CAAA,EAAA,IAGF,AACA,CADA,EAAuB,Cem1BP,EAEpB,Afr1B8B,CAAA,IAAA,CAAA,EACV,MAAA,Oeo1BC,EAErB,Sfp1BU,CR0FG,AQ1FI,CR0FH,AQ1FK,Ce6sCF,QAAA,Cf7sCW,Ceo1BN,EAEtB,2Bfr1ByC,CAAE,CAAC,ArB6pBA,CoCwLd,EAE9B,Yfr1Be,MAAA,CAAO,Eeq1BD,EAErB,CftzBK,IAAM,GAA6B,GAAmB,CAC3D,Ge4yCK,If7zCE,CACL,AAgBM,CequCR,CAhbsB,CAsfoB,CAAA,AApf1C,Efv0BQ,ER6GkE,CAAC,CAAA,AQ7GnE,CAAA,EACJ,GAAM,CR2EG,QAAA,CAAA,CAAA,GuB2vBa,EAE1B,EvB7vBa,CAAA,CQ3EgB,CAAA,Qew0BhB,EAEb,uBfz0B8B,Eey0BL,Afz0BM,Ee20B/B,Af30BuC,CaqEiB,CAAC,ObpEnD,EACA,CR0EO,IuB+vBG,EAGhB,Ef50BM,WAEJ,CAAC,AekxCH,CfjxCE,CeuxCF,KfvxCS,CAAC,ER+EK,AuB0vBS,EAExB,2BAA2B,EAE3B,QAAQ,EAGR,UlC76BA,CiDEgD,Kf26BhC,EAChB,KlC96BW,CACM,CFiCuB,AoCskBsB,CpCtkBtB,AoCskBsB,CfllBvC,QnBpBG,GA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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79]}