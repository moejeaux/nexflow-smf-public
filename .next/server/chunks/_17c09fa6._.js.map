{"version":3,"sources":["../../../src/lib/llm.ts","../../../src/social/replyAgent.ts","../../../src/integrations/xClient.ts","../../../src/social/replyRunner.ts","../../../src/app/api/cron/social-reply/route.ts","../../../node_modules/next/src/build/templates/app-route.ts"],"sourcesContent":["/**\r\n * LLM Client Abstraction\r\n * \r\n * Provides a simple interface for generating JSON from LLM prompts.\r\n * Supports OpenAI and Anthropic APIs via environment configuration.\r\n */\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'LLM' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface LLMGenerateOptions {\r\n  /** System prompt */\r\n  system: string;\r\n  /** User prompt */\r\n  prompt: string;\r\n  /** Optional hint about expected schema (for logging/debugging) */\r\n  schemaHint?: string;\r\n  /** Temperature (0-1, default: 0.7) */\r\n  temperature?: number;\r\n  /** Max tokens (default: 1024) */\r\n  maxTokens?: number;\r\n}\r\n\r\nexport interface LLMConfig {\r\n  /** LLM provider: 'openai' or 'anthropic' */\r\n  provider: 'openai' | 'anthropic';\r\n  /** API key */\r\n  apiKey: string;\r\n  /** Model ID */\r\n  model: string;\r\n  /** Base URL (optional, for proxies) */\r\n  baseUrl?: string;\r\n}\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\nfunction loadLLMConfig(): LLMConfig {\r\n  const provider = (process.env.LLM_PROVIDER || 'openai') as 'openai' | 'anthropic';\r\n  \r\n  let apiKey: string;\r\n  let model: string;\r\n  let baseUrl: string | undefined;\r\n\r\n  if (provider === 'anthropic') {\r\n    apiKey = process.env.ANTHROPIC_API_KEY || '';\r\n    model = process.env.LLM_MODEL || 'claude-3-haiku-20240307';\r\n    baseUrl = process.env.ANTHROPIC_BASE_URL;\r\n  } else {\r\n    apiKey = process.env.OPENAI_API_KEY || '';\r\n    model = process.env.LLM_MODEL || 'gpt-4o-mini';\r\n    baseUrl = process.env.OPENAI_BASE_URL;\r\n  }\r\n\r\n  return { provider, apiKey, model, baseUrl };\r\n}\r\n\r\n// =============================================================================\r\n// LLM CLIENT\r\n// =============================================================================\r\n\r\nclass LLMClient {\r\n  private config: LLMConfig;\r\n\r\n  constructor() {\r\n    this.config = loadLLMConfig();\r\n  }\r\n\r\n  /**\r\n   * Generate JSON from LLM with system/user prompts.\r\n   * Automatically parses the response as JSON.\r\n   */\r\n  async generateJson<T>(options: LLMGenerateOptions): Promise<T | null> {\r\n    const { system, prompt, temperature = 0.7, maxTokens = 1024 } = options;\r\n\r\n    if (!this.config.apiKey) {\r\n      logger.warn({ msg: 'LLM API key not configured, returning null' });\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      let rawContent: string;\r\n\r\n      if (this.config.provider === 'anthropic') {\r\n        rawContent = await this.callAnthropic(system, prompt, temperature, maxTokens);\r\n      } else {\r\n        rawContent = await this.callOpenAI(system, prompt, temperature, maxTokens);\r\n      }\r\n\r\n      // Extract JSON from the response (handle markdown code blocks)\r\n      const jsonStr = this.extractJson(rawContent);\r\n      \r\n      if (!jsonStr) {\r\n        logger.error({ \r\n          msg: 'Failed to extract JSON from LLM response',\r\n          rawContent: rawContent.slice(0, 500),\r\n        });\r\n        return null;\r\n      }\r\n\r\n      return JSON.parse(jsonStr) as T;\r\n\r\n    } catch (error) {\r\n      logger.error({\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        msg: 'LLM generation failed',\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call OpenAI Chat Completions API\r\n   */\r\n  private async callOpenAI(\r\n    system: string,\r\n    prompt: string,\r\n    temperature: number,\r\n    maxTokens: number\r\n  ): Promise<string> {\r\n    const baseUrl = this.config.baseUrl || 'https://api.openai.com';\r\n    const url = `${baseUrl}/v1/chat/completions`;\r\n\r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Authorization': `Bearer ${this.config.apiKey}`,\r\n      },\r\n      body: JSON.stringify({\r\n        model: this.config.model,\r\n        messages: [\r\n          { role: 'system', content: system },\r\n          { role: 'user', content: prompt },\r\n        ],\r\n        temperature,\r\n        max_tokens: maxTokens,\r\n        response_format: { type: 'json_object' },\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      throw new Error(`OpenAI API error (${response.status}): ${errorText}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    return data.choices?.[0]?.message?.content || '';\r\n  }\r\n\r\n  /**\r\n   * Call Anthropic Messages API\r\n   */\r\n  private async callAnthropic(\r\n    system: string,\r\n    prompt: string,\r\n    temperature: number,\r\n    maxTokens: number\r\n  ): Promise<string> {\r\n    const baseUrl = this.config.baseUrl || 'https://api.anthropic.com';\r\n    const url = `${baseUrl}/v1/messages`;\r\n\r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'x-api-key': this.config.apiKey,\r\n        'anthropic-version': '2023-06-01',\r\n      },\r\n      body: JSON.stringify({\r\n        model: this.config.model,\r\n        max_tokens: maxTokens,\r\n        system,\r\n        messages: [\r\n          { role: 'user', content: prompt },\r\n        ],\r\n        temperature,\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      throw new Error(`Anthropic API error (${response.status}): ${errorText}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    return data.content?.[0]?.text || '';\r\n  }\r\n\r\n  /**\r\n   * Extract JSON from LLM response (handles markdown code blocks)\r\n   */\r\n  private extractJson(content: string): string | null {\r\n    // Try to parse directly first\r\n    const trimmed = content.trim();\r\n    if (trimmed.startsWith('[') || trimmed.startsWith('{')) {\r\n      return trimmed;\r\n    }\r\n\r\n    // Look for JSON in code blocks\r\n    const codeBlockMatch = content.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\r\n    if (codeBlockMatch) {\r\n      return codeBlockMatch[1].trim();\r\n    }\r\n\r\n    // Look for array or object anywhere in the content\r\n    const jsonMatch = content.match(/(\\[[\\s\\S]*\\]|\\{[\\s\\S]*\\})/);\r\n    if (jsonMatch) {\r\n      return jsonMatch[1].trim();\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if LLM is configured\r\n   */\r\n  isConfigured(): boolean {\r\n    return !!this.config.apiKey;\r\n  }\r\n\r\n  /**\r\n   * Get current config summary (for logging)\r\n   */\r\n  getConfigSummary(): Record<string, unknown> {\r\n    return {\r\n      provider: this.config.provider,\r\n      model: this.config.model,\r\n      hasApiKey: !!this.config.apiKey,\r\n      hasBaseUrl: !!this.config.baseUrl,\r\n    };\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nexport const llm = new LLMClient();\r\n\r\nexport default llm;\r\n\r\n","/**\r\n * SMF Reply Agent\r\n * \r\n * Decides whether to reply to posts about x402/agents/infrastructure\r\n * and generates concise, high-signal replies that explain SMF's role.\r\n */\r\n\r\nimport { llm } from '@/lib/llm';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'ReplyAgent' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\n/**\r\n * Input for the reply agent\r\n */\r\nexport interface ReplyAgentInput {\r\n  /** Full text of the post to potentially reply to */\r\n  postText: string;\r\n  /** Handle of the author (e.g., @zauthx402) */\r\n  postAuthor: string;\r\n  /** 1-2 previous posts in the thread (if available) */\r\n  threadContext?: string[];\r\n  /** Whether we've already replied to this author/thread in last 7 days */\r\n  alreadyReplied?: boolean;\r\n}\r\n\r\n/**\r\n * Decision not to reply\r\n */\r\nexport interface NoReplyDecision {\r\n  shouldReply: false;\r\n  reason: string;\r\n}\r\n\r\n/**\r\n * Decision to reply with generated text\r\n */\r\nexport interface ReplyDecision {\r\n  shouldReply: true;\r\n  replyText: string;\r\n  angle: string;\r\n}\r\n\r\nexport type ReplyAgentOutput = NoReplyDecision | ReplyDecision;\r\n\r\n// =============================================================================\r\n// SMF FACTS (Ground Truth)\r\n// =============================================================================\r\n\r\n/**\r\n * Canonical facts about SMF that the agent must respect.\r\n * These are the ONLY claims the agent is allowed to make.\r\n */\r\nconst SMF_FACTS = {\r\n  smf_role: \"SMF is a meta-facilitator for x402 that chooses which facilitator to route a payment through, based on health, latency, cost, and risk.\",\r\n  \r\n  smf_layers: [\r\n    \"Observability: pulls facilitator health and performance (e.g., from x402scan / internal metrics).\",\r\n    \"Policy & risk: OFAC/KYT checks, risk scores, trust tiers, blocking risky flows.\",\r\n    \"Coordinator & bandit: offline 'shadow routing' that simulates alternative routing decisions before they ever touch production.\",\r\n    \"Dev UX: intended to feel like a single facilitator endpoint or SDK for apps and agents.\"\r\n  ],\r\n  \r\n  zauth_positioning: \"Zauth focuses on autonomous security testing and 'truth' about x402 endpoints (pentesting, correctness, abuse prevention). SMF focuses on routing, payments, and policy. They are complementary.\",\r\n};\r\n\r\n// =============================================================================\r\n// SYSTEM PROMPT\r\n// =============================================================================\r\n\r\nconst SYSTEM_PROMPT = `\r\nYou are an AI reply agent for NexFlow SMF, a meta-facilitator that routes x402 payments across multiple facilitators with observability, risk, and policy built in.\r\n\r\nYour job is to decide whether to reply to a given post about x402/agents/infrastructure and, if yes, generate a concise, high-signal reply that explains SMF's role without being spammy.\r\n\r\nSMF FACTS (you must respect these exactly):\r\n\r\nsmf_role: \"${SMF_FACTS.smf_role}\"\r\n\r\nsmf_layers:\r\n${SMF_FACTS.smf_layers.map((l, i) => `${i + 1}. ${l}`).join('\\n')}\r\n\r\nzauth_positioning: \"${SMF_FACTS.zauth_positioning}\"\r\n\r\nWHEN TO REPLY:\r\nONLY reply if ALL are true:\r\n- The post is clearly about at least one of: x402, AI agents, facilitators, agent infra, security around x402, or agent payments.\r\n- SMF's role is relevant (e.g., they mention routing, payments, facilitators, reliability, or infra gaps).\r\n- The tone is neutral or positive (no hostile threads; don't argue).\r\n\r\nDO NOT reply if:\r\n- The post is pure trading/price talk without infra/product discussion.\r\n- The thread is an argument, drama, or off-topic for x402/agents.\r\n- The already_replied flag is true.\r\n\r\nHOW TO REPLY (if you do):\r\nGuidelines for reply_text:\r\n- Length: 1-2 sentences, max ~260 characters.\r\n- Tone: technical, matter-of-fact, no hype, no emojis.\r\n- Content rules:\r\n  - Acknowledge the original work when appropriate (e.g., \"Love seeing more x402 security infra here.\").\r\n  - Briefly position SMF using smf_role in your own words.\r\n  - If the post is about Zauth / security, emphasize complementarity using zauth_positioning.\r\n  - Optional soft pointer like \"we're building this into NexFlow's SMF\" or \"SMF sits on the routing side of x402 for agents.\"\r\n  - No links.\r\n\r\nSTYLE CONSTRAINTS:\r\n- Never oversell or promise features that are not part of smf_facts.\r\n- Do not discuss internal file paths, implementation details, or roadmap specifics.\r\n- Do not criticize other projects; always frame SMF as complementary infra.\r\n\r\nOUTPUT FORMAT:\r\nReturn ONLY valid JSON in one of these shapes:\r\n\r\nIf you decide NOT to reply:\r\n{\r\n  \"should_reply\": false,\r\n  \"reason\": \"short explanation\"\r\n}\r\n\r\nIf you decide TO reply:\r\n{\r\n  \"should_reply\": true,\r\n  \"reply_text\": \"your reply here, max 260 characters\",\r\n  \"angle\": \"which angle you chose: e.g., 'routing vs security', 'meta-facilitator explainer', 'agent-friendly payments'\"\r\n}\r\n`.trim();\r\n\r\n// =============================================================================\r\n// USER PROMPT BUILDER\r\n// =============================================================================\r\n\r\nfunction buildUserPrompt(input: ReplyAgentInput): string {\r\n  const parts: string[] = [];\r\n  \r\n  parts.push(`POST TO EVALUATE:`);\r\n  parts.push(`Author: ${input.postAuthor}`);\r\n  parts.push(`Text: \"${input.postText}\"`);\r\n  \r\n  if (input.threadContext && input.threadContext.length > 0) {\r\n    parts.push(`\\nTHREAD CONTEXT (previous posts):`);\r\n    input.threadContext.forEach((ctx, i) => {\r\n      parts.push(`${i + 1}. \"${ctx}\"`);\r\n    });\r\n  }\r\n  \r\n  parts.push(`\\nalready_replied: ${input.alreadyReplied ? 'true' : 'false'}`);\r\n  \r\n  parts.push(`\\nDecide whether to reply and output JSON.`);\r\n  \r\n  return parts.join('\\n');\r\n}\r\n\r\n// =============================================================================\r\n// REPLY AGENT\r\n// =============================================================================\r\n\r\n/**\r\n * Evaluate a post and decide whether to reply.\r\n * \r\n * @param input - The post and context to evaluate\r\n * @returns Decision object with shouldReply and either reason or replyText\r\n */\r\nexport async function evaluateForReply(\r\n  input: ReplyAgentInput\r\n): Promise<ReplyAgentOutput> {\r\n  // Quick rejection: already replied\r\n  if (input.alreadyReplied) {\r\n    return {\r\n      shouldReply: false,\r\n      reason: 'Already replied to this author/thread in the last 7 days.',\r\n    };\r\n  }\r\n\r\n  // Check if LLM is configured\r\n  if (!llm.isConfigured()) {\r\n    logger.warn({ msg: 'LLM not configured, cannot evaluate for reply' });\r\n    return {\r\n      shouldReply: false,\r\n      reason: 'LLM not configured.',\r\n    };\r\n  }\r\n\r\n  logger.info({\r\n    postAuthor: input.postAuthor,\r\n    postLength: input.postText.length,\r\n    hasContext: !!input.threadContext?.length,\r\n    msg: 'Evaluating post for reply',\r\n  });\r\n\r\n  try {\r\n    const userPrompt = buildUserPrompt(input);\r\n\r\n    const result = await llm.generateJson<{\r\n      should_reply: boolean;\r\n      reason?: string;\r\n      reply_text?: string;\r\n      angle?: string;\r\n    }>({\r\n      system: SYSTEM_PROMPT,\r\n      prompt: userPrompt,\r\n      schemaHint: 'ReplyDecision object',\r\n      temperature: 0.5,\r\n      maxTokens: 512,\r\n    });\r\n\r\n    if (!result) {\r\n      logger.warn({ msg: 'LLM returned null result' });\r\n      return {\r\n        shouldReply: false,\r\n        reason: 'LLM returned invalid response.',\r\n      };\r\n    }\r\n\r\n    // Validate and transform result\r\n    if (result.should_reply === true) {\r\n      // Validate reply_text\r\n      if (!result.reply_text || typeof result.reply_text !== 'string') {\r\n        logger.warn({ msg: 'LLM returned should_reply=true but no reply_text' });\r\n        return {\r\n          shouldReply: false,\r\n          reason: 'Invalid reply generated.',\r\n        };\r\n      }\r\n\r\n      // Enforce max length\r\n      let replyText = result.reply_text.trim();\r\n      if (replyText.length > 280) {\r\n        replyText = replyText.slice(0, 277) + '...';\r\n      }\r\n\r\n      // Validate no blocked content\r\n      if (!validateReplyContent(replyText)) {\r\n        logger.warn({ msg: 'Reply failed content validation' });\r\n        return {\r\n          shouldReply: false,\r\n          reason: 'Generated reply failed content validation.',\r\n        };\r\n      }\r\n\r\n      logger.info({\r\n        postAuthor: input.postAuthor,\r\n        angle: result.angle,\r\n        replyLength: replyText.length,\r\n        msg: 'Generated reply',\r\n      });\r\n\r\n      return {\r\n        shouldReply: true,\r\n        replyText,\r\n        angle: result.angle || 'general',\r\n      };\r\n    } else {\r\n      logger.info({\r\n        postAuthor: input.postAuthor,\r\n        reason: result.reason,\r\n        msg: 'Decided not to reply',\r\n      });\r\n\r\n      return {\r\n        shouldReply: false,\r\n        reason: result.reason || 'No relevant angle for SMF.',\r\n      };\r\n    }\r\n\r\n  } catch (error) {\r\n    logger.error({\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n      msg: 'Reply evaluation failed',\r\n    });\r\n    return {\r\n      shouldReply: false,\r\n      reason: 'Evaluation error.',\r\n    };\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// CONTENT VALIDATION\r\n// =============================================================================\r\n\r\n/**\r\n * Blocked patterns for reply content\r\n */\r\nconst BLOCKED_REPLY_PATTERNS = [\r\n  /localhost/i,\r\n  /127\\.0\\.0\\.1/i,\r\n  /internal/i,\r\n  /roadmap/i,\r\n  /soon/i,\r\n  /guaranteed/i,\r\n  /moon/i,\r\n  /pump/i,\r\n  /dump/i,\r\n  /\\bshit\\b/i,\r\n  /\\bfuck\\b/i,\r\n  /http[s]?:\\/\\//i,  // No links\r\n];\r\n\r\n/**\r\n * Validate reply content against guardrails\r\n */\r\nfunction validateReplyContent(text: string): boolean {\r\n  for (const pattern of BLOCKED_REPLY_PATTERNS) {\r\n    if (pattern.test(text)) {\r\n      logger.warn({ pattern: pattern.source, msg: 'Reply blocked by guardrail' });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Check for emojis (should have none per style guide)\r\n  const emojiCount = (text.match(/\\p{Emoji}/gu) || []).length;\r\n  if (emojiCount > 0) {\r\n    logger.warn({ emojiCount, msg: 'Reply has emojis (style violation)' });\r\n    // Warn but don't block\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// =============================================================================\r\n// EXPORTS\r\n// =============================================================================\r\n\r\nexport { SMF_FACTS, SYSTEM_PROMPT as REPLY_AGENT_SYSTEM_PROMPT };\r\n\r\n","/**\r\n * X Posting Client for SMF\r\n * \r\n * Client module for posting tweets via the X Posting Service.\r\n * Includes retry logic for rate limits and typed responses.\r\n */\r\n\r\n// Re-export types for convenience\r\nexport type { \r\n  TweetMeta, \r\n  TweetRequestBody, \r\n  TweetSuccessResponse, \r\n  TweetErrorResponse,\r\n  TweetErrorCode,\r\n  TweetResponse,\r\n} from './xClient.types.js';\r\n\r\nimport type { \r\n  TweetMeta, \r\n  TweetSuccessResponse, \r\n  TweetErrorResponse \r\n} from './xClient.types.js';\r\n\r\n/**\r\n * Configuration for the X Posting Client\r\n */\r\nexport type XClientConfig = {\r\n  /** Base URL of the X Posting Service (e.g., \"http://localhost:3001\") */\r\n  baseUrl: string;\r\n  /** Optional API key for authentication between SMF and X service */\r\n  apiKey?: string;\r\n};\r\n\r\n/**\r\n * Options for posting a tweet\r\n */\r\nexport type PostTweetOptions = {\r\n  /** Maximum number of retries on rate limit (default: 2) */\r\n  maxRetries?: number;\r\n  /** Initial delay in ms before first retry (default: 5000) */\r\n  initialDelayMs?: number;\r\n};\r\n\r\n/**\r\n * Error thrown when posting fails after retries\r\n */\r\nexport class XPostingError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public readonly response: TweetErrorResponse\r\n  ) {\r\n    super(message);\r\n    this.name = 'XPostingError';\r\n  }\r\n}\r\n\r\n/**\r\n * Sleep utility for retry delays\r\n */\r\nfunction sleep(ms: number): Promise<void> {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n/**\r\n * Client for posting tweets via the X Posting Service.\r\n * \r\n * @example\r\n * ```ts\r\n * const client = new XPostingClient({ baseUrl: 'http://localhost:3001' });\r\n * \r\n * const result = await client.postTweet(\r\n *   'Hello from SMF!',\r\n *   { agentId: 'nexflow-agent', topic: 'intro' }\r\n * );\r\n * \r\n * console.log('Posted:', result.tweetId);\r\n * ```\r\n */\r\nexport class XPostingClient {\r\n  constructor(private config: XClientConfig) {}\r\n\r\n  /**\r\n   * Post a tweet with optional metadata and retry logic.\r\n   * \r\n   * @param text - Tweet content (max 280 characters)\r\n   * @param meta - Optional metadata for tracking\r\n   * @param options - Retry options\r\n   * @returns Success response with tweet ID\r\n   * @throws XPostingError on non-retriable errors or after max retries\r\n   */\r\n  async postTweet(\r\n    text: string,\r\n    meta?: TweetMeta,\r\n    options?: PostTweetOptions\r\n  ): Promise<TweetSuccessResponse> {\r\n    const maxRetries = options?.maxRetries ?? 2;\r\n    const initialDelayMs = options?.initialDelayMs ?? 5_000;\r\n\r\n    let attempt = 0;\r\n    let delay = initialDelayMs;\r\n\r\n    while (true) {\r\n      attempt++;\r\n      \r\n      const result = await this.doPostTweet(text, meta);\r\n      \r\n      // Success!\r\n      if (result.ok) {\r\n        return result;\r\n      }\r\n      \r\n      // Rate limit - check if we should retry\r\n      if (result.code === 'RATE_LIMIT' && attempt <= maxRetries) {\r\n        // Use server-provided retry time if available, otherwise use exponential backoff\r\n        const waitMs = result.retryAfterSeconds \r\n          ? result.retryAfterSeconds * 1000 \r\n          : delay;\r\n        \r\n        console.log(`[X-CLIENT] Rate limited. Retrying in ${Math.ceil(waitMs / 1000)}s (attempt ${attempt}/${maxRetries + 1})`);\r\n        \r\n        await sleep(waitMs);\r\n        \r\n        // Exponential backoff for next retry\r\n        delay *= 2;\r\n        continue;\r\n      }\r\n      \r\n      // Non-retriable error or max retries exceeded\r\n      throw new XPostingError(\r\n        `Failed to post tweet: ${result.code} - ${result.message}`,\r\n        result\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal method to make the actual POST request.\r\n   */\r\n  private async doPostTweet(\r\n    text: string,\r\n    meta?: TweetMeta\r\n  ): Promise<TweetSuccessResponse | TweetErrorResponse> {\r\n    const url = `${this.config.baseUrl}/x/tweet`;\r\n    \r\n    const headers: Record<string, string> = {\r\n      'Content-Type': 'application/json',\r\n    };\r\n    \r\n    // Add API key if configured\r\n    if (this.config.apiKey) {\r\n      headers['Authorization'] = `Bearer ${this.config.apiKey}`;\r\n    }\r\n    \r\n    try {\r\n      const response = await fetch(url, {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify({ text, meta }),\r\n      });\r\n      \r\n      const body = await response.json() as TweetSuccessResponse | TweetErrorResponse;\r\n      return body;\r\n      \r\n    } catch (error: any) {\r\n      // Network error\r\n      return {\r\n        ok: false,\r\n        status: 0,\r\n        code: 'UNKNOWN',\r\n        message: `Network error connecting to X service: ${error.message}`,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check the connection status of the X service.\r\n   */\r\n  async checkStatus(): Promise<{ connected: boolean; message?: string }> {\r\n    try {\r\n      const response = await fetch(`${this.config.baseUrl}/auth/x/status`);\r\n      const body = await response.json();\r\n      return {\r\n        connected: body.connected ?? false,\r\n        message: body.message,\r\n      };\r\n    } catch (error: any) {\r\n      return {\r\n        connected: false,\r\n        message: `Failed to connect to X service: ${error.message}`,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Health check for the X service.\r\n   */\r\n  async healthCheck(): Promise<boolean> {\r\n    try {\r\n      const response = await fetch(`${this.config.baseUrl}/health`);\r\n      return response.ok;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create an XPostingClient from environment variables.\r\n * \r\n * Environment variables:\r\n * - X_POSTING_BASE_URL: Base URL of X service (default: http://localhost:3001)\r\n * - X_POSTING_API_KEY: Optional API key for authentication\r\n * \r\n * @returns Configured XPostingClient instance\r\n */\r\nexport function createXPostingClientFromEnv(): XPostingClient {\r\n  const baseUrl = process.env.X_POSTING_BASE_URL || 'http://localhost:3001';\r\n  const apiKey = process.env.X_POSTING_API_KEY;\r\n  \r\n  return new XPostingClient({ baseUrl, apiKey });\r\n}\r\n\r\n","/**\r\n * SMF Reply Runner\r\n * \r\n * Coordinates the SMF reply agent for X (Twitter) with strict cadence\r\n * and rate limiting. Runs every 15 minutes via cron.\r\n * \r\n * Constraints:\r\n * - Max 8 replies per 24 hours\r\n * - At least 120 minutes between replies\r\n * - Max 1 reply per 15-minute run\r\n */\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport { evaluateForReply, type ReplyAgentInput } from './replyAgent';\r\nimport { createXPostingClientFromEnv } from '@/integrations/xClient';\r\nimport { Pool } from 'pg';\r\n\r\nconst logger = createLogger({ component: 'ReplyRunner' });\r\n\r\n// =============================================================================\r\n// DATABASE CONNECTION\r\n// =============================================================================\r\n\r\nlet pool: Pool | null = null;\r\n\r\nfunction getPool(): Pool | null {\r\n  if (pool) return pool;\r\n  \r\n  const databaseUrl = process.env.DATABASE_URL;\r\n  if (!databaseUrl || !databaseUrl.startsWith('postgresql://')) {\r\n    logger.warn({ msg: 'DATABASE_URL not configured for social reply state' });\r\n    return null;\r\n  }\r\n  \r\n  pool = new Pool({\r\n    connectionString: databaseUrl,\r\n    max: 3,\r\n    idleTimeoutMillis: 30000,\r\n    connectionTimeoutMillis: 5000,\r\n  });\r\n  \r\n  return pool;\r\n}\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\n/** Maximum replies allowed in a 24-hour window */\r\nconst MAX_REPLIES_PER_24H = 8;\r\n\r\n/** Minimum minutes between replies (2 hours) */\r\nconst MIN_MINUTES_BETWEEN_REPLIES = 120;\r\n\r\n/** Maximum candidates to fetch per run */\r\nconst MAX_CANDIDATES_PER_RUN = 30;\r\n\r\n/** Search query for finding relevant posts */\r\nconst SEARCH_QUERY = 'x402 OR facilitator OR \"agent payments\" OR ZAUTH OR \"payment infrastructure\"';\r\n\r\n/** Minimum score threshold to reply (configurable via env) */\r\nconst REPLY_SCORE_THRESHOLD = parseFloat(process.env.REPLY_SCORE_THRESHOLD ?? '0.7');\r\n\r\n/** Maximum age in hours for normal posts (hard cutoff) */\r\nconst MAX_POST_AGE_HOURS = 48;\r\n\r\n/** Maximum age in hours for \"big announcement\" posts */\r\nconst MAX_BIG_ANNOUNCEMENT_AGE_HOURS = 72;\r\n\r\n/** Authors considered \"big announcements\" (official ecosystem accounts) */\r\nconst BIG_ANNOUNCEMENT_AUTHORS = [\r\n  '@x402protocol',\r\n  '@coinaboratory',\r\n  '@zauthx402',\r\n  '@payloaddotxyz',\r\n  // Add more official accounts as needed\r\n];\r\n\r\n/** Keywords that indicate a \"big announcement\" post */\r\nconst BIG_ANNOUNCEMENT_KEYWORDS = [\r\n  'launching',\r\n  'announcing',\r\n  'introducing',\r\n  'release',\r\n  'mainnet',\r\n  'partnership',\r\n  'integration',\r\n];\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\n/**\r\n * Persistent state for tracking reply activity\r\n */\r\nexport interface SocialReplyState {\r\n  /** ID of the last checked post (for pagination) */\r\n  lastCheckedPostId: string | null;\r\n  /** Timestamp of the last reply we posted */\r\n  lastReplyAt: Date | null;\r\n  /** Number of replies posted in the last 24 hours */\r\n  repliesLast24h: number;\r\n  /** Timestamp when repliesLast24h was last reset */\r\n  repliesWindowStart: Date;\r\n}\r\n\r\n/**\r\n * A candidate post to potentially reply to\r\n */\r\nexport interface CandidatePost {\r\n  /** Post ID */\r\n  id: string;\r\n  /** Post text content */\r\n  text: string;\r\n  /** Author handle (e.g., @zauthx402) */\r\n  author: string;\r\n  /** Thread ID for deduplication */\r\n  threadId: string;\r\n  /** Previous posts in thread (if available) */\r\n  threadContext?: string[];\r\n  /** Post timestamp */\r\n  postedAt: Date;\r\n  /** LLM-computed relevance score (0-1) */\r\n  relevanceScore?: number;\r\n  /** Number of likes on the post */\r\n  likes?: number;\r\n  /** Number of replies to the post */\r\n  replies?: number;\r\n  /** If this post is a reply, the ID it's replying to */\r\n  inReplyTo?: string;\r\n}\r\n\r\n/**\r\n * Result of a reply scan run\r\n */\r\nexport interface ReplyScanResult {\r\n  /** Whether a reply was posted this run */\r\n  postedReply: boolean;\r\n  /** Number of candidates fetched */\r\n  candidatesFetched: number;\r\n  /** Number of candidates evaluated by the agent */\r\n  candidatesEvaluated: number;\r\n  /** Reason if no reply was posted */\r\n  skipReason?: string;\r\n  /** The reply that was posted (if any) */\r\n  replyPosted?: {\r\n    inReplyToId: string;\r\n    text: string;\r\n    angle: string;\r\n  };\r\n  /** Duration of the run in ms */\r\n  durationMs: number;\r\n}\r\n\r\n// =============================================================================\r\n// SOCIAL STATE STORE (PostgreSQL-backed)\r\n// =============================================================================\r\n\r\nconst STATE_ID = 'smf-reply-agent';\r\n\r\n/**\r\n * Persistent store for social reply state using PostgreSQL.\r\n * Creates table if it doesn't exist.\r\n */\r\nexport const socialStateStore = {\r\n  /**\r\n   * Ensure the state table exists\r\n   */\r\n  async ensureTable(): Promise<void> {\r\n    const db = getPool();\r\n    if (!db) return;\r\n    \r\n    await db.query(`\r\n      CREATE TABLE IF NOT EXISTS social_reply_state (\r\n        id TEXT PRIMARY KEY,\r\n        last_checked_post_id TEXT,\r\n        last_reply_at TIMESTAMPTZ,\r\n        replies_last_24h INTEGER DEFAULT 0,\r\n        replies_window_start TIMESTAMPTZ DEFAULT NOW(),\r\n        updated_at TIMESTAMPTZ DEFAULT NOW()\r\n      )\r\n    `);\r\n  },\r\n\r\n  /**\r\n   * Get current state\r\n   */\r\n  async get(): Promise<SocialReplyState> {\r\n    const db = getPool();\r\n    \r\n    // Default state if no DB\r\n    const defaultState: SocialReplyState = {\r\n      lastCheckedPostId: null,\r\n      lastReplyAt: null,\r\n      repliesLast24h: 0,\r\n      repliesWindowStart: new Date(),\r\n    };\r\n    \r\n    if (!db) {\r\n      logger.warn({ msg: 'No database, using default state' });\r\n      return defaultState;\r\n    }\r\n    \r\n    try {\r\n      await this.ensureTable();\r\n      \r\n      const result = await db.query(\r\n        'SELECT * FROM social_reply_state WHERE id = $1',\r\n        [STATE_ID]\r\n      );\r\n      \r\n      if (result.rows.length === 0) {\r\n        // Insert default state\r\n        await db.query(`\r\n          INSERT INTO social_reply_state (id, replies_window_start)\r\n          VALUES ($1, NOW())\r\n          ON CONFLICT (id) DO NOTHING\r\n        `, [STATE_ID]);\r\n        \r\n        logger.info({ msg: 'Initialized social reply state in database' });\r\n        return defaultState;\r\n      }\r\n      \r\n      const row = result.rows[0];\r\n      return {\r\n        lastCheckedPostId: row.last_checked_post_id,\r\n        lastReplyAt: row.last_reply_at ? new Date(row.last_reply_at) : null,\r\n        repliesLast24h: row.replies_last_24h || 0,\r\n        repliesWindowStart: new Date(row.replies_window_start || Date.now()),\r\n      };\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to get social state from DB' });\r\n      return defaultState;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update state\r\n   */\r\n  async update(updates: Partial<SocialReplyState>): Promise<void> {\r\n    const db = getPool();\r\n    if (!db) {\r\n      logger.warn({ updates, msg: 'No database, skipping state update' });\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      await this.ensureTable();\r\n      \r\n      const setClauses: string[] = ['updated_at = NOW()'];\r\n      const values: any[] = [];\r\n      let paramIndex = 1;\r\n      \r\n      if (updates.lastCheckedPostId !== undefined) {\r\n        setClauses.push(`last_checked_post_id = $${paramIndex++}`);\r\n        values.push(updates.lastCheckedPostId);\r\n      }\r\n      if (updates.lastReplyAt !== undefined) {\r\n        setClauses.push(`last_reply_at = $${paramIndex++}`);\r\n        values.push(updates.lastReplyAt);\r\n      }\r\n      if (updates.repliesLast24h !== undefined) {\r\n        setClauses.push(`replies_last_24h = $${paramIndex++}`);\r\n        values.push(updates.repliesLast24h);\r\n      }\r\n      if (updates.repliesWindowStart !== undefined) {\r\n        setClauses.push(`replies_window_start = $${paramIndex++}`);\r\n        values.push(updates.repliesWindowStart);\r\n      }\r\n      \r\n      values.push(STATE_ID);\r\n      \r\n      await db.query(`\r\n        INSERT INTO social_reply_state (id, ${\r\n          updates.lastCheckedPostId !== undefined ? 'last_checked_post_id,' : ''\r\n        }${updates.lastReplyAt !== undefined ? 'last_reply_at,' : ''\r\n        }${updates.repliesLast24h !== undefined ? 'replies_last_24h,' : ''\r\n        }${updates.repliesWindowStart !== undefined ? 'replies_window_start,' : ''\r\n        } updated_at)\r\n        VALUES ($${paramIndex}, ${values.slice(0, -1).map((_, i) => `$${i + 1}`).join(', ')}${values.length > 1 ? ',' : ''} NOW())\r\n        ON CONFLICT (id) DO UPDATE SET ${setClauses.join(', ')}\r\n      `, values);\r\n      \r\n      logger.debug({ updates, msg: 'Updated social reply state in database' });\r\n    } catch (error) {\r\n      logger.error({ error, msg: 'Failed to update social state in DB' });\r\n    }\r\n  },\r\n};\r\n\r\n// =============================================================================\r\n// X API FUNCTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Fetch recent posts matching our search criteria.\r\n * \r\n * NOTE: X API v2 search requires elevated access ($100/month Basic tier).\r\n * For now, this returns empty - posts should come from a webhook/stream\r\n * or manual curation. To enable search, set X_SEARCH_BEARER_TOKEN.\r\n */\r\nexport async function fetchRecentPosts(params: {\r\n  sinceId: string | null;\r\n  limit: number;\r\n  query: string;\r\n}): Promise<CandidatePost[]> {\r\n  const bearerToken = process.env.X_SEARCH_BEARER_TOKEN;\r\n  \r\n  // If no bearer token, return empty (search requires paid tier)\r\n  if (!bearerToken) {\r\n    logger.info({\r\n      sinceId: params.sinceId,\r\n      limit: params.limit,\r\n      msg: 'X search not configured (X_SEARCH_BEARER_TOKEN missing), returning empty',\r\n    });\r\n    return [];\r\n  }\r\n  \r\n  try {\r\n    const url = new URL('https://api.twitter.com/2/tweets/search/recent');\r\n    url.searchParams.set('query', params.query);\r\n    url.searchParams.set('max_results', String(Math.min(params.limit, 100)));\r\n    url.searchParams.set('tweet.fields', 'author_id,conversation_id,created_at,public_metrics');\r\n    url.searchParams.set('expansions', 'author_id');\r\n    url.searchParams.set('user.fields', 'username');\r\n    \r\n    if (params.sinceId) {\r\n      url.searchParams.set('since_id', params.sinceId);\r\n    }\r\n    \r\n    const response = await fetch(url.toString(), {\r\n      headers: {\r\n        'Authorization': `Bearer ${bearerToken}`,\r\n      },\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      logger.error({\r\n        status: response.status,\r\n        error: errorText,\r\n        msg: 'X search API error',\r\n      });\r\n      return [];\r\n    }\r\n    \r\n    const data = await response.json();\r\n    const tweets = data.data || [];\r\n    const users = data.includes?.users || [];\r\n    \r\n    // Map user IDs to usernames\r\n    const userMap = new Map(users.map((u: any) => [u.id, u.username]));\r\n    \r\n    const candidates: CandidatePost[] = tweets.map((tweet: any) => ({\r\n      id: tweet.id,\r\n      text: tweet.text,\r\n      author: `@${userMap.get(tweet.author_id) || 'unknown'}`,\r\n      threadId: tweet.conversation_id || tweet.id,\r\n      postedAt: new Date(tweet.created_at),\r\n      likes: tweet.public_metrics?.like_count || 0,\r\n      replies: tweet.public_metrics?.reply_count || 0,\r\n      inReplyTo: tweet.in_reply_to_user_id ? tweet.id : undefined,\r\n    }));\r\n    \r\n    logger.info({\r\n      fetched: candidates.length,\r\n      sinceId: params.sinceId,\r\n      msg: 'Fetched posts from X search API',\r\n    });\r\n    \r\n    return candidates;\r\n  } catch (error) {\r\n    logger.error({\r\n      error: error instanceof Error ? error.message : 'Unknown',\r\n      msg: 'Failed to fetch posts from X',\r\n    });\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Post a reply to a tweet using the X Posting Service.\r\n */\r\nexport async function postReply(params: {\r\n  inReplyToId: string;\r\n  text: string;\r\n}): Promise<{ success: boolean; tweetId?: string; error?: string }> {\r\n  const xClient = createXPostingClientFromEnv();\r\n  \r\n  try {\r\n    // Check if X service is connected\r\n    const status = await xClient.checkStatus();\r\n    if (!status.connected) {\r\n      logger.warn({\r\n        message: status.message,\r\n        msg: 'X service not connected, cannot post reply',\r\n      });\r\n      return { success: false, error: 'X service not connected' };\r\n    }\r\n    \r\n    // Post the reply\r\n    // Note: The current XPostingClient doesn't support in_reply_to directly,\r\n    // so we include the reply context in the meta for tracking.\r\n    // To actually reply to a tweet, the X Posting Service needs to support\r\n    // the reply parameter in its /x/tweet endpoint.\r\n    const result = await xClient.postTweet(\r\n      params.text,\r\n      {\r\n        agentId: 'smf-reply-agent',\r\n        topic: 'reply',\r\n        correlationId: params.inReplyToId,\r\n      }\r\n    );\r\n    \r\n    logger.info({\r\n      tweetId: result.tweetId,\r\n      inReplyToId: params.inReplyToId,\r\n      msg: 'Reply posted successfully via X Posting Service',\r\n    });\r\n    \r\n    return { success: true, tweetId: result.tweetId };\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n    logger.error({\r\n      error: errorMessage,\r\n      inReplyToId: params.inReplyToId,\r\n      msg: 'Failed to post reply',\r\n    });\r\n    return { success: false, error: errorMessage };\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure the replies tracking table exists\r\n */\r\nasync function ensureRepliesTable(): Promise<void> {\r\n  const db = getPool();\r\n  if (!db) return;\r\n  \r\n  await db.query(`\r\n    CREATE TABLE IF NOT EXISTS social_replies (\r\n      id SERIAL PRIMARY KEY,\r\n      thread_id TEXT NOT NULL,\r\n      post_id TEXT NOT NULL,\r\n      reply_text TEXT,\r\n      angle TEXT,\r\n      replied_at TIMESTAMPTZ DEFAULT NOW(),\r\n      UNIQUE(thread_id, post_id)\r\n    )\r\n  `);\r\n  \r\n  await db.query(`\r\n    CREATE INDEX IF NOT EXISTS idx_social_replies_thread_id \r\n    ON social_replies(thread_id)\r\n  `);\r\n}\r\n\r\n/**\r\n * Check if we've already replied to a thread (within last 7 days).\r\n */\r\nexport async function hasRepliedToThread(threadId: string): Promise<boolean> {\r\n  const db = getPool();\r\n  \r\n  if (!db) {\r\n    logger.debug({ threadId, msg: 'No database, assuming not replied' });\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    await ensureRepliesTable();\r\n    \r\n    const result = await db.query(\r\n      `SELECT 1 FROM social_replies \r\n       WHERE thread_id = $1 \r\n       AND replied_at > NOW() - INTERVAL '7 days'\r\n       LIMIT 1`,\r\n      [threadId]\r\n    );\r\n    \r\n    const hasReplied = result.rows.length > 0;\r\n    \r\n    logger.debug({ \r\n      threadId, \r\n      hasReplied,\r\n      msg: 'Checked thread reply status' \r\n    });\r\n    \r\n    return hasReplied;\r\n  } catch (error) {\r\n    logger.error({ error, threadId, msg: 'Failed to check thread reply status' });\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Record that we replied to a thread (for deduplication).\r\n */\r\nexport async function recordReply(params: {\r\n  threadId: string;\r\n  postId: string;\r\n  replyText: string;\r\n  angle: string;\r\n}): Promise<void> {\r\n  const db = getPool();\r\n  \r\n  if (!db) {\r\n    logger.warn({ params, msg: 'No database, skipping reply record' });\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    await ensureRepliesTable();\r\n    \r\n    await db.query(\r\n      `INSERT INTO social_replies (thread_id, post_id, reply_text, angle, replied_at)\r\n       VALUES ($1, $2, $3, $4, NOW())\r\n       ON CONFLICT (thread_id, post_id) DO UPDATE SET\r\n         reply_text = EXCLUDED.reply_text,\r\n         angle = EXCLUDED.angle,\r\n         replied_at = NOW()`,\r\n      [params.threadId, params.postId, params.replyText, params.angle]\r\n    );\r\n    \r\n    logger.info({\r\n      threadId: params.threadId,\r\n      postId: params.postId,\r\n      angle: params.angle,\r\n      msg: 'Recorded reply in database',\r\n    });\r\n  } catch (error) {\r\n    logger.error({ error, params, msg: 'Failed to record reply' });\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// HELPER FUNCTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Get the newest post ID from candidates for pagination\r\n */\r\nfunction getNewestPostId(candidates: CandidatePost[], currentLastId: string | null): string | null {\r\n  if (candidates.length === 0) {\r\n    return currentLastId;\r\n  }\r\n  \r\n  // Assuming IDs are sortable (newer = higher)\r\n  const sortedByTime = [...candidates].sort(\r\n    (a, b) => b.postedAt.getTime() - a.postedAt.getTime()\r\n  );\r\n  \r\n  return sortedByTime[0].id;\r\n}\r\n\r\n/**\r\n * Sort candidates by composite score (highest first)\r\n */\r\nfunction sortByScore(candidates: CandidatePost[]): CandidatePost[] {\r\n  // Compute and cache scores\r\n  const scored = candidates.map(post => ({\r\n    post,\r\n    score: calculatePostScore(post),\r\n  }));\r\n  \r\n  // Sort by score descending\r\n  scored.sort((a, b) => b.score - a.score);\r\n  \r\n  return scored.map(s => s.post);\r\n}\r\n\r\n/**\r\n * Check if a post is a \"big announcement\" (allowed longer age window)\r\n */\r\nfunction isBigAnnouncement(post: CandidatePost): boolean {\r\n  // Check if author is on whitelist\r\n  const authorLower = post.author.toLowerCase();\r\n  if (BIG_ANNOUNCEMENT_AUTHORS.some(a => authorLower.includes(a.toLowerCase().replace('@', '')))) {\r\n    return true;\r\n  }\r\n  \r\n  // Check for announcement keywords\r\n  const textLower = post.text.toLowerCase();\r\n  if (BIG_ANNOUNCEMENT_KEYWORDS.some(kw => textLower.includes(kw))) {\r\n    return true;\r\n  }\r\n  \r\n  return false;\r\n}\r\n\r\n/**\r\n * Calculate composite score for a candidate post.\r\n * \r\n * Formula: score = (recency * 0.4) + (engagement * 0.3) + (relevance * 0.3)\r\n *          + 0.1 if active thread boost applies\r\n * \r\n * Returns 0 if post is too old (hard cutoff).\r\n */\r\nexport function calculatePostScore(post: CandidatePost): number {\r\n  const now = new Date();\r\n  const ageHours = (now.getTime() - post.postedAt.getTime()) / (1000 * 60 * 60);\r\n  \r\n  // === AGE CUTOFF (hard constraint) ===\r\n  const maxAge = isBigAnnouncement(post) ? MAX_BIG_ANNOUNCEMENT_AGE_HOURS : MAX_POST_AGE_HOURS;\r\n  if (ageHours > maxAge) {\r\n    logger.debug({\r\n      postId: post.id,\r\n      ageHours: Math.round(ageHours),\r\n      maxAge,\r\n      isBigAnnouncement: isBigAnnouncement(post),\r\n      msg: 'Post too old, score = 0',\r\n    });\r\n    return 0;\r\n  }\r\n  \r\n  // === RECENCY SCORE (0-1) ===\r\n  // Exponential decay over the max age window\r\n  // At age=0: recency=1, at age=maxAge: recencyâ‰ˆ0.05\r\n  const recencyDecay = Math.exp(-3 * ageHours / maxAge);\r\n  const recency = Math.max(0, Math.min(1, recencyDecay));\r\n  \r\n  // === ENGAGEMENT SCORE (0-1) ===\r\n  // Weight replies more than likes: engagement_raw = likes + 2*replies\r\n  // Cap at 50 to avoid viral posts dominating\r\n  const likes = post.likes ?? 0;\r\n  const replies = post.replies ?? 0;\r\n  const engagementRaw = likes + 2 * replies;\r\n  const engagement = Math.min(engagementRaw, 50) / 50;\r\n  \r\n  // === RELEVANCE SCORE (0-1) ===\r\n  // Use LLM-computed score if available, otherwise use keyword heuristic\r\n  const relevance = post.relevanceScore ?? computeKeywordRelevance(post.text);\r\n  \r\n  // === WEIGHTED COMPOSITE ===\r\n  let score = (recency * 0.4) + (engagement * 0.3) + (relevance * 0.3);\r\n  \r\n  // === ACTIVE THREAD BOOST ===\r\n  // If this is a reply in an active thread (>2 replies), boost score\r\n  if (post.inReplyTo && replies > 2) {\r\n    score += 0.1;\r\n  }\r\n  \r\n  // Clamp to [0, 1]\r\n  score = Math.max(0, Math.min(1, score));\r\n  \r\n  logger.debug({\r\n    postId: post.id,\r\n    ageHours: Math.round(ageHours * 10) / 10,\r\n    recency: Math.round(recency * 100) / 100,\r\n    engagement: Math.round(engagement * 100) / 100,\r\n    relevance: Math.round(relevance * 100) / 100,\r\n    activeThreadBoost: post.inReplyTo && replies > 2,\r\n    finalScore: Math.round(score * 100) / 100,\r\n    msg: 'Calculated post score',\r\n  });\r\n  \r\n  return score;\r\n}\r\n\r\n/**\r\n * Compute keyword-based relevance score (0-1) as fallback when no LLM score\r\n */\r\nfunction computeKeywordRelevance(text: string): number {\r\n  const lower = text.toLowerCase();\r\n  let rawScore = 0;\r\n  \r\n  // High-value keywords (weight by importance)\r\n  if (lower.includes('x402')) rawScore += 10;\r\n  if (lower.includes('facilitator')) rawScore += 8;\r\n  if (lower.includes('agent payment')) rawScore += 8;\r\n  if (lower.includes('zauth')) rawScore += 7;\r\n  if (lower.includes('routing')) rawScore += 5;\r\n  if (lower.includes('infrastructure')) rawScore += 4;\r\n  if (lower.includes('payment')) rawScore += 3;\r\n  if (lower.includes('agent')) rawScore += 2;\r\n  \r\n  // Normalize to 0-1 (max possible ~47)\r\n  return Math.min(rawScore / 30, 1);\r\n}\r\n\r\n/**\r\n * Reset the 24-hour reply counter if the window has passed\r\n */\r\nfunction maybeResetDailyCounter(state: SocialReplyState): SocialReplyState {\r\n  const now = new Date();\r\n  const windowAgeMs = now.getTime() - state.repliesWindowStart.getTime();\r\n  const twentyFourHoursMs = 24 * 60 * 60 * 1000;\r\n  \r\n  if (windowAgeMs >= twentyFourHoursMs) {\r\n    return {\r\n      ...state,\r\n      repliesLast24h: 0,\r\n      repliesWindowStart: now,\r\n    };\r\n  }\r\n  \r\n  return state;\r\n}\r\n\r\n// =============================================================================\r\n// MAIN RUNNER\r\n// =============================================================================\r\n\r\n/**\r\n * Run a single reply scan tick.\r\n * \r\n * Called every 15 minutes by cron. Fetches candidates, evaluates them,\r\n * and posts at most 1 reply if within rate limits.\r\n */\r\nexport async function runReplyScanTick(): Promise<ReplyScanResult> {\r\n  const startTime = Date.now();\r\n  \r\n  logger.info({ msg: 'ðŸ” Starting reply scan tick' });\r\n  \r\n  // 1. Get current state\r\n  let state = await socialStateStore.get();\r\n  \r\n  // 2. Reset daily counter if 24h window has passed\r\n  state = maybeResetDailyCounter(state);\r\n  \r\n  // 3. Check rate limits BEFORE fetching candidates\r\n  const now = new Date();\r\n  const minutesSinceLastReply = state.lastReplyAt\r\n    ? (now.getTime() - state.lastReplyAt.getTime()) / 60000\r\n    : Infinity;\r\n  \r\n  const canPostBasedOnTime = minutesSinceLastReply >= MIN_MINUTES_BETWEEN_REPLIES;\r\n  const withinDailyLimit = state.repliesLast24h < MAX_REPLIES_PER_24H;\r\n  \r\n  logger.info({\r\n    minutesSinceLastReply: Math.round(minutesSinceLastReply),\r\n    repliesLast24h: state.repliesLast24h,\r\n    canPostBasedOnTime,\r\n    withinDailyLimit,\r\n    msg: 'Rate limit check',\r\n  });\r\n  \r\n  // 4. Fetch candidates\r\n  const candidates = await fetchRecentPosts({\r\n    sinceId: state.lastCheckedPostId,\r\n    limit: MAX_CANDIDATES_PER_RUN,\r\n    query: SEARCH_QUERY,\r\n  });\r\n  \r\n  // 5. Update pagination cursor (always, even if we don't reply)\r\n  const newLastCheckedId = getNewestPostId(candidates, state.lastCheckedPostId);\r\n  \r\n  // 6. Early exit if no candidates\r\n  if (candidates.length === 0) {\r\n    await socialStateStore.update({\r\n      lastCheckedPostId: newLastCheckedId,\r\n    });\r\n    \r\n    const result: ReplyScanResult = {\r\n      postedReply: false,\r\n      candidatesFetched: 0,\r\n      candidatesEvaluated: 0,\r\n      skipReason: 'no_candidates',\r\n      durationMs: Date.now() - startTime,\r\n    };\r\n    \r\n    logger.info({ ...result, msg: 'âœ… Reply scan complete (no candidates)' });\r\n    return result;\r\n  }\r\n  \r\n  // 7. Sort by composite score (recency + engagement + relevance)\r\n  const sortedCandidates = sortByScore(candidates);\r\n  \r\n  // Log top candidates for debugging\r\n  logger.info({\r\n    topCandidates: sortedCandidates.slice(0, 5).map(p => ({\r\n      id: p.id,\r\n      author: p.author,\r\n      score: Math.round(calculatePostScore(p) * 100) / 100,\r\n      ageHours: Math.round((Date.now() - p.postedAt.getTime()) / (1000 * 60 * 60) * 10) / 10,\r\n    })),\r\n    msg: 'Top candidates by score',\r\n  });\r\n  \r\n  // 8. Check if we can post at all\r\n  if (!canPostBasedOnTime) {\r\n    await socialStateStore.update({\r\n      lastCheckedPostId: newLastCheckedId,\r\n    });\r\n    \r\n    const result: ReplyScanResult = {\r\n      postedReply: false,\r\n      candidatesFetched: candidates.length,\r\n      candidatesEvaluated: 0,\r\n      skipReason: 'cooldown_not_elapsed',\r\n      durationMs: Date.now() - startTime,\r\n    };\r\n    \r\n    logger.info({ \r\n      ...result, \r\n      minutesRemaining: Math.round(MIN_MINUTES_BETWEEN_REPLIES - minutesSinceLastReply),\r\n      msg: 'âœ… Reply scan complete (cooldown)' \r\n    });\r\n    return result;\r\n  }\r\n  \r\n  if (!withinDailyLimit) {\r\n    await socialStateStore.update({\r\n      lastCheckedPostId: newLastCheckedId,\r\n    });\r\n    \r\n    const result: ReplyScanResult = {\r\n      postedReply: false,\r\n      candidatesFetched: candidates.length,\r\n      candidatesEvaluated: 0,\r\n      skipReason: 'daily_cap_reached',\r\n      durationMs: Date.now() - startTime,\r\n    };\r\n    \r\n    logger.info({ \r\n      ...result, \r\n      repliesUsed: state.repliesLast24h,\r\n      maxReplies: MAX_REPLIES_PER_24H,\r\n      msg: 'âœ… Reply scan complete (daily cap)' \r\n    });\r\n    return result;\r\n  }\r\n  \r\n  // 9. Evaluate candidates and try to post\r\n  let postedReply = false;\r\n  let candidatesEvaluated = 0;\r\n  let candidatesBelowThreshold = 0;\r\n  let replyPosted: ReplyScanResult['replyPosted'] = undefined;\r\n  \r\n  for (const post of sortedCandidates) {\r\n    // Calculate score and check threshold BEFORE calling agent\r\n    const postScore = calculatePostScore(post);\r\n    \r\n    if (postScore < REPLY_SCORE_THRESHOLD) {\r\n      candidatesBelowThreshold++;\r\n      logger.debug({\r\n        postId: post.id,\r\n        score: postScore,\r\n        threshold: REPLY_SCORE_THRESHOLD,\r\n        msg: 'Skipping candidate below score threshold',\r\n      });\r\n      continue;\r\n    }\r\n    \r\n    candidatesEvaluated++;\r\n    \r\n    // Check if we've already replied to this thread\r\n    const alreadyReplied = await hasRepliedToThread(post.threadId);\r\n    \r\n    // Build agent input\r\n    const agentInput: ReplyAgentInput = {\r\n      postText: post.text,\r\n      postAuthor: post.author,\r\n      threadContext: post.threadContext,\r\n      alreadyReplied,\r\n    };\r\n    \r\n    // Call the reply agent\r\n    const agentResult = await evaluateForReply(agentInput);\r\n    \r\n    logger.debug({\r\n      postId: post.id,\r\n      author: post.author,\r\n      shouldReply: agentResult.shouldReply,\r\n      reason: agentResult.shouldReply ? undefined : (agentResult as any).reason,\r\n      msg: 'Agent evaluation result',\r\n    });\r\n    \r\n    if (!agentResult.shouldReply) {\r\n      continue;\r\n    }\r\n    \r\n    // Post the reply\r\n    const postResult = await postReply({\r\n      inReplyToId: post.id,\r\n      text: agentResult.replyText,\r\n    });\r\n    \r\n    if (!postResult.success) {\r\n      logger.error({\r\n        postId: post.id,\r\n        error: postResult.error,\r\n        msg: 'Failed to post reply',\r\n      });\r\n      continue;\r\n    }\r\n    \r\n    // Record the reply for deduplication\r\n    await recordReply({\r\n      threadId: post.threadId,\r\n      postId: post.id,\r\n      replyText: agentResult.replyText,\r\n      angle: agentResult.angle,\r\n    });\r\n    \r\n    // Update state\r\n    await socialStateStore.update({\r\n      lastCheckedPostId: newLastCheckedId,\r\n      lastReplyAt: now,\r\n      repliesLast24h: state.repliesLast24h + 1,\r\n    });\r\n    \r\n    postedReply = true;\r\n    replyPosted = {\r\n      inReplyToId: post.id,\r\n      text: agentResult.replyText,\r\n      angle: agentResult.angle,\r\n    };\r\n    \r\n    logger.info({\r\n      postId: post.id,\r\n      author: post.author,\r\n      angle: agentResult.angle,\r\n      replyPreview: agentResult.replyText.slice(0, 50),\r\n      msg: 'âœ… Reply posted successfully',\r\n    });\r\n    \r\n    // Only post ONE reply per run\r\n    break;\r\n  }\r\n  \r\n  // 10. Update state if we didn't post\r\n  if (!postedReply) {\r\n    await socialStateStore.update({\r\n      lastCheckedPostId: newLastCheckedId,\r\n    });\r\n  }\r\n  \r\n  // 11. Determine skip reason\r\n  let skipReason: string | undefined;\r\n  if (!postedReply) {\r\n    if (candidatesBelowThreshold === sortedCandidates.length) {\r\n      skipReason = 'no_candidate_above_threshold';\r\n    } else if (candidatesEvaluated > 0) {\r\n      skipReason = 'agent_returned_none';\r\n    } else {\r\n      skipReason = 'no_good_candidates';\r\n    }\r\n  }\r\n  \r\n  // 12. Return result\r\n  const result: ReplyScanResult = {\r\n    postedReply,\r\n    candidatesFetched: candidates.length,\r\n    candidatesEvaluated,\r\n    skipReason,\r\n    replyPosted,\r\n    durationMs: Date.now() - startTime,\r\n  };\r\n  \r\n  logger.info({\r\n    ...result,\r\n    candidatesBelowThreshold,\r\n    scoreThreshold: REPLY_SCORE_THRESHOLD,\r\n    msg: `âœ… Reply scan complete (${postedReply ? 'replied' : 'no reply'})`,\r\n  });\r\n  \r\n  return result;\r\n}\r\n\r\n// =============================================================================\r\n// EXPORTS\r\n// =============================================================================\r\n\r\nexport {\r\n  MAX_REPLIES_PER_24H,\r\n  MIN_MINUTES_BETWEEN_REPLIES,\r\n  MAX_CANDIDATES_PER_RUN,\r\n  MAX_POST_AGE_HOURS,\r\n  MAX_BIG_ANNOUNCEMENT_AGE_HOURS,\r\n  REPLY_SCORE_THRESHOLD,\r\n  SEARCH_QUERY,\r\n};\r\n\r\n","// =============================================================================\r\n// SOCIAL REPLY CRON ENDPOINT\r\n// =============================================================================\r\n// GET /api/cron/social-reply\r\n//\r\n// Runs every 15 minutes to scan for posts to reply to.\r\n// Respects strict rate limits:\r\n// - Max 8 replies per 24 hours\r\n// - At least 2 hours between replies\r\n// - Max 1 reply per run\r\n//\r\n// Environment Variables:\r\n//   - SOCIAL_REPLY_ENABLED: \"true\" to enable\r\n//   - CRON_SECRET: Optional secret for authorization\r\n//\r\n// Triggered by Vercel Cron or manual invocation\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport { runReplyScanTick } from '@/social/replyRunner';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { withCronJobTracking, type CronJobContext } from '@/lib/cron-job-wrapper';\r\n\r\nconst logger = createLogger({ component: 'SocialReplyCron' });\r\n\r\n// =============================================================================\r\n// CRON HANDLER\r\n// =============================================================================\r\n\r\nasync function socialReplyHandler(\r\n  _request: NextRequest,\r\n  context: CronJobContext\r\n): Promise<{ ok: boolean; [key: string]: any }> {\r\n  const { runId, requestId } = context;\r\n\r\n  logger.info({ runId, requestId, msg: 'Starting social reply scan' });\r\n\r\n  const result = await runReplyScanTick();\r\n\r\n  logger.info({\r\n    runId,\r\n    requestId,\r\n    ...result,\r\n    msg: 'Social reply scan completed',\r\n  });\r\n\r\n  return {\r\n    ok: true,\r\n    ...result,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// EXPORTS\r\n// =============================================================================\r\n\r\nexport const dynamic = 'force-dynamic';\r\nexport const maxDuration = 60;\r\n\r\nexport const GET = withCronJobTracking(socialReplyHandler, {\r\n  jobId: 'social-reply',\r\n  enabledEnvVar: 'SOCIAL_REPLY_ENABLED',\r\n  timeout: 55000, // 55s (leave buffer for wrapper overhead)\r\n  minInterval: 14 * 60 * 1000, // 14 minutes (schedule is every 15 min)\r\n});\r\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n"],"names":["AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","addRequestMeta","getRequestMeta","getTracer","SpanKind","setReferenceManifestsSingleton","createServerModuleMap","normalizeAppPath","NodeNextRequest","NodeNextResponse","NextRequestAdapter","signalFromNodeResponse","BaseServerSpan","getRevalidateReason","sendResponse","fromNodeOutgoingHttpHeaders","toNodeOutgoingHttpHeaders","getCacheControlHeader","INFINITE_CACHE","NEXT_CACHE_TAGS_HEADER","NoFallbackError","CachedRouteKind","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks","handler","req","res","ctx","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","params","nextConfig","parsedUrl","isDraftMode","prerenderManifest","routerServerContext","isOnDemandRevalidate","revalidateOnlyGenerated","resolvedPathname","clientReferenceManifest","serverActionsManifest","normalizedSrcPage","isIsr","Boolean","dynamicRoutes","routes","render404","isPrerendered","prerenderInfo","fallback","experimental","adapterPath","cacheKey","supportsDynamicResponse","isStaticGeneration","serverModuleMap","method","tracer","activeSpan","getActiveScopeSpan","context","renderOpts","authInterrupts","cacheComponents","incrementalCache","cacheLifeProfiles","cacheLife","onClose","cb","on","onAfterTaskError","undefined","onInstrumentationRequestError","error","_request","errorContext","onRequestError","sharedContext","nodeNextReq","nodeNextRes","nextReq","fromNodeNextRequest","invokeRouteModule","span","handle","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","isMinimalMode","MINIMAL_MODE","handleResponse","currentSpan","cacheEntry","responseGenerator","previousCacheEntry","setHeader","response","fetchMetrics","pendingWaitUntil","cacheTags","collectedTags","blob","headers","type","revalidate","collectedRevalidate","expire","collectedExpire","value","status","body","Buffer","from","arrayBuffer","cacheControl","err","isStale","routerKind","routePath","routeType","revalidateReason","routeKind","isFallback","isRoutePPREnabled","Error","isMiss","delete","getHeader","set","Response","withPropagatedContext","trace","spanName","SERVER","attributes","url"],"mappings":"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","ignoreList":[5]}