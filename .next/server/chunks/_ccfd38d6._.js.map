{"version":3,"sources":["../../../src/services/settlement/insurance-pool.ts","../../../src/services/settlement/fee-manager.ts","../../../src/app/api/v1/settlement/audit-trail/route.ts","../../../node_modules/next/src/build/templates/app-route.ts"],"sourcesContent":["// =============================================================================\r\n// INSURANCE POOL - DEPRECATED (Replaced by Protected Payments)\r\n// =============================================================================\r\n// \r\n// ⚠️  DEPRECATION NOTICE:\r\n// The insurance pool fee mechanism has been removed and replaced by\r\n// \"Protected Payments\" - NexFlow's automatic anomaly detection system.\r\n// \r\n// What this means:\r\n// - Insurance pool no longer receives fee allocations (0%)\r\n// - Protection is provided by circuit breakers + anomaly detection\r\n// - This class is retained for backwards compatibility only\r\n// - Claims/slashing logic remains for historical data\r\n//\r\n// See: src/services/smf/anomaly-detector.ts for Protected Payments\r\n// =============================================================================\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  EscrowAccount,\r\n  SettlementAuditLog,\r\n  AuditAction,\r\n} from '@/types/batch-settlement';\r\nimport { INSURANCE_POOL_BPS, MAX_PLATFORM_FEE_BPS } from './fee-manager';\r\n\r\n// Lazy import to avoid DB errors in unit tests\r\nasync function safeCreateAuditLog(input: any): Promise<void> {\r\n  try {\r\n    const { createAuditLog } = await import('@/db/batch-settlement');\r\n    await createAuditLog(input);\r\n  } catch (error) {\r\n    // Log but don't fail - audit logging is best effort\r\n    logger.warn({ error }, 'Failed to create audit log (DB may not be available)');\r\n  }\r\n}\r\n\r\nconst logger = createLogger({ component: 'InsurancePool' });\r\n\r\n// =============================================================================\r\n// CONSTANTS\r\n// =============================================================================\r\n\r\n/** Minimum insurance pool balance as percentage of total escrow */\r\nexport const MIN_COVERAGE_RATIO = 0.05; // 5% coverage\r\n\r\n/** Maximum single claim as percentage of pool */\r\nexport const MAX_CLAIM_RATIO = 0.25; // Max 25% of pool per claim\r\n\r\n/** Slashing conditions and their severity (basis points) */\r\nexport const SLASHING_CONDITIONS = {\r\n  /** Failed to settle batch within SLA */\r\n  SETTLEMENT_TIMEOUT: 100, // 1%\r\n  /** Submitted invalid Merkle proof */\r\n  INVALID_PROOF: 500, // 5%\r\n  /** Insufficient escrow during settlement */\r\n  INSUFFICIENT_ESCROW: 200, // 2%\r\n  /** Repeated settlement failures */\r\n  REPEATED_FAILURES: 300, // 3%\r\n  /** Attempted double-spend */\r\n  DOUBLE_SPEND: 1000, // 10%\r\n  /** Governance decision */\r\n  GOVERNANCE_PENALTY: 0, // Variable, set by governance\r\n} as const;\r\n\r\nexport type SlashingReason = keyof typeof SLASHING_CONDITIONS;\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface InsurancePoolState {\r\n  /** Total balance in the insurance pool (by token) */\r\n  balances: Map<string, bigint>;\r\n  /** Total claims paid out (by token) */\r\n  totalClaimsPaid: Map<string, bigint>;\r\n  /** Total slashing collected (by token) */\r\n  totalSlashingCollected: Map<string, bigint>;\r\n  /** Current coverage ratio */\r\n  coverageRatio: number;\r\n  /** Last updated timestamp */\r\n  lastUpdated: Date;\r\n}\r\n\r\nexport interface ClaimRequest {\r\n  /** Unique claim identifier */\r\n  claimId: string;\r\n  /** Claimant (facilitator) ID */\r\n  claimantId: string;\r\n  /** Reason for claim */\r\n  reason: string;\r\n  /** Amount requested */\r\n  amountRequested: bigint;\r\n  /** Token address */\r\n  tokenAddress: string;\r\n  /** Network */\r\n  network: string;\r\n  /** Related batch ID if applicable */\r\n  batchId?: string;\r\n  /** Supporting evidence/details */\r\n  evidence: Record<string, unknown>;\r\n  /** Claim status */\r\n  status: 'pending' | 'approved' | 'rejected' | 'paid';\r\n  /** Created timestamp */\r\n  createdAt: Date;\r\n  /** Resolved timestamp */\r\n  resolvedAt?: Date;\r\n}\r\n\r\nexport interface SlashingEvent {\r\n  /** Slashing event ID */\r\n  id: string;\r\n  /** Facilitator being slashed */\r\n  facilitatorId: string;\r\n  /** Reason for slashing */\r\n  reason: SlashingReason;\r\n  /** Amount slashed */\r\n  amountSlashed: bigint;\r\n  /** Token address */\r\n  tokenAddress: string;\r\n  /** Network */\r\n  network: string;\r\n  /** Related batch ID if applicable */\r\n  batchId?: string;\r\n  /** Additional details */\r\n  details: Record<string, unknown>;\r\n  /** Timestamp */\r\n  createdAt: Date;\r\n  /** Transaction hash on chain */\r\n  transactionHash?: string;\r\n}\r\n\r\nexport interface CoverageInfo {\r\n  /** Facilitator ID */\r\n  facilitatorId: string;\r\n  /** Token being covered */\r\n  tokenAddress: string;\r\n  /** Coverage amount available */\r\n  coverageAmount: bigint;\r\n  /** Maximum claimable amount */\r\n  maxClaimable: bigint;\r\n  /** Facilitator's risk score */\r\n  riskScore: number;\r\n  /** Premium rate (additional fee for coverage) */\r\n  premiumBps: number;\r\n  /** Coverage status */\r\n  status: 'active' | 'at_risk' | 'suspended';\r\n}\r\n\r\nexport interface GovernanceDecision {\r\n  /** Decision ID */\r\n  id: string;\r\n  /** Type of decision */\r\n  type: 'claim_approval' | 'claim_rejection' | 'slashing' | 'parameter_update';\r\n  /** Target facilitator if applicable */\r\n  targetFacilitatorId?: string;\r\n  /** Amount involved */\r\n  amount?: bigint;\r\n  /** Reasoning */\r\n  reason: string;\r\n  /** Votes for */\r\n  votesFor: number;\r\n  /** Votes against */\r\n  votesAgainst: number;\r\n  /** Decision status */\r\n  status: 'pending' | 'approved' | 'rejected' | 'executed';\r\n  /** Timestamp */\r\n  createdAt: Date;\r\n  /** Execution timestamp */\r\n  executedAt?: Date;\r\n}\r\n\r\n// =============================================================================\r\n// INSURANCE POOL CLASS\r\n// =============================================================================\r\n\r\n/**\r\n * @deprecated Replaced by Protected Payments (anomaly detection)\r\n * \r\n * Manages the insurance pool for facilitator coverage.\r\n * \r\n * ⚠️  Pool no longer receives fee allocations (0%).\r\n * Protection is now provided by:\r\n * - Circuit breakers (automatic failover)\r\n * - Anomaly detection (real-time monitoring)\r\n * - Canary deployments (gradual traffic increase)\r\n * \r\n * This class is retained for:\r\n * - Backwards compatibility with existing code\r\n * - Historical slashing/claims data access\r\n */\r\nexport class InsurancePool {\r\n  private state: InsurancePoolState;\r\n  private pendingClaims: Map<string, ClaimRequest>;\r\n  private slashingHistory: SlashingEvent[];\r\n\r\n  constructor() {\r\n    this.state = {\r\n      balances: new Map(),\r\n      totalClaimsPaid: new Map(),\r\n      totalSlashingCollected: new Map(),\r\n      coverageRatio: 0,\r\n      lastUpdated: new Date(),\r\n    };\r\n    this.pendingClaims = new Map();\r\n    this.slashingHistory = [];\r\n  }\r\n\r\n  // ===========================================================================\r\n  // POOL FUNDING\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * @deprecated Insurance pool no longer receives fee allocations.\r\n   * \r\n   * This method now returns 0 allocation but is retained for backwards\r\n   * compatibility. Protection is provided by Protected Payments (anomaly detection).\r\n   * \r\n   * Called after each batch settlement.\r\n   */\r\n  async allocateFees(\r\n    totalFees: bigint,\r\n    tokenAddress: string,\r\n    batchId: string\r\n  ): Promise<{\r\n    insuranceAllocation: bigint;\r\n    newPoolBalance: bigint;\r\n  }> {\r\n    // DEPRECATED: Insurance pool no longer receives allocations\r\n    // Protection is now provided by anomaly detection (Protected Payments)\r\n    const insuranceAllocation = BigInt(0);\r\n\r\n    // Get current balance (no change)\r\n    const currentBalance = this.state.balances.get(tokenAddress) ?? BigInt(0);\r\n    const newBalance = currentBalance; // No change\r\n    this.state.lastUpdated = new Date();\r\n\r\n    // Log deprecation notice (best effort)\r\n    logger.debug({\r\n      batchId,\r\n      tokenAddress,\r\n      allocation: '0',\r\n      newBalance: newBalance.toString(),\r\n      notice: 'Insurance pool deprecated - Protected Payments now active',\r\n    }, 'Insurance allocation skipped (deprecated)');\r\n\r\n    return {\r\n      insuranceAllocation,\r\n      newPoolBalance: newBalance,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get current pool balance for a token.\r\n   */\r\n  getPoolBalance(tokenAddress: string): bigint {\r\n    return this.state.balances.get(tokenAddress) ?? BigInt(0);\r\n  }\r\n\r\n  /**\r\n   * Get total pool balance across all tokens (for reporting).\r\n   */\r\n  getTotalPoolBalance(): Map<string, bigint> {\r\n    return new Map(this.state.balances);\r\n  }\r\n\r\n  // ===========================================================================\r\n  // SLASHING\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Apply slashing to a facilitator's escrow.\r\n   * Returns amount slashed and new escrow balance.\r\n   */\r\n  async applySlashing(\r\n    facilitatorId: string,\r\n    reason: SlashingReason,\r\n    escrowBalance: bigint,\r\n    tokenAddress: string,\r\n    network: string,\r\n    batchId?: string,\r\n    customAmount?: bigint\r\n  ): Promise<SlashingEvent> {\r\n    // Calculate slashing amount\r\n    const slashingBps = SLASHING_CONDITIONS[reason];\r\n    const slashingAmount = customAmount ?? ((escrowBalance * BigInt(slashingBps)) / BigInt(10000));\r\n\r\n    // Create slashing event\r\n    const event: SlashingEvent = {\r\n      id: `slash_${Date.now()}_${Math.random().toString(36).slice(2)}`,\r\n      facilitatorId,\r\n      reason,\r\n      amountSlashed: slashingAmount,\r\n      tokenAddress,\r\n      network,\r\n      batchId,\r\n      details: {\r\n        escrow_balance_before: escrowBalance.toString(),\r\n        slashing_bps: slashingBps,\r\n        reason_description: this.getSlashingReasonDescription(reason),\r\n      },\r\n      createdAt: new Date(),\r\n    };\r\n\r\n    // Record slashing\r\n    this.slashingHistory.push(event);\r\n\r\n    // Add slashing to pool\r\n    const currentSlashing = this.state.totalSlashingCollected.get(tokenAddress) ?? BigInt(0);\r\n    this.state.totalSlashingCollected.set(tokenAddress, currentSlashing + slashingAmount);\r\n\r\n    // Add to pool balance\r\n    const currentBalance = this.state.balances.get(tokenAddress) ?? BigInt(0);\r\n    this.state.balances.set(tokenAddress, currentBalance + slashingAmount);\r\n\r\n    // Log audit entry (best effort)\r\n    await safeCreateAuditLog({\r\n      batch_id: batchId,\r\n      action: 'slashing_applied',\r\n      amount_wei: slashingAmount,\r\n      previous_balance_wei: escrowBalance,\r\n      new_balance_wei: escrowBalance - slashingAmount,\r\n      actor: 'insurance_pool',\r\n      details: {\r\n        facilitator_id: facilitatorId,\r\n        reason,\r\n        slashing_bps: slashingBps,\r\n      },\r\n    });\r\n\r\n    logger.warn({\r\n      facilitatorId,\r\n      reason,\r\n      amount: slashingAmount.toString(),\r\n      tokenAddress,\r\n    }, 'Slashing applied');\r\n\r\n    return event;\r\n  }\r\n\r\n  /**\r\n   * Get slashing reason description.\r\n   */\r\n  private getSlashingReasonDescription(reason: SlashingReason): string {\r\n    const descriptions: Record<SlashingReason, string> = {\r\n      SETTLEMENT_TIMEOUT: 'Failed to settle batch within agreed SLA timeframe',\r\n      INVALID_PROOF: 'Submitted an invalid Merkle proof for settlement',\r\n      INSUFFICIENT_ESCROW: 'Had insufficient escrow balance during settlement attempt',\r\n      REPEATED_FAILURES: 'Multiple consecutive settlement failures',\r\n      DOUBLE_SPEND: 'Attempted to settle the same payment multiple times',\r\n      GOVERNANCE_PENALTY: 'Penalty applied by governance decision',\r\n    };\r\n    return descriptions[reason];\r\n  }\r\n\r\n  /**\r\n   * Get slashing history for a facilitator.\r\n   */\r\n  getSlashingHistory(facilitatorId?: string): SlashingEvent[] {\r\n    if (facilitatorId) {\r\n      return this.slashingHistory.filter((e) => e.facilitatorId === facilitatorId);\r\n    }\r\n    return [...this.slashingHistory];\r\n  }\r\n\r\n  // ===========================================================================\r\n  // CLAIMS\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Submit an insurance claim.\r\n   */\r\n  async submitClaim(claim: Omit<ClaimRequest, 'claimId' | 'status' | 'createdAt'>): Promise<ClaimRequest> {\r\n    const claimId = `claim_${Date.now()}_${Math.random().toString(36).slice(2)}`;\r\n    \r\n    const poolBalance = this.getPoolBalance(claim.tokenAddress);\r\n    const maxClaim = (poolBalance * BigInt(Math.floor(MAX_CLAIM_RATIO * 10000))) / BigInt(10000);\r\n\r\n    if (claim.amountRequested > maxClaim) {\r\n      throw new Error(`Claim amount ${claim.amountRequested} exceeds maximum ${maxClaim}`);\r\n    }\r\n\r\n    const newClaim: ClaimRequest = {\r\n      ...claim,\r\n      claimId,\r\n      status: 'pending',\r\n      createdAt: new Date(),\r\n    };\r\n\r\n    this.pendingClaims.set(claimId, newClaim);\r\n\r\n    logger.info({\r\n      claimId,\r\n      claimantId: claim.claimantId,\r\n      amount: claim.amountRequested.toString(),\r\n    }, 'Insurance claim submitted');\r\n\r\n    return newClaim;\r\n  }\r\n\r\n  /**\r\n   * Approve a pending claim (requires governance).\r\n   */\r\n  async approveClaim(claimId: string, approvedBy: string): Promise<ClaimRequest> {\r\n    const claim = this.pendingClaims.get(claimId);\r\n    if (!claim) {\r\n      throw new Error(`Claim ${claimId} not found`);\r\n    }\r\n\r\n    if (claim.status !== 'pending') {\r\n      throw new Error(`Claim ${claimId} is not pending (status: ${claim.status})`);\r\n    }\r\n\r\n    claim.status = 'approved';\r\n    claim.resolvedAt = new Date();\r\n\r\n    // Log audit (best effort)\r\n    await safeCreateAuditLog({\r\n      batch_id: claim.batchId,\r\n      action: 'fee_captured', // Using available action type\r\n      amount_wei: claim.amountRequested,\r\n      actor: approvedBy,\r\n      details: {\r\n        claim_id: claimId,\r\n        claimant_id: claim.claimantId,\r\n        claim_action: 'approved',\r\n        reason: claim.reason,\r\n      },\r\n    });\r\n\r\n    logger.info({\r\n      claimId,\r\n      approvedBy,\r\n      amount: claim.amountRequested.toString(),\r\n    }, 'Insurance claim approved');\r\n\r\n    return claim;\r\n  }\r\n\r\n  /**\r\n   * Pay out an approved claim.\r\n   */\r\n  async payoutClaim(claimId: string): Promise<{\r\n    claim: ClaimRequest;\r\n    newPoolBalance: bigint;\r\n  }> {\r\n    const claim = this.pendingClaims.get(claimId);\r\n    if (!claim) {\r\n      throw new Error(`Claim ${claimId} not found`);\r\n    }\r\n\r\n    if (claim.status !== 'approved') {\r\n      throw new Error(`Claim ${claimId} is not approved (status: ${claim.status})`);\r\n    }\r\n\r\n    const poolBalance = this.getPoolBalance(claim.tokenAddress);\r\n    if (poolBalance < claim.amountRequested) {\r\n      throw new Error(`Insufficient pool balance: ${poolBalance} < ${claim.amountRequested}`);\r\n    }\r\n\r\n    // Deduct from pool\r\n    const newBalance = poolBalance - claim.amountRequested;\r\n    this.state.balances.set(claim.tokenAddress, newBalance);\r\n\r\n    // Update claims paid\r\n    const currentPaid = this.state.totalClaimsPaid.get(claim.tokenAddress) ?? BigInt(0);\r\n    this.state.totalClaimsPaid.set(claim.tokenAddress, currentPaid + claim.amountRequested);\r\n\r\n    claim.status = 'paid';\r\n    claim.resolvedAt = new Date();\r\n\r\n    logger.info({\r\n      claimId,\r\n      amount: claim.amountRequested.toString(),\r\n      newPoolBalance: newBalance.toString(),\r\n    }, 'Insurance claim paid');\r\n\r\n    return {\r\n      claim,\r\n      newPoolBalance: newBalance,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reject a pending claim.\r\n   */\r\n  async rejectClaim(claimId: string, rejectedBy: string, reason: string): Promise<ClaimRequest> {\r\n    const claim = this.pendingClaims.get(claimId);\r\n    if (!claim) {\r\n      throw new Error(`Claim ${claimId} not found`);\r\n    }\r\n\r\n    claim.status = 'rejected';\r\n    claim.resolvedAt = new Date();\r\n\r\n    logger.info({\r\n      claimId,\r\n      rejectedBy,\r\n      reason,\r\n    }, 'Insurance claim rejected');\r\n\r\n    return claim;\r\n  }\r\n\r\n  /**\r\n   * Get pending claims.\r\n   */\r\n  getPendingClaims(): ClaimRequest[] {\r\n    return Array.from(this.pendingClaims.values()).filter((c) => c.status === 'pending');\r\n  }\r\n\r\n  // ===========================================================================\r\n  // COVERAGE INFO\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get coverage information for a facilitator.\r\n   */\r\n  getCoverageInfo(\r\n    facilitatorId: string,\r\n    tokenAddress: string,\r\n    escrowBalance: bigint\r\n  ): CoverageInfo {\r\n    const poolBalance = this.getPoolBalance(tokenAddress);\r\n    const maxClaimable = (poolBalance * BigInt(Math.floor(MAX_CLAIM_RATIO * 10000))) / BigInt(10000);\r\n\r\n    // Calculate risk score based on slashing history\r\n    const facilitatorSlashing = this.getSlashingHistory(facilitatorId);\r\n    const riskScore = Math.min(100, facilitatorSlashing.length * 20);\r\n\r\n    // Coverage amount is proportional to escrow and pool balance\r\n    const coverageRatio = poolBalance > BigInt(0)\r\n      ? Number((escrowBalance * BigInt(100)) / poolBalance) / 100\r\n      : 0;\r\n    const coverageAmount = coverageRatio > 1\r\n      ? maxClaimable\r\n      : (maxClaimable * BigInt(Math.floor(coverageRatio * 10000))) / BigInt(10000);\r\n\r\n    // Higher risk = higher premium\r\n    const premiumBps = Math.min(50, riskScore / 2); // 0-50 bps based on risk\r\n\r\n    return {\r\n      facilitatorId,\r\n      tokenAddress,\r\n      coverageAmount,\r\n      maxClaimable,\r\n      riskScore,\r\n      premiumBps,\r\n      status: riskScore > 60 ? 'suspended' : riskScore > 30 ? 'at_risk' : 'active',\r\n    };\r\n  }\r\n\r\n  // ===========================================================================\r\n  // POOL STATE & REPORTING\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get current pool state.\r\n   */\r\n  getState(): InsurancePoolState {\r\n    return {\r\n      balances: new Map(this.state.balances),\r\n      totalClaimsPaid: new Map(this.state.totalClaimsPaid),\r\n      totalSlashingCollected: new Map(this.state.totalSlashingCollected),\r\n      coverageRatio: this.state.coverageRatio,\r\n      lastUpdated: this.state.lastUpdated,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate current coverage ratio.\r\n   */\r\n  calculateCoverageRatio(totalEscrowAcrossAllFacilitators: bigint, tokenAddress: string): number {\r\n    const poolBalance = this.getPoolBalance(tokenAddress);\r\n    if (totalEscrowAcrossAllFacilitators === BigInt(0)) {\r\n      return 1.0; // 100% coverage if no escrow\r\n    }\r\n    return Number((poolBalance * BigInt(10000)) / totalEscrowAcrossAllFacilitators) / 10000;\r\n  }\r\n\r\n  /**\r\n   * Generate pool summary for dashboard.\r\n   */\r\n  generatePoolSummary(): {\r\n    totalBalance: Map<string, string>;\r\n    totalClaimsPaid: Map<string, string>;\r\n    totalSlashingCollected: Map<string, string>;\r\n    pendingClaimsCount: number;\r\n    pendingClaimsTotal: Map<string, string>;\r\n    slashingEventsCount: number;\r\n  } {\r\n    const pendingClaimsTotal = new Map<string, string>();\r\n    for (const claim of this.getPendingClaims()) {\r\n      const current = BigInt(pendingClaimsTotal.get(claim.tokenAddress) ?? '0');\r\n      pendingClaimsTotal.set(claim.tokenAddress, (current + claim.amountRequested).toString());\r\n    }\r\n\r\n    // Convert bigints to strings for JSON serialization\r\n    const toStringMap = (m: Map<string, bigint>) => {\r\n      const result = new Map<string, string>();\r\n      for (const [k, v] of m) {\r\n        result.set(k, v.toString());\r\n      }\r\n      return result;\r\n    };\r\n\r\n    return {\r\n      totalBalance: toStringMap(this.state.balances),\r\n      totalClaimsPaid: toStringMap(this.state.totalClaimsPaid),\r\n      totalSlashingCollected: toStringMap(this.state.totalSlashingCollected),\r\n      pendingClaimsCount: this.getPendingClaims().length,\r\n      pendingClaimsTotal,\r\n      slashingEventsCount: this.slashingHistory.length,\r\n    };\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// SINGLETON INSTANCE\r\n// =============================================================================\r\n\r\nlet insurancePoolInstance: InsurancePool | null = null;\r\n\r\nexport function getInsurancePool(): InsurancePool {\r\n  if (!insurancePoolInstance) {\r\n    insurancePoolInstance = new InsurancePool();\r\n  }\r\n  return insurancePoolInstance;\r\n}\r\n\r\nexport function resetInsurancePool(): void {\r\n  insurancePoolInstance = null;\r\n}\r\n\r\n","// =============================================================================\r\n// FEE MANAGER - PLATFORM FEE CAPTURE & MANAGEMENT\r\n// =============================================================================\r\n// Handles fee calculation, capture, validation, and reporting for SMF settlements\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport {\r\n  createPlatformFee,\r\n  getPlatformFee,\r\n  getPlatformFeesByBatch,\r\n  getPlatformFeesByFacilitator,\r\n  getTotalFeesByToken,\r\n  updatePlatformFeeStatus,\r\n  createAuditLog,\r\n} from '@/db/batch-settlement';\r\nimport type {\r\n  PlatformFee,\r\n  PlatformFeeStatus,\r\n  RecordPlatformFeeInput,\r\n  BatchSettlementConfig,\r\n  DEFAULT_BATCH_CONFIG,\r\n} from '@/types/batch-settlement';\r\n\r\nconst logger = createLogger({ component: 'FeeManager' });\r\n\r\n// =============================================================================\r\n// CONSTANTS\r\n// =============================================================================\r\n\r\n/** Platform fee: 0.25% (25 basis points) - single unified fee */\r\nexport const PLATFORM_FEE_BPS = 25;\r\n\r\n/** Maximum allowed platform fee: 0.25% (25 basis points) */\r\nexport const MAX_PLATFORM_FEE_BPS = 25;\r\n\r\n/** Basis points denominator */\r\nexport const BPS_DENOMINATOR = 10000;\r\n\r\n/**\r\n * @deprecated Insurance pool removed - replaced by Protected Payments (anomaly detection)\r\n * Kept for backwards compatibility with existing code references\r\n */\r\nexport const INSURANCE_POOL_BPS = 0;\r\n\r\n/** Operations pool allocation from fees (100% of platform fee) */\r\nexport const OPERATIONS_POOL_BPS = 25; // 0.25%\r\n\r\n/**\r\n * @deprecated Treasury allocation consolidated into operations\r\n */\r\nexport const TREASURY_POOL_BPS = 0;\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface FeeCalculation {\r\n  /** Gross payment amount */\r\n  grossAmount: bigint;\r\n  /** Platform fee amount */\r\n  feeAmount: bigint;\r\n  /** Net amount after fee deduction */\r\n  netAmount: bigint;\r\n  /** Fee rate in basis points */\r\n  feeBps: number;\r\n}\r\n\r\nexport interface FeeBreakdown {\r\n  /** Total fee collected */\r\n  totalFee: bigint;\r\n  /**\r\n   * @deprecated Insurance pool removed - replaced by Protected Payments\r\n   * Always returns 0n for backwards compatibility\r\n   */\r\n  insuranceAllocation: bigint;\r\n  /** Amount allocated to operations (100% of fee) */\r\n  operationsAllocation: bigint;\r\n  /**\r\n   * @deprecated Treasury consolidated into operations\r\n   * Always returns 0n for backwards compatibility\r\n   */\r\n  treasuryAllocation: bigint;\r\n}\r\n\r\nexport interface FeeValidationResult {\r\n  valid: boolean;\r\n  errors: string[];\r\n  warnings: string[];\r\n}\r\n\r\nexport interface FeeSummary {\r\n  /** Total fees collected (all time) */\r\n  totalFeesCollected: bigint;\r\n  /** Total fees pending capture */\r\n  totalFeesPending: bigint;\r\n  /** Total fees withdrawn */\r\n  totalFeesWithdrawn: bigint;\r\n  /** Fees by token address */\r\n  byToken: Map<string, bigint>;\r\n  /** Fees by facilitator */\r\n  byFacilitator: Map<string, bigint>;\r\n  /** Count of fee records */\r\n  recordCount: number;\r\n}\r\n\r\nexport interface FeeCapture {\r\n  id: string;\r\n  batchId: string;\r\n  paymentId: string | null;\r\n  facilitatorId: string;\r\n  feeAmount: bigint;\r\n  status: PlatformFeeStatus;\r\n  capturedAt: Date | null;\r\n}\r\n\r\n// =============================================================================\r\n// FEE MANAGER CLASS\r\n// =============================================================================\r\n\r\n/**\r\n * Manages platform fee calculation, capture, and distribution.\r\n * \r\n * Fee Structure (25 bps = 0.25%):\r\n * - Platform Fee: 0.25% (25 bps) - 100% to operations\r\n * \r\n * Protected Payments (replaces Insurance Pool):\r\n * - Real-time anomaly detection\r\n * - Automatic circuit breaker protection\r\n * - No separate insurance fee required\r\n */\r\nexport class FeeManager {\r\n  private config: BatchSettlementConfig;\r\n\r\n  constructor(config: Partial<BatchSettlementConfig> = {}) {\r\n    this.config = {\r\n      max_batch_size: config.max_batch_size ?? 100,\r\n      min_batch_size: config.min_batch_size ?? 10,\r\n      max_batch_delay_ms: config.max_batch_delay_ms ?? 60_000,\r\n      min_batch_value_wei: config.min_batch_value_wei ?? BigInt('1000000'),\r\n      platform_fee_bps: Math.min(config.platform_fee_bps ?? MAX_PLATFORM_FEE_BPS, MAX_PLATFORM_FEE_BPS),\r\n      max_retry_attempts: config.max_retry_attempts ?? 3,\r\n      retry_delay_ms: config.retry_delay_ms ?? 30_000,\r\n      escrow_buffer_ratio: config.escrow_buffer_ratio ?? 1.1,\r\n    };\r\n  }\r\n\r\n  // ===========================================================================\r\n  // FEE CALCULATION\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Calculate platform fee for a payment amount.\r\n   * Fee is capped at MAX_PLATFORM_FEE_BPS (0.25%)\r\n   */\r\n  calculateFee(paymentAmount: bigint, customFeeBps?: number): FeeCalculation {\r\n    const feeBps = Math.min(customFeeBps ?? this.config.platform_fee_bps, MAX_PLATFORM_FEE_BPS);\r\n    const feeAmount = (paymentAmount * BigInt(feeBps)) / BigInt(BPS_DENOMINATOR);\r\n    const netAmount = paymentAmount - feeAmount;\r\n\r\n    return {\r\n      grossAmount: paymentAmount,\r\n      feeAmount,\r\n      netAmount,\r\n      feeBps,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate batch fees for multiple payments.\r\n   */\r\n  calculateBatchFees(amounts: bigint[], customFeeBps?: number): {\r\n    calculations: FeeCalculation[];\r\n    totalGross: bigint;\r\n    totalFees: bigint;\r\n    totalNet: bigint;\r\n  } {\r\n    const calculations = amounts.map((amount) => this.calculateFee(amount, customFeeBps));\r\n    \r\n    return {\r\n      calculations,\r\n      totalGross: calculations.reduce((sum, c) => sum + c.grossAmount, BigInt(0)),\r\n      totalFees: calculations.reduce((sum, c) => sum + c.feeAmount, BigInt(0)),\r\n      totalNet: calculations.reduce((sum, c) => sum + c.netAmount, BigInt(0)),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Break down fee into allocation pools.\r\n   * \r\n   * Note: Insurance pool has been removed (replaced by Protected Payments).\r\n   * All fees now go to operations.\r\n   */\r\n  breakdownFee(totalFee: bigint): FeeBreakdown {\r\n    // Single platform fee - no insurance split\r\n    // Protected Payments (anomaly detection) replaces insurance\r\n    return {\r\n      totalFee,\r\n      insuranceAllocation: BigInt(0), // DEPRECATED: replaced by Protected Payments\r\n      operationsAllocation: totalFee, // 100% to operations\r\n      treasuryAllocation: BigInt(0),  // Consolidated into operations\r\n    };\r\n  }\r\n\r\n  // ===========================================================================\r\n  // FEE VALIDATION\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Validate fee parameters before capture.\r\n   */\r\n  validateFee(\r\n    paymentAmount: bigint,\r\n    feeAmount: bigint,\r\n    feeBps: number\r\n  ): FeeValidationResult {\r\n    const errors: string[] = [];\r\n    const warnings: string[] = [];\r\n\r\n    // Check fee doesn't exceed maximum\r\n    if (feeBps > MAX_PLATFORM_FEE_BPS) {\r\n      errors.push(`Fee rate ${feeBps} bps exceeds maximum ${MAX_PLATFORM_FEE_BPS} bps`);\r\n    }\r\n\r\n    // Check fee amount matches rate\r\n    const expectedFee = (paymentAmount * BigInt(feeBps)) / BigInt(BPS_DENOMINATOR);\r\n    const tolerance = BigInt(1); // Allow 1 wei tolerance for rounding\r\n    \r\n    if (feeAmount < expectedFee - tolerance || feeAmount > expectedFee + tolerance) {\r\n      errors.push(`Fee amount ${feeAmount} doesn't match expected ${expectedFee} for ${feeBps} bps`);\r\n    }\r\n\r\n    // Warnings for unusual conditions\r\n    if (paymentAmount === BigInt(0)) {\r\n      warnings.push('Zero payment amount');\r\n    }\r\n\r\n    if (feeAmount === BigInt(0) && paymentAmount > BigInt(0)) {\r\n      warnings.push('Zero fee on non-zero payment');\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n      warnings,\r\n    };\r\n  }\r\n\r\n  // ===========================================================================\r\n  // FEE CAPTURE\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Capture platform fee from a payment.\r\n   * Records fee in database and logs audit entry.\r\n   */\r\n  async captureFee(input: RecordPlatformFeeInput): Promise<PlatformFee> {\r\n    // Validate fee\r\n    const validation = this.validateFee(\r\n      input.payment_amount_wei,\r\n      input.fee_amount_wei,\r\n      input.fee_bps\r\n    );\r\n\r\n    if (!validation.valid) {\r\n      throw new Error(`Fee validation failed: ${validation.errors.join(', ')}`);\r\n    }\r\n\r\n    // Log warnings\r\n    for (const warning of validation.warnings) {\r\n      logger.warn({ warning, input }, 'Fee capture warning');\r\n    }\r\n\r\n    // Create fee record\r\n    const fee = await createPlatformFee(input);\r\n\r\n    // Log audit entry\r\n    await createAuditLog({\r\n      batch_id: input.batch_id,\r\n      action: 'fee_captured',\r\n      amount_wei: input.fee_amount_wei,\r\n      actor: 'fee_manager',\r\n      details: {\r\n        payment_id: input.payment_id,\r\n        facilitator_id: input.facilitator_id,\r\n        fee_bps: input.fee_bps,\r\n        payment_amount: input.payment_amount_wei.toString(),\r\n      },\r\n    });\r\n\r\n    logger.info({\r\n      feeId: fee.id,\r\n      batchId: input.batch_id,\r\n      amount: input.fee_amount_wei.toString(),\r\n      feeBps: input.fee_bps,\r\n    }, 'Fee captured');\r\n\r\n    return fee;\r\n  }\r\n\r\n  /**\r\n   * Capture fees for an entire batch atomically.\r\n   */\r\n  async captureBatchFees(\r\n    batchId: string,\r\n    facilitatorId: string,\r\n    network: string,\r\n    tokenAddress: string,\r\n    payments: Array<{ paymentId: string; amount: bigint }>\r\n  ): Promise<{\r\n    fees: PlatformFee[];\r\n    totalFees: bigint;\r\n    breakdown: FeeBreakdown;\r\n  }> {\r\n    const fees: PlatformFee[] = [];\r\n    let totalFees = BigInt(0);\r\n\r\n    for (const payment of payments) {\r\n      const calculation = this.calculateFee(payment.amount);\r\n      \r\n      const fee = await this.captureFee({\r\n        batch_id: batchId,\r\n        payment_id: payment.paymentId,\r\n        facilitator_id: facilitatorId,\r\n        network,\r\n        token_address: tokenAddress,\r\n        fee_amount_wei: calculation.feeAmount,\r\n        fee_bps: calculation.feeBps,\r\n        payment_amount_wei: payment.amount,\r\n      });\r\n\r\n      fees.push(fee);\r\n      totalFees += calculation.feeAmount;\r\n    }\r\n\r\n    const breakdown = this.breakdownFee(totalFees);\r\n\r\n    logger.info({\r\n      batchId,\r\n      paymentCount: payments.length,\r\n      totalFees: totalFees.toString(),\r\n      insuranceAllocation: breakdown.insuranceAllocation.toString(),\r\n    }, 'Batch fees captured');\r\n\r\n    return { fees, totalFees, breakdown };\r\n  }\r\n\r\n  /**\r\n   * Mark fee as withdrawn.\r\n   */\r\n  async markFeeWithdrawn(feeId: string, withdrawalTxHash: string): Promise<void> {\r\n    await updatePlatformFeeStatus(feeId, 'withdrawn', withdrawalTxHash);\r\n\r\n    logger.info({\r\n      feeId,\r\n      txHash: withdrawalTxHash,\r\n    }, 'Fee marked as withdrawn');\r\n  }\r\n\r\n  /**\r\n   * Mark fee as refunded (in case of settlement failure).\r\n   */\r\n  async markFeeRefunded(feeId: string): Promise<void> {\r\n    await updatePlatformFeeStatus(feeId, 'refunded');\r\n\r\n    logger.info({ feeId }, 'Fee marked as refunded');\r\n  }\r\n\r\n  // ===========================================================================\r\n  // FEE QUERIES\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get fee by ID.\r\n   */\r\n  async getFee(feeId: string): Promise<PlatformFee | null> {\r\n    return getPlatformFee(feeId);\r\n  }\r\n\r\n  /**\r\n   * Get all fees for a batch.\r\n   */\r\n  async getBatchFees(batchId: string): Promise<PlatformFee[]> {\r\n    return getPlatformFeesByBatch(batchId);\r\n  }\r\n\r\n  /**\r\n   * Get fees for a facilitator.\r\n   */\r\n  async getFacilitatorFees(\r\n    facilitatorId: string,\r\n    options?: {\r\n      status?: PlatformFeeStatus;\r\n      tokenAddress?: string;\r\n      network?: string;\r\n      limit?: number;\r\n      offset?: number;\r\n    }\r\n  ): Promise<PlatformFee[]> {\r\n    return getPlatformFeesByFacilitator(facilitatorId, options);\r\n  }\r\n\r\n  /**\r\n   * Get total fees collected by token.\r\n   */\r\n  async getTotalFees(tokenAddress: string): Promise<{\r\n    total: bigint;\r\n    pending: bigint;\r\n    captured: bigint;\r\n    withdrawn: bigint;\r\n  }> {\r\n    return getTotalFeesByToken(tokenAddress);\r\n  }\r\n\r\n  /**\r\n   * Generate fee summary for dashboard.\r\n   */\r\n  async generateFeeSummary(options?: {\r\n    startDate?: Date;\r\n    endDate?: Date;\r\n    facilitatorId?: string;\r\n    network?: string;\r\n  }): Promise<FeeSummary> {\r\n    // This would be implemented with more complex queries\r\n    // For now, return a placeholder structure\r\n    const byToken = new Map<string, bigint>();\r\n    const byFacilitator = new Map<string, bigint>();\r\n\r\n    return {\r\n      totalFeesCollected: BigInt(0),\r\n      totalFeesPending: BigInt(0),\r\n      totalFeesWithdrawn: BigInt(0),\r\n      byToken,\r\n      byFacilitator,\r\n      recordCount: 0,\r\n    };\r\n  }\r\n\r\n  // ===========================================================================\r\n  // CONFIGURATION\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get current fee configuration.\r\n   */\r\n  getConfig(): BatchSettlementConfig {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * Get current fee rate in basis points.\r\n   */\r\n  getFeeBps(): number {\r\n    return this.config.platform_fee_bps;\r\n  }\r\n\r\n  /**\r\n   * Update fee configuration.\r\n   * Note: Fee rate cannot exceed MAX_PLATFORM_FEE_BPS\r\n   */\r\n  updateConfig(updates: Partial<BatchSettlementConfig>): void {\r\n    if (updates.platform_fee_bps !== undefined) {\r\n      if (updates.platform_fee_bps > MAX_PLATFORM_FEE_BPS) {\r\n        throw new Error(`Fee rate ${updates.platform_fee_bps} exceeds maximum ${MAX_PLATFORM_FEE_BPS} bps`);\r\n      }\r\n    }\r\n\r\n    this.config = { ...this.config, ...updates };\r\n    logger.info({ config: this.config }, 'Fee config updated');\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// SINGLETON INSTANCE\r\n// =============================================================================\r\n\r\nlet feeManagerInstance: FeeManager | null = null;\r\n\r\nexport function getFeeManager(): FeeManager {\r\n  if (!feeManagerInstance) {\r\n    feeManagerInstance = new FeeManager();\r\n  }\r\n  return feeManagerInstance;\r\n}\r\n\r\nexport function resetFeeManager(): void {\r\n  feeManagerInstance = null;\r\n}\r\n\r\n// =============================================================================\r\n// UTILITY FUNCTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Calculate fee for a single payment amount.\r\n */\r\nexport function calculatePlatformFee(amount: bigint, feeBps: number = MAX_PLATFORM_FEE_BPS): bigint {\r\n  return (amount * BigInt(Math.min(feeBps, MAX_PLATFORM_FEE_BPS))) / BigInt(BPS_DENOMINATOR);\r\n}\r\n\r\n/**\r\n * Calculate net amount after fee deduction.\r\n */\r\nexport function calculateNetAmount(amount: bigint, feeBps: number = MAX_PLATFORM_FEE_BPS): bigint {\r\n  const fee = calculatePlatformFee(amount, feeBps);\r\n  return amount - fee;\r\n}\r\n\r\n/**\r\n * Validate that fee rate is within allowed range.\r\n */\r\nexport function isValidFeeRate(feeBps: number): boolean {\r\n  return feeBps >= 0 && feeBps <= MAX_PLATFORM_FEE_BPS;\r\n}\r\n\r\n","// =============================================================================\r\n// SETTLEMENT AUDIT TRAIL API\r\n// =============================================================================\r\n// Public API for viewing settlement audit trail, fees, and insurance status\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport {\r\n  getAllAuditLogs,\r\n  getBatchAuditLogs,\r\n  getAuditLogsByAction,\r\n  getTotalFeesByToken,\r\n  getPlatformFeesByFacilitator,\r\n  getTotalPendingFees,\r\n} from '@/db/batch-settlement';\r\nimport { getInsurancePool } from '@/services/settlement/insurance-pool';\r\nimport { getFeeManager, MAX_PLATFORM_FEE_BPS, BPS_DENOMINATOR } from '@/services/settlement/fee-manager';\r\nimport type { AuditAction, SettlementAuditLog } from '@/types/batch-settlement';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'AuditTrailAPI' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\ninterface AuditTrailResponse {\r\n  success: boolean;\r\n  data?: {\r\n    auditLogs: SerializedAuditLog[];\r\n    pagination: {\r\n      limit: number;\r\n      offset: number;\r\n      hasMore: boolean;\r\n    };\r\n  };\r\n  error?: string;\r\n}\r\n\r\ninterface FeeSummaryResponse {\r\n  success: boolean;\r\n  data?: {\r\n    totalFeesCollected: string;\r\n    totalFeesPending: string;\r\n    totalFeesWithdrawn: string;\r\n    feeRateBps: number;\r\n    feeRatePercent: string;\r\n    byToken: Record<string, {\r\n      total: string;\r\n      pending: string;\r\n      captured: string;\r\n      withdrawn: string;\r\n    }>;\r\n    lastUpdated: string;\r\n  };\r\n  error?: string;\r\n}\r\n\r\ninterface InsurancePoolResponse {\r\n  success: boolean;\r\n  data?: {\r\n    balances: Record<string, string>;\r\n    totalClaimsPaid: Record<string, string>;\r\n    totalSlashingCollected: Record<string, string>;\r\n    pendingClaimsCount: number;\r\n    pendingClaimsTotal: Record<string, string>;\r\n    slashingEventsCount: number;\r\n    coverageInfo: {\r\n      minCoverageRatio: number;\r\n      maxClaimRatio: number;\r\n    };\r\n    lastUpdated: string;\r\n  };\r\n  error?: string;\r\n}\r\n\r\ninterface DashboardResponse {\r\n  success: boolean;\r\n  data?: {\r\n    fees: {\r\n      totalCollected: string;\r\n      totalPending: string;\r\n      feeRateBps: number;\r\n    };\r\n    insurance: {\r\n      poolBalance: string;\r\n      claimsPaid: string;\r\n      pendingClaims: number;\r\n      slashingEvents: number;\r\n    };\r\n    recentActivity: SerializedAuditLog[];\r\n    governanceDecisions: unknown[];\r\n  };\r\n  error?: string;\r\n}\r\n\r\n// Serialized audit log for JSON response\r\ninterface SerializedAuditLog {\r\n  id: string;\r\n  batch_id: string | null;\r\n  escrow_id: string | null;\r\n  action: AuditAction;\r\n  amount_wei: string | null;\r\n  previous_balance_wei: string | null;\r\n  new_balance_wei: string | null;\r\n  actor: string;\r\n  transaction_hash: string | null;\r\n  details: Record<string, unknown> | null;\r\n  created_at: string;\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\nfunction serializeAuditLog(log: SettlementAuditLog): SerializedAuditLog {\r\n  return {\r\n    id: log.id,\r\n    batch_id: log.batch_id,\r\n    escrow_id: log.escrow_id,\r\n    action: log.action,\r\n    amount_wei: log.amount_wei?.toString() ?? null,\r\n    previous_balance_wei: log.previous_balance_wei?.toString() ?? null,\r\n    new_balance_wei: log.new_balance_wei?.toString() ?? null,\r\n    actor: log.actor,\r\n    transaction_hash: log.transaction_hash,\r\n    details: log.details,\r\n    created_at: log.created_at.toISOString(),\r\n  };\r\n}\r\n\r\nfunction mapToRecord(map: Map<string, string>): Record<string, string> {\r\n  const record: Record<string, string> = {};\r\n  for (const [key, value] of map) {\r\n    record[key] = value;\r\n  }\r\n  return record;\r\n}\r\n\r\n// =============================================================================\r\n// GET - Audit Trail Query\r\n// =============================================================================\r\n\r\n/**\r\n * GET /api/v1/settlement/audit-trail\r\n * \r\n * Query Parameters:\r\n * - view: 'logs' | 'fees' | 'insurance' | 'dashboard' (default: 'logs')\r\n * - action: filter by action type (fee_captured, slashing_applied, etc.)\r\n * - batch_id: filter by batch ID\r\n * - facilitator_id: filter by facilitator ID\r\n * - token_address: filter by token address\r\n * - start_date: filter by start date (ISO string)\r\n * - end_date: filter by end date (ISO string)\r\n * - limit: pagination limit (default: 50, max: 1000)\r\n * - offset: pagination offset (default: 0)\r\n */\r\nexport async function GET(request: NextRequest): Promise<NextResponse> {\r\n  try {\r\n    const { searchParams } = new URL(request.url);\r\n    const view = searchParams.get('view') || 'logs';\r\n    \r\n    switch (view) {\r\n      case 'logs':\r\n        return handleAuditLogsQuery(searchParams);\r\n      case 'fees':\r\n        return handleFeeSummaryQuery(searchParams);\r\n      case 'insurance':\r\n        return handleInsuranceQuery();\r\n      case 'dashboard':\r\n        return handleDashboardQuery(searchParams);\r\n      default:\r\n        return NextResponse.json(\r\n          { success: false, error: `Invalid view: ${view}` },\r\n          { status: 400 }\r\n        );\r\n    }\r\n  } catch (error) {\r\n    logger.error({ error }, 'Audit trail API error');\r\n    return NextResponse.json(\r\n      { success: false, error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// QUERY HANDLERS\r\n// =============================================================================\r\n\r\nasync function handleAuditLogsQuery(\r\n  searchParams: URLSearchParams\r\n): Promise<NextResponse<AuditTrailResponse>> {\r\n  const action = searchParams.get('action') as AuditAction | null;\r\n  const batchId = searchParams.get('batch_id');\r\n  const startDateStr = searchParams.get('start_date');\r\n  const endDateStr = searchParams.get('end_date');\r\n  const limit = Math.min(parseInt(searchParams.get('limit') || '50'), 1000);\r\n  const offset = parseInt(searchParams.get('offset') || '0');\r\n\r\n  const startDate = startDateStr ? new Date(startDateStr) : undefined;\r\n  const endDate = endDateStr ? new Date(endDateStr) : undefined;\r\n\r\n  let logs: SettlementAuditLog[];\r\n\r\n  if (batchId) {\r\n    // Get logs for specific batch\r\n    logs = await getBatchAuditLogs(batchId);\r\n  } else if (action) {\r\n    // Get logs by action type\r\n    logs = await getAuditLogsByAction(action, {\r\n      startDate,\r\n      endDate,\r\n      limit: limit + 1, // Fetch one extra to check hasMore\r\n    });\r\n  } else {\r\n    // Get all logs\r\n    logs = await getAllAuditLogs({\r\n      action: action ?? undefined,\r\n      startDate,\r\n      endDate,\r\n      limit: limit + 1,\r\n      offset,\r\n    });\r\n  }\r\n\r\n  const hasMore = logs.length > limit;\r\n  if (hasMore) {\r\n    logs = logs.slice(0, limit);\r\n  }\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: {\r\n      auditLogs: logs.map(serializeAuditLog),\r\n      pagination: {\r\n        limit,\r\n        offset,\r\n        hasMore,\r\n      },\r\n    },\r\n  });\r\n}\r\n\r\nasync function handleFeeSummaryQuery(\r\n  searchParams: URLSearchParams\r\n): Promise<NextResponse<FeeSummaryResponse>> {\r\n  const tokenAddress = searchParams.get('token_address');\r\n  const facilitatorId = searchParams.get('facilitator_id');\r\n\r\n  const feeManager = getFeeManager();\r\n  const currentFeeBps = feeManager.getFeeBps();\r\n\r\n  // Default token addresses to check\r\n  const tokens = tokenAddress \r\n    ? [tokenAddress]\r\n    : [\r\n        '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC (mainnet)\r\n        '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC (Base)\r\n        '0xdAC17F958D2ee523a2206206994597C13D831ec7', // USDT\r\n      ];\r\n\r\n  const byToken: Record<string, {\r\n    total: string;\r\n    pending: string;\r\n    captured: string;\r\n    withdrawn: string;\r\n  }> = {};\r\n\r\n  let totalCollected = BigInt(0);\r\n  let totalPending = BigInt(0);\r\n  let totalWithdrawn = BigInt(0);\r\n\r\n  for (const token of tokens) {\r\n    const totals = await getTotalFeesByToken(token);\r\n    byToken[token] = {\r\n      total: totals.total.toString(),\r\n      pending: totals.pending.toString(),\r\n      captured: totals.captured.toString(),\r\n      withdrawn: totals.withdrawn.toString(),\r\n    };\r\n    totalCollected += totals.total;\r\n    totalPending += totals.pending;\r\n    totalWithdrawn += totals.withdrawn;\r\n  }\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: {\r\n      totalFeesCollected: totalCollected.toString(),\r\n      totalFeesPending: totalPending.toString(),\r\n      totalFeesWithdrawn: totalWithdrawn.toString(),\r\n      feeRateBps: currentFeeBps,\r\n      feeRatePercent: `${(currentFeeBps / 100).toFixed(2)}%`,\r\n      byToken,\r\n      lastUpdated: new Date().toISOString(),\r\n    },\r\n  });\r\n}\r\n\r\nasync function handleInsuranceQuery(): Promise<NextResponse<InsurancePoolResponse>> {\r\n  const insurancePool = getInsurancePool();\r\n  const summary = insurancePool.generatePoolSummary();\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: {\r\n      balances: mapToRecord(summary.totalBalance),\r\n      totalClaimsPaid: mapToRecord(summary.totalClaimsPaid),\r\n      totalSlashingCollected: mapToRecord(summary.totalSlashingCollected),\r\n      pendingClaimsCount: summary.pendingClaimsCount,\r\n      pendingClaimsTotal: mapToRecord(summary.pendingClaimsTotal),\r\n      slashingEventsCount: summary.slashingEventsCount,\r\n      coverageInfo: {\r\n        minCoverageRatio: 0.05, // 5%\r\n        maxClaimRatio: 0.25, // 25% max single claim\r\n      },\r\n      lastUpdated: new Date().toISOString(),\r\n    },\r\n  });\r\n}\r\n\r\nasync function handleDashboardQuery(\r\n  searchParams: URLSearchParams\r\n): Promise<NextResponse<DashboardResponse>> {\r\n  const feeManager = getFeeManager();\r\n  const insurancePool = getInsurancePool();\r\n\r\n  // Get fee summary\r\n  const totalPending = await getTotalPendingFees();\r\n  \r\n  // Get insurance summary\r\n  const summary = insurancePool.generatePoolSummary();\r\n  \r\n  // Calculate total insurance balance across all tokens\r\n  let totalInsuranceBalance = BigInt(0);\r\n  for (const [, balance] of summary.totalBalance) {\r\n    totalInsuranceBalance += BigInt(balance);\r\n  }\r\n  \r\n  let totalClaimsPaid = BigInt(0);\r\n  for (const [, paid] of summary.totalClaimsPaid) {\r\n    totalClaimsPaid += BigInt(paid);\r\n  }\r\n\r\n  // Get recent activity\r\n  const recentLogs = await getAllAuditLogs({ limit: 10 });\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: {\r\n      fees: {\r\n        totalCollected: '0', // Would need aggregation across all tokens\r\n        totalPending: totalPending.toString(),\r\n        feeRateBps: feeManager.getFeeBps(),\r\n      },\r\n      insurance: {\r\n        poolBalance: totalInsuranceBalance.toString(),\r\n        claimsPaid: totalClaimsPaid.toString(),\r\n        pendingClaims: summary.pendingClaimsCount,\r\n        slashingEvents: summary.slashingEventsCount,\r\n      },\r\n      recentActivity: recentLogs.map(serializeAuditLog),\r\n      governanceDecisions: [], // Would be populated from governance module\r\n    },\r\n  });\r\n}\r\n\r\n// =============================================================================\r\n// POST - Submit Insurance Claim (Protected)\r\n// =============================================================================\r\n\r\n/**\r\n * POST /api/v1/settlement/audit-trail\r\n * \r\n * Body:\r\n * - action: 'submit_claim' | 'approve_claim' | 'reject_claim'\r\n * - claim_id: (for approve/reject)\r\n * - claimant_id: (for submit_claim)\r\n * - amount: (for submit_claim)\r\n * - token_address: (for submit_claim)\r\n * - network: (for submit_claim)\r\n * - reason: (for submit_claim or reject_claim)\r\n * - evidence: (for submit_claim)\r\n */\r\nexport async function POST(request: NextRequest): Promise<NextResponse> {\r\n  try {\r\n    const body = await request.json();\r\n    const { action } = body;\r\n\r\n    // Note: In production, this would require authentication and authorization\r\n    // For now, we just validate the request structure\r\n\r\n    switch (action) {\r\n      case 'submit_claim': {\r\n        const { claimant_id, amount, token_address, network, reason, evidence, batch_id } = body;\r\n        \r\n        if (!claimant_id || !amount || !token_address || !network || !reason) {\r\n          return NextResponse.json(\r\n            { success: false, error: 'Missing required fields for claim submission' },\r\n            { status: 400 }\r\n          );\r\n        }\r\n\r\n        const insurancePool = getInsurancePool();\r\n        const claim = await insurancePool.submitClaim({\r\n          claimantId: claimant_id,\r\n          amountRequested: BigInt(amount),\r\n          tokenAddress: token_address,\r\n          network,\r\n          reason,\r\n          evidence: evidence || {},\r\n          batchId: batch_id,\r\n        });\r\n\r\n        return NextResponse.json({\r\n          success: true,\r\n          data: {\r\n            claimId: claim.claimId,\r\n            status: claim.status,\r\n            createdAt: claim.createdAt.toISOString(),\r\n          },\r\n        });\r\n      }\r\n\r\n      case 'approve_claim': {\r\n        const { claim_id, approved_by } = body;\r\n        \r\n        if (!claim_id || !approved_by) {\r\n          return NextResponse.json(\r\n            { success: false, error: 'Missing claim_id or approved_by' },\r\n            { status: 400 }\r\n          );\r\n        }\r\n\r\n        const insurancePool = getInsurancePool();\r\n        const claim = await insurancePool.approveClaim(claim_id, approved_by);\r\n\r\n        return NextResponse.json({\r\n          success: true,\r\n          data: {\r\n            claimId: claim.claimId,\r\n            status: claim.status,\r\n            resolvedAt: claim.resolvedAt?.toISOString(),\r\n          },\r\n        });\r\n      }\r\n\r\n      case 'reject_claim': {\r\n        const { claim_id, rejected_by, reason: rejectReason } = body;\r\n        \r\n        if (!claim_id || !rejected_by || !rejectReason) {\r\n          return NextResponse.json(\r\n            { success: false, error: 'Missing required fields for claim rejection' },\r\n            { status: 400 }\r\n          );\r\n        }\r\n\r\n        const insurancePool = getInsurancePool();\r\n        const claim = await insurancePool.rejectClaim(claim_id, rejected_by, rejectReason);\r\n\r\n        return NextResponse.json({\r\n          success: true,\r\n          data: {\r\n            claimId: claim.claimId,\r\n            status: claim.status,\r\n            resolvedAt: claim.resolvedAt?.toISOString(),\r\n          },\r\n        });\r\n      }\r\n\r\n      default:\r\n        return NextResponse.json(\r\n          { success: false, error: `Unknown action: ${action}` },\r\n          { status: 400 }\r\n        );\r\n    }\r\n  } catch (error) {\r\n    logger.error({ error }, 'Audit trail POST error');\r\n    return NextResponse.json(\r\n      { success: false, error: error instanceof Error ? error.message : 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n"],"names":["AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","addRequestMeta","getRequestMeta","getTracer","SpanKind","setReferenceManifestsSingleton","createServerModuleMap","normalizeAppPath","NodeNextRequest","NodeNextResponse","NextRequestAdapter","signalFromNodeResponse","BaseServerSpan","getRevalidateReason","sendResponse","fromNodeOutgoingHttpHeaders","toNodeOutgoingHttpHeaders","getCacheControlHeader","INFINITE_CACHE","NEXT_CACHE_TAGS_HEADER","NoFallbackError","CachedRouteKind","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks","handler","req","res","ctx","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","params","nextConfig","parsedUrl","isDraftMode","prerenderManifest","routerServerContext","isOnDemandRevalidate","revalidateOnlyGenerated","resolvedPathname","clientReferenceManifest","serverActionsManifest","normalizedSrcPage","isIsr","Boolean","dynamicRoutes","routes","render404","isPrerendered","prerenderInfo","fallback","experimental","adapterPath","cacheKey","supportsDynamicResponse","isStaticGeneration","serverModuleMap","method","tracer","activeSpan","getActiveScopeSpan","context","renderOpts","authInterrupts","cacheComponents","incrementalCache","cacheLifeProfiles","cacheLife","onClose","cb","on","onAfterTaskError","undefined","onInstrumentationRequestError","error","_request","errorContext","onRequestError","sharedContext","nodeNextReq","nodeNextRes","nextReq","fromNodeNextRequest","invokeRouteModule","span","handle","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","isMinimalMode","MINIMAL_MODE","handleResponse","currentSpan","cacheEntry","responseGenerator","previousCacheEntry","setHeader","response","fetchMetrics","pendingWaitUntil","cacheTags","collectedTags","blob","headers","type","revalidate","collectedRevalidate","expire","collectedExpire","value","status","body","Buffer","from","arrayBuffer","cacheControl","err","isStale","routerKind","routePath","routeType","revalidateReason","routeKind","isFallback","isRoutePPREnabled","Error","isMiss","delete","getHeader","set","Response","withPropagatedContext","trace","spanName","SERVER","attributes","url"],"mappings":"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","ignoreList":[3]}