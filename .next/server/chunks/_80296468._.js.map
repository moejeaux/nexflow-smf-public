{"version":3,"sources":["../../../src/infra/x402scan/x402scan-observability-client.ts","../../../src/infra/x402scan/types.ts","../../../src/infra/scattering/scattering-client.ts","../../../src/infra/scattering/types.ts","../../../src/app/api/cron/pull-metrics/route.ts","../../../node_modules/next/src/build/templates/app-route.ts"],"sourcesContent":["// =============================================================================\r\n// X402SCAN OBSERVABILITY CLIENT\r\n// =============================================================================\r\n// Client for fetching observability data from x402scan's public TRPC API\r\n// Mirrors the same endpoints used by x402scan's observability pages\r\n//\r\n// Features:\r\n// - Circuit breaker protection against cascading failures\r\n// - Response caching with stale-while-revalidate pattern\r\n// - Graceful degradation with cached fallbacks\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport { getCircuitBreaker, type CircuitBreakerStats } from '@/lib/circuit-breaker';\r\nimport {\r\n  type FacilitatorPathMetrics,\r\n  type FacilitatorPathMetricsTimeframe,\r\n  type FacilitatorSummary,\r\n  type FacilitatorMethodMetrics,\r\n  type FetchFacilitatorObservabilityParams,\r\n  type FetchFacilitatorInvocationsParams,\r\n  type X402ScanStatusCodeBucket,\r\n  type X402ScanStatusCodeBucketRaw,\r\n  type X402ScanErrorRateBucket,\r\n  type X402ScanErrorRateBucketRaw,\r\n  type X402ScanLatencyBucket,\r\n  type X402ScanLatencyBucketRaw,\r\n  type X402ScanMethodStats,\r\n  type X402ScanMethodStatsRaw,\r\n  type X402ScanInvocation,\r\n  type TRPCResponse,\r\n  timeframeToHours,\r\n  timeframeToBucketMinutes,\r\n  toX402ScanFacilitatorName,\r\n  toNexFlowFacilitatorId,\r\n  normalizeStatusCodeBucket,\r\n  normalizeErrorRateBucket,\r\n  normalizeLatencyBucket,\r\n  normalizeMethodStats,\r\n} from './types';\r\n\r\nconst logger = createLogger({ component: 'X402ScanObservabilityClient' });\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\nconst X402SCAN_BASE_URL = process.env.X402SCAN_BASE_URL ?? 'https://www.x402scan.com';\r\nconst X402SCAN_TIMEOUT_MS = parseInt(process.env.X402SCAN_TIMEOUT_MS ?? '10000', 10);\r\n\r\n// Cache TTL settings\r\nconst CACHE_TTL_MS = parseInt(process.env.X402SCAN_CACHE_TTL_MS ?? '300000', 10); // 5 minutes\r\nconst STALE_TTL_MS = parseInt(process.env.X402SCAN_STALE_TTL_MS ?? '1800000', 10); // 30 minutes (serve stale)\r\n\r\n// =============================================================================\r\n// CIRCUIT BREAKER\r\n// =============================================================================\r\n\r\nconst circuitBreaker = getCircuitBreaker({\r\n  name: 'x402scan',\r\n  failureThreshold: 3,\r\n  successThreshold: 2,\r\n  resetTimeout: 60000, // 1 minute\r\n  failureWindow: 300000, // 5 minutes\r\n  requestTimeout: X402SCAN_TIMEOUT_MS,\r\n});\r\n\r\n/**\r\n * Get circuit breaker stats for monitoring\r\n */\r\nexport function getX402ScanCircuitBreakerStats(): CircuitBreakerStats {\r\n  return circuitBreaker.getStats();\r\n}\r\n\r\n// =============================================================================\r\n// RESPONSE CACHE\r\n// =============================================================================\r\n\r\ninterface CacheEntry<T> {\r\n  data: T;\r\n  fetchedAt: number;\r\n  isStale: boolean;\r\n}\r\n\r\nconst responseCache = new Map<string, CacheEntry<any>>();\r\n\r\n/**\r\n * Get cache key for a request\r\n */\r\nfunction getCacheKey(endpoint: string, input: Record<string, unknown>): string {\r\n  return `${endpoint}:${JSON.stringify(input)}`;\r\n}\r\n\r\n/**\r\n * Get cached response if available and not expired\r\n */\r\nfunction getCachedResponse<T>(cacheKey: string): { data: T; isStale: boolean } | null {\r\n  const entry = responseCache.get(cacheKey);\r\n  if (!entry) return null;\r\n  \r\n  const age = Date.now() - entry.fetchedAt;\r\n  \r\n  // Fresh cache - return immediately\r\n  if (age < CACHE_TTL_MS) {\r\n    return { data: entry.data, isStale: false };\r\n  }\r\n  \r\n  // Stale but usable - return with flag\r\n  if (age < STALE_TTL_MS) {\r\n    return { data: entry.data, isStale: true };\r\n  }\r\n  \r\n  // Too old - remove from cache\r\n  responseCache.delete(cacheKey);\r\n  return null;\r\n}\r\n\r\n/**\r\n * Store response in cache\r\n */\r\nfunction setCachedResponse<T>(cacheKey: string, data: T): void {\r\n  responseCache.set(cacheKey, {\r\n    data,\r\n    fetchedAt: Date.now(),\r\n    isStale: false,\r\n  });\r\n  \r\n  // Clean up old entries if cache gets too large\r\n  if (responseCache.size > 1000) {\r\n    const now = Date.now();\r\n    const keysToDelete: string[] = [];\r\n    responseCache.forEach((entry, key) => {\r\n      if (now - entry.fetchedAt > STALE_TTL_MS) {\r\n        keysToDelete.push(key);\r\n      }\r\n    });\r\n    keysToDelete.forEach(key => responseCache.delete(key));\r\n  }\r\n}\r\n\r\n/**\r\n * Clear all cached responses\r\n */\r\nexport function clearX402ScanCache(): void {\r\n  responseCache.clear();\r\n  logger.info('x402scan response cache cleared');\r\n}\r\n\r\n/**\r\n * Get cache statistics\r\n */\r\nexport function getX402ScanCacheStats(): {\r\n  size: number;\r\n  freshEntries: number;\r\n  staleEntries: number;\r\n} {\r\n  const now = Date.now();\r\n  let freshEntries = 0;\r\n  let staleEntries = 0;\r\n  \r\n  responseCache.forEach((entry) => {\r\n    const age = now - entry.fetchedAt;\r\n    if (age < CACHE_TTL_MS) {\r\n      freshEntries++;\r\n    } else if (age < STALE_TTL_MS) {\r\n      staleEntries++;\r\n    }\r\n  });\r\n  \r\n  return {\r\n    size: responseCache.size,\r\n    freshEntries,\r\n    staleEntries,\r\n  };\r\n}\r\n\r\n/**\r\n * TRPC API endpoints used by x402scan observability pages\r\n */\r\nconst TRPC_ENDPOINTS = {\r\n  statusCodes: '/api/trpc/public.facilitatorObservability.statusCodes',\r\n  errorRate: '/api/trpc/public.facilitatorObservability.errorRate',\r\n  latency: '/api/trpc/public.facilitatorObservability.latency',\r\n  methods: '/api/trpc/public.facilitatorObservability.methods',\r\n  invocations: '/api/trpc/public.facilitatorObservability.invocations',\r\n} as const;\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Build date range for a timeframe\r\n */\r\nfunction buildDateRange(timeframe: FacilitatorPathMetricsTimeframe): { startDate: string; endDate: string } {\r\n  const endDate = new Date();\r\n  const startDate = new Date(endDate.getTime() - timeframeToHours(timeframe) * 60 * 60 * 1000);\r\n  return {\r\n    startDate: startDate.toISOString(),\r\n    endDate: endDate.toISOString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Build TRPC input JSON for x402scan API\r\n */\r\nfunction buildTRPCInput(params: Record<string, unknown>): string {\r\n  return JSON.stringify({ json: params });\r\n}\r\n\r\n/**\r\n * Fetch from x402scan TRPC API with circuit breaker protection and caching\r\n */\r\nasync function fetchTRPC<T>(endpoint: string, input: Record<string, unknown>): Promise<T> {\r\n  const cacheKey = getCacheKey(endpoint, input);\r\n  \r\n  // Check cache first\r\n  const cached = getCachedResponse<T>(cacheKey);\r\n  \r\n  // If we have fresh cache, return immediately\r\n  if (cached && !cached.isStale) {\r\n    return cached.data;\r\n  }\r\n  \r\n  // Check if circuit breaker allows requests\r\n  if (!circuitBreaker.isAllowingRequests()) {\r\n    // Circuit is open - try to use stale cache\r\n    if (cached) {\r\n      logger.warn({\r\n        endpoint,\r\n        cacheAge: Date.now() - (responseCache.get(cacheKey)?.fetchedAt || 0),\r\n      }, 'x402scan circuit breaker open - serving stale cache');\r\n      return cached.data;\r\n    }\r\n    \r\n    // No cache available - throw\r\n    throw new Error('x402scan circuit breaker is open and no cached data available');\r\n  }\r\n  \r\n  // Execute request through circuit breaker\r\n  try {\r\n    const data = await circuitBreaker.execute(async () => {\r\n      const url = new URL(endpoint, X402SCAN_BASE_URL);\r\n      url.searchParams.set('input', buildTRPCInput(input));\r\n\r\n      const response = await fetch(url.toString(), {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Accept': 'application/json',\r\n        },\r\n        signal: AbortSignal.timeout(X402SCAN_TIMEOUT_MS),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const text = await response.text().catch(() => 'Unknown error');\r\n        throw new Error(`x402scan API error: ${response.status} - ${text}`);\r\n      }\r\n\r\n      const responseData = await response.json() as TRPCResponse<T>;\r\n      return responseData.result.data.json;\r\n    });\r\n    \r\n    // Cache successful response\r\n    setCachedResponse(cacheKey, data);\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    // Request failed - try to serve stale cache\r\n    if (cached) {\r\n      logger.warn({\r\n        endpoint,\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        cacheAge: Date.now() - (responseCache.get(cacheKey)?.fetchedAt || 0),\r\n      }, 'x402scan request failed - serving stale cache');\r\n      return cached.data;\r\n    }\r\n    \r\n    // No fallback available\r\n    throw error;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// INDIVIDUAL API FETCHERS\r\n// =============================================================================\r\n\r\n/**\r\n * Fetch status code distribution over time\r\n * Fetches raw data from x402scan and normalizes it\r\n */\r\nexport async function fetchStatusCodes(\r\n  facilitatorName: string,\r\n  startDate: string,\r\n  endDate: string,\r\n  bucketMinutes: number\r\n): Promise<X402ScanStatusCodeBucket[]> {\r\n  const rawData = await fetchTRPC<X402ScanStatusCodeBucketRaw[]>(TRPC_ENDPOINTS.statusCodes, {\r\n    facilitatorName,\r\n    startDate,\r\n    endDate,\r\n    bucketMinutes,\r\n  });\r\n  return rawData.map(normalizeStatusCodeBucket);\r\n}\r\n\r\n/**\r\n * Fetch error rate over time\r\n * Fetches raw data from x402scan and normalizes it\r\n */\r\nexport async function fetchErrorRate(\r\n  facilitatorName: string,\r\n  startDate: string,\r\n  endDate: string,\r\n  bucketMinutes: number\r\n): Promise<X402ScanErrorRateBucket[]> {\r\n  const rawData = await fetchTRPC<X402ScanErrorRateBucketRaw[]>(TRPC_ENDPOINTS.errorRate, {\r\n    facilitatorName,\r\n    startDate,\r\n    endDate,\r\n    bucketMinutes,\r\n  });\r\n  return rawData.map(normalizeErrorRateBucket);\r\n}\r\n\r\n/**\r\n * Fetch latency percentiles over time\r\n * Fetches raw data from x402scan and normalizes it\r\n */\r\nexport async function fetchLatency(\r\n  facilitatorName: string,\r\n  startDate: string,\r\n  endDate: string,\r\n  bucketMinutes: number\r\n): Promise<X402ScanLatencyBucket[]> {\r\n  const rawData = await fetchTRPC<X402ScanLatencyBucketRaw[]>(TRPC_ENDPOINTS.latency, {\r\n    facilitatorName,\r\n    startDate,\r\n    endDate,\r\n    bucketMinutes,\r\n  });\r\n  return rawData.map(normalizeLatencyBucket);\r\n}\r\n\r\n/**\r\n * Fetch method-level stats\r\n * Fetches raw data from x402scan and normalizes it\r\n */\r\nexport async function fetchMethods(\r\n  facilitatorName: string,\r\n  startDate: string,\r\n  endDate: string\r\n): Promise<X402ScanMethodStats[]> {\r\n  const rawData = await fetchTRPC<X402ScanMethodStatsRaw[]>(TRPC_ENDPOINTS.methods, {\r\n    facilitatorName,\r\n    startDate,\r\n    endDate,\r\n  });\r\n  return rawData.map(normalizeMethodStats);\r\n}\r\n\r\n/**\r\n * Fetch individual invocations (usually filtered to errors)\r\n */\r\nexport async function fetchInvocations(\r\n  params: FetchFacilitatorInvocationsParams\r\n): Promise<{ invocations: X402ScanInvocation[]; total: number }> {\r\n  const { startDate, endDate } = buildDateRange(params.timeframe);\r\n  \r\n  return fetchTRPC<{ invocations: X402ScanInvocation[]; total: number }>(TRPC_ENDPOINTS.invocations, {\r\n    facilitatorName: toX402ScanFacilitatorName(params.facilitatorName),\r\n    startDate,\r\n    endDate,\r\n    page: params.page ?? 1,\r\n    pageSize: params.pageSize ?? 50,\r\n    statusFilter: params.statusFilter ?? '5xx',\r\n  });\r\n}\r\n\r\n// =============================================================================\r\n// MAIN AGGREGATION FUNCTION\r\n// =============================================================================\r\n\r\n/**\r\n * Fetch all facilitator observability data and aggregate into FacilitatorPathMetrics\r\n * \r\n * This function mirrors x402scan's observability page by calling:\r\n * - statusCodes: for 2xx/3xx/4xx/5xx distribution\r\n * - errorRate: for error rate over time\r\n * - latency: for p50/p90/p99 percentiles\r\n * - methods: for method-level breakdown\r\n * \r\n * @param params - Query parameters\r\n * @returns Array of FacilitatorPathMetrics, one per time bucket\r\n */\r\nexport async function fetchFacilitatorObservability(\r\n  params: FetchFacilitatorObservabilityParams\r\n): Promise<FacilitatorPathMetrics[]> {\r\n  const facilitatorName = toX402ScanFacilitatorName(params.facilitatorName);\r\n  const { startDate, endDate } = buildDateRange(params.timeframe);\r\n  const bucketMinutes = timeframeToBucketMinutes(params.timeframe);\r\n  const fetchedAt = new Date().toISOString();\r\n\r\n  logger.info({\r\n    facilitatorName,\r\n    timeframe: params.timeframe,\r\n    startDate,\r\n    endDate,\r\n    bucketMinutes,\r\n    msg: 'Fetching x402scan observability data',\r\n  });\r\n\r\n  try {\r\n    // Fetch all data in parallel\r\n    const [statusCodes, errorRates, latencies, methods] = await Promise.all([\r\n      fetchStatusCodes(facilitatorName, startDate, endDate, bucketMinutes).catch((e) => {\r\n        logger.warn({ error: e.message, facilitatorName }, 'Failed to fetch status codes');\r\n        return [] as X402ScanStatusCodeBucket[];\r\n      }),\r\n      fetchErrorRate(facilitatorName, startDate, endDate, bucketMinutes).catch((e) => {\r\n        logger.warn({ error: e.message, facilitatorName }, 'Failed to fetch error rate');\r\n        return [] as X402ScanErrorRateBucket[];\r\n      }),\r\n      fetchLatency(facilitatorName, startDate, endDate, bucketMinutes).catch((e) => {\r\n        logger.warn({ error: e.message, facilitatorName }, 'Failed to fetch latency');\r\n        return [] as X402ScanLatencyBucket[];\r\n      }),\r\n      fetchMethods(facilitatorName, startDate, endDate).catch((e) => {\r\n        logger.warn({ error: e.message, facilitatorName }, 'Failed to fetch methods');\r\n        return [] as X402ScanMethodStats[];\r\n      }),\r\n    ]);\r\n\r\n    // Build lookup maps for error rate and latency by time bucket\r\n    const errorRateMap = new Map<string, X402ScanErrorRateBucket>();\r\n    for (const bucket of errorRates) {\r\n      errorRateMap.set(bucket.timeBucket, bucket);\r\n    }\r\n\r\n    const latencyMap = new Map<string, X402ScanLatencyBucket>();\r\n    for (const bucket of latencies) {\r\n      latencyMap.set(bucket.timeBucket, bucket);\r\n    }\r\n\r\n    // Convert method stats to FacilitatorMethodMetrics\r\n    const methodMetrics: FacilitatorMethodMetrics[] = methods.map((m) => ({\r\n      method: m.method,\r\n      requests: m.requests,\r\n      errors: m.errors,\r\n      errorRate: m.requests > 0 ? m.errors / m.requests : 0,\r\n      avgDurationMs: m.avgDurationMs,\r\n      lastSeen: m.lastSeen,\r\n    }));\r\n\r\n    // Build FacilitatorPathMetrics from status code buckets\r\n    const metrics: FacilitatorPathMetrics[] = statusCodes.map((sc) => {\r\n      const errorRate = errorRateMap.get(sc.timeBucket);\r\n      const latency = latencyMap.get(sc.timeBucket);\r\n      \r\n      const totalRequests = sc.count2xx + sc.count3xx + sc.count4xx + sc.count5xx;\r\n      const successCount = sc.count2xx + sc.count3xx;\r\n      const failureCount = sc.count4xx + sc.count5xx;\r\n\r\n      // Calculate bucket end time (bucket start + bucket duration)\r\n      const bucketStart = new Date(sc.timeBucket);\r\n      const bucketEnd = new Date(bucketStart.getTime() + bucketMinutes * 60 * 1000);\r\n\r\n      return {\r\n        kind: 'facilitator-global' as const, // Global facilitator metrics (not per-path)\r\n        facilitatorId: toNexFlowFacilitatorId(facilitatorName),\r\n        // resourceUrl and serverId will be set when fetching per-path metrics\r\n        resourceUrl: undefined,\r\n        serverId: undefined,\r\n        timeframe: params.timeframe,\r\n        bucketMinutes,\r\n        timeBucketStart: sc.timeBucket,\r\n        timeBucketEnd: bucketEnd.toISOString(),\r\n        invocations: totalRequests,\r\n        successCount,\r\n        failureCount,\r\n        // Status code buckets\r\n        count2xx: sc.count2xx,\r\n        count3xx: sc.count3xx,\r\n        count4xx: sc.count4xx,\r\n        count5xx: sc.count5xx,\r\n        errorRate: errorRate?.errorRate ?? (totalRequests > 0 ? failureCount / totalRequests : 0),\r\n        p50LatencyMs: latency?.p50,\r\n        p90LatencyMs: latency?.p90,\r\n        p95LatencyMs: latency ? (latency.p90 + latency.p99) / 2 : undefined, // Interpolate p95\r\n        p99LatencyMs: latency?.p99,\r\n        avgLatencyMs: latency ? (latency.p50 + latency.p90) / 2 : undefined, // Approximate avg\r\n        methods: methodMetrics,\r\n        fetchedAt,\r\n      };\r\n    });\r\n\r\n    logger.info({\r\n      facilitatorName,\r\n      timeframe: params.timeframe,\r\n      bucketCount: metrics.length,\r\n      totalInvocations: metrics.reduce((sum, m) => sum + m.invocations, 0),\r\n      msg: 'x402scan observability data fetched successfully',\r\n    });\r\n\r\n    return metrics;\r\n  } catch (error) {\r\n    logger.error({\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n      facilitatorName,\r\n      timeframe: params.timeframe,\r\n      msg: 'Failed to fetch x402scan observability data',\r\n    });\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Fetch and summarize facilitator observability data\r\n * Useful for quick SMF routing decisions\r\n */\r\nexport async function fetchFacilitatorSummary(\r\n  params: FetchFacilitatorObservabilityParams\r\n): Promise<FacilitatorSummary> {\r\n  const metrics = await fetchFacilitatorObservability(params);\r\n  const fetchedAt = new Date().toISOString();\r\n\r\n  // Aggregate across all buckets\r\n  let totalInvocations = 0;\r\n  let totalSuccesses = 0;\r\n  let totalFailures = 0;\r\n  let p50Sum = 0;\r\n  let p90Sum = 0;\r\n  let p99Sum = 0;\r\n  let latencyCount = 0;\r\n\r\n  for (const m of metrics) {\r\n    totalInvocations += m.invocations;\r\n    totalSuccesses += m.successCount;\r\n    totalFailures += m.failureCount;\r\n    \r\n    if (m.p50LatencyMs !== undefined) {\r\n      p50Sum += m.p50LatencyMs;\r\n      p90Sum += m.p90LatencyMs ?? 0;\r\n      p99Sum += m.p99LatencyMs ?? 0;\r\n      latencyCount++;\r\n    }\r\n  }\r\n\r\n  // Get methods from first bucket (they're the same across all buckets)\r\n  const topMethods = metrics[0]?.methods ?? [];\r\n\r\n  return {\r\n    facilitatorId: toNexFlowFacilitatorId(params.facilitatorName),\r\n    timeframe: params.timeframe,\r\n    totalInvocations,\r\n    totalSuccesses,\r\n    totalFailures,\r\n    overallErrorRate: totalInvocations > 0 ? totalFailures / totalInvocations : 0,\r\n    avgP50LatencyMs: latencyCount > 0 ? p50Sum / latencyCount : undefined,\r\n    avgP90LatencyMs: latencyCount > 0 ? p90Sum / latencyCount : undefined,\r\n    avgP99LatencyMs: latencyCount > 0 ? p99Sum / latencyCount : undefined,\r\n    topMethods,\r\n    dataStart: metrics[0]?.timeBucketStart ?? '',\r\n    dataEnd: metrics[metrics.length - 1]?.timeBucketEnd ?? '',\r\n    fetchedAt,\r\n  };\r\n}\r\n\r\n/**\r\n * Fetch observability summaries for multiple facilitators\r\n */\r\nexport async function fetchMultipleFacilitatorSummaries(\r\n  facilitatorNames: string[],\r\n  timeframe: FacilitatorPathMetricsTimeframe\r\n): Promise<Map<string, FacilitatorSummary>> {\r\n  const results = new Map<string, FacilitatorSummary>();\r\n\r\n  // Fetch in parallel with error handling per facilitator\r\n  const promises = facilitatorNames.map(async (name) => {\r\n    try {\r\n      const summary = await fetchFacilitatorSummary({ facilitatorName: name, timeframe });\r\n      return { name, summary, error: null };\r\n    } catch (error) {\r\n      logger.warn({\r\n        facilitatorName: name,\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        msg: 'Failed to fetch facilitator summary',\r\n      });\r\n      return { name, summary: null, error };\r\n    }\r\n  });\r\n\r\n  const settled = await Promise.all(promises);\r\n  \r\n  for (const result of settled) {\r\n    if (result.summary) {\r\n      results.set(result.name, result.summary);\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\n// =============================================================================\r\n// EXPORTS\r\n// =============================================================================\r\n\r\nexport {\r\n  X402SCAN_BASE_URL,\r\n  TRPC_ENDPOINTS,\r\n};\r\n\r\n","// =============================================================================\n// X402SCAN OBSERVABILITY TYPES\n// =============================================================================\n// Types for x402scan observability data used by NexFlow SMF\n// Based on x402scan TRPC API response shapes\n\n/**\n * Timeframe for observability data queries\n */\nexport type FacilitatorPathMetricsTimeframe = '1h' | '6h' | '1d' | '7d' | '30d';\n\n/**\n * Convert timeframe to hours for date calculations\n */\nexport function timeframeToHours(timeframe: FacilitatorPathMetricsTimeframe): number {\n  switch (timeframe) {\n    case '1h': return 1;\n    case '6h': return 6;\n    case '1d': return 24;\n    case '7d': return 24 * 7;\n    case '30d': return 24 * 30;\n    default: return 24;\n  }\n}\n\n/**\n * Get appropriate bucket size in minutes for a timeframe\n */\nexport function timeframeToBucketMinutes(timeframe: FacilitatorPathMetricsTimeframe): number {\n  switch (timeframe) {\n    case '1h': return 5;\n    case '6h': return 10;\n    case '1d': return 10;\n    case '7d': return 60;\n    case '30d': return 360;\n    default: return 10;\n  }\n}\n\n// =============================================================================\n// RAW API RESPONSE TYPES (from x402scan TRPC)\n// These match the ACTUAL x402scan API responses - field names and types\n// =============================================================================\n\n/**\n * RAW status code bucket from x402scan API\n * Endpoint: /api/trpc/public.facilitatorObservability.statusCodes\n * NOTE: x402scan returns string values and uses \"ts\" and \"r_Xxx\" field names\n */\nexport interface X402ScanStatusCodeBucketRaw {\n  ts: string;                   // Timestamp like \"2025-12-26 15:00:00\" (NOT ISO)\n  r_2xx: string;                // String count\n  r_3xx: string;\n  r_4xx: string;\n  r_5xx: string;\n}\n\n/**\n * Normalized status code bucket (internal use)\n */\nexport interface X402ScanStatusCodeBucket {\n  timeBucket: string;           // ISO timestamp\n  count2xx: number;\n  count3xx: number;\n  count4xx: number;\n  count5xx: number;\n}\n\n/**\n * RAW error rate bucket from x402scan API\n * Endpoint: /api/trpc/public.facilitatorObservability.errorRate\n */\nexport interface X402ScanErrorRateBucketRaw {\n  ts: string;                   // Timestamp like \"2025-12-26 15:00:00\"\n  error_rate: string;           // String decimal like \"0.001\"\n  total_requests: string;\n  error_count: string;\n}\n\n/**\n * Normalized error rate bucket (internal use)\n */\nexport interface X402ScanErrorRateBucket {\n  timeBucket: string;           // ISO timestamp\n  errorRate: number;            // 0-1 decimal\n  totalRequests: number;\n  errorCount: number;\n}\n\n/**\n * RAW latency bucket from x402scan API\n * Endpoint: /api/trpc/public.facilitatorObservability.latency\n */\nexport interface X402ScanLatencyBucketRaw {\n  ts: string;                   // Timestamp like \"2025-12-26 15:00:00\"\n  p50: string;                  // String milliseconds\n  p90: string;\n  p99: string;\n}\n\n/**\n * Normalized latency bucket (internal use)\n */\nexport interface X402ScanLatencyBucket {\n  timeBucket: string;           // ISO timestamp\n  p50: number;                  // milliseconds\n  p90: number;                  // milliseconds\n  p99: number;                  // milliseconds\n}\n\n// =============================================================================\n// RAW TO NORMALIZED CONVERTERS\n// =============================================================================\n\n/**\n * Convert x402scan timestamp to ISO format\n * Input: \"2025-12-26 15:00:00\" -> Output: \"2025-12-26T15:00:00.000Z\"\n */\nexport function parseX402ScanTimestamp(ts: string): string {\n  // Replace space with T and add Z for UTC\n  return ts.replace(' ', 'T') + '.000Z';\n}\n\n/**\n * Convert raw status code bucket to normalized format\n */\nexport function normalizeStatusCodeBucket(raw: X402ScanStatusCodeBucketRaw): X402ScanStatusCodeBucket {\n  return {\n    timeBucket: parseX402ScanTimestamp(raw.ts),\n    count2xx: parseInt(raw.r_2xx, 10) || 0,\n    count3xx: parseInt(raw.r_3xx, 10) || 0,\n    count4xx: parseInt(raw.r_4xx, 10) || 0,\n    count5xx: parseInt(raw.r_5xx, 10) || 0,\n  };\n}\n\n/**\n * Convert raw error rate bucket to normalized format\n */\nexport function normalizeErrorRateBucket(raw: X402ScanErrorRateBucketRaw): X402ScanErrorRateBucket {\n  return {\n    timeBucket: parseX402ScanTimestamp(raw.ts),\n    errorRate: parseFloat(raw.error_rate) || 0,\n    totalRequests: parseInt(raw.total_requests, 10) || 0,\n    errorCount: parseInt(raw.error_count, 10) || 0,\n  };\n}\n\n/**\n * Convert raw latency bucket to normalized format\n */\nexport function normalizeLatencyBucket(raw: X402ScanLatencyBucketRaw): X402ScanLatencyBucket {\n  return {\n    timeBucket: parseX402ScanTimestamp(raw.ts),\n    p50: parseFloat(raw.p50) || 0,\n    p90: parseFloat(raw.p90) || 0,\n    p99: parseFloat(raw.p99) || 0,\n  };\n}\n\n/**\n * RAW method stats from x402scan API\n * Endpoint: /api/trpc/public.facilitatorObservability.methods\n */\nexport interface X402ScanMethodStatsRaw {\n  method: string;               // e.g., \"settle\", \"verify\"\n  total_requests: string;       // String count\n  error_count: string;          // String count\n  avg_duration: number;         // Actually a number here\n  last_seen: string;            // Timestamp like \"2025-12-27 15:02:53.353\"\n}\n\n/**\n * Normalized method stats (internal use)\n */\nexport interface X402ScanMethodStats {\n  method: string;               // e.g., \"settle\", \"verify\"\n  requests: number;\n  errors: number;\n  avgDurationMs: number;\n  lastSeen: string;             // Normalized timestamp\n}\n\n/**\n * Convert raw method stats to normalized format\n */\nexport function normalizeMethodStats(raw: X402ScanMethodStatsRaw): X402ScanMethodStats {\n  return {\n    method: raw.method,\n    requests: parseInt(raw.total_requests, 10) || 0,\n    errors: parseInt(raw.error_count, 10) || 0,\n    avgDurationMs: raw.avg_duration || 0,\n    lastSeen: raw.last_seen ? parseX402ScanTimestamp(raw.last_seen.split('.')[0]) : '',\n  };\n}\n\n/**\n * Invocation record from x402scan\n * Endpoint: /api/trpc/public.facilitatorObservability.invocations\n */\nexport interface X402ScanInvocation {\n  id?: string;\n  method: string;               // e.g., \"settle\"\n  eventType: string;            // e.g., \"facilitator_failure\"\n  status: number;               // HTTP status code\n  durationMs: number;\n  errorType?: string;           // e.g., \"facilitator_error\"\n  time: string;                 // ISO timestamp or relative\n  resourceUrl?: string;         // Target server URL if available\n}\n\n/**\n * TRPC response wrapper\n */\nexport interface TRPCResponse<T> {\n  result: {\n    data: {\n      json: T;\n    };\n  };\n}\n\n// =============================================================================\n// NEXFLOW AGGREGATED TYPES\n// =============================================================================\n\n/**\n * Kind of metrics record\n * - \"facilitator-global\": Aggregate metrics for a facilitator across all paths\n * - \"facilitator-path\": Metrics for a specific facilitator + server/resource path\n */\nexport type FacilitatorMetricsKind = 'facilitator-global' | 'facilitator-path';\n\n/**\n * Aggregated facilitator metrics for a time bucket\n * This is the primary type NexFlow stores and uses for SMF optimization\n * \n * Retention policy:\n * - Raw buckets (bucketMinutes < 60): keep 7 days\n * - Hourly buckets: keep 30 days\n * - Daily rollups: keep 90 days\n */\nexport interface FacilitatorPathMetrics {\n  /** Record kind: global facilitator metrics or per-path metrics */\n  kind: FacilitatorMetricsKind;\n  \n  /** Facilitator identifier (e.g., \"coinbase\", \"payai\", \"dexter\") */\n  facilitatorId: string;\n  \n  /** Server/resource URL - REQUIRED when kind is \"facilitator-path\" */\n  resourceUrl?: string;\n  \n  /** x402scan server ID if available (for linking to x402scan server pages) */\n  serverId?: string;\n  \n  /** Network identifier if present (e.g., \"eip155:8453\") */\n  network?: string;\n  \n  /** Timeframe this data covers */\n  timeframe: FacilitatorPathMetricsTimeframe;\n  \n  /** Bucket size in minutes (e.g., 5, 10, 60) */\n  bucketMinutes: number;\n  \n  /** Start of the time bucket (ISO timestamp) */\n  timeBucketStart: string;\n  \n  /** End of the time bucket (ISO timestamp) */\n  timeBucketEnd: string;\n  \n  /** Total number of invocations/requests */\n  invocations: number;\n  \n  /** Number of successful requests (2xx + 3xx) */\n  successCount: number;\n  \n  /** Number of failed requests (4xx + 5xx) */\n  failureCount: number;\n  \n  // =========================================================================\n  // Status code buckets (from x402scan statusCodes endpoint)\n  // =========================================================================\n  \n  /** Count of 2xx responses */\n  count2xx: number;\n  \n  /** Count of 3xx responses */\n  count3xx: number;\n  \n  /** Count of 4xx responses */\n  count4xx: number;\n  \n  /** Count of 5xx responses */\n  count5xx: number;\n  \n  /** Error rate as decimal (0-1) */\n  errorRate: number;\n  \n  /** Average latency in milliseconds */\n  avgLatencyMs?: number;\n  \n  /** 50th percentile latency */\n  p50LatencyMs?: number;\n  \n  /** 90th percentile latency */\n  p90LatencyMs?: number;\n  \n  /** 95th percentile latency (interpolated from p90/p99 if needed) */\n  p95LatencyMs?: number;\n  \n  /** 99th percentile latency */\n  p99LatencyMs?: number;\n  \n  /** Method breakdown if available */\n  methods?: FacilitatorMethodMetrics[];\n  \n  /** When this record was fetched from x402scan */\n  fetchedAt: string;\n}\n\n/**\n * Per-method metrics within a facilitator\n */\nexport interface FacilitatorMethodMetrics {\n  method: string;               // e.g., \"settle\", \"verify\"\n  requests: number;\n  errors: number;\n  errorRate: number;            // 0-1\n  avgDurationMs: number;\n  lastSeen?: string;\n}\n\n/**\n * Facilitator summary across all time buckets\n * Useful for SMF routing decisions\n */\nexport interface FacilitatorSummary {\n  facilitatorId: string;\n  timeframe: FacilitatorPathMetricsTimeframe;\n  \n  /** Aggregate stats */\n  totalInvocations: number;\n  totalSuccesses: number;\n  totalFailures: number;\n  overallErrorRate: number;\n  \n  /** Latency percentiles across all buckets */\n  avgP50LatencyMs?: number;\n  avgP90LatencyMs?: number;\n  avgP99LatencyMs?: number;\n  \n  /** Most active methods */\n  topMethods: FacilitatorMethodMetrics[];\n  \n  /** Data freshness */\n  dataStart: string;\n  dataEnd: string;\n  fetchedAt: string;\n}\n\n// =============================================================================\n// QUERY PARAMETERS\n// =============================================================================\n\n/**\n * Parameters for fetching facilitator observability data\n */\nexport interface FetchFacilitatorObservabilityParams {\n  /** Facilitator name as used by x402scan (e.g., \"coinbase\") */\n  facilitatorName: string;\n  \n  /** Timeframe to fetch */\n  timeframe: FacilitatorPathMetricsTimeframe;\n  \n  /** Optional chain filter (not yet supported by x402scan) */\n  chain?: string;\n}\n\n/**\n * Parameters for fetching invocations (error logs)\n */\nexport interface FetchFacilitatorInvocationsParams {\n  facilitatorName: string;\n  timeframe: FacilitatorPathMetricsTimeframe;\n  page?: number;\n  pageSize?: number;\n  statusFilter?: '2xx' | '3xx' | '4xx' | '5xx' | 'all';\n}\n\n// =============================================================================\n// FACILITATOR MAPPING\n// =============================================================================\n\n/**\n * Map NexFlow facilitator IDs to x402scan facilitator names\n * NOTE: x402scan uses specific casing for facilitator names\n */\nexport const NEXFLOW_TO_X402SCAN_FACILITATOR_MAP: Record<string, string> = {\n  // Core facilitators\n  'cdp': 'coinbase',\n  'coinbase': 'coinbase',\n  'payai': 'payAI',      // x402scan uses capital AI\n  'dexter': 'dexter',\n  'x402rs': 'x402rs',    // Not on x402scan yet\n  \n  // Cronos x402 facilitator - https://docs.cronos.org/cronos-x402-facilitator\n  // TODO: Verify exact x402scan facilitator name once indexed\n  'cronos': 'cronos',\n  \n  // Additional x402scan facilitators\n  'heurist': 'heurist',\n  'anyspend': 'anyspend',\n  'openx402': 'openx402',\n  'questflow': 'questflow',\n  'codenut': 'codenut',\n  'virtuals': 'virtuals',\n  'corbits': 'corbits',\n  'thirdweb': 'thirdweb',\n};\n\n/**\n * Map x402scan facilitator names to NexFlow facilitator IDs\n */\nexport const X402SCAN_TO_NEXFLOW_FACILITATOR_MAP: Record<string, string> = {\n  // Core facilitators\n  'coinbase': 'cdp',\n  'payAI': 'payai',       // x402scan uses capital AI\n  'dexter': 'dexter',\n  'x402rs': 'x402rs',\n  \n  // Cronos x402 facilitator - https://docs.cronos.org/cronos-x402-facilitator\n  // TODO: Verify exact x402scan facilitator name once indexed\n  'cronos': 'cronos',\n  'Cronos': 'cronos',     // May be capitalized\n  \n  // Additional x402scan facilitators (mapped to same name)\n  'heurist': 'heurist',\n  'anyspend': 'anyspend',\n  'openx402': 'openx402',\n  'questflow': 'questflow',\n  'codenut': 'codenut',\n  'virtuals': 'virtuals',\n  'corbits': 'corbits',\n  'thirdweb': 'thirdweb',\n};\n\n/**\n * Get x402scan facilitator name from NexFlow ID\n */\nexport function toX402ScanFacilitatorName(nexflowId: string): string {\n  return NEXFLOW_TO_X402SCAN_FACILITATOR_MAP[nexflowId] ?? nexflowId;\n}\n\n/**\n * Get NexFlow facilitator ID from x402scan name\n */\nexport function toNexFlowFacilitatorId(x402scanName: string): string {\n  return X402SCAN_TO_NEXFLOW_FACILITATOR_MAP[x402scanName] ?? x402scanName;\n}\n\n","/**\n * Scattering API Client\n * \n * Fetches x402 facilitator volume/activity metrics from Scattering.io\n * which aggregates data from Dune Analytics dashboards.\n * \n * Features:\n * - Circuit breaker protection against cascading failures\n * - Response caching with stale-while-revalidate pattern\n * - Graceful degradation with cached fallbacks\n */\n\nimport { createLogger } from '@/lib/logger';\nimport { getCircuitBreaker, type CircuitBreakerStats } from '@/lib/circuit-breaker';\nimport {\n  RawScatteringFacilitator,\n  ScatteringFacilitatorMetrics,\n  FetchScatteringParams,\n  toNexFlowFacilitatorIdFromScattering,\n} from './types';\n\nconst logger = createLogger({ component: 'ScatteringClient' });\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\nconst SCATTERING_BASE_URL = process.env.SCATTERING_BASE_URL ?? 'https://api.scattering.io';\nconst SCATTERING_CATEGORY_ID = process.env.SCATTERING_CATEGORY_ID ?? '5';\nconst SCATTERING_TIMEOUT_MS = Number(process.env.SCATTERING_TIMEOUT_MS ?? 15000);\n\n// Cache TTL settings\nconst CACHE_TTL_MS = parseInt(process.env.SCATTERING_CACHE_TTL_MS ?? '300000', 10); // 5 minutes\nconst STALE_TTL_MS = parseInt(process.env.SCATTERING_STALE_TTL_MS ?? '1800000', 10); // 30 minutes\n\n// =============================================================================\n// CIRCUIT BREAKER\n// =============================================================================\n\nconst circuitBreaker = getCircuitBreaker({\n  name: 'scattering',\n  failureThreshold: 3,\n  successThreshold: 2,\n  resetTimeout: 60000, // 1 minute\n  failureWindow: 300000, // 5 minutes\n  requestTimeout: SCATTERING_TIMEOUT_MS,\n});\n\n/**\n * Get circuit breaker stats for monitoring\n */\nexport function getScatteringCircuitBreakerStats(): CircuitBreakerStats {\n  return circuitBreaker.getStats();\n}\n\n// =============================================================================\n// RESPONSE CACHE\n// =============================================================================\n\ninterface CacheEntry<T> {\n  data: T;\n  fetchedAt: number;\n}\n\nconst responseCache = new Map<string, CacheEntry<ScatteringFacilitatorMetrics[]>>();\n\n/**\n * Get cached response if available\n */\nfunction getCachedResponse(days: number): { data: ScatteringFacilitatorMetrics[]; isStale: boolean } | null {\n  const cacheKey = `facilitators:${days}`;\n  const entry = responseCache.get(cacheKey);\n  if (!entry) return null;\n  \n  const age = Date.now() - entry.fetchedAt;\n  \n  if (age < CACHE_TTL_MS) {\n    return { data: entry.data, isStale: false };\n  }\n  \n  if (age < STALE_TTL_MS) {\n    return { data: entry.data, isStale: true };\n  }\n  \n  responseCache.delete(cacheKey);\n  return null;\n}\n\n/**\n * Store response in cache\n */\nfunction setCachedResponse(days: number, data: ScatteringFacilitatorMetrics[]): void {\n  const cacheKey = `facilitators:${days}`;\n  responseCache.set(cacheKey, {\n    data,\n    fetchedAt: Date.now(),\n  });\n}\n\n/**\n * Clear all cached responses\n */\nexport function clearScatteringCache(): void {\n  responseCache.clear();\n  logger.info('Scattering response cache cleared');\n}\n\n/**\n * Get cache statistics\n */\nexport function getScatteringCacheStats(): {\n  size: number;\n  entries: Array<{ days: number; age: number; isStale: boolean }>;\n} {\n  const now = Date.now();\n  const entries: Array<{ days: number; age: number; isStale: boolean }> = [];\n  \n  responseCache.forEach((entry, key) => {\n    const days = parseInt(key.split(':')[1], 10);\n    const age = now - entry.fetchedAt;\n    entries.push({\n      days,\n      age,\n      isStale: age >= CACHE_TTL_MS,\n    });\n  });\n  \n  return {\n    size: responseCache.size,\n    entries,\n  };\n}\n\n// =============================================================================\n// CLIENT FUNCTIONS\n// =============================================================================\n\n/**\n * Fetch facilitator metrics from Scattering API\n * \n * Features:\n * - Circuit breaker protection\n * - Response caching with stale-while-revalidate\n * - Graceful degradation to cached data on failure\n * \n * @param params - Query parameters\n * @returns Array of normalized ScatteringFacilitatorMetrics\n */\nexport async function fetchScatteringFacilitators(\n  params: FetchScatteringParams = {}\n): Promise<ScatteringFacilitatorMetrics[]> {\n  const days = params.days ?? 3;\n  const url = `${SCATTERING_BASE_URL}/capi/dune/categories/${SCATTERING_CATEGORY_ID}/period-comparison?days=${days}`;\n\n  // Check cache first\n  const cached = getCachedResponse(days);\n  \n  // Return fresh cache immediately\n  if (cached && !cached.isStale) {\n    logger.debug({ days, cacheHit: true }, 'Scattering cache hit (fresh)');\n    return cached.data;\n  }\n  \n  // Check if circuit breaker allows requests\n  if (!circuitBreaker.isAllowingRequests()) {\n    if (cached) {\n      logger.warn({ days }, 'Scattering circuit breaker open - serving stale cache');\n      return cached.data;\n    }\n    throw new Error('Scattering circuit breaker is open and no cached data available');\n  }\n\n  logger.info({ url, days }, 'Fetching Scattering facilitator metrics');\n\n  try {\n    const validMetrics = await circuitBreaker.execute(async () => {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), SCATTERING_TIMEOUT_MS);\n\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n          'Accept': 'application/json',\n          'User-Agent': 'NexFlow-SMF/1.0',\n        },\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`Scattering API error: ${response.status} ${response.statusText}`);\n      }\n\n      const rawData: RawScatteringFacilitator[] = await response.json();\n\n      if (!Array.isArray(rawData)) {\n        throw new Error('Scattering API returned non-array response');\n      }\n\n      logger.info(\n        { facilitatorCount: rawData.length },\n        'Scattering API response received'\n      );\n\n      // Map raw data to normalized metrics\n      const metrics = rawData.map((raw) => mapRawToMetrics(raw, days));\n\n      // Filter out facilitators with no data\n      return metrics.filter((m) => m !== null) as ScatteringFacilitatorMetrics[];\n    });\n\n    // Cache successful response\n    setCachedResponse(days, validMetrics);\n\n    logger.info(\n      { \n        totalFacilitators: validMetrics.length,\n        topByVolume: validMetrics\n          .sort((a, b) => b.volumeUsd3d - a.volumeUsd3d)\n          .slice(0, 5)\n          .map((m) => `${m.facilitatorId}: $${formatNumber(m.volumeUsd3d)}`)\n          .join(', '),\n      },\n      'Scattering metrics processed successfully'\n    );\n\n    return validMetrics;\n  } catch (error: any) {\n    // Try to serve stale cache on failure\n    if (cached) {\n      logger.warn({\n        days,\n        error: error.message,\n        cacheAge: Date.now() - (responseCache.get(`facilitators:${days}`)?.fetchedAt || 0),\n      }, 'Scattering request failed - serving stale cache');\n      return cached.data;\n    }\n\n    if (error.name === 'AbortError') {\n      logger.error({ url, timeoutMs: SCATTERING_TIMEOUT_MS }, 'Scattering API request timed out');\n      throw new Error(`Scattering API timeout after ${SCATTERING_TIMEOUT_MS}ms`);\n    }\n\n    logger.error({ error: error.message, url }, 'Failed to fetch Scattering metrics');\n    throw error;\n  }\n}\n\n/**\n * Fetch metrics for a specific facilitator by NexFlow ID\n * \n * @param facilitatorId - NexFlow facilitator ID (e.g., \"cdp\", \"dexter\")\n * @param params - Query parameters\n * @returns ScatteringFacilitatorMetrics or null if not found\n */\nexport async function fetchScatteringMetricsForFacilitator(\n  facilitatorId: string,\n  params: FetchScatteringParams = {}\n): Promise<ScatteringFacilitatorMetrics | null> {\n  const allMetrics = await fetchScatteringFacilitators(params);\n  return allMetrics.find((m) => m.facilitatorId === facilitatorId) ?? null;\n}\n\n// =============================================================================\n// MAPPING FUNCTIONS\n// =============================================================================\n\n/**\n * Map raw Scattering API response to normalized metrics\n */\nfunction mapRawToMetrics(\n  raw: RawScatteringFacilitator,\n  days: number\n): ScatteringFacilitatorMetrics | null {\n  try {\n    const { query_result, project_name, chain_ids, tags, id, market_cap } = raw;\n\n    if (!query_result || !query_result.data) {\n      logger.warn({ projectName: project_name }, 'Facilitator has no query result data');\n      return null;\n    }\n\n    const { data, data_change_rates } = query_result;\n\n    // Parse total_amount which may be string or number\n    const totalAmount = typeof data.total_amount === 'string'\n      ? parseFloat(data.total_amount)\n      : data.total_amount;\n\n    const metrics: ScatteringFacilitatorMetrics = {\n      facilitatorId: toNexFlowFacilitatorIdFromScattering(project_name),\n      scatteringName: project_name,\n      period: '3d',\n      volumeUsd3d: data.amount ?? 0,\n      txCount3d: data.interaction ?? 0,\n      uniqueBuyers3d: data.unique_buyers ?? 0,\n      uniqueSellers3d: data.unique_sellers ?? 0,\n      volumeUsdAllTime: totalAmount ?? 0,\n      chains: normalizeChains(chain_ids),\n      marketCap: market_cap,\n      volumeChangeRate: data_change_rates?.amount,\n      txChangeRate: data_change_rates?.interaction,\n      buyersChangeRate: data_change_rates?.unique_buyers,\n      fetchedAt: new Date().toISOString(),\n      scatteringId: id,\n      tags: tags,\n    };\n\n    return metrics;\n  } catch (error: any) {\n    logger.warn(\n      { projectName: raw.project_name, error: error.message },\n      'Failed to map Scattering facilitator'\n    );\n    return null;\n  }\n}\n\n/**\n * Normalize chain IDs to consistent format\n */\nfunction normalizeChains(chainIds: string[]): string[] {\n  if (!chainIds || !Array.isArray(chainIds)) {\n    return [];\n  }\n\n  return chainIds.map((chain) => {\n    const lower = chain.toLowerCase();\n    \n    // Map common variations\n    switch (lower) {\n      case 'base':\n        return 'eip155:8453';\n      case 'solana':\n        return 'solana:mainnet';\n      case 'polygon':\n        return 'eip155:137';\n      case 'bsc':\n      case 'bnb':\n        return 'eip155:56';\n      case 'ethereum':\n      case 'eth':\n        return 'eip155:1';\n      // Cronos networks - https://docs.cronos.org/cronos-x402-facilitator\n      case 'cronos':\n        return 'eip155:25';\n      case 'cronos-testnet':\n        return 'eip155:338';\n      default:\n        return lower;\n    }\n  });\n}\n\n/**\n * Format number for logging (e.g., 137535 -> \"137.5K\")\n */\nfunction formatNumber(num: number): string {\n  if (num >= 1_000_000) {\n    return `${(num / 1_000_000).toFixed(1)}M`;\n  }\n  if (num >= 1_000) {\n    return `${(num / 1_000).toFixed(1)}K`;\n  }\n  return num.toFixed(2);\n}\n\n// =============================================================================\n// EXPORTS\n// =============================================================================\n\nexport {\n  SCATTERING_BASE_URL,\n  SCATTERING_CATEGORY_ID,\n  SCATTERING_TIMEOUT_MS,\n};\n\n","/**\n * Scattering / Dune Analytics Types for NexFlow SMF\n * \n * Scattering aggregates x402 facilitator volume data from Dune Analytics dashboards.\n * This provides business/activity metrics (volume, txns, users) to complement\n * x402scan's observability metrics (latency, error rates, status codes).\n * \n * API: https://api.scattering.io/capi/dune/categories/5/period-comparison?days=3\n */\n\n// =============================================================================\n// RAW API RESPONSE TYPES\n// =============================================================================\n\n/**\n * Raw facilitator data from Scattering API\n * Based on actual API response structure\n */\nexport interface RawScatteringFacilitator {\n  /** Internal Scattering ID */\n  id: number;\n  \n  /** Project/facilitator name (e.g., \"Coinbase\", \"Dexter\", \"PayAI Network\") */\n  project_name: string;\n  \n  /** Logo URL */\n  project_logo?: string;\n  \n  /** Project website */\n  project_website?: string;\n  \n  /** Twitter handle */\n  twitter_user_name?: string;\n  \n  /** URL slug */\n  slug?: string;\n  \n  /** Dune query ID for this facilitator */\n  dune_query_id?: string;\n  \n  /** Supported chains (e.g., [\"base\", \"solana\"]) */\n  chain_ids: string[];\n  \n  /** Contract addresses and metadata */\n  contract_addresses?: string[];\n  \n  /** Tags (e.g., [\"Facilitator\", \"x402\"]) */\n  tags?: string[];\n  \n  /** Market cap if token exists */\n  market_cap?: number;\n  \n  /** Query result containing metrics */\n  query_result: RawScatteringQueryResult;\n}\n\n/**\n * Query result nested in facilitator data\n */\nexport interface RawScatteringQueryResult {\n  /** Date of query */\n  query_date: string;\n  \n  /** Legacy fields (usually 0) */\n  contract_interaction?: number;\n  users?: number;\n  \n  /** Current period data */\n  data: RawScatteringPeriodData;\n  \n  /** Change rates vs comparison period */\n  data_change_rates: RawScatteringChangeRates;\n  \n  /** Comparison period data */\n  comparison_data: RawScatteringPeriodData;\n  \n  /** Legacy change rates */\n  contract_interaction_change_rate?: number;\n  users_change_rate?: number;\n}\n\n/**\n * Period data (current or comparison)\n */\nexport interface RawScatteringPeriodData {\n  /** Volume in USD */\n  amount: number;\n  \n  /** Date string */\n  day: string;\n  \n  /** Transaction count */\n  interaction: number;\n  \n  /** All-time volume (may be string or number) */\n  total_amount: number | string;\n  \n  /** Unique buyer addresses */\n  unique_buyers: number;\n  \n  /** Unique seller addresses */\n  unique_sellers: number;\n  \n  /** Total unique users */\n  users: number;\n}\n\n/**\n * Change rates (percentage) vs prior period\n */\nexport interface RawScatteringChangeRates {\n  /** Volume change % */\n  amount?: number;\n  \n  /** Transaction count change % */\n  interaction?: number;\n  \n  /** All-time volume change % */\n  total_amount?: number;\n  \n  /** Unique buyers change % */\n  unique_buyers?: number;\n  \n  /** Unique sellers change % */\n  unique_sellers?: number;\n  \n  /** Total users change % */\n  users?: number;\n}\n\n// =============================================================================\n// NORMALIZED NEXFLOW TYPES\n// =============================================================================\n\n/**\n * Supported period for Scattering queries\n * Currently only 3d is reliably available via the period-comparison endpoint\n */\nexport type ScatteringPeriod = '3d';\n\n/**\n * Normalized Scattering metrics for NexFlow SMF\n */\nexport interface ScatteringFacilitatorMetrics {\n  /** NexFlow facilitator ID (e.g., \"cdp\", \"payai\", \"dexter\") */\n  facilitatorId: string;\n  \n  /** Original Scattering project name */\n  scatteringName: string;\n  \n  /** Period these metrics cover */\n  period: ScatteringPeriod;\n  \n  /** 3-day volume in USD */\n  volumeUsd3d: number;\n  \n  /** 3-day transaction count */\n  txCount3d: number;\n  \n  /** 3-day unique buyer addresses */\n  uniqueBuyers3d: number;\n  \n  /** 3-day unique seller addresses */\n  uniqueSellers3d: number;\n  \n  /** All-time volume in USD */\n  volumeUsdAllTime: number;\n  \n  /** Supported chains (normalized) */\n  chains: string[];\n  \n  /** Market cap if available */\n  marketCap?: number;\n  \n  /** Volume change rate vs prior 3d (percentage) */\n  volumeChangeRate?: number;\n  \n  /** Transaction count change rate vs prior 3d (percentage) */\n  txChangeRate?: number;\n  \n  /** Unique buyers change rate vs prior 3d (percentage) */\n  buyersChangeRate?: number;\n  \n  /** When this data was fetched */\n  fetchedAt: string;\n  \n  /** Scattering internal ID for reference */\n  scatteringId?: number;\n  \n  /** Tags from Scattering */\n  tags?: string[];\n}\n\n// =============================================================================\n// FACILITATOR MAPPING\n// =============================================================================\n\n/**\n * Map Scattering project names to NexFlow facilitator IDs\n * Scattering uses display names; NexFlow uses lowercase IDs\n */\nexport const SCATTERING_TO_NEXFLOW_FACILITATOR_MAP: Record<string, string> = {\n  // Core facilitators\n  'Coinbase': 'cdp',\n  'coinbase': 'cdp',\n  'Dexter': 'dexter',\n  'dexter': 'dexter',\n  'PayAI Network': 'payai',\n  'payai': 'payai',\n  'x402rs': 'x402rs',\n  // Cronos x402 facilitator - https://docs.cronos.org/cronos-x402-facilitator\n  // TODO: Verify exact Scattering project name once tracked\n  'Cronos': 'cronos',\n  'cronos': 'cronos',\n  'Cronos Labs': 'cronos',  // Possible variation\n  \n  // Additional facilitators\n  'Heurist': 'heurist',\n  'heurist': 'heurist',\n  'Anyspend': 'anyspend',\n  'anyspend': 'anyspend',\n  'Open x402': 'openx402',\n  'openx402': 'openx402',\n  'Questflow': 'questflow',\n  'questflow': 'questflow',\n  'CodeNutPay': 'codenut',\n  'codenut': 'codenut',\n  'Virtuals Protocol': 'virtuals',\n  'virtuals': 'virtuals',\n  'Thirdweb': 'thirdweb',\n  'thirdweb': 'thirdweb',\n  'Corbits': 'corbits',\n  'corbits': 'corbits',\n  'Pieverse': 'pieverse',\n  'pieverse': 'pieverse',\n  'AurraCloud': 'aurracloud',\n  'aurracloud': 'aurracloud',\n  'Polygon': 'polygon',\n  'polygon': 'polygon',\n  'Unibase': 'unibase',\n  'unibase': 'unibase',\n  'Treasure': 'treasure',\n  'treasure': 'treasure',\n  'Mogami': 'mogami',\n  'mogami': 'mogami',\n  'xEcho': 'xecho',\n  'xecho': 'xecho',\n  'Ultravioleta DAO': 'ultravioletadao',\n  'ultravioletadao': 'ultravioletadao',\n  'Daydreams': 'daydreams',\n  'daydreams': 'daydreams',\n  'x402jobs': 'x402jobs',\n  'b402': 'b402',\n  'x444': 'x444',\n  'x402Bscan': 'x402bscan',\n  'AltLayer': 'altlayer',\n  'altlayer': 'altlayer',\n  'AceDataCloud': 'acedatacloud',\n  'OpenMid': 'openmid',\n};\n\n/**\n * Map NexFlow facilitator IDs to Scattering project names\n */\nexport const NEXFLOW_TO_SCATTERING_FACILITATOR_MAP: Record<string, string> = {\n  'cdp': 'Coinbase',\n  'dexter': 'Dexter',\n  'payai': 'PayAI Network',\n  'x402rs': 'x402rs',\n  // Cronos x402 facilitator - https://docs.cronos.org/cronos-x402-facilitator\n  // TODO: Verify exact Scattering project name once tracked\n  'cronos': 'Cronos',\n  'heurist': 'Heurist',\n  'anyspend': 'Anyspend',\n  'openx402': 'Open x402',\n  'questflow': 'Questflow',\n  'codenut': 'CodeNutPay',\n  'virtuals': 'Virtuals Protocol',\n  'thirdweb': 'Thirdweb',\n  'corbits': 'Corbits',\n  'pieverse': 'Pieverse',\n  'aurracloud': 'AurraCloud',\n  'polygon': 'Polygon',\n  'unibase': 'Unibase',\n  'treasure': 'Treasure',\n  'mogami': 'Mogami',\n  'xecho': 'xEcho',\n  'ultravioletadao': 'Ultravioleta DAO',\n  'daydreams': 'Daydreams',\n  'x402jobs': 'x402jobs',\n  'b402': 'b402',\n  'x444': 'x444',\n  'x402bscan': 'x402Bscan',\n  'altlayer': 'AltLayer',\n  'acedatacloud': 'AceDataCloud',\n  'openmid': 'OpenMid',\n};\n\n/**\n * Convert Scattering project name to NexFlow facilitator ID\n */\nexport function toNexFlowFacilitatorIdFromScattering(scatteringName: string): string {\n  return SCATTERING_TO_NEXFLOW_FACILITATOR_MAP[scatteringName] \n    ?? scatteringName.toLowerCase().replace(/\\s+/g, '');\n}\n\n/**\n * Convert NexFlow facilitator ID to Scattering project name\n */\nexport function toScatteringFacilitatorName(nexflowId: string): string | undefined {\n  return NEXFLOW_TO_SCATTERING_FACILITATOR_MAP[nexflowId];\n}\n\n// =============================================================================\n// QUERY PARAMETERS\n// =============================================================================\n\n/**\n * Parameters for fetching Scattering facilitator data\n */\nexport interface FetchScatteringParams {\n  /** Number of days for period comparison (default: 3) */\n  days?: number;\n}\n\n","// =============================================================================\r\n// VERCEL CRON ENDPOINT: Pull External Metrics\r\n// =============================================================================\r\n// GET /api/cron/pull-metrics\r\n// Pulls facilitator metrics from x402scan and Scattering/Dune\r\n// Called by Vercel Cron every 4 hours (schedule: \"0 */4 * * *\")\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { withCronJobTracking, type CronJobContext } from '@/lib/cron-job-wrapper';\r\nimport { fetchFacilitatorObservability, fetchFacilitatorSummary } from '@/infra/x402scan/x402scan-observability-client';\r\nimport { upsertFacilitatorPathMetrics, upsertFacilitatorSummaries } from '@/services/facilitator-metrics-service';\r\nimport { fetchScatteringFacilitators } from '@/infra/scattering/scattering-client';\r\nimport { upsertScatteringMetrics } from '@/services/facilitator-volume-service';\r\nimport type { FacilitatorPathMetricsTimeframe } from '@/infra/x402scan/types';\r\n\r\nconst logger = createLogger({ component: 'PullMetricsCron' });\r\n\r\n// Facilitators to pull x402scan data for\r\nconst X402SCAN_FACILITATORS = [\r\n  'coinbase',  // CDP\r\n  'dexter',\r\n  'payAI',     // Note: capital AI for x402scan\r\n];\r\n\r\n// Timeframes to pull\r\nconst TIMEFRAMES: FacilitatorPathMetricsTimeframe[] = ['1d', '7d'];\r\n\r\n// =============================================================================\r\n// CRON HANDLER\r\n// =============================================================================\r\n\r\nasync function pullMetricsHandler(\r\n  _request: NextRequest,\r\n  context: CronJobContext\r\n): Promise<{ ok: boolean; [key: string]: any }> {\r\n  const { runId, requestId } = context;\r\n\r\n  const results = {\r\n    x402scan: { success: 0, failed: 0, errors: [] as string[] },\r\n    scattering: { success: false, error: null as string | null },\r\n    timestamp: new Date().toISOString(),\r\n  };\r\n\r\n  // ==========================================================================\r\n  // 1. Pull x402scan observability data\r\n  // ==========================================================================\r\n  logger.info({ runId, requestId, msg: 'Starting x402scan metrics pull' });\r\n  \r\n  for (const facilitator of X402SCAN_FACILITATORS) {\r\n    for (const timeframe of TIMEFRAMES) {\r\n      try {\r\n        // Fetch time-bucketed metrics\r\n        const metrics = await fetchFacilitatorObservability({\r\n          facilitatorName: facilitator,  // Fixed: was incorrectly `facilitatorId`\r\n          timeframe,\r\n        });\r\n\r\n        if (metrics.length > 0) {\r\n          await upsertFacilitatorPathMetrics(metrics);\r\n          results.x402scan.success++;\r\n          logger.info({ runId, requestId, facilitator, timeframe, metricsCount: metrics.length }, 'x402scan metrics stored');\r\n        }\r\n\r\n        // Fetch summary separately (aggregated stats across all buckets)\r\n        try {\r\n          const summary = await fetchFacilitatorSummary({\r\n            facilitatorName: facilitator,\r\n            timeframe,\r\n          });\r\n          await upsertFacilitatorSummaries([summary]);\r\n        } catch (summaryError: any) {\r\n          // Summary fetch failure is non-critical, just log it\r\n          logger.warn({ runId, requestId, facilitator, timeframe, error: summaryError.message }, 'Failed to fetch facilitator summary');\r\n        }\r\n      } catch (error: any) {\r\n        results.x402scan.failed++;\r\n        results.x402scan.errors.push(`${facilitator}/${timeframe}: ${error.message}`);\r\n        logger.error({ runId, requestId, facilitator, timeframe, error: error.message }, 'Failed to pull x402scan metrics');\r\n      }\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // 2. Pull Scattering/Dune volume data\r\n  // ==========================================================================\r\n  logger.info({ runId, requestId, msg: 'Starting Scattering metrics pull' });\r\n  \r\n  try {\r\n    const scatteringData = await fetchScatteringFacilitators({ days: 3 });\r\n    await upsertScatteringMetrics(scatteringData);\r\n    results.scattering.success = true;\r\n    logger.info({ runId, requestId, facilitatorCount: scatteringData.length }, 'Scattering metrics stored');\r\n  } catch (error: any) {\r\n    results.scattering.error = error.message;\r\n    logger.error({ runId, requestId, error: error.message }, 'Failed to pull Scattering metrics');\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Log summary\r\n  // ==========================================================================\r\n  logger.info({\r\n    runId,\r\n    requestId,\r\n    x402scanSuccess: results.x402scan.success,\r\n    x402scanFailed: results.x402scan.failed,\r\n    scatteringSuccess: results.scattering.success,\r\n    msg: 'Metrics pull completed',\r\n  });\r\n\r\n  const hasErrors = results.x402scan.failed > 0 || results.scattering.error !== null;\r\n\r\n  return {\r\n    ok: !hasErrors,\r\n    ...results,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// EXPORTS\r\n// =============================================================================\r\n\r\nexport const dynamic = 'force-dynamic';\r\nexport const maxDuration = 60;\r\n\r\nexport const GET = withCronJobTracking(pullMetricsHandler, {\r\n  jobId: 'pull-metrics',\r\n  timeout: 55000, // 55s (leave buffer for wrapper overhead)\r\n  minInterval: 230 * 60 * 1000, // 230 minutes (schedule is every 4 hours)\r\n});\r\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n"],"names":["AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","addRequestMeta","getRequestMeta","getTracer","SpanKind","setReferenceManifestsSingleton","createServerModuleMap","normalizeAppPath","NodeNextRequest","NodeNextResponse","NextRequestAdapter","signalFromNodeResponse","BaseServerSpan","getRevalidateReason","sendResponse","fromNodeOutgoingHttpHeaders","toNodeOutgoingHttpHeaders","getCacheControlHeader","INFINITE_CACHE","NEXT_CACHE_TAGS_HEADER","NoFallbackError","CachedRouteKind","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks","handler","req","res","ctx","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","params","nextConfig","parsedUrl","isDraftMode","prerenderManifest","routerServerContext","isOnDemandRevalidate","revalidateOnlyGenerated","resolvedPathname","clientReferenceManifest","serverActionsManifest","normalizedSrcPage","isIsr","Boolean","dynamicRoutes","routes","render404","isPrerendered","prerenderInfo","fallback","experimental","adapterPath","cacheKey","supportsDynamicResponse","isStaticGeneration","serverModuleMap","method","tracer","activeSpan","getActiveScopeSpan","context","renderOpts","authInterrupts","cacheComponents","incrementalCache","cacheLifeProfiles","cacheLife","onClose","cb","on","onAfterTaskError","undefined","onInstrumentationRequestError","error","_request","errorContext","onRequestError","sharedContext","nodeNextReq","nodeNextRes","nextReq","fromNodeNextRequest","invokeRouteModule","span","handle","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","isMinimalMode","MINIMAL_MODE","handleResponse","currentSpan","cacheEntry","responseGenerator","previousCacheEntry","setHeader","response","fetchMetrics","pendingWaitUntil","cacheTags","collectedTags","blob","headers","type","revalidate","collectedRevalidate","expire","collectedExpire","value","status","body","Buffer","from","arrayBuffer","cacheControl","err","isStale","routerKind","routePath","routeType","revalidateReason","routeKind","isFallback","isRoutePPREnabled","Error","isMiss","delete","getHeader","set","Response","withPropagatedContext","trace","spanName","SERVER","attributes","url"],"mappings":"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","ignoreList":[5]}