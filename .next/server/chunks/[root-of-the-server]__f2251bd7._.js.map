{"version":3,"sources":["turbopack:///[project]/node_modules/thread-stream/package.json","../../../src/services/facilitator-metrics-reader.ts","../../../src/integrations/x402/facilitators/facilitator-registry.ts"],"sourcesContent":["{\"name\":\"thread-stream\",\"version\":\"3.1.0\",\"description\":\"A streaming way to send data to a Node.js Worker Thread\",\"main\":\"index.js\",\"types\":\"index.d.ts\",\"dependencies\":{\"real-require\":\"^0.2.0\"},\"devDependencies\":{\"@types/node\":\"^20.1.0\",\"@types/tap\":\"^15.0.0\",\"@yao-pkg/pkg\":\"^5.11.5\",\"desm\":\"^1.3.0\",\"fastbench\":\"^1.0.1\",\"husky\":\"^9.0.6\",\"pino-elasticsearch\":\"^8.0.0\",\"sonic-boom\":\"^4.0.1\",\"standard\":\"^17.0.0\",\"tap\":\"^16.2.0\",\"ts-node\":\"^10.8.0\",\"typescript\":\"^5.3.2\",\"why-is-node-running\":\"^2.2.2\"},\"scripts\":{\"build\":\"tsc --noEmit\",\"test\":\"standard && npm run build && npm run transpile && tap \\\"test/**/*.test.*js\\\" && tap --ts test/*.test.*ts\",\"test:ci\":\"standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts\",\"test:ci:js\":\"tap --no-check-coverage --timeout=120 --coverage-report=lcovonly \\\"test/**/*.test.*js\\\"\",\"test:ci:ts\":\"tap --ts --no-check-coverage --coverage-report=lcovonly \\\"test/**/*.test.*ts\\\"\",\"test:yarn\":\"npm run transpile && tap \\\"test/**/*.test.js\\\" --no-check-coverage\",\"transpile\":\"sh ./test/ts/transpile.sh\",\"prepare\":\"husky install\"},\"standard\":{\"ignore\":[\"test/ts/**/*\",\"test/syntax-error.mjs\"]},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/mcollina/thread-stream.git\"},\"keywords\":[\"worker\",\"thread\",\"threads\",\"stream\"],\"author\":\"Matteo Collina <hello@matteocollina.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/mcollina/thread-stream/issues\"},\"homepage\":\"https://github.com/mcollina/thread-stream#readme\"}","// =============================================================================\n// FACILITATOR METRICS READER\n// =============================================================================\n// Read-side helper for SMF to access facilitator path metrics\n// Used by the SMF router to inform routing decisions\n//\n// Scoring blends two data sources:\n// 1. x402scan: Observability metrics (success rate, latency, confidence)\n// 2. Scattering: Activity metrics (volume, tx count, unique buyers)\n\nimport { createLogger } from '@/lib/logger';\nimport {\n  type FacilitatorPathMetrics,\n  type FacilitatorSummary,\n  type FacilitatorPathMetricsTimeframe,\n} from '@/infra/x402scan/types';\nimport {\n  loadAllMetrics,\n  loadAllSummaries,\n  getSummary,\n  getMetricsForFacilitator,\n} from './facilitator-metrics-service';\nimport {\n  getScatteringMetricsForFacilitator,\n  computeActivityScore,\n} from './facilitator-volume-service';\nimport type { ScatteringFacilitatorMetrics } from '@/infra/scattering/types';\n\nconst logger = createLogger({ component: 'FacilitatorMetricsReader' });\n\n// =============================================================================\n// FRESHNESS & CONFIDENCE CONFIGURATION\n// =============================================================================\n\n/**\n * Configuration for determining when metrics are trustworthy\n * These thresholds prevent routing decisions based on stale or thin data\n */\nexport interface MetricsTrustConfig {\n  /** Maximum age of data to trust (hours) */\n  maxDataAgeHours: number;\n  /** Minimum invocations for high confidence scoring */\n  minInvocationsHighConfidence: number;\n  /** Minimum invocations to use data at all */\n  minInvocationsMinimum: number;\n  /** Penalty multiplier for low confidence data (0-1) */\n  lowConfidencePenalty: number;\n}\n\n/**\n * Default trust configuration\n * Can be overridden via environment variables\n */\nexport const DEFAULT_TRUST_CONFIG: MetricsTrustConfig = {\n  maxDataAgeHours: parseFloat(process.env.METRICS_MAX_AGE_HOURS ?? '4'),\n  minInvocationsHighConfidence: parseInt(process.env.METRICS_MIN_INVOCATIONS_HIGH ?? '1000', 10),\n  minInvocationsMinimum: parseInt(process.env.METRICS_MIN_INVOCATIONS ?? '100', 10),\n  lowConfidencePenalty: parseFloat(process.env.METRICS_LOW_CONFIDENCE_PENALTY ?? '0.5'),\n};\n\n/**\n * Check if metrics should be trusted for routing decisions\n */\nexport function shouldTrustMetrics(\n  dataAgeHours: number,\n  invocations: number,\n  config: MetricsTrustConfig = DEFAULT_TRUST_CONFIG\n): { trust: boolean; confidence: 'high' | 'medium' | 'low' | 'none'; reason: string } {\n  // Data too old\n  if (dataAgeHours > config.maxDataAgeHours) {\n    return {\n      trust: false,\n      confidence: 'none',\n      reason: `data-stale:${dataAgeHours.toFixed(1)}h-old`,\n    };\n  }\n\n  // Not enough data\n  if (invocations < config.minInvocationsMinimum) {\n    return {\n      trust: false,\n      confidence: 'none',\n      reason: `insufficient-data:${invocations}-invocations`,\n    };\n  }\n\n  // High confidence\n  if (invocations >= config.minInvocationsHighConfidence) {\n    return {\n      trust: true,\n      confidence: 'high',\n      reason: `high-confidence:${invocations}-invocations`,\n    };\n  }\n\n  // Medium confidence\n  return {\n    trust: true,\n    confidence: 'medium',\n    reason: `medium-confidence:${invocations}-invocations`,\n  };\n}\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface GetBestPathsParams {\n  /** Facilitator ID (NexFlow format, e.g., \"cdp\", \"payai\") */\n  facilitatorId: string;\n  \n  /** Network filter (optional) */\n  network?: string;\n  \n  /** Timeframe to consider (default: \"1d\") */\n  timeframe?: FacilitatorPathMetricsTimeframe;\n  \n  /** Maximum number of results */\n  limit?: number;\n}\n\nexport interface FacilitatorScoreParams {\n  /** Facilitator ID */\n  facilitatorId: string;\n  \n  /** Timeframe to consider */\n  timeframe?: FacilitatorPathMetricsTimeframe;\n}\n\nexport interface FacilitatorScore {\n  facilitatorId: string;\n  score: number;             // 0-100, higher is better\n  successRate: number;       // 0-1\n  avgLatencyMs?: number;\n  p95LatencyMs?: number;\n  totalInvocations: number;\n  dataFreshness: number;     // hours since last data\n  confidence: 'high' | 'medium' | 'low' | 'none';  // based on data availability\n  reasons: string[];\n  // Scattering activity metrics\n  scatteringActivityScore?: number;    // 0-1 activity score from Scattering\n  scatteringVolume3d?: number;         // 3-day volume in USD\n  scatteringTxCount3d?: number;        // 3-day transaction count\n  scatteringUniqueBuyers3d?: number;   // 3-day unique buyers\n  scatteringLowActivity?: boolean;     // true if below thresholds\n}\n\nexport interface FacilitatorRanking {\n  rankings: FacilitatorScore[];\n  timestamp: string;\n  timeframe: FacilitatorPathMetricsTimeframe;\n}\n\n// =============================================================================\n// SCORING WEIGHTS & CONFIGURATION\n// =============================================================================\n\n/**\n * Scattering score weight (0-1)\n * Controls how much Scattering activity metrics influence the final score\n * Default: 0.2 (20%) - configurable via SCATTERING_SCORE_WEIGHT env var\n */\nconst SCATTERING_SCORE_WEIGHT = parseFloat(process.env.SCATTERING_SCORE_WEIGHT ?? '0.2');\n\n/**\n * Minimum thresholds for Scattering data to be considered meaningful\n * Below these thresholds, activity is flagged as \"low\" and doesn't boost score\n */\nconst SCATTERING_MIN_TX_COUNT_3D = parseInt(process.env.SCATTERING_MIN_TX_COUNT ?? '100', 10);\nconst SCATTERING_MIN_VOLUME_USD_3D = parseFloat(process.env.SCATTERING_MIN_VOLUME ?? '100');\n\n/**\n * x402scan score weight (the remainder after Scattering)\n * x402scan measures reliability (success rate, latency, confidence)\n */\nconst X402SCAN_SCORE_WEIGHT = 1 - SCATTERING_SCORE_WEIGHT;\n\n/**\n * Internal weights for x402scan sub-components\n * These are applied to the x402scan portion of the score\n */\nconst SCORING_WEIGHTS = {\n  successRate: 50,     // 50% weight on success rate\n  latency: 30,         // 30% weight on latency\n  volume: 10,          // 10% weight on volume (more volume = more confidence)\n  freshness: 10,       // 10% weight on data freshness\n};\n\n// =============================================================================\n// QUERY FUNCTIONS\n// =============================================================================\n\n/**\n * Get best performing facilitator paths\n * Sorted by success rate, then by latency\n */\nexport async function getBestFacilitatorPaths(\n  params: GetBestPathsParams\n): Promise<FacilitatorPathMetrics[]> {\n  const timeframe = params.timeframe ?? '1d';\n  const limit = params.limit ?? 10;\n\n  try {\n    const metrics = await getMetricsForFacilitator(params.facilitatorId, timeframe);\n\n    if (metrics.length === 0) {\n      logger.debug({\n        facilitatorId: params.facilitatorId,\n        timeframe,\n        msg: 'No metrics found for facilitator',\n      });\n      return [];\n    }\n\n    // Sort by success rate (descending), then by latency (ascending)\n    const sorted = [...metrics].sort((a, b) => {\n      // Primary: higher success rate is better\n      const successRateDiff = (1 - b.errorRate) - (1 - a.errorRate);\n      if (Math.abs(successRateDiff) > 0.01) {\n        return successRateDiff > 0 ? 1 : -1;\n      }\n\n      // Secondary: lower latency is better\n      const aLatency = a.p95LatencyMs ?? a.avgLatencyMs ?? Infinity;\n      const bLatency = b.p95LatencyMs ?? b.avgLatencyMs ?? Infinity;\n      return aLatency - bLatency;\n    });\n\n    return sorted.slice(0, limit);\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId: params.facilitatorId,\n      msg: 'Failed to get best facilitator paths',\n    });\n    return [];\n  }\n}\n\n/**\n * Calculate a composite score for a facilitator blending:\n * 1. x402scan: reliability metrics (success rate, latency, confidence)\n * 2. Scattering: activity metrics (volume, tx count, unique buyers)\n * \n * Score is 0-100, higher is better\n * \n * The blend is controlled by SCATTERING_SCORE_WEIGHT (default 0.2):\n * - x402scan contributes (1 - SCATTERING_SCORE_WEIGHT) * x402scanScore\n * - Scattering contributes SCATTERING_SCORE_WEIGHT * scatteringScore\n */\nexport async function getFacilitatorScore(\n  params: FacilitatorScoreParams\n): Promise<FacilitatorScore | null> {\n  const timeframe = params.timeframe ?? '1d';\n  const reasons: string[] = [];\n\n  try {\n    // ==========================================================================\n    // PART 1: x402scan reliability metrics\n    // ==========================================================================\n    const summary = await getSummary(params.facilitatorId, timeframe);\n    \n    let x402scanScore = 50; // Default neutral\n    let successRate = 0;\n    let hoursOld = Infinity;\n    let totalInvocations = 0;\n    let avgLatencyMs: number | undefined;\n    let p95LatencyMs: number | undefined;\n    let hasX402scanData = false;\n\n    if (summary) {\n      hasX402scanData = true;\n      \n      // Calculate success rate score (0-50)\n      successRate = 1 - summary.overallErrorRate;\n      const successRateScore = successRate * SCORING_WEIGHTS.successRate;\n      reasons.push(`success-rate:${(successRate * 100).toFixed(1)}%`);\n\n      // Calculate latency score (0-30)\n      let latencyScore = SCORING_WEIGHTS.latency;\n      const p95 = summary.avgP90LatencyMs ?? summary.avgP99LatencyMs;\n      if (p95 !== undefined) {\n        const normalizedLatency = Math.min(p95, 2000) / 2000;\n        latencyScore = (1 - normalizedLatency) * SCORING_WEIGHTS.latency;\n        reasons.push(`p95-latency:${p95.toFixed(0)}ms`);\n        p95LatencyMs = summary.avgP90LatencyMs;\n      } else {\n        latencyScore = SCORING_WEIGHTS.latency * 0.5;\n        reasons.push('latency:unknown');\n      }\n\n      // Calculate volume score (0-10)\n      const volumeThreshold = 1000;\n      const volumeRatio = Math.min(summary.totalInvocations / volumeThreshold, 1);\n      const volumeScore = volumeRatio * SCORING_WEIGHTS.volume;\n      totalInvocations = summary.totalInvocations;\n      reasons.push(`x402scan:${summary.totalInvocations}/${summary.totalInvocations >= 1000 ? 'high' : summary.totalInvocations >= 100 ? 'medium' : 'low'}-confidence`);\n\n      // Calculate freshness score (0-10)\n      const fetchedAt = new Date(summary.fetchedAt);\n      hoursOld = (Date.now() - fetchedAt.getTime()) / (1000 * 60 * 60);\n      const freshnessRatio = Math.max(0, 1 - hoursOld / 24);\n      const freshnessScore = freshnessRatio * SCORING_WEIGHTS.freshness;\n\n      x402scanScore = successRateScore + latencyScore + volumeScore + freshnessScore;\n      avgLatencyMs = summary.avgP50LatencyMs;\n    } else {\n      reasons.push('x402scan:no-data');\n    }\n\n    // ==========================================================================\n    // PART 2: Scattering activity metrics\n    // ==========================================================================\n    let scatteringActivityScore = 0;\n    let scatteringVolume3d: number | undefined;\n    let scatteringTxCount3d: number | undefined;\n    let scatteringUniqueBuyers3d: number | undefined;\n    let scatteringLowActivity = false;\n    let hasScatteringData = false;\n\n    try {\n      const scattering = await getScatteringMetricsForFacilitator(params.facilitatorId);\n      \n      if (scattering) {\n        hasScatteringData = true;\n        scatteringVolume3d = scattering.volumeUsd3d;\n        scatteringTxCount3d = scattering.txCount3d;\n        scatteringUniqueBuyers3d = scattering.uniqueBuyers3d;\n\n        // Check for low activity guardrail\n        const isLowActivity = \n          scattering.txCount3d < SCATTERING_MIN_TX_COUNT_3D &&\n          scattering.volumeUsd3d < SCATTERING_MIN_VOLUME_USD_3D;\n\n        if (isLowActivity) {\n          scatteringLowActivity = true;\n          scatteringActivityScore = 0.1; // Minimal score for low activity\n          reasons.push(`scattering-low-activity:${scattering.txCount3d}tx/$${scattering.volumeUsd3d.toFixed(0)}`);\n        } else {\n          // Compute normalized activity score (0-1)\n          scatteringActivityScore = computeActivityScore(scattering);\n          reasons.push(`scattering-activity:${scatteringActivityScore.toFixed(2)}`);\n        }\n      } else {\n        reasons.push('scattering:no-data');\n      }\n    } catch (error) {\n      logger.debug({\n        error: error instanceof Error ? error.message : 'Unknown',\n        facilitatorId: params.facilitatorId,\n        msg: 'Failed to fetch Scattering metrics for scoring',\n      });\n      reasons.push('scattering:error');\n    }\n\n    // ==========================================================================\n    // PART 3: Blend x402scan and Scattering scores\n    // ==========================================================================\n    let finalScore: number;\n    \n    if (hasX402scanData && hasScatteringData) {\n      // Both sources available - blend according to weights\n      // x402scan score is 0-100, Scattering score is 0-1 (convert to 0-100)\n      finalScore = (X402SCAN_SCORE_WEIGHT * x402scanScore) + \n                   (SCATTERING_SCORE_WEIGHT * scatteringActivityScore * 100);\n    } else if (hasX402scanData) {\n      // Only x402scan - use full weight\n      finalScore = x402scanScore;\n    } else if (hasScatteringData) {\n      // Only Scattering - convert to 0-100 scale\n      finalScore = scatteringActivityScore * 100;\n    } else {\n      // No data - neutral score\n      finalScore = 50;\n    }\n\n    // ==========================================================================\n    // PART 4: Determine confidence level\n    // ==========================================================================\n    let confidence: 'high' | 'medium' | 'low' | 'none' = 'none';\n    \n    if (hasX402scanData) {\n      if (totalInvocations >= 1000 && hoursOld < 6) {\n        confidence = 'high';\n      } else if (totalInvocations >= 100 && hoursOld < 24) {\n        confidence = 'medium';\n      } else {\n        confidence = 'low';\n      }\n    } else if (hasScatteringData && !scatteringLowActivity) {\n      // Scattering-only data provides some confidence\n      confidence = scatteringActivityScore > 0.5 ? 'medium' : 'low';\n    }\n\n    return {\n      facilitatorId: params.facilitatorId,\n      score: Math.round(finalScore),\n      successRate,\n      avgLatencyMs,\n      p95LatencyMs,\n      totalInvocations,\n      dataFreshness: hoursOld,\n      confidence,\n      reasons,\n      // Scattering fields\n      scatteringActivityScore: hasScatteringData ? scatteringActivityScore : undefined,\n      scatteringVolume3d,\n      scatteringTxCount3d,\n      scatteringUniqueBuyers3d,\n      scatteringLowActivity: scatteringLowActivity || undefined,\n    };\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId: params.facilitatorId,\n      msg: 'Failed to get facilitator score',\n    });\n    return null;\n  }\n}\n\n/**\n * Rank multiple facilitators by their x402scan-derived score\n * Enforces freshness and confidence thresholds - only returns trusted scores\n * \n * @param facilitatorIds - List of facilitator IDs to rank\n * @param timeframe - Timeframe for metrics (default: '1d')\n * @param config - Trust configuration (default: DEFAULT_TRUST_CONFIG)\n */\nexport async function rankFacilitators(\n  facilitatorIds: string[],\n  timeframe: FacilitatorPathMetricsTimeframe = '1d',\n  config: MetricsTrustConfig = DEFAULT_TRUST_CONFIG\n): Promise<FacilitatorRanking> {\n  const scores: FacilitatorScore[] = [];\n  const untrusted: Array<{ id: string; reason: string }> = [];\n\n  for (const id of facilitatorIds) {\n    const score = await getFacilitatorScore({ facilitatorId: id, timeframe });\n    \n    if (!score) {\n      untrusted.push({ id, reason: 'no-data' });\n      continue;\n    }\n\n    // Check if metrics meet trust thresholds\n    const trustCheck = shouldTrustMetrics(\n      score.dataFreshness,\n      score.totalInvocations,\n      config\n    );\n\n    if (!trustCheck.trust) {\n      untrusted.push({ id, reason: trustCheck.reason });\n      // Still include in rankings but with penalized score\n      scores.push({\n        ...score,\n        score: score.score * config.lowConfidencePenalty, // Heavy penalty\n        confidence: 'low',\n        reasons: [...score.reasons, `untrusted:${trustCheck.reason}`],\n      });\n      continue;\n    }\n\n    // Apply confidence-based adjustments\n    if (trustCheck.confidence === 'medium') {\n      // Slight penalty for medium confidence\n      scores.push({\n        ...score,\n        score: score.score * 0.9, // 10% penalty\n        confidence: 'medium',\n        reasons: [...score.reasons, trustCheck.reason],\n      });\n    } else {\n      // High confidence - use score as-is\n      scores.push({\n        ...score,\n        reasons: [...score.reasons, trustCheck.reason],\n      });\n    }\n  }\n\n  // Log untrusted facilitators for visibility\n  if (untrusted.length > 0) {\n    logger.debug({\n      untrusted,\n      trusted: scores.filter((s) => s.confidence !== 'low').map((s) => s.facilitatorId),\n      msg: 'Facilitator metrics trust check results',\n    });\n  }\n\n  // Sort by score descending\n  scores.sort((a, b) => b.score - a.score);\n\n  return {\n    rankings: scores,\n    timestamp: new Date().toISOString(),\n    timeframe,\n  };\n}\n\n/**\n * Get recommended facilitator for a given context\n * Uses x402scan data to inform the recommendation\n * Falls back to default candidate when metrics are stale/missing\n */\nexport async function getRecommendedFacilitator(\n  candidateIds: string[],\n  options?: {\n    network?: string;\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    prioritize?: 'latency' | 'reliability' | 'balanced';\n    trustConfig?: MetricsTrustConfig;\n  }\n): Promise<{\n  recommended: string | null;\n  ranking: FacilitatorRanking;\n  reason: string;\n  usedFallback: boolean;\n}> {\n  const timeframe = options?.timeframe ?? '1d';\n  const trustConfig = options?.trustConfig ?? DEFAULT_TRUST_CONFIG;\n  const ranking = await rankFacilitators(candidateIds, timeframe, trustConfig);\n\n  // Check if we have any trusted rankings\n  const trustedRankings = ranking.rankings.filter((r) => r.confidence !== 'low');\n\n  if (trustedRankings.length === 0) {\n    // No trusted data - fall back to first candidate\n    logger.warn({\n      candidates: candidateIds,\n      rankings: ranking.rankings.map((r) => ({\n        id: r.facilitatorId,\n        confidence: r.confidence,\n        reasons: r.reasons,\n      })),\n      msg: 'No trusted x402scan data available, using fallback',\n    });\n\n    return {\n      recommended: candidateIds[0] ?? null,\n      ranking,\n      reason: 'No trusted x402scan data (stale or insufficient), using default order',\n      usedFallback: true,\n    };\n  }\n\n  const prioritize = options?.prioritize ?? 'balanced';\n  let recommended: FacilitatorScore;\n\n  switch (prioritize) {\n    case 'latency':\n      // Sort by latency (ascending), filter out unknown latency, only trusted\n      const byLatency = trustedRankings\n        .filter((r) => r.p95LatencyMs !== undefined)\n        .sort((a, b) => (a.p95LatencyMs ?? Infinity) - (b.p95LatencyMs ?? Infinity));\n      recommended = byLatency[0] ?? trustedRankings[0];\n      break;\n\n    case 'reliability':\n      // Sort by success rate (descending), only trusted\n      const byReliability = [...trustedRankings].sort((a, b) => b.successRate - a.successRate);\n      recommended = byReliability[0];\n      break;\n\n    case 'balanced':\n    default:\n      // Use overall score from trusted rankings\n      recommended = trustedRankings[0];\n      break;\n  }\n\n  return {\n    recommended: recommended.facilitatorId,\n    ranking,\n    reason: `Selected ${recommended.facilitatorId} with score ${recommended.score} ` +\n      `(${recommended.confidence} confidence, ${recommended.reasons.slice(0, 3).join(', ')})`,\n    usedFallback: false,\n  };\n}\n\n/**\n * Check if a facilitator should be avoided based on recent performance\n */\nexport async function shouldAvoidFacilitator(\n  facilitatorId: string,\n  threshold: {\n    maxErrorRate?: number;    // Default: 0.2 (20%)\n    minInvocations?: number;  // Default: 10\n  } = {}\n): Promise<{\n  avoid: boolean;\n  reason?: string;\n}> {\n  const maxErrorRate = threshold.maxErrorRate ?? 0.2;\n  const minInvocations = threshold.minInvocations ?? 10;\n\n  try {\n    const score = await getFacilitatorScore({ facilitatorId, timeframe: '1d' });\n\n    if (!score) {\n      return { avoid: false, reason: 'No data available' };\n    }\n\n    // Not enough data to make a decision\n    if (score.totalInvocations < minInvocations) {\n      return { avoid: false, reason: `Insufficient data (${score.totalInvocations} invocations)` };\n    }\n\n    // Check error rate\n    const errorRate = 1 - score.successRate;\n    if (errorRate > maxErrorRate) {\n      return {\n        avoid: true,\n        reason: `Error rate ${(errorRate * 100).toFixed(1)}% exceeds threshold ${(maxErrorRate * 100).toFixed(1)}%`,\n      };\n    }\n\n    return { avoid: false };\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId,\n      msg: 'Failed to check if facilitator should be avoided',\n    });\n    return { avoid: false, reason: 'Error checking metrics' };\n  }\n}\n\n/**\n * Get all available facilitator summaries\n * Useful for dashboard/monitoring\n */\nexport async function getAllFacilitatorSummaries(): Promise<Record<string, FacilitatorSummary>> {\n  return loadAllSummaries();\n}\n\n// =============================================================================\n// SMF EXPLAINER\n// =============================================================================\n\n/**\n * Structured explanation for SMF routing decisions\n */\nexport interface FacilitatorExplanation {\n  facilitatorId: string;\n  selected: boolean;\n  score: number;\n  confidence: 'high' | 'medium' | 'low' | 'none';\n  shortReason: string;      // One-line summary\n  detailedReasons: string[];\n  metrics: {\n    successRate?: number;\n    errorRate?: number;\n    p95LatencyMs?: number;\n    invocations?: number;\n    dataAgeHours?: number;\n  };\n}\n\n/**\n * Get a structured explanation for why a facilitator was/wasn't selected\n * Used by SMF to provide transparent routing decisions\n * \n * @example\n * const explanation = await getFacilitatorExplainer('cdp', { timeframe: '1d' });\n * console.log(explanation.shortReason);\n * // \"cdp: 98.5% success, 185ms p95, high confidence (12K invocations)\"\n */\nexport async function getFacilitatorExplainer(\n  facilitatorId: string,\n  options?: {\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    wasSelected?: boolean;\n  }\n): Promise<FacilitatorExplanation> {\n  const timeframe = options?.timeframe ?? '1d';\n  const wasSelected = options?.wasSelected ?? false;\n\n  const score = await getFacilitatorScore({ facilitatorId, timeframe });\n\n  if (!score) {\n    return {\n      facilitatorId,\n      selected: wasSelected,\n      score: 50,\n      confidence: 'low',\n      shortReason: `${facilitatorId}: no x402scan data available`,\n      detailedReasons: ['No observability data from x402scan'],\n      metrics: {},\n    };\n  }\n\n  // Build short reason string\n  const successPct = (score.successRate * 100).toFixed(1);\n  const latencyStr = score.p95LatencyMs ? `${score.p95LatencyMs.toFixed(0)}ms p95` : 'latency unknown';\n  const volumeStr = score.totalInvocations >= 1000 \n    ? `${(score.totalInvocations / 1000).toFixed(1)}K invocations`\n    : `${score.totalInvocations} invocations`;\n\n  const shortReason = `${facilitatorId}: ${successPct}% success, ${latencyStr}, ${score.confidence} confidence (${volumeStr})`;\n\n  // Build detailed reasons\n  const detailedReasons: string[] = [];\n  \n  if (score.successRate >= 0.99) {\n    detailedReasons.push(`Excellent success rate: ${successPct}%`);\n  } else if (score.successRate >= 0.95) {\n    detailedReasons.push(`Good success rate: ${successPct}%`);\n  } else if (score.successRate >= 0.90) {\n    detailedReasons.push(`Acceptable success rate: ${successPct}%`);\n  } else {\n    detailedReasons.push(`⚠️ Low success rate: ${successPct}%`);\n  }\n\n  if (score.p95LatencyMs !== undefined) {\n    if (score.p95LatencyMs < 200) {\n      detailedReasons.push(`Fast response times: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    } else if (score.p95LatencyMs < 500) {\n      detailedReasons.push(`Moderate latency: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    } else {\n      detailedReasons.push(`⚠️ High latency: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    }\n  }\n\n  if (score.confidence === 'high') {\n    detailedReasons.push(`High confidence: ${volumeStr}, data ${score.dataFreshness.toFixed(1)}h old`);\n  } else if (score.confidence === 'medium') {\n    detailedReasons.push(`Medium confidence: ${volumeStr}`);\n  } else {\n    detailedReasons.push(`Low confidence: limited data (${volumeStr})`);\n  }\n\n  if (score.dataFreshness > 12) {\n    detailedReasons.push(`⚠️ Data is ${score.dataFreshness.toFixed(1)} hours old`);\n  }\n\n  return {\n    facilitatorId,\n    selected: wasSelected,\n    score: score.score,\n    confidence: score.confidence,\n    shortReason,\n    detailedReasons,\n    metrics: {\n      successRate: score.successRate,\n      errorRate: 1 - score.successRate,\n      p95LatencyMs: score.p95LatencyMs,\n      invocations: score.totalInvocations,\n      dataAgeHours: score.dataFreshness,\n    },\n  };\n}\n\n/**\n * Get explanations for multiple facilitators (for comparison)\n */\nexport async function getMultipleFacilitatorExplanations(\n  facilitatorIds: string[],\n  options?: {\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    selectedId?: string;\n  }\n): Promise<FacilitatorExplanation[]> {\n  const explanations: FacilitatorExplanation[] = [];\n\n  for (const id of facilitatorIds) {\n    const explanation = await getFacilitatorExplainer(id, {\n      timeframe: options?.timeframe,\n      wasSelected: id === options?.selectedId,\n    });\n    explanations.push(explanation);\n  }\n\n  // Sort by score descending\n  return explanations.sort((a, b) => b.score - a.score);\n}\n\n","// =============================================================================\r\n// FACILITATOR REGISTRY\r\n// =============================================================================\r\n// Central registry of facilitator configurations\r\n// This is the source of truth for facilitator metadata\r\n\r\nexport interface FacilitatorRegistryEntry {\r\n  id: string;\r\n  name: string;\r\n  baseUrl: string;\r\n  networks: string[]; // CAIP-2 network IDs\r\n  tokens: string[]; // Token symbols or addresses\r\n  feeBps: number;\r\n  priority: number;\r\n}\r\n\r\n/**\r\n * Facilitator ID type - all known facilitators\r\n * Use this union type for type-safe facilitator references\r\n */\r\nexport type FacilitatorId = 'cdp' | 'payai' | 'x402rs' | 'dexter' | 'cronos' | 'dummy';\r\n\r\n/**\r\n * Facilitator registry\r\n * CDP is the primary facilitator for x402 payments\r\n */\r\nexport const FACILITATORS: Record<string, FacilitatorRegistryEntry> = {\r\n  cdp: {\r\n    id: 'cdp',\r\n    name: 'CDP x402 Facilitator',\r\n    baseUrl: process.env.CDP_FACILITATOR_URL || 'https://api.cdp.coinbase.com/platform/v2/x402',\r\n    networks: ['eip155:8453', 'solana:mainnet', 'eip155:84532', 'solana:devnet'], // Base mainnet, Solana mainnet, Base sepolia, Solana devnet\r\n    tokens: ['USDC'],\r\n    feeBps: 0,\r\n    priority: 100, // High priority (primary facilitator)\r\n  },\r\n  payai: {\r\n    id: 'payai',\r\n    name: 'PayAI Facilitator',\r\n    baseUrl: process.env.PAYAI_FACILITATOR_URL || 'https://facilitator.payai.network',\r\n    networks: ['eip155:1', 'eip155:8453', 'eip155:56', 'eip155:137', 'solana:mainnet'], // Multi-chain support\r\n    tokens: ['USDC'],\r\n    feeBps: 10, // Example: 0.1% fee (to be confirmed with PayAI)\r\n    priority: 200, // Lower priority than CDP\r\n  },\r\n  /**\r\n   * X402rs Facilitator\r\n   * \r\n   * Rust-based x402 facilitator operated by the x402 community.\r\n   * Supports Base (mainnet & testnet) and XDC networks.\r\n   * \r\n   * Source: https://x402.org/networks\r\n   */\r\n  x402rs: {\r\n    id: 'x402rs',\r\n    name: 'X402rs Facilitator',\r\n    baseUrl: process.env.X402RS_FACILITATOR_URL || 'https://facilitator.x402.rs',\r\n    networks: [\r\n      'eip155:84532',  // Base Sepolia (testnet)\r\n      'eip155:8453',   // Base mainnet\r\n      'xdc:50',        // XDC mainnet\r\n    ],\r\n    tokens: ['USDC'],\r\n    feeBps: 0, // Community facilitator - no fees (to be confirmed)\r\n    priority: 150, // Between CDP (100) and PayAI (200)\r\n  },\r\n  /**\r\n   * Dexter Facilitator\r\n   * \r\n   * Solana-native x402 facilitator operated by Dexter.\r\n   * Public facilitator URL: https://facilitator.dexter.cash\r\n   * Standard x402 endpoints: /verify and /settle\r\n   * \r\n   * Supports Solana mainnet and devnet networks.\r\n   */\r\n  dexter: {\r\n    id: 'dexter',\r\n    name: 'Dexter Facilitator',\r\n    baseUrl: process.env.DEXTER_FACILITATOR_URL || 'https://facilitator.dexter.cash',\r\n    networks: [\r\n      'solana:101',    // Solana mainnet (CAIP-2)\r\n      'solana:mainnet', // Legacy alias\r\n      'solana:102',    // Solana devnet (CAIP-2)\r\n      'solana:devnet', // Legacy alias\r\n    ],\r\n    tokens: ['USDC'],\r\n    feeBps: 0, // To be confirmed with Dexter\r\n    priority: 120, // Between CDP (100) and X402rs (150) - strong Solana support\r\n  },\r\n  /**\r\n   * Cronos x402 Facilitator\r\n   * \r\n   * Official Cronos Labs x402 facilitator for Cronos network.\r\n   * Base URL: https://facilitator.cronoslabs.org\r\n   * Documentation: https://docs.cronos.org/cronos-x402-facilitator\r\n   * \r\n   * Endpoints:\r\n   * - Health: GET /healthcheck\r\n   * - Verify: POST /v2/x402/verify\r\n   * - Settle: POST /v2/x402/settle\r\n   * - Discovery: GET /v2/x402/supported\r\n   * \r\n   * Networks: \"cronos\" (mainnet, chain ID 25), \"cronos-testnet\" (testnet, chain ID 338)\r\n   * Rate limits: 5 requests per minute per IP for settle/verify\r\n   */\r\n  cronos: {\r\n    id: 'cronos',\r\n    name: 'Cronos x402 Facilitator',\r\n    baseUrl: process.env.CRONOS_FACILITATOR_URL || 'https://facilitator.cronoslabs.org',\r\n    networks: [\r\n      'eip155:25',     // Cronos mainnet (CAIP-2)\r\n      'cronos',        // Legacy alias\r\n      'eip155:338',    // Cronos testnet (CAIP-2)\r\n      'cronos-testnet', // Legacy alias\r\n    ],\r\n    tokens: ['USDC', 'USDX'], // Cronos stablecoins (actual assets from /v2/x402/supported)\r\n    feeBps: 0, // Cronos facilitator fee policy\r\n    priority: 130, // Similar priority tier as community facilitators\r\n  },\r\n} as const;\r\n\r\n/**\r\n * Get facilitator by ID\r\n */\r\nexport function getFacilitator(id: string): FacilitatorRegistryEntry | undefined {\r\n  return FACILITATORS[id];\r\n}\r\n\r\n/**\r\n * Get all facilitators\r\n */\r\nexport function getAllFacilitators(): FacilitatorRegistryEntry[] {\r\n  return Object.values(FACILITATORS);\r\n}\r\n\r\n/**\r\n * Get facilitators for a specific network\r\n */\r\nexport function getFacilitatorsForNetwork(network: string): FacilitatorRegistryEntry[] {\r\n  return Object.values(FACILITATORS).filter((f) => f.networks.includes(network));\r\n}\r\n\r\n"],"names":[],"mappings":"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"}