{"version":3,"sources":["../../../src/lib/ops-alerting.ts","../../../src/lib/cron-job-wrapper.ts","../../../src/lib/rate-limit-unified.ts","../../../src/lib/rate-limit-store.ts","../../../src/db/cron-jobs.ts"],"sourcesContent":["// =============================================================================\r\n// OPERATIONS ALERTING\r\n// =============================================================================\r\n// Unified alerting for cron jobs, system health, and operational events.\r\n// Supports Slack and PagerDuty with configurable thresholds.\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'OpsAlerting' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport type AlertSeverity = 'critical' | 'warning' | 'info';\r\nexport type AlertChannel = 'slack' | 'pagerduty' | 'all';\r\n\r\nexport interface OpsAlert {\r\n  /** Unique identifier for deduplication */\r\n  dedupKey: string;\r\n  /** Alert title/summary */\r\n  title: string;\r\n  /** Detailed description */\r\n  description: string;\r\n  /** Severity level */\r\n  severity: AlertSeverity;\r\n  /** Source component/system */\r\n  source: string;\r\n  /** Additional context */\r\n  context?: Record<string, any>;\r\n  /** Which channels to send to */\r\n  channel?: AlertChannel;\r\n  /** Link to runbook or dashboard */\r\n  runbookUrl?: string;\r\n}\r\n\r\nexport interface CronJobFailureAlert {\r\n  jobId: string;\r\n  jobName?: string;\r\n  consecutiveFailures: number;\r\n  lastError?: string;\r\n  lastFailureAt?: Date;\r\n  runId?: string;\r\n}\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\nconst CONFIG = {\r\n  // Alert thresholds\r\n  warningThreshold: 3, // 3+ consecutive failures = warning\r\n  criticalThreshold: 5, // 5+ consecutive failures = critical\r\n  \r\n  // Cooldown to prevent alert spam (5 minutes per job)\r\n  alertCooldownMs: 5 * 60 * 1000,\r\n  \r\n  // Environment\r\n  environment: process.env.NODE_ENV || 'development',\r\n  appName: 'NexFlow',\r\n};\r\n\r\n// In-memory cooldown tracking\r\nconst alertCooldowns = new Map<string, number>();\r\n\r\n// =============================================================================\r\n// SLACK INTEGRATION\r\n// =============================================================================\r\n\r\ninterface SlackBlock {\r\n  type: 'section' | 'header' | 'divider' | 'context' | 'actions';\r\n  text?: {\r\n    type: 'plain_text' | 'mrkdwn';\r\n    text: string;\r\n    emoji?: boolean;\r\n  };\r\n  fields?: Array<{\r\n    type: 'plain_text' | 'mrkdwn';\r\n    text: string;\r\n  }>;\r\n  elements?: Array<{\r\n    type: 'button';\r\n    text: { type: 'plain_text'; text: string; emoji?: boolean };\r\n    url?: string;\r\n    style?: 'primary' | 'danger';\r\n  }>;\r\n}\r\n\r\nasync function sendSlackAlert(alert: OpsAlert): Promise<boolean> {\r\n  const webhookUrl = process.env.SLACK_WEBHOOK_URL || process.env.SLACK_OPS_WEBHOOK_URL;\r\n  \r\n  if (!webhookUrl) {\r\n    logger.debug({ alertTitle: alert.title }, 'Slack webhook not configured, skipping');\r\n    return false;\r\n  }\r\n  \r\n  const emoji = getSeverityEmoji(alert.severity);\r\n  const color = getSeverityColor(alert.severity);\r\n  \r\n  const blocks: SlackBlock[] = [\r\n    {\r\n      type: 'header',\r\n      text: {\r\n        type: 'plain_text',\r\n        text: `${emoji} ${alert.title}`,\r\n        emoji: true,\r\n      },\r\n    },\r\n    {\r\n      type: 'section',\r\n      text: {\r\n        type: 'mrkdwn',\r\n        text: alert.description,\r\n      },\r\n    },\r\n    {\r\n      type: 'section',\r\n      fields: [\r\n        { type: 'mrkdwn', text: `*Severity:* ${alert.severity.toUpperCase()}` },\r\n        { type: 'mrkdwn', text: `*Source:* ${alert.source}` },\r\n        { type: 'mrkdwn', text: `*Environment:* ${CONFIG.environment}` },\r\n        { type: 'mrkdwn', text: `*Time:* ${new Date().toISOString()}` },\r\n      ],\r\n    },\r\n  ];\r\n  \r\n  // Add context fields if provided\r\n  if (alert.context && Object.keys(alert.context).length > 0) {\r\n    const contextFields = Object.entries(alert.context)\r\n      .slice(0, 6) // Limit to 6 fields\r\n      .map(([key, value]) => ({\r\n        type: 'mrkdwn' as const,\r\n        text: `*${key}:* ${formatValue(value)}`,\r\n      }));\r\n    \r\n    blocks.push({\r\n      type: 'section',\r\n      fields: contextFields,\r\n    });\r\n  }\r\n  \r\n  // Add runbook link if provided\r\n  if (alert.runbookUrl) {\r\n    blocks.push({\r\n      type: 'actions',\r\n      elements: [\r\n        {\r\n          type: 'button',\r\n          text: { type: 'plain_text', text: 'üìñ View Runbook', emoji: true },\r\n          url: alert.runbookUrl,\r\n          style: 'primary',\r\n        },\r\n      ],\r\n    });\r\n  }\r\n  \r\n  blocks.push({ type: 'divider' });\r\n  blocks.push({\r\n    type: 'context',\r\n    elements: [\r\n      {\r\n        type: 'mrkdwn' as any,\r\n        text: `${CONFIG.appName} Operations ‚Ä¢ Dedup Key: \\`${alert.dedupKey}\\``,\r\n      },\r\n    ],\r\n  } as any);\r\n  \r\n  try {\r\n    const response = await fetch(webhookUrl, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({\r\n        text: `[${alert.severity.toUpperCase()}] ${alert.title}`,\r\n        blocks,\r\n        attachments: [{ color }],\r\n      }),\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      const text = await response.text().catch(() => '');\r\n      logger.error({ status: response.status, body: text }, 'Failed to send Slack alert');\r\n      return false;\r\n    }\r\n    \r\n    logger.info({ dedupKey: alert.dedupKey, title: alert.title }, 'Slack alert sent');\r\n    return true;\r\n  } catch (error) {\r\n    logger.error({ error, dedupKey: alert.dedupKey }, 'Error sending Slack alert');\r\n    return false;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// PAGERDUTY INTEGRATION\r\n// =============================================================================\r\n\r\ninterface PagerDutyEvent {\r\n  routing_key: string;\r\n  event_action: 'trigger' | 'acknowledge' | 'resolve';\r\n  dedup_key: string;\r\n  payload: {\r\n    summary: string;\r\n    source: string;\r\n    severity: 'critical' | 'error' | 'warning' | 'info';\r\n    timestamp: string;\r\n    component?: string;\r\n    group?: string;\r\n    class?: string;\r\n    custom_details?: Record<string, any>;\r\n  };\r\n  links?: Array<{ href: string; text: string }>;\r\n}\r\n\r\nasync function sendPagerDutyAlert(alert: OpsAlert): Promise<boolean> {\r\n  const routingKey = process.env.PAGERDUTY_ROUTING_KEY || process.env.PAGERDUTY_INTEGRATION_KEY;\r\n  \r\n  if (!routingKey) {\r\n    logger.debug({ alertTitle: alert.title }, 'PagerDuty routing key not configured, skipping');\r\n    return false;\r\n  }\r\n  \r\n  // Only send critical/warning to PagerDuty (skip info)\r\n  if (alert.severity === 'info') {\r\n    logger.debug({ dedupKey: alert.dedupKey }, 'Skipping info alert for PagerDuty');\r\n    return false;\r\n  }\r\n  \r\n  const event: PagerDutyEvent = {\r\n    routing_key: routingKey,\r\n    event_action: 'trigger',\r\n    dedup_key: alert.dedupKey,\r\n    payload: {\r\n      summary: `[${CONFIG.appName}] ${alert.title}`,\r\n      source: alert.source,\r\n      severity: mapSeverityToPagerDuty(alert.severity),\r\n      timestamp: new Date().toISOString(),\r\n      component: alert.source,\r\n      group: CONFIG.appName,\r\n      class: 'cron-job-failure',\r\n      custom_details: {\r\n        description: alert.description,\r\n        environment: CONFIG.environment,\r\n        ...alert.context,\r\n      },\r\n    },\r\n    links: alert.runbookUrl\r\n      ? [{ href: alert.runbookUrl, text: 'Runbook' }]\r\n      : undefined,\r\n  };\r\n  \r\n  try {\r\n    const response = await fetch('https://events.pagerduty.com/v2/enqueue', {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify(event),\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      const text = await response.text().catch(() => '');\r\n      logger.error({ status: response.status, body: text }, 'Failed to send PagerDuty alert');\r\n      return false;\r\n    }\r\n    \r\n    const result = await response.json().catch(() => ({}));\r\n    logger.info({\r\n      dedupKey: alert.dedupKey,\r\n      title: alert.title,\r\n      pdDedupKey: result.dedup_key,\r\n    }, 'PagerDuty alert sent');\r\n    return true;\r\n  } catch (error) {\r\n    logger.error({ error, dedupKey: alert.dedupKey }, 'Error sending PagerDuty alert');\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Resolve a PagerDuty incident\r\n */\r\nexport async function resolvePagerDutyAlert(dedupKey: string): Promise<boolean> {\r\n  const routingKey = process.env.PAGERDUTY_ROUTING_KEY || process.env.PAGERDUTY_INTEGRATION_KEY;\r\n  \r\n  if (!routingKey) {\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    const response = await fetch('https://events.pagerduty.com/v2/enqueue', {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({\r\n        routing_key: routingKey,\r\n        event_action: 'resolve',\r\n        dedup_key: dedupKey,\r\n      }),\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      logger.error({ status: response.status }, 'Failed to resolve PagerDuty alert');\r\n      return false;\r\n    }\r\n    \r\n    logger.info({ dedupKey }, 'PagerDuty alert resolved');\r\n    return true;\r\n  } catch (error) {\r\n    logger.error({ error, dedupKey }, 'Error resolving PagerDuty alert');\r\n    return false;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// MAIN ALERTING FUNCTION\r\n// =============================================================================\r\n\r\n/**\r\n * Send an operational alert to configured channels\r\n */\r\nexport async function sendOpsAlert(alert: OpsAlert): Promise<{ slack: boolean; pagerduty: boolean }> {\r\n  // Check cooldown\r\n  const lastAlertTime = alertCooldowns.get(alert.dedupKey);\r\n  if (lastAlertTime && Date.now() - lastAlertTime < CONFIG.alertCooldownMs) {\r\n    logger.debug({ dedupKey: alert.dedupKey }, 'Alert in cooldown, skipping');\r\n    return { slack: false, pagerduty: false };\r\n  }\r\n  \r\n  // Update cooldown\r\n  alertCooldowns.set(alert.dedupKey, Date.now());\r\n  \r\n  // Clean old cooldowns (prevent memory leak)\r\n  if (alertCooldowns.size > 1000) {\r\n    const cutoff = Date.now() - CONFIG.alertCooldownMs * 2;\r\n    const entries = Array.from(alertCooldowns.entries());\r\n    for (const [key, time] of entries) {\r\n      if (time < cutoff) {\r\n        alertCooldowns.delete(key);\r\n      }\r\n    }\r\n  }\r\n  \r\n  const channel = alert.channel || 'all';\r\n  const results = { slack: false, pagerduty: false };\r\n  \r\n  // Send to Slack\r\n  if (channel === 'slack' || channel === 'all') {\r\n    results.slack = await sendSlackAlert(alert);\r\n  }\r\n  \r\n  // Send to PagerDuty\r\n  if (channel === 'pagerduty' || channel === 'all') {\r\n    results.pagerduty = await sendPagerDutyAlert(alert);\r\n  }\r\n  \r\n  return results;\r\n}\r\n\r\n// =============================================================================\r\n// CRON JOB FAILURE ALERTING\r\n// =============================================================================\r\n\r\n/**\r\n * Alert on cron job consecutive failures\r\n */\r\nexport async function alertCronJobFailure(failure: CronJobFailureAlert): Promise<void> {\r\n  const { jobId, consecutiveFailures, lastError, lastFailureAt, runId } = failure;\r\n  \r\n  // Determine severity based on consecutive failures\r\n  let severity: AlertSeverity;\r\n  if (consecutiveFailures >= CONFIG.criticalThreshold) {\r\n    severity = 'critical';\r\n  } else if (consecutiveFailures >= CONFIG.warningThreshold) {\r\n    severity = 'warning';\r\n  } else {\r\n    // Below threshold, don't alert\r\n    logger.debug({\r\n      jobId,\r\n      consecutiveFailures,\r\n      threshold: CONFIG.warningThreshold,\r\n    }, 'Below alert threshold');\r\n    return;\r\n  }\r\n  \r\n  const jobName = failure.jobName || jobId;\r\n  \r\n  await sendOpsAlert({\r\n    dedupKey: `cron-failure:${jobId}`,\r\n    title: `Cron Job Failing: ${jobName}`,\r\n    description: consecutiveFailures >= CONFIG.criticalThreshold\r\n      ? `üö® *CRITICAL*: Job \\`${jobId}\\` has failed ${consecutiveFailures} consecutive times and requires immediate attention.`\r\n      : `‚ö†Ô∏è Job \\`${jobId}\\` has failed ${consecutiveFailures} consecutive times.`,\r\n    severity,\r\n    source: `cron-job:${jobId}`,\r\n    context: {\r\n      'Job ID': jobId,\r\n      'Consecutive Failures': consecutiveFailures,\r\n      'Last Error': lastError ? truncate(lastError, 200) : 'N/A',\r\n      'Last Failure': lastFailureAt ? lastFailureAt.toISOString() : 'N/A',\r\n      'Run ID': runId || 'N/A',\r\n    },\r\n    runbookUrl: process.env.CRON_RUNBOOK_URL,\r\n  });\r\n}\r\n\r\n/**\r\n * Alert that a cron job has recovered\r\n */\r\nexport async function alertCronJobRecovered(jobId: string, jobName?: string): Promise<void> {\r\n  const name = jobName || jobId;\r\n  \r\n  // Send Slack notification (info level)\r\n  await sendOpsAlert({\r\n    dedupKey: `cron-recovery:${jobId}:${Date.now()}`, // Unique key for recovery\r\n    title: `Cron Job Recovered: ${name}`,\r\n    description: `‚úÖ Job \\`${jobId}\\` has recovered and is running successfully.`,\r\n    severity: 'info',\r\n    source: `cron-job:${jobId}`,\r\n    channel: 'slack', // Only notify Slack for recovery\r\n  });\r\n  \r\n  // Resolve any open PagerDuty incident\r\n  await resolvePagerDutyAlert(`cron-failure:${jobId}`);\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\nfunction getSeverityEmoji(severity: AlertSeverity): string {\r\n  switch (severity) {\r\n    case 'critical':\r\n      return 'üö®';\r\n    case 'warning':\r\n      return '‚ö†Ô∏è';\r\n    case 'info':\r\n      return '‚ÑπÔ∏è';\r\n  }\r\n}\r\n\r\nfunction getSeverityColor(severity: AlertSeverity): string {\r\n  switch (severity) {\r\n    case 'critical':\r\n      return '#dc3545'; // Red\r\n    case 'warning':\r\n      return '#ffc107'; // Yellow/Amber\r\n    case 'info':\r\n      return '#17a2b8'; // Blue\r\n  }\r\n}\r\n\r\nfunction mapSeverityToPagerDuty(severity: AlertSeverity): PagerDutyEvent['payload']['severity'] {\r\n  switch (severity) {\r\n    case 'critical':\r\n      return 'critical';\r\n    case 'warning':\r\n      return 'warning';\r\n    case 'info':\r\n      return 'info';\r\n  }\r\n}\r\n\r\nfunction formatValue(value: any): string {\r\n  if (value === null || value === undefined) {\r\n    return 'N/A';\r\n  }\r\n  if (typeof value === 'object') {\r\n    return JSON.stringify(value).slice(0, 100);\r\n  }\r\n  return String(value).slice(0, 100);\r\n}\r\n\r\nfunction truncate(str: string, maxLength: number): string {\r\n  if (str.length <= maxLength) return str;\r\n  return str.slice(0, maxLength - 3) + '...';\r\n}\r\n\r\n// =============================================================================\r\n// EXPORTS\r\n// =============================================================================\r\n\r\nexport {\r\n  CONFIG as OPS_ALERT_CONFIG,\r\n};\r\n\r\n","// =============================================================================\r\n// CRON JOB WRAPPER\r\n// =============================================================================\r\n// Higher-order function that wraps cron job handlers with:\r\n// - Run tracking (start, complete, fail)\r\n// - Error handling and logging\r\n// - Timeout management\r\n// - Consecutive failure alerting\r\n// - Rate limiting (prevent concurrent runs)\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { createLogger } from './logger';\r\nimport {\r\n  createJobRun,\r\n  completeJobRun,\r\n  getJobConfig,\r\n  getFailingJobs,\r\n  type TriggerSource,\r\n} from '@/db/cron-jobs';\r\nimport { rateLimitCronJob } from './rate-limit-unified';\r\nimport { alertCronJobFailure, alertCronJobRecovered } from './ops-alerting';\r\n\r\nconst logger = createLogger({ component: 'CronJobWrapper' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface CronJobContext {\r\n  runId: string;\r\n  jobId: string;\r\n  requestId: string;\r\n  attemptNumber: number;\r\n  triggerSource: TriggerSource;\r\n  startTime: number;\r\n}\r\n\r\nexport type CronJobHandler = (\r\n  request: NextRequest,\r\n  context: CronJobContext\r\n) => Promise<{ ok: boolean; [key: string]: any }>;\r\n\r\nexport interface CronJobOptions {\r\n  /** Job identifier (must match cron_job_config.job_id) */\r\n  jobId: string;\r\n  \r\n  /** Timeout in milliseconds (overrides config) */\r\n  timeout?: number;\r\n  \r\n  /** Minimum interval between runs in milliseconds */\r\n  minInterval?: number;\r\n  \r\n  /** Environment variable to check for enabled status */\r\n  enabledEnvVar?: string;\r\n  \r\n  /** Whether to skip rate limiting */\r\n  skipRateLimit?: boolean;\r\n}\r\n\r\n// =============================================================================\r\n// CRON JOB WRAPPER\r\n// =============================================================================\r\n\r\n/**\r\n * Wrap a cron job handler with tracking and error handling\r\n */\r\nexport function withCronJobTracking(\r\n  handler: CronJobHandler,\r\n  options: CronJobOptions\r\n): (request: NextRequest) => Promise<NextResponse> {\r\n  return async (request: NextRequest): Promise<NextResponse> => {\r\n    const requestId = crypto.randomUUID();\r\n    const startTime = Date.now();\r\n    \r\n    // ==========================================================================\r\n    // 1. Check authorization\r\n    // ==========================================================================\r\n    const cronSecret = process.env.CRON_SECRET;\r\n    if (cronSecret) {\r\n      const authHeader = request.headers.get('authorization');\r\n      if (authHeader !== `Bearer ${cronSecret}`) {\r\n        logger.warn({ jobId: options.jobId, requestId }, 'Unauthorized cron request');\r\n        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n      }\r\n    }\r\n    \r\n    // ==========================================================================\r\n    // 2. Check if job is enabled (env var or config)\r\n    // ==========================================================================\r\n    if (options.enabledEnvVar) {\r\n      const enabled = process.env[options.enabledEnvVar];\r\n      if (enabled !== 'true') {\r\n        logger.info({ jobId: options.jobId, requestId }, `Skipping - disabled via ${options.enabledEnvVar}`);\r\n        return NextResponse.json({\r\n          ok: true,\r\n          skipped: true,\r\n          reason: `Disabled via ${options.enabledEnvVar}`,\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Check database config\r\n    try {\r\n      const config = await getJobConfig(options.jobId);\r\n      if (config && !config.enabled) {\r\n        logger.info({ jobId: options.jobId, requestId }, 'Skipping - disabled in config');\r\n        return NextResponse.json({\r\n          ok: true,\r\n          skipped: true,\r\n          reason: 'Disabled in job configuration',\r\n        });\r\n      }\r\n    } catch (error) {\r\n      // Config check failed, continue anyway\r\n      logger.warn({ jobId: options.jobId, requestId, error }, 'Failed to check job config');\r\n    }\r\n    \r\n    // ==========================================================================\r\n    // 3. Rate limiting (prevent concurrent runs)\r\n    // ==========================================================================\r\n    if (!options.skipRateLimit) {\r\n      try {\r\n        const rateLimitResult = await rateLimitCronJob(\r\n          options.jobId,\r\n          options.minInterval\r\n        );\r\n        \r\n        if (!rateLimitResult.allowed) {\r\n          logger.warn({ jobId: options.jobId, requestId }, 'Rate limited - too soon since last run');\r\n          return NextResponse.json(\r\n            {\r\n              ok: false,\r\n              error: 'Rate limited',\r\n              retryAfter: Math.ceil((rateLimitResult.resetAt - Date.now()) / 1000),\r\n            },\r\n            {\r\n              status: 429,\r\n              headers: {\r\n                'Retry-After': Math.ceil((rateLimitResult.resetAt - Date.now()) / 1000).toString(),\r\n              },\r\n            }\r\n          );\r\n        }\r\n      } catch (error) {\r\n        // Rate limit check failed, continue anyway\r\n        logger.warn({ jobId: options.jobId, requestId, error }, 'Rate limit check failed');\r\n      }\r\n    }\r\n    \r\n    // ==========================================================================\r\n    // 4. Parse trigger source and attempt number\r\n    // ==========================================================================\r\n    const triggerSource = (request.headers.get('x-trigger-source') || 'cron') as TriggerSource;\r\n    const attemptNumber = parseInt(request.headers.get('x-attempt-number') || '1', 10);\r\n    \r\n    // Parse input params from URL\r\n    const inputParams: Record<string, any> = {};\r\n    const url = new URL(request.url);\r\n    url.searchParams.forEach((value, key) => {\r\n      inputParams[key] = value;\r\n    });\r\n    \r\n    // ==========================================================================\r\n    // 5. Create job run record\r\n    // ==========================================================================\r\n    let runId: string | undefined;\r\n    try {\r\n      const run = await createJobRun({\r\n        jobId: options.jobId,\r\n        triggerSource,\r\n        attemptNumber,\r\n        inputParams: Object.keys(inputParams).length > 0 ? inputParams : undefined,\r\n        metadata: {\r\n          requestId,\r\n          userAgent: request.headers.get('user-agent'),\r\n        },\r\n      });\r\n      runId = run.id;\r\n    } catch (error) {\r\n      logger.warn({ jobId: options.jobId, requestId, error }, 'Failed to create job run record');\r\n      // Continue without tracking\r\n    }\r\n    \r\n    const context: CronJobContext = {\r\n      runId: runId || requestId,\r\n      jobId: options.jobId,\r\n      requestId,\r\n      attemptNumber,\r\n      triggerSource,\r\n      startTime,\r\n    };\r\n    \r\n    logger.info({\r\n      jobId: options.jobId,\r\n      runId,\r\n      requestId,\r\n      triggerSource,\r\n      attemptNumber,\r\n      inputParams,\r\n    }, 'Starting cron job');\r\n    \r\n    // ==========================================================================\r\n    // 6. Execute handler with timeout\r\n    // ==========================================================================\r\n    const timeout = options.timeout || 60000;\r\n    let result: { ok: boolean; [key: string]: any };\r\n    let status: 'completed' | 'failed' | 'timeout' = 'completed';\r\n    let errorMessage: string | undefined;\r\n    let errorStack: string | undefined;\r\n    \r\n    try {\r\n      result = await Promise.race([\r\n        handler(request, context),\r\n        new Promise<never>((_, reject) =>\r\n          setTimeout(() => reject(new Error('Job timeout')), timeout)\r\n        ),\r\n      ]);\r\n      \r\n      if (!result.ok) {\r\n        status = 'failed';\r\n        errorMessage = result.error || 'Job returned ok: false';\r\n      }\r\n    } catch (error) {\r\n      const isTimeout = error instanceof Error && error.message === 'Job timeout';\r\n      status = isTimeout ? 'timeout' : 'failed';\r\n      errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      errorStack = error instanceof Error ? error.stack : undefined;\r\n      \r\n      logger.error({\r\n        jobId: options.jobId,\r\n        runId,\r\n        requestId,\r\n        status,\r\n        error: errorMessage,\r\n      }, 'Cron job failed');\r\n      \r\n      result = {\r\n        ok: false,\r\n        error: errorMessage,\r\n        status,\r\n      };\r\n    }\r\n    \r\n    const durationMs = Date.now() - startTime;\r\n    \r\n    // ==========================================================================\r\n    // 7. Complete job run record\r\n    // ==========================================================================\r\n    if (runId) {\r\n      try {\r\n        await completeJobRun({\r\n          runId,\r\n          status,\r\n          outputSummary: truncateOutput(result),\r\n          errorMessage,\r\n          errorStack,\r\n        });\r\n      } catch (error) {\r\n        logger.warn({ jobId: options.jobId, runId, error }, 'Failed to complete job run record');\r\n      }\r\n    }\r\n    \r\n    // ==========================================================================\r\n    // 8. Check for consecutive failures and alert\r\n    // ==========================================================================\r\n    if (status !== 'completed') {\r\n      try {\r\n        const failingJobs = await getFailingJobs(3);\r\n        const thisJob = failingJobs.find(j => j.job_id === options.jobId);\r\n        if (thisJob) {\r\n          logger.error({\r\n            jobId: options.jobId,\r\n            consecutiveFailures: thisJob.consecutive_failures,\r\n            lastFailure: thisJob.last_failure_at,\r\n          }, `Job has ${thisJob.consecutive_failures} consecutive failures - needs attention`);\r\n          \r\n          // Send alert via Slack/PagerDuty\r\n          await alertCronJobFailure({\r\n            jobId: options.jobId,\r\n            consecutiveFailures: thisJob.consecutive_failures,\r\n            lastError: errorMessage,\r\n            lastFailureAt: thisJob.last_failure_at ? new Date(thisJob.last_failure_at) : undefined,\r\n            runId,\r\n          });\r\n        }\r\n      } catch (error) {\r\n        logger.warn({ jobId: options.jobId, error }, 'Failed to check failing jobs');\r\n      }\r\n    } else {\r\n      // Job succeeded - check if this is a recovery from previous failures\r\n      try {\r\n        // Get job status to see if it had consecutive failures before\r\n        const config = await getJobConfig(options.jobId);\r\n        if (config && config.consecutive_failures && config.consecutive_failures >= 3) {\r\n          // This is a recovery - notify\r\n          await alertCronJobRecovered(options.jobId);\r\n        }\r\n      } catch (error) {\r\n        // Non-critical, just log\r\n        logger.debug({ jobId: options.jobId, error }, 'Could not check for recovery notification');\r\n      }\r\n    }\r\n    \r\n    logger.info({\r\n      jobId: options.jobId,\r\n      runId,\r\n      requestId,\r\n      status,\r\n      durationMs,\r\n      ok: result.ok,\r\n    }, 'Cron job completed');\r\n    \r\n    // ==========================================================================\r\n    // 9. Return response\r\n    // ==========================================================================\r\n    return NextResponse.json({\r\n      ...result,\r\n      _meta: {\r\n        runId,\r\n        requestId,\r\n        durationMs,\r\n        status,\r\n      },\r\n    }, {\r\n      status: result.ok ? 200 : 500,\r\n    });\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Truncate output for storage (limit to ~10KB)\r\n */\r\nfunction truncateOutput(output: Record<string, any>): Record<string, any> {\r\n  const str = JSON.stringify(output);\r\n  if (str.length <= 10000) {\r\n    return output;\r\n  }\r\n  \r\n  // Truncate large fields\r\n  const truncated = { ...output };\r\n  for (const [key, value] of Object.entries(truncated)) {\r\n    if (typeof value === 'string' && value.length > 500) {\r\n      truncated[key] = value.substring(0, 500) + '... (truncated)';\r\n    } else if (Array.isArray(value) && value.length > 10) {\r\n      truncated[key] = [...value.slice(0, 10), `... (${value.length - 10} more)`];\r\n    }\r\n  }\r\n  \r\n  return truncated;\r\n}\r\n\r\n","// =============================================================================\r\n// UNIFIED RATE LIMITING\r\n// =============================================================================\r\n// Single implementation for both Edge and Node.js environments.\r\n// Supports distributed rate limiting via Redis with in-memory fallback.\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { getRateLimitStore, getEdgeRateLimitStore, type RateLimitStore } from './rate-limit-store';\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface RateLimitConfig {\r\n  windowMs: number;\r\n  maxRequests: number;\r\n  identifier: string;\r\n}\r\n\r\nexport interface RateLimitResult {\r\n  allowed: boolean;\r\n  remaining: number;\r\n  resetAt: number;\r\n  limit: number;\r\n}\r\n\r\nexport interface RateLimitTier {\r\n  name: string;\r\n  windowMs: number;\r\n  maxRequests: number;\r\n}\r\n\r\n// =============================================================================\r\n// DEFAULT TIERS\r\n// =============================================================================\r\n\r\nexport const RATE_LIMIT_TIERS: Record<string, RateLimitTier> = {\r\n  // Per-IP global limits\r\n  global: { name: 'global', windowMs: 60 * 60 * 1000, maxRequests: 1000 },\r\n  \r\n  // Per-endpoint limits (per IP, per minute)\r\n  endpoint: { name: 'endpoint', windowMs: 60 * 1000, maxRequests: 100 },\r\n  \r\n  // API key tiers (per hour)\r\n  free: { name: 'free', windowMs: 60 * 60 * 1000, maxRequests: 100 },\r\n  starter: { name: 'starter', windowMs: 60 * 60 * 1000, maxRequests: 1000 },\r\n  pro: { name: 'pro', windowMs: 60 * 60 * 1000, maxRequests: 5000 },\r\n  enterprise: { name: 'enterprise', windowMs: 60 * 60 * 1000, maxRequests: 50000 },\r\n  \r\n  // Cron job rate limiting (per minute)\r\n  cron: { name: 'cron', windowMs: 60 * 1000, maxRequests: 1 },\r\n};\r\n\r\n// =============================================================================\r\n// METRICS TRACKING\r\n// =============================================================================\r\n\r\ninterface RateLimitMetrics {\r\n  requests: Map<string, number>;      // tier:type -> total requests\r\n  blocked: Map<string, number>;       // tier:type -> blocked requests\r\n  latencies: Map<string, number[]>;   // tier:type -> latencies (last 100)\r\n  lastReset: number;\r\n}\r\n\r\nconst metrics: RateLimitMetrics = {\r\n  requests: new Map(),\r\n  blocked: new Map(),\r\n  latencies: new Map(),\r\n  lastReset: Date.now(),\r\n};\r\n\r\nconst MAX_LATENCY_SAMPLES = 100;\r\nconst METRICS_RESET_INTERVAL_MS = 60 * 60 * 1000; // 1 hour\r\n\r\n/**\r\n * Record a rate limit check\r\n */\r\nfunction recordMetric(\r\n  type: string,\r\n  allowed: boolean,\r\n  latencyMs: number\r\n): void {\r\n  // Reset metrics hourly\r\n  const now = Date.now();\r\n  if (now - metrics.lastReset > METRICS_RESET_INTERVAL_MS) {\r\n    metrics.requests.clear();\r\n    metrics.blocked.clear();\r\n    metrics.latencies.clear();\r\n    metrics.lastReset = now;\r\n  }\r\n  \r\n  // Record request\r\n  const key = type;\r\n  metrics.requests.set(key, (metrics.requests.get(key) || 0) + 1);\r\n  \r\n  // Record blocked\r\n  if (!allowed) {\r\n    metrics.blocked.set(key, (metrics.blocked.get(key) || 0) + 1);\r\n  }\r\n  \r\n  // Record latency (keep last N samples)\r\n  let latencies = metrics.latencies.get(key);\r\n  if (!latencies) {\r\n    latencies = [];\r\n    metrics.latencies.set(key, latencies);\r\n  }\r\n  latencies.push(latencyMs);\r\n  if (latencies.length > MAX_LATENCY_SAMPLES) {\r\n    latencies.shift();\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate percentile from sorted array\r\n */\r\nfunction percentile(sorted: number[], p: number): number {\r\n  if (sorted.length === 0) return 0;\r\n  const idx = Math.ceil(sorted.length * p) - 1;\r\n  return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];\r\n}\r\n\r\n/**\r\n * Get rate limit metrics for observability\r\n */\r\nexport function getRateLimitMetrics(): {\r\n  byType: Record<string, {\r\n    total: number;\r\n    blocked: number;\r\n    blockRate: string;\r\n    latency: { p50: number; p95: number; p99: number };\r\n  }>;\r\n  totals: {\r\n    requests: number;\r\n    blocked: number;\r\n    blockRate: string;\r\n  };\r\n  lastReset: string;\r\n} {\r\n  const byType: Record<string, any> = {};\r\n  let totalRequests = 0;\r\n  let totalBlocked = 0;\r\n  \r\n  const types = new Set([\r\n    ...metrics.requests.keys(),\r\n    ...metrics.blocked.keys(),\r\n  ]);\r\n  \r\n  for (const type of types) {\r\n    const requests = metrics.requests.get(type) || 0;\r\n    const blocked = metrics.blocked.get(type) || 0;\r\n    const latencies = metrics.latencies.get(type) || [];\r\n    \r\n    totalRequests += requests;\r\n    totalBlocked += blocked;\r\n    \r\n    // Calculate latency percentiles\r\n    const sorted = [...latencies].sort((a, b) => a - b);\r\n    \r\n    byType[type] = {\r\n      total: requests,\r\n      blocked,\r\n      blockRate: requests > 0 ? ((blocked / requests) * 100).toFixed(2) + '%' : '0%',\r\n      latency: {\r\n        p50: Math.round(percentile(sorted, 0.5)),\r\n        p95: Math.round(percentile(sorted, 0.95)),\r\n        p99: Math.round(percentile(sorted, 0.99)),\r\n      },\r\n    };\r\n  }\r\n  \r\n  return {\r\n    byType,\r\n    totals: {\r\n      requests: totalRequests,\r\n      blocked: totalBlocked,\r\n      blockRate: totalRequests > 0 \r\n        ? ((totalBlocked / totalRequests) * 100).toFixed(2) + '%' \r\n        : '0%',\r\n    },\r\n    lastReset: new Date(metrics.lastReset).toISOString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Reset rate limit metrics (for testing)\r\n */\r\nexport function resetRateLimitMetrics(): void {\r\n  metrics.requests.clear();\r\n  metrics.blocked.clear();\r\n  metrics.latencies.clear();\r\n  metrics.lastReset = Date.now();\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Extract API key from Authorization header\r\n */\r\nexport function extractApiKey(request: NextRequest): string | null {\r\n  const authHeader = request.headers.get('authorization');\r\n  if (!authHeader) return null;\r\n  \r\n  if (authHeader.startsWith('Bearer ')) {\r\n    return authHeader.substring(7).trim();\r\n  }\r\n  return authHeader.trim();\r\n}\r\n\r\n/**\r\n * Get client IP address\r\n */\r\nexport function getClientIp(request: NextRequest): string {\r\n  return (\r\n    request.ip ||\r\n    request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() ||\r\n    request.headers.get('x-real-ip') ||\r\n    'unknown'\r\n  );\r\n}\r\n\r\n/**\r\n * Hash a string for use as rate limit key (don't store full API keys)\r\n */\r\nfunction hashKey(key: string): string {\r\n  // Use first 16 chars as identifier (safe for rate limiting)\r\n  return key.substring(0, 16);\r\n}\r\n\r\n// =============================================================================\r\n// CORE RATE LIMIT CHECK\r\n// =============================================================================\r\n\r\n/**\r\n * Check rate limit against a store\r\n */\r\nasync function checkRateLimitAsync(\r\n  store: RateLimitStore,\r\n  config: RateLimitConfig,\r\n  metricType?: string\r\n): Promise<RateLimitResult> {\r\n  const start = Date.now();\r\n  const entry = await store.increment(config.identifier, config.windowMs);\r\n  \r\n  const allowed = entry.count <= config.maxRequests;\r\n  const remaining = Math.max(0, config.maxRequests - entry.count);\r\n  \r\n  // Record metrics if type provided\r\n  if (metricType) {\r\n    recordMetric(metricType, allowed, Date.now() - start);\r\n  }\r\n  \r\n  return {\r\n    allowed,\r\n    remaining,\r\n    resetAt: entry.resetAt,\r\n    limit: config.maxRequests,\r\n  };\r\n}\r\n\r\n/**\r\n * Synchronous check for Edge runtime\r\n */\r\nfunction checkRateLimitSync(\r\n  store: RateLimitStore,\r\n  config: RateLimitConfig\r\n): RateLimitResult {\r\n  const now = Date.now();\r\n  const key = config.identifier;\r\n  \r\n  // Note: This is a simplified sync version that may not be perfectly accurate\r\n  // but works for Edge runtime where we can't await\r\n  const resetAt = now + config.windowMs;\r\n  \r\n  return {\r\n    allowed: true, // Edge allows through, Node enforces\r\n    remaining: config.maxRequests,\r\n    resetAt,\r\n    limit: config.maxRequests,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API - ASYNC (Node.js)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by API key (Node.js - database lookup)\r\n */\r\nexport async function rateLimitByApiKey(\r\n  request: NextRequest,\r\n  apiKeyRateLimit?: number\r\n): Promise<RateLimitResult | null> {\r\n  const token = extractApiKey(request);\r\n  if (!token) return null;\r\n  \r\n  const store = await getRateLimitStore();\r\n  const limit = apiKeyRateLimit || RATE_LIMIT_TIERS.starter.maxRequests;\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.starter.windowMs,\r\n    maxRequests: limit,\r\n    identifier: `api_key:${hashKey(token)}`,\r\n  }, 'api_key');\r\n}\r\n\r\n/**\r\n * Rate limit by endpoint (Node.js)\r\n */\r\nexport async function rateLimitByEndpoint(\r\n  request: NextRequest,\r\n  endpointId: string,\r\n  maxRequests?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.endpoint.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.endpoint.maxRequests,\r\n    identifier: `endpoint:${endpointId}:${ip}`,\r\n  }, `endpoint:${endpointId}`);\r\n}\r\n\r\n/**\r\n * Rate limit by IP (Node.js)\r\n */\r\nexport async function rateLimitByIp(\r\n  request: NextRequest,\r\n  maxRequests?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.global.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.global.maxRequests,\r\n    identifier: `global:${ip}`,\r\n  }, 'global');\r\n}\r\n\r\n/**\r\n * Rate limit cron job (prevent concurrent runs)\r\n */\r\nexport async function rateLimitCronJob(\r\n  cronId: string,\r\n  intervalMs?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: intervalMs || RATE_LIMIT_TIERS.cron.windowMs,\r\n    maxRequests: RATE_LIMIT_TIERS.cron.maxRequests,\r\n    identifier: `cron:${cronId}`,\r\n  }, `cron:${cronId}`);\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API - SYNC (Edge Runtime)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by IP (Edge - sync, in-memory only)\r\n */\r\nexport function rateLimitByIpEdge(\r\n  request: NextRequest,\r\n  maxRequests?: number\r\n): RateLimitResult {\r\n  const store = getEdgeRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.global.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.global.maxRequests,\r\n    identifier: `global:${ip}`,\r\n  });\r\n}\r\n\r\n/**\r\n * Rate limit by API key (Edge - sync, default limit only)\r\n */\r\nexport function rateLimitByApiKeyEdge(\r\n  request: NextRequest,\r\n  defaultLimit?: number\r\n): RateLimitResult | null {\r\n  const token = extractApiKey(request);\r\n  if (!token) return null;\r\n  \r\n  const store = getEdgeRateLimitStore();\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.starter.windowMs,\r\n    maxRequests: defaultLimit || RATE_LIMIT_TIERS.starter.maxRequests,\r\n    identifier: `api_key:${hashKey(token)}`,\r\n  });\r\n}\r\n\r\n// =============================================================================\r\n// RESPONSE HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Add rate limit headers to response\r\n */\r\nexport function addRateLimitHeaders(\r\n  response: NextResponse,\r\n  result: RateLimitResult\r\n): NextResponse {\r\n  response.headers.set('X-RateLimit-Limit', result.limit.toString());\r\n  response.headers.set('X-RateLimit-Remaining', result.remaining.toString());\r\n  response.headers.set('X-RateLimit-Reset', new Date(result.resetAt).toISOString());\r\n  return response;\r\n}\r\n\r\n/**\r\n * Create rate limit error response\r\n */\r\nexport function createRateLimitResponse(result: RateLimitResult): NextResponse {\r\n  const resetDate = new Date(result.resetAt).toISOString();\r\n  const retryAfter = Math.ceil((result.resetAt - Date.now()) / 1000);\r\n  \r\n  const response = NextResponse.json(\r\n    {\r\n      error: 'Rate limit exceeded',\r\n      code: 'RATE_LIMIT_EXCEEDED',\r\n      message: `Too many requests. Limit: ${result.limit} per hour. Try again after ${resetDate}`,\r\n      retryAfter,\r\n    },\r\n    { status: 429 }\r\n  );\r\n  \r\n  response.headers.set('Retry-After', retryAfter.toString());\r\n  return addRateLimitHeaders(response, result);\r\n}\r\n\r\n// =============================================================================\r\n// COMPOSITE CHECKS\r\n// =============================================================================\r\n\r\n/**\r\n * Check all rate limits (API key + endpoint + global)\r\n * Returns first exceeded limit, or null if all pass\r\n */\r\nexport async function checkAllRateLimits(\r\n  request: NextRequest,\r\n  options?: {\r\n    endpointId?: string;\r\n    apiKeyRateLimit?: number;\r\n  }\r\n): Promise<{ result: RateLimitResult; type: string } | null> {\r\n  // 1. Global IP limit\r\n  const globalResult = await rateLimitByIp(request);\r\n  if (!globalResult.allowed) {\r\n    return { result: globalResult, type: 'global' };\r\n  }\r\n  \r\n  // 2. API key limit (if authenticated)\r\n  const apiKeyResult = await rateLimitByApiKey(request, options?.apiKeyRateLimit);\r\n  if (apiKeyResult && !apiKeyResult.allowed) {\r\n    return { result: apiKeyResult, type: 'api_key' };\r\n  }\r\n  \r\n  // 3. Endpoint limit (if specified)\r\n  if (options?.endpointId) {\r\n    const endpointResult = await rateLimitByEndpoint(request, options.endpointId);\r\n    if (!endpointResult.allowed) {\r\n      return { result: endpointResult, type: 'endpoint' };\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * Get rate limit info for response headers (async version)\r\n * Returns the most restrictive limit for informational headers\r\n */\r\nexport async function getRateLimitHeaders(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): Promise<RateLimitResult | null> {\r\n  const results: RateLimitResult[] = [];\r\n\r\n  // Global IP limit\r\n  const globalResult = await rateLimitByIp(request);\r\n  results.push(globalResult);\r\n\r\n  // API key limit\r\n  const apiKeyResult = await rateLimitByApiKey(request);\r\n  if (apiKeyResult) {\r\n    results.push(apiKeyResult);\r\n  }\r\n\r\n  // Endpoint limit\r\n  if (endpointId) {\r\n    const endpointResult = await rateLimitByEndpoint(request, endpointId);\r\n    results.push(endpointResult);\r\n  }\r\n\r\n  // Return the most restrictive (lowest remaining)\r\n  if (results.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return results.reduce((min, current) =>\r\n    current.remaining < min.remaining ? current : min\r\n  );\r\n}\r\n\r\n// =============================================================================\r\n// EDGE-COMPATIBLE FUNCTIONS (Sync)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by endpoint (Edge - sync, in-memory only)\r\n */\r\nexport function rateLimitByEndpointEdge(\r\n  request: NextRequest,\r\n  endpointId: string,\r\n  maxRequests?: number\r\n): RateLimitResult {\r\n  const store = getEdgeRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.endpoint.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.endpoint.maxRequests,\r\n    identifier: `endpoint:${endpointId}:${ip}`,\r\n  });\r\n}\r\n\r\n/**\r\n * Check all rate limits (Edge-compatible, sync version)\r\n * Returns first exceeded limit, or null if all pass\r\n */\r\nexport function checkAllRateLimitsEdge(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): { result: RateLimitResult; type: string } | null {\r\n  // 1. Global IP limit\r\n  const globalResult = rateLimitByIpEdge(request);\r\n  if (!globalResult.allowed) {\r\n    return { result: globalResult, type: 'global' };\r\n  }\r\n  \r\n  // 2. API key limit (Edge uses default limit)\r\n  const apiKeyResult = rateLimitByApiKeyEdge(request);\r\n  if (apiKeyResult && !apiKeyResult.allowed) {\r\n    return { result: apiKeyResult, type: 'api_key' };\r\n  }\r\n  \r\n  // 3. Endpoint limit (if specified)\r\n  if (endpointId) {\r\n    const endpointResult = rateLimitByEndpointEdge(request, endpointId);\r\n    if (!endpointResult.allowed) {\r\n      return { result: endpointResult, type: 'endpoint' };\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * Get rate limit info for response headers (Edge-compatible, sync version)\r\n */\r\nexport function getRateLimitHeadersEdge(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): RateLimitResult | null {\r\n  const results: RateLimitResult[] = [];\r\n\r\n  // Global IP limit\r\n  results.push(rateLimitByIpEdge(request));\r\n\r\n  // API key limit\r\n  const apiKeyResult = rateLimitByApiKeyEdge(request);\r\n  if (apiKeyResult) {\r\n    results.push(apiKeyResult);\r\n  }\r\n\r\n  // Endpoint limit\r\n  if (endpointId) {\r\n    results.push(rateLimitByEndpointEdge(request, endpointId));\r\n  }\r\n\r\n  // Return the most restrictive (lowest remaining)\r\n  if (results.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return results.reduce((min, current) =>\r\n    current.remaining < min.remaining ? current : min\r\n  );\r\n}\r\n\r\n","// =============================================================================\r\n// RATE LIMIT STORE\r\n// =============================================================================\r\n// Pluggable backing store for rate limiting with Upstash Redis support and in-memory fallback.\r\n// Supports distributed rate limiting across serverless instances.\r\n//\r\n// Environment Variables:\r\n// - UPSTASH_REDIS_REST_URL: Upstash Redis REST URL (from Vercel integration)\r\n// - UPSTASH_REDIS_REST_TOKEN: Upstash Redis REST token (from Vercel integration)\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'RateLimitStore' });\r\n\r\nexport interface RateLimitEntry {\r\n  count: number;\r\n  resetAt: number;\r\n}\r\n\r\nexport interface RateLimitStore {\r\n  get(key: string): Promise<RateLimitEntry | null>;\r\n  set(key: string, entry: RateLimitEntry): Promise<void>;\r\n  increment(key: string, windowMs: number): Promise<RateLimitEntry>;\r\n}\r\n\r\n// =============================================================================\r\n// IN-MEMORY STORE (fallback)\r\n// =============================================================================\r\n\r\nclass InMemoryStore implements RateLimitStore {\r\n  private store = new Map<string, RateLimitEntry>();\r\n  private cleanupInterval: ReturnType<typeof setInterval> | null = null;\r\n\r\n  constructor() {\r\n    // Cleanup every 5 minutes\r\n    if (typeof setInterval !== 'undefined') {\r\n      this.cleanupInterval = setInterval(() => this.cleanup(), 5 * 60 * 1000);\r\n    }\r\n  }\r\n\r\n  private cleanup(): void {\r\n    const now = Date.now();\r\n    const keysToDelete: string[] = [];\r\n    this.store.forEach((value, key) => {\r\n      if (value.resetAt < now) {\r\n        keysToDelete.push(key);\r\n      }\r\n    });\r\n    keysToDelete.forEach(key => this.store.delete(key));\r\n  }\r\n\r\n  async get(key: string): Promise<RateLimitEntry | null> {\r\n    const entry = this.store.get(key);\r\n    if (!entry || entry.resetAt < Date.now()) {\r\n      return null;\r\n    }\r\n    return entry;\r\n  }\r\n\r\n  async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n    this.store.set(key, entry);\r\n  }\r\n\r\n  async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n    const now = Date.now();\r\n    const existing = this.store.get(key);\r\n\r\n    if (!existing || existing.resetAt < now) {\r\n      const entry = { count: 1, resetAt: now + windowMs };\r\n      this.store.set(key, entry);\r\n      return entry;\r\n    }\r\n\r\n    existing.count++;\r\n    this.store.set(key, existing);\r\n    return existing;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// UPSTASH REDIS STORE (distributed)\r\n// =============================================================================\r\n\r\nclass UpstashRedisStore implements RateLimitStore {\r\n  private redis: any;\r\n\r\n  constructor(redisClient: any) {\r\n    this.redis = redisClient;\r\n  }\r\n\r\n  async get(key: string): Promise<RateLimitEntry | null> {\r\n    try {\r\n      const data = await this.redis.get(`ratelimit:${key}`);\r\n      if (!data) return null;\r\n      \r\n      // Upstash returns parsed JSON automatically if it's a JSON string\r\n      const entry = typeof data === 'string' ? JSON.parse(data) : data;\r\n      if (entry.resetAt < Date.now()) return null;\r\n      return entry as RateLimitEntry;\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis GET failed');\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n    try {\r\n      const ttlMs = Math.max(entry.resetAt - Date.now(), 1000);\r\n      const ttlSeconds = Math.ceil(ttlMs / 1000);\r\n      \r\n      await this.redis.set(\r\n        `ratelimit:${key}`,\r\n        JSON.stringify(entry),\r\n        { ex: ttlSeconds }\r\n      );\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis SET failed');\r\n    }\r\n  }\r\n\r\n  async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n    try {\r\n      const redisKey = `ratelimit:${key}`;\r\n      const now = Date.now();\r\n\r\n      // Get current entry\r\n      const data = await this.redis.get(redisKey);\r\n      \r\n      let count = 1;\r\n      let resetAt = now + windowMs;\r\n      \r\n      if (data) {\r\n        const entry = typeof data === 'string' ? JSON.parse(data) : data;\r\n        if (entry.resetAt > now) {\r\n          count = entry.count + 1;\r\n          resetAt = entry.resetAt;\r\n        }\r\n      }\r\n      \r\n      const newEntry = { count, resetAt };\r\n      const ttlMs = resetAt - now;\r\n      const ttlSeconds = Math.ceil(ttlMs / 1000);\r\n      \r\n      await this.redis.set(redisKey, JSON.stringify(newEntry), { ex: ttlSeconds });\r\n      \r\n      return newEntry;\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis INCR failed');\r\n      // Fallback: return a permissive entry\r\n      return { count: 1, resetAt: Date.now() + windowMs };\r\n    }\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// STORE FACTORY\r\n// =============================================================================\r\n\r\nlet storeInstance: RateLimitStore | null = null;\r\n\r\n/**\r\n * Get the rate limit store singleton.\r\n * Uses Upstash Redis if configured, otherwise falls back to in-memory.\r\n */\r\nexport async function getRateLimitStore(): Promise<RateLimitStore> {\r\n  if (storeInstance) {\r\n    return storeInstance;\r\n  }\r\n\r\n  // Check for Upstash Redis environment variables (set by Vercel integration)\r\n  const upstashUrl = process.env.UPSTASH_REDIS_REST_URL;\r\n  const upstashToken = process.env.UPSTASH_REDIS_REST_TOKEN;\r\n\r\n  if (upstashUrl && upstashToken) {\r\n    try {\r\n      // Dynamic import to avoid build issues\r\n      const { Redis } = await import('@upstash/redis');\r\n      const redis = new Redis({\r\n        url: upstashUrl,\r\n        token: upstashToken,\r\n      });\r\n\r\n      // Test connection\r\n      await redis.ping();\r\n      \r\n      logger.info('Rate limit store using Upstash Redis');\r\n      storeInstance = new UpstashRedisStore(redis);\r\n      return storeInstance;\r\n    } catch (error) {\r\n      logger.warn({ error }, 'Upstash Redis connection failed, falling back to in-memory');\r\n    }\r\n  }\r\n\r\n  // Legacy support: check for REDIS_URL (ioredis)\r\n  const redisUrl = process.env.REDIS_URL;\r\n  if (redisUrl) {\r\n    try {\r\n      const { Redis } = await import('ioredis');\r\n      const redis = new Redis(redisUrl, {\r\n        maxRetriesPerRequest: 3,\r\n        enableReadyCheck: true,\r\n        connectTimeout: 5000,\r\n        lazyConnect: true,\r\n      });\r\n\r\n      await redis.connect();\r\n      logger.info('Rate limit store using Redis (ioredis)');\r\n      \r\n      // Use a simple wrapper that matches UpstashRedisStore behavior\r\n      storeInstance = {\r\n        async get(key: string): Promise<RateLimitEntry | null> {\r\n          const data = await redis.get(`ratelimit:${key}`);\r\n          if (!data) return null;\r\n          const entry = JSON.parse(data) as RateLimitEntry;\r\n          if (entry.resetAt < Date.now()) return null;\r\n          return entry;\r\n        },\r\n        async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n          const ttlMs = Math.max(entry.resetAt - Date.now(), 1000);\r\n          await redis.set(`ratelimit:${key}`, JSON.stringify(entry), 'PX', ttlMs);\r\n        },\r\n        async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n          const now = Date.now();\r\n          const redisKey = `ratelimit:${key}`;\r\n          const data = await redis.get(redisKey);\r\n          \r\n          let count = 1;\r\n          let resetAt = now + windowMs;\r\n          \r\n          if (data) {\r\n            const entry = JSON.parse(data);\r\n            if (entry.resetAt > now) {\r\n              count = entry.count + 1;\r\n              resetAt = entry.resetAt;\r\n            }\r\n          }\r\n          \r\n          const newEntry = { count, resetAt };\r\n          const ttlMs = resetAt - now;\r\n          await redis.set(redisKey, JSON.stringify(newEntry), 'PX', ttlMs);\r\n          return newEntry;\r\n        }\r\n      };\r\n      return storeInstance;\r\n    } catch (error) {\r\n      logger.warn({ error }, 'Redis connection failed, falling back to in-memory');\r\n    }\r\n  }\r\n\r\n  logger.info('Rate limit store using in-memory (non-distributed)');\r\n  storeInstance = new InMemoryStore();\r\n  return storeInstance;\r\n}\r\n\r\n/**\r\n * Synchronous in-memory store for Edge runtime.\r\n * Edge runtime can use Upstash but requires async initialization.\r\n */\r\nexport function getEdgeRateLimitStore(): RateLimitStore {\r\n  // Edge runtime uses in-memory for sync access\r\n  // For async Edge operations, use getRateLimitStore()\r\n  if (!storeInstance) {\r\n    storeInstance = new InMemoryStore();\r\n  }\r\n  return storeInstance;\r\n}\r\n\r\n/**\r\n * Reset the store singleton (for testing)\r\n */\r\nexport function resetRateLimitStore(): void {\r\n  storeInstance = null;\r\n}\r\n","// =============================================================================\r\n// CRON JOB DATABASE OPERATIONS\r\n// =============================================================================\r\n// Database operations for cron job tracking and configuration.\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'CronJobDb' });\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport type CronJobStatus = 'pending' | 'running' | 'completed' | 'failed' | 'timeout';\r\nexport type TriggerSource = 'cron' | 'manual' | 'retry';\r\n\r\nexport interface CronJobRun {\r\n  id: string;\r\n  job_id: string;\r\n  status: CronJobStatus;\r\n  started_at: string;\r\n  completed_at?: string;\r\n  duration_ms?: number;\r\n  trigger_source: TriggerSource;\r\n  attempt_number: number;\r\n  input_params?: Record<string, any>;\r\n  output_summary?: Record<string, any>;\r\n  error_message?: string;\r\n  error_stack?: string;\r\n  metadata?: Record<string, any>;\r\n  created_at: string;\r\n}\r\n\r\nexport interface CronJobConfig {\r\n  job_id: string;\r\n  display_name: string;\r\n  description?: string;\r\n  schedule?: string;\r\n  enabled: boolean;\r\n  timeout_ms: number;\r\n  max_retries: number;\r\n  retry_delay_ms: number;\r\n  alert_on_failure: boolean;\r\n  consecutive_failures: number;\r\n  last_success_at?: string;\r\n  last_failure_at?: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface CreateJobRunInput {\r\n  jobId: string;\r\n  triggerSource?: TriggerSource;\r\n  attemptNumber?: number;\r\n  inputParams?: Record<string, any>;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nexport interface CompleteJobRunInput {\r\n  runId: string;\r\n  status: 'completed' | 'failed' | 'timeout';\r\n  outputSummary?: Record<string, any>;\r\n  errorMessage?: string;\r\n  errorStack?: string;\r\n}\r\n\r\n// =============================================================================\r\n// JOB RUN OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Create a new job run record\r\n */\r\nexport async function createJobRun(input: CreateJobRunInput): Promise<CronJobRun> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  \r\n  if ('pool' in db) {\r\n    // PostgreSQL\r\n    const result = await db.query(\r\n      `INSERT INTO cron_job_runs (id, job_id, status, trigger_source, attempt_number, input_params, metadata)\r\n       VALUES ($1, $2, 'running', $3, $4, $5, $6)\r\n       RETURNING *`,\r\n      [\r\n        id,\r\n        input.jobId,\r\n        input.triggerSource || 'cron',\r\n        input.attemptNumber || 1,\r\n        input.inputParams ? JSON.stringify(input.inputParams) : null,\r\n        input.metadata ? JSON.stringify(input.metadata) : null,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite\r\n    db.prepare(\r\n      `INSERT INTO cron_job_runs (id, job_id, status, trigger_source, attempt_number, input_params, metadata, started_at, created_at)\r\n       VALUES (?, ?, 'running', ?, ?, ?, ?, datetime('now'), datetime('now'))`\r\n    ).run(\r\n      id,\r\n      input.jobId,\r\n      input.triggerSource || 'cron',\r\n      input.attemptNumber || 1,\r\n      input.inputParams ? JSON.stringify(input.inputParams) : null,\r\n      input.metadata ? JSON.stringify(input.metadata) : null\r\n    );\r\n    return db.prepare('SELECT * FROM cron_job_runs WHERE id = ?').get(id) as CronJobRun;\r\n  }\r\n}\r\n\r\n/**\r\n * Complete a job run (success or failure)\r\n */\r\nexport async function completeJobRun(input: CompleteJobRunInput): Promise<void> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    await db.query(\r\n      `UPDATE cron_job_runs\r\n       SET status = $1,\r\n           completed_at = now(),\r\n           duration_ms = EXTRACT(EPOCH FROM (now() - started_at)) * 1000,\r\n           output_summary = $2,\r\n           error_message = $3,\r\n           error_stack = $4\r\n       WHERE id = $5`,\r\n      [\r\n        input.status,\r\n        input.outputSummary ? JSON.stringify(input.outputSummary) : null,\r\n        input.errorMessage || null,\r\n        input.errorStack || null,\r\n        input.runId,\r\n      ]\r\n    );\r\n  } else {\r\n    db.prepare(\r\n      `UPDATE cron_job_runs\r\n       SET status = ?,\r\n           completed_at = datetime('now'),\r\n           duration_ms = (julianday('now') - julianday(started_at)) * 86400000,\r\n           output_summary = ?,\r\n           error_message = ?,\r\n           error_stack = ?\r\n       WHERE id = ?`\r\n    ).run(\r\n      input.status,\r\n      input.outputSummary ? JSON.stringify(input.outputSummary) : null,\r\n      input.errorMessage || null,\r\n      input.errorStack || null,\r\n      input.runId\r\n    );\r\n  }\r\n\r\n  // Update config stats\r\n  await updateConfigStats(input);\r\n}\r\n\r\n/**\r\n * Update job config statistics after run completion\r\n */\r\nasync function updateConfigStats(input: CompleteJobRunInput): Promise<void> {\r\n  const db = getDb();\r\n  \r\n  // Get the job_id from the run\r\n  let jobId: string;\r\n  if ('pool' in db) {\r\n    const result = await db.query(\r\n      'SELECT job_id FROM cron_job_runs WHERE id = $1',\r\n      [input.runId]\r\n    );\r\n    if (result.rows.length === 0) return;\r\n    jobId = result.rows[0].job_id;\r\n  } else {\r\n    const row = db.prepare('SELECT job_id FROM cron_job_runs WHERE id = ?').get(input.runId) as { job_id: string } | undefined;\r\n    if (!row) return;\r\n    jobId = row.job_id;\r\n  }\r\n\r\n  if (input.status === 'completed') {\r\n    // Reset consecutive failures, update last success\r\n    if ('pool' in db) {\r\n      await db.query(\r\n        `UPDATE cron_job_config\r\n         SET consecutive_failures = 0, last_success_at = now(), updated_at = now()\r\n         WHERE job_id = $1`,\r\n        [jobId]\r\n      );\r\n    } else {\r\n      db.prepare(\r\n        `UPDATE cron_job_config\r\n         SET consecutive_failures = 0, last_success_at = datetime('now'), updated_at = datetime('now')\r\n         WHERE job_id = ?`\r\n      ).run(jobId);\r\n    }\r\n  } else if (input.status === 'failed' || input.status === 'timeout') {\r\n    // Increment consecutive failures, update last failure\r\n    if ('pool' in db) {\r\n      await db.query(\r\n        `UPDATE cron_job_config\r\n         SET consecutive_failures = consecutive_failures + 1, last_failure_at = now(), updated_at = now()\r\n         WHERE job_id = $1`,\r\n        [jobId]\r\n      );\r\n    } else {\r\n      db.prepare(\r\n        `UPDATE cron_job_config\r\n         SET consecutive_failures = consecutive_failures + 1, last_failure_at = datetime('now'), updated_at = datetime('now')\r\n         WHERE job_id = ?`\r\n      ).run(jobId);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get recent runs for a job\r\n */\r\nexport async function getRecentJobRuns(\r\n  jobId: string,\r\n  limit = 20\r\n): Promise<CronJobRun[]> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    const result = await db.query(\r\n      `SELECT * FROM cron_job_runs\r\n       WHERE job_id = $1\r\n       ORDER BY started_at DESC\r\n       LIMIT $2`,\r\n      [jobId, limit]\r\n    );\r\n    return result.rows;\r\n  } else {\r\n    return db.prepare(\r\n      `SELECT * FROM cron_job_runs\r\n       WHERE job_id = ?\r\n       ORDER BY started_at DESC\r\n       LIMIT ?`\r\n    ).all(jobId, limit) as CronJobRun[];\r\n  }\r\n}\r\n\r\n/**\r\n * Get all job runs across all jobs (recent)\r\n */\r\nexport async function getAllRecentRuns(limit = 50): Promise<CronJobRun[]> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    const result = await db.query(\r\n      `SELECT * FROM cron_job_runs\r\n       ORDER BY started_at DESC\r\n       LIMIT $1`,\r\n      [limit]\r\n    );\r\n    return result.rows;\r\n  } else {\r\n    return db.prepare(\r\n      `SELECT * FROM cron_job_runs\r\n       ORDER BY started_at DESC\r\n       LIMIT ?`\r\n    ).all(limit) as CronJobRun[];\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// JOB CONFIG OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Get job configuration\r\n */\r\nexport async function getJobConfig(jobId: string): Promise<CronJobConfig | null> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    const result = await db.query(\r\n      'SELECT * FROM cron_job_config WHERE job_id = $1',\r\n      [jobId]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    return db.prepare('SELECT * FROM cron_job_config WHERE job_id = ?').get(jobId) as CronJobConfig | null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all job configurations\r\n */\r\nexport async function getAllJobConfigs(): Promise<CronJobConfig[]> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    const result = await db.query('SELECT * FROM cron_job_config ORDER BY job_id');\r\n    return result.rows;\r\n  } else {\r\n    return db.prepare('SELECT * FROM cron_job_config ORDER BY job_id').all() as CronJobConfig[];\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a job is enabled\r\n */\r\nexport async function isJobEnabled(jobId: string): Promise<boolean> {\r\n  const config = await getJobConfig(jobId);\r\n  return config?.enabled ?? true;\r\n}\r\n\r\n/**\r\n * Get jobs with consecutive failures exceeding threshold\r\n */\r\nexport async function getFailingJobs(threshold = 3): Promise<CronJobConfig[]> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    const result = await db.query(\r\n      `SELECT * FROM cron_job_config\r\n       WHERE consecutive_failures >= $1 AND alert_on_failure = true\r\n       ORDER BY consecutive_failures DESC`,\r\n      [threshold]\r\n    );\r\n    return result.rows;\r\n  } else {\r\n    return db.prepare(\r\n      `SELECT * FROM cron_job_config\r\n       WHERE consecutive_failures >= ? AND alert_on_failure = 1\r\n       ORDER BY consecutive_failures DESC`\r\n    ).all(threshold) as CronJobConfig[];\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// CLEANUP\r\n// =============================================================================\r\n\r\n/**\r\n * Delete old job runs (older than retention days)\r\n */\r\nexport async function cleanupOldRuns(retentionDays = 30): Promise<number> {\r\n  const db = getDb();\r\n  \r\n  if ('pool' in db) {\r\n    const result = await db.query(\r\n      `DELETE FROM cron_job_runs\r\n       WHERE created_at < now() - interval '${retentionDays} days'`\r\n    );\r\n    const deleted = result.rowCount || 0;\r\n    logger.info({ retentionDays, deleted }, 'Cleaned up old cron job runs');\r\n    return deleted;\r\n  } else {\r\n    const result = db.prepare(\r\n      `DELETE FROM cron_job_runs\r\n       WHERE created_at < datetime('now', '-' || ? || ' days')`\r\n    ).run(retentionDays);\r\n    const deleted = result.changes;\r\n    logger.info({ retentionDays, deleted }, 'Cleaned up old cron job runs');\r\n    return deleted;\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}