{"version":3,"sources":["../../../src/lib/webhook-queue.ts"],"sourcesContent":["// =============================================================================\r\n// WEBHOOK DELIVERY QUEUE\r\n// =============================================================================\r\n// BullMQ queue for webhook delivery with retry logic\r\n// Note: bullmq may not be installed - this module handles missing dependencies gracefully\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'WebhookQueue' });\r\n\r\n// Lazy load bullmq to handle missing dependencies\r\nlet Queue: any;\r\nlet QueueOptions: any;\r\nlet webhookQueueInstance: any = null;\r\n\r\nasync function loadBullMQ() {\r\n  if (!Queue) {\r\n    try {\r\n      // Use dynamic import with webpack ignore comment to prevent build-time resolution\r\n      // @ts-ignore - bullmq may not be installed\r\n      const bullmq = await import(/* webpackIgnore: true */ 'bullmq').catch(() => {\r\n        // Fallback: return null if module doesn't exist\r\n        return null;\r\n      });\r\n      \r\n      if (!bullmq) {\r\n        throw new Error('bullmq package not installed');\r\n      }\r\n      \r\n      Queue = bullmq.Queue;\r\n      QueueOptions = bullmq.QueueOptions;\r\n    } catch (error) {\r\n      logger.warn({ error }, 'bullmq not available - webhook queue features will be disabled');\r\n      throw new Error('bullmq package not installed');\r\n    }\r\n  }\r\n  return { Queue, QueueOptions };\r\n}\r\n\r\nasync function getWebhookQueue() {\r\n  if (!webhookQueueInstance) {\r\n    try {\r\n      const { Queue: QueueClass, QueueOptions: QueueOptionsType } = await loadBullMQ();\r\n      \r\n      // Redis connection configuration\r\n      const redisConnection = {\r\n        host: process.env.REDIS_HOST || 'localhost',\r\n        port: parseInt(process.env.REDIS_PORT || '6379'),\r\n        password: process.env.REDIS_PASSWORD,\r\n        // Use REDIS_URL if provided (for cloud Redis like Upstash)\r\n        ...(process.env.REDIS_URL ? { url: process.env.REDIS_URL } : {}),\r\n      };\r\n\r\n      // Queue options\r\n      const queueOptions: any = {\r\n        connection: redisConnection,\r\n        defaultJobOptions: {\r\n          attempts: 3,\r\n          backoff: {\r\n            type: 'exponential',\r\n            delay: 2000, // Start with 2 seconds\r\n          },\r\n          removeOnComplete: {\r\n            age: 24 * 3600, // Keep completed jobs for 24 hours\r\n            count: 1000, // Keep last 1000 completed jobs\r\n          },\r\n          removeOnFail: {\r\n            age: 7 * 24 * 3600, // Keep failed jobs for 7 days\r\n          },\r\n        },\r\n      };\r\n\r\n      // Create webhook delivery queue\r\n      webhookQueueInstance = new QueueClass('webhook-delivery', queueOptions);\r\n    } catch (error) {\r\n      logger.warn({ error }, 'Failed to initialize webhook queue');\r\n      return null;\r\n    }\r\n  }\r\n  return webhookQueueInstance;\r\n}\r\n\r\n// Export a getter instead of direct instance\r\nexport const webhookQueue = {\r\n  get instance() {\r\n    // This will only work in runtime, not during build\r\n    // Use getWebhookQueue() instead for async access\r\n    return webhookQueueInstance;\r\n  }\r\n};\r\n\r\nexport interface WebhookJobData {\r\n  webhookConfigId: string;\r\n  eventId: string;\r\n  eventType: string;\r\n  url: string;\r\n  payload: string;\r\n  signature: string;\r\n  attempt?: number;\r\n}\r\n\r\n/**\r\n * Add webhook delivery job to queue\r\n */\r\nexport async function enqueueWebhookDelivery(data: WebhookJobData): Promise<string> {\r\n  try {\r\n    const queue = await getWebhookQueue();\r\n    if (!queue) {\r\n      throw new Error('Webhook queue not available (bullmq not installed or Redis not configured)');\r\n    }\r\n    \r\n    const job = await queue.add('deliver', data, {\r\n      jobId: `webhook_${data.webhookConfigId}_${data.eventId}_${Date.now()}`,\r\n    });\r\n    \r\n    logger.info('Webhook delivery job enqueued', {\r\n      jobId: job.id,\r\n      webhookConfigId: data.webhookConfigId,\r\n      eventId: data.eventId,\r\n      url: data.url,\r\n    });\r\n    \r\n    return job.id!;\r\n  } catch (error) {\r\n    logger.error('Failed to enqueue webhook delivery', {\r\n      webhookConfigId: data.webhookConfigId,\r\n      eventId: data.eventId,\r\n      error,\r\n    });\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Get queue statistics\r\n */\r\nexport async function getQueueStats() {\r\n  const queue = await getWebhookQueue();\r\n  if (!queue) {\r\n    return {\r\n      waiting: 0,\r\n      active: 0,\r\n      completed: 0,\r\n      failed: 0,\r\n      delayed: 0,\r\n      total: 0,\r\n      available: false,\r\n    };\r\n  }\r\n\r\n  const [waiting, active, completed, failed, delayed] = await Promise.all([\r\n    queue.getWaitingCount(),\r\n    queue.getActiveCount(),\r\n    queue.getCompletedCount(),\r\n    queue.getFailedCount(),\r\n    queue.getDelayedCount(),\r\n  ]);\r\n\r\n  return {\r\n    waiting,\r\n    active,\r\n    completed,\r\n    failed,\r\n    delayed,\r\n    total: waiting + active + completed + failed + delayed,\r\n    available: true,\r\n  };\r\n}\r\n\r\n/**\r\n * Clean up old jobs\r\n */\r\nexport async function cleanupQueue(): Promise<void> {\r\n  try {\r\n    const queue = await getWebhookQueue();\r\n    if (!queue) {\r\n      logger.warn('Cannot cleanup queue - webhook queue not available');\r\n      return;\r\n    }\r\n    \r\n    // Clean up old completed jobs (beyond retention period)\r\n    await queue.clean(24 * 3600 * 1000, 1000, 'completed');\r\n    // Clean up old failed jobs (beyond retention period)\r\n    await queue.clean(7 * 24 * 3600 * 1000, 1000, 'failed');\r\n    logger.info('Queue cleanup completed');\r\n  } catch (error) {\r\n    logger.error('Failed to cleanup queue', { error });\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}