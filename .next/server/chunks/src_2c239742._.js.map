{"version":3,"sources":["../../../src/db/facilitator-registration.ts","../../../src/types/facilitator-registration.ts","../../../src/services/smf/facilitator-registry.ts"],"sourcesContent":["// =============================================================================\r\n// Facilitator Registration Query Helpers\r\n// =============================================================================\r\n// Database operations for facilitator registration, verification, and promotion.\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\n/**\r\n * Check if database is PostgreSQL\r\n */\r\nfunction isPostgres(db: any): boolean {\r\n  return db && typeof db.pool !== 'undefined';\r\n}\r\nimport type {\r\n  FacilitatorRow,\r\n  VerificationAttempt,\r\n  CanaryMetricsRecord,\r\n  FacilitatorPromotion,\r\n  CallbackTestRecord,\r\n  RegistrationStatus,\r\n} from '@/types/facilitator-registration';\r\n\r\nconst logger = createLogger({ component: 'FacilitatorRegistrationDB' });\r\n\r\n// =============================================================================\r\n// FACILITATOR CRUD\r\n// =============================================================================\r\n\r\n/**\r\n * Create a new facilitator registration with pending status\r\n */\r\nexport async function createFacilitatorRegistration(params: {\r\n  name: string;\r\n  domain: string;\r\n  dns_txt_proof: string;\r\n  callback_url: string;\r\n  supported_chains: string[];\r\n  supported_tokens: string[];\r\n  registered_by: string;\r\n}): Promise<FacilitatorRow> {\r\n  const db = getDb();\r\n  const id = `fac_${crypto.randomUUID().replace(/-/g, '').substring(0, 16)}`;\r\n  const now = new Date().toISOString();\r\n\r\n  // Check domain uniqueness\r\n  if (isPostgres(db)) {\r\n    const existing = await (db as any).pool.query(\r\n      `SELECT id FROM facilitators WHERE domain = $1`,\r\n      [params.domain]\r\n    );\r\n    if (existing.rows.length > 0) {\r\n      throw new Error('DOMAIN_ALREADY_REGISTERED');\r\n    }\r\n\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO facilitators (\r\n        id, name, status, base_url, priority, domain, dns_txt_proof, callback_url,\r\n        registration_status, canary_traffic_share, max_traffic_share,\r\n        supported_chains, supported_tokens, registered_by, created_at, updated_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        params.name,\r\n        'testing',  // operational status\r\n        params.callback_url,  // use callback_url as base_url\r\n        100,  // default priority\r\n        params.domain,\r\n        params.dns_txt_proof,\r\n        params.callback_url,\r\n        'pending',  // registration_status\r\n        0.01,  // canary_traffic_share (1%)\r\n        0.20,  // max_traffic_share (20%)\r\n        JSON.stringify(params.supported_chains),\r\n        JSON.stringify(params.supported_tokens),\r\n        params.registered_by,\r\n        now,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite\r\n    const existingStmt = (db as any).prepare('SELECT id FROM facilitators WHERE domain = ?');\r\n    const existing = existingStmt.get(params.domain);\r\n    if (existing) {\r\n      throw new Error('DOMAIN_ALREADY_REGISTERED');\r\n    }\r\n\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO facilitators (\r\n        id, name, status, base_url, priority, domain, dns_txt_proof, callback_url,\r\n        registration_status, canary_traffic_share, max_traffic_share,\r\n        supported_chains, supported_tokens, registered_by, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      params.name,\r\n      'testing',\r\n      params.callback_url,\r\n      100,\r\n      params.domain,\r\n      params.dns_txt_proof,\r\n      params.callback_url,\r\n      'pending',\r\n      0.01,\r\n      0.20,\r\n      JSON.stringify(params.supported_chains),\r\n      JSON.stringify(params.supported_tokens),\r\n      params.registered_by,\r\n      now,\r\n      now\r\n    );\r\n\r\n    const row = (db as any).prepare('SELECT * FROM facilitators WHERE id = ?').get(id);\r\n    return row;\r\n  }\r\n}\r\n\r\n/**\r\n * Get facilitator by ID\r\n */\r\nexport async function getFacilitatorById(id: string): Promise<FacilitatorRow | null> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitators WHERE id = $1`,\r\n      [id]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    const row = (db as any).prepare('SELECT * FROM facilitators WHERE id = ?').get(id);\r\n    return row || null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get facilitator by domain\r\n */\r\nexport async function getFacilitatorByDomain(domain: string): Promise<FacilitatorRow | null> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitators WHERE domain = $1`,\r\n      [domain]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    const row = (db as any).prepare('SELECT * FROM facilitators WHERE domain = ?').get(domain);\r\n    return row || null;\r\n  }\r\n}\r\n\r\n/**\r\n * Update facilitator registration status\r\n */\r\nexport async function updateFacilitatorStatus(\r\n  facilitator_id: string,\r\n  registration_status: RegistrationStatus,\r\n  verified_at?: Date\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    await (db as any).pool.query(\r\n      `UPDATE facilitators \r\n       SET registration_status = $1, verified_at = $2, updated_at = $3\r\n       WHERE id = $4`,\r\n      [registration_status, verified_at?.toISOString() || null, now, facilitator_id]\r\n    );\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      UPDATE facilitators \r\n      SET registration_status = ?, verified_at = ?, updated_at = ?\r\n      WHERE id = ?\r\n    `);\r\n    stmt.run(registration_status, verified_at?.toISOString() || null, now, facilitator_id);\r\n  }\r\n\r\n  logger.info({ facilitator_id, registration_status }, 'Facilitator status updated');\r\n}\r\n\r\n/**\r\n * Update canary traffic share\r\n */\r\nexport async function updateCanaryShare(\r\n  facilitator_id: string,\r\n  canary_traffic_share: number,\r\n  max_traffic_share?: number\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    if (max_traffic_share !== undefined) {\r\n      await (db as any).pool.query(\r\n        `UPDATE facilitators \r\n         SET canary_traffic_share = $1, max_traffic_share = $2, updated_at = $3\r\n         WHERE id = $4`,\r\n        [canary_traffic_share, max_traffic_share, now, facilitator_id]\r\n      );\r\n    } else {\r\n      await (db as any).pool.query(\r\n        `UPDATE facilitators \r\n         SET canary_traffic_share = $1, updated_at = $2\r\n         WHERE id = $3`,\r\n        [canary_traffic_share, now, facilitator_id]\r\n      );\r\n    }\r\n  } else {\r\n    if (max_traffic_share !== undefined) {\r\n      const stmt = (db as any).prepare(`\r\n        UPDATE facilitators \r\n        SET canary_traffic_share = ?, max_traffic_share = ?, updated_at = ?\r\n        WHERE id = ?\r\n      `);\r\n      stmt.run(canary_traffic_share, max_traffic_share, now, facilitator_id);\r\n    } else {\r\n      const stmt = (db as any).prepare(`\r\n        UPDATE facilitators \r\n        SET canary_traffic_share = ?, updated_at = ?\r\n        WHERE id = ?\r\n      `);\r\n      stmt.run(canary_traffic_share, now, facilitator_id);\r\n    }\r\n  }\r\n\r\n  logger.info({ facilitator_id, canary_traffic_share, max_traffic_share }, 'Canary share updated');\r\n}\r\n\r\n/**\r\n * List verified facilitators for routing\r\n */\r\nexport async function listVerifiedFacilitators(): Promise<FacilitatorRow[]> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitators \r\n       WHERE registration_status = 'verified'\r\n       ORDER BY canary_traffic_share DESC, verified_at ASC`\r\n    );\r\n    return result.rows;\r\n  } else {\r\n    const rows = (db as any).prepare(`\r\n      SELECT * FROM facilitators \r\n      WHERE registration_status = 'verified'\r\n      ORDER BY canary_traffic_share DESC, verified_at ASC\r\n    `).all();\r\n    return rows;\r\n  }\r\n}\r\n\r\n/**\r\n * List pending facilitators\r\n */\r\nexport async function listPendingFacilitators(): Promise<FacilitatorRow[]> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitators \r\n       WHERE registration_status = 'pending'\r\n       ORDER BY created_at ASC`\r\n    );\r\n    return result.rows;\r\n  } else {\r\n    const rows = (db as any).prepare(`\r\n      SELECT * FROM facilitators \r\n      WHERE registration_status = 'pending'\r\n      ORDER BY created_at ASC\r\n    `).all();\r\n    return rows;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// VERIFICATION ATTEMPTS\r\n// =============================================================================\r\n\r\n/**\r\n * Record a verification attempt\r\n */\r\nexport async function recordVerificationAttempt(params: {\r\n  facilitator_id: string;\r\n  attempt_type: 'dns_lookup' | 'registration' | 'callback_test';\r\n  status: 'success' | 'failed' | 'rate_limited' | 'cooldown';\r\n  ip_address: string;\r\n  details?: Record<string, unknown>;\r\n}): Promise<void> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    await (db as any).pool.query(\r\n      `INSERT INTO facilitator_verification_attempts \r\n       (id, facilitator_id, attempt_type, status, ip_address, details, created_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, $7)`,\r\n      [\r\n        id,\r\n        params.facilitator_id,\r\n        params.attempt_type,\r\n        params.status,\r\n        params.ip_address,\r\n        JSON.stringify(params.details || {}),\r\n        now,\r\n      ]\r\n    );\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO facilitator_verification_attempts \r\n      (id, facilitator_id, attempt_type, status, ip_address, details, created_at)\r\n      VALUES (?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      params.facilitator_id,\r\n      params.attempt_type,\r\n      params.status,\r\n      params.ip_address,\r\n      JSON.stringify(params.details || {}),\r\n      now\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Get recent verification attempts for rate limiting\r\n */\r\nexport async function getRecentVerificationAttempts(\r\n  facilitator_id: string,\r\n  attempt_type: string,\r\n  minutes_back: number = 60\r\n): Promise<VerificationAttempt[]> {\r\n  const db = getDb();\r\n  const cutoff = new Date(Date.now() - minutes_back * 60 * 1000).toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_verification_attempts \r\n       WHERE facilitator_id = $1 \r\n         AND attempt_type = $2 \r\n         AND created_at > $3\r\n       ORDER BY created_at DESC`,\r\n      [facilitator_id, attempt_type, cutoff]\r\n    );\r\n    return result.rows.map(rowToVerificationAttempt);\r\n  } else {\r\n    const rows = (db as any).prepare(`\r\n      SELECT * FROM facilitator_verification_attempts \r\n      WHERE facilitator_id = ? \r\n        AND attempt_type = ? \r\n        AND created_at > ?\r\n      ORDER BY created_at DESC\r\n    `).all(facilitator_id, attempt_type, cutoff);\r\n    return rows.map(rowToVerificationAttempt);\r\n  }\r\n}\r\n\r\nfunction rowToVerificationAttempt(row: any): VerificationAttempt {\r\n  return {\r\n    id: row.id,\r\n    facilitator_id: row.facilitator_id,\r\n    attempt_type: row.attempt_type,\r\n    status: row.status,\r\n    ip_address: row.ip_address,\r\n    details: typeof row.details === 'string' ? JSON.parse(row.details) : row.details,\r\n    created_at: new Date(row.created_at),\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// CANARY METRICS\r\n// =============================================================================\r\n\r\n/**\r\n * Record canary metrics for a period\r\n */\r\nexport async function recordCanaryMetrics(params: {\r\n  facilitator_id: string;\r\n  period_start: Date;\r\n  period_end: Date;\r\n  requests: number;\r\n  success_rate: number;\r\n  avg_latency_ms: number;\r\n  error_rate: number;\r\n}): Promise<CanaryMetricsRecord> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO canary_metrics \r\n       (id, facilitator_id, period_start, period_end, requests, success_rate, avg_latency_ms, error_rate, created_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\r\n       ON CONFLICT (facilitator_id, period_start, period_end) \r\n       DO UPDATE SET requests = $5, success_rate = $6, avg_latency_ms = $7, error_rate = $8\r\n       RETURNING *`,\r\n      [\r\n        id,\r\n        params.facilitator_id,\r\n        params.period_start.toISOString(),\r\n        params.period_end.toISOString(),\r\n        params.requests,\r\n        params.success_rate,\r\n        params.avg_latency_ms,\r\n        params.error_rate,\r\n        now,\r\n      ]\r\n    );\r\n    return rowToCanaryMetrics(result.rows[0]);\r\n  } else {\r\n    // SQLite: try insert, update on conflict\r\n    try {\r\n      const stmt = (db as any).prepare(`\r\n        INSERT INTO canary_metrics \r\n        (id, facilitator_id, period_start, period_end, requests, success_rate, avg_latency_ms, error_rate, created_at)\r\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n      `);\r\n      stmt.run(\r\n        id,\r\n        params.facilitator_id,\r\n        params.period_start.toISOString(),\r\n        params.period_end.toISOString(),\r\n        params.requests,\r\n        params.success_rate,\r\n        params.avg_latency_ms,\r\n        params.error_rate,\r\n        now\r\n      );\r\n    } catch {\r\n      // Update existing\r\n      const stmt = (db as any).prepare(`\r\n        UPDATE canary_metrics \r\n        SET requests = ?, success_rate = ?, avg_latency_ms = ?, error_rate = ?\r\n        WHERE facilitator_id = ? AND period_start = ? AND period_end = ?\r\n      `);\r\n      stmt.run(\r\n        params.requests,\r\n        params.success_rate,\r\n        params.avg_latency_ms,\r\n        params.error_rate,\r\n        params.facilitator_id,\r\n        params.period_start.toISOString(),\r\n        params.period_end.toISOString()\r\n      );\r\n    }\r\n\r\n    const row = (db as any).prepare(`\r\n      SELECT * FROM canary_metrics \r\n      WHERE facilitator_id = ? AND period_start = ?\r\n    `).get(params.facilitator_id, params.period_start.toISOString());\r\n    return rowToCanaryMetrics(row);\r\n  }\r\n}\r\n\r\n/**\r\n * Get canary metrics for a period\r\n */\r\nexport async function getCanaryMetricsForPeriod(\r\n  facilitator_id: string,\r\n  days_back: number = 7\r\n): Promise<CanaryMetricsRecord[]> {\r\n  const db = getDb();\r\n  const cutoff = new Date(Date.now() - days_back * 86400 * 1000).toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM canary_metrics \r\n       WHERE facilitator_id = $1 AND period_start >= $2\r\n       ORDER BY period_start DESC`,\r\n      [facilitator_id, cutoff]\r\n    );\r\n    return result.rows.map(rowToCanaryMetrics);\r\n  } else {\r\n    const rows = (db as any).prepare(`\r\n      SELECT * FROM canary_metrics \r\n      WHERE facilitator_id = ? AND period_start >= ?\r\n      ORDER BY period_start DESC\r\n    `).all(facilitator_id, cutoff);\r\n    return rows.map(rowToCanaryMetrics);\r\n  }\r\n}\r\n\r\nfunction rowToCanaryMetrics(row: any): CanaryMetricsRecord {\r\n  return {\r\n    id: row.id,\r\n    facilitator_id: row.facilitator_id,\r\n    period_start: new Date(row.period_start),\r\n    period_end: new Date(row.period_end),\r\n    requests: row.requests,\r\n    success_rate: row.success_rate,\r\n    avg_latency_ms: row.avg_latency_ms,\r\n    error_rate: row.error_rate,\r\n    created_at: new Date(row.created_at),\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// PROMOTIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Record a promotion event\r\n */\r\nexport async function recordPromotion(params: {\r\n  facilitator_id: string;\r\n  from_share: number;\r\n  to_share: number;\r\n  reason: 'auto_promotion' | 'manual' | 'demotion';\r\n  metrics_snapshot: Record<string, unknown>;\r\n}): Promise<FacilitatorPromotion> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO facilitator_promotions \r\n       (id, facilitator_id, from_share, to_share, reason, metrics_snapshot, promoted_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, $7)\r\n       RETURNING *`,\r\n      [\r\n        id,\r\n        params.facilitator_id,\r\n        params.from_share,\r\n        params.to_share,\r\n        params.reason,\r\n        JSON.stringify(params.metrics_snapshot),\r\n        now,\r\n      ]\r\n    );\r\n    return rowToPromotion(result.rows[0]);\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO facilitator_promotions \r\n      (id, facilitator_id, from_share, to_share, reason, metrics_snapshot, promoted_at)\r\n      VALUES (?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      params.facilitator_id,\r\n      params.from_share,\r\n      params.to_share,\r\n      params.reason,\r\n      JSON.stringify(params.metrics_snapshot),\r\n      now\r\n    );\r\n\r\n    const row = (db as any).prepare('SELECT * FROM facilitator_promotions WHERE id = ?').get(id);\r\n    return rowToPromotion(row);\r\n  }\r\n}\r\n\r\n/**\r\n * Get promotion history for a facilitator\r\n */\r\nexport async function getPromotionHistory(\r\n  facilitator_id: string,\r\n  limit: number = 10\r\n): Promise<FacilitatorPromotion[]> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_promotions \r\n       WHERE facilitator_id = $1\r\n       ORDER BY promoted_at DESC\r\n       LIMIT $2`,\r\n      [facilitator_id, limit]\r\n    );\r\n    return result.rows.map(rowToPromotion);\r\n  } else {\r\n    const rows = (db as any).prepare(`\r\n      SELECT * FROM facilitator_promotions \r\n      WHERE facilitator_id = ?\r\n      ORDER BY promoted_at DESC\r\n      LIMIT ?\r\n    `).all(facilitator_id, limit);\r\n    return rows.map(rowToPromotion);\r\n  }\r\n}\r\n\r\nfunction rowToPromotion(row: any): FacilitatorPromotion {\r\n  return {\r\n    id: row.id,\r\n    facilitator_id: row.facilitator_id,\r\n    from_share: row.from_share,\r\n    to_share: row.to_share,\r\n    reason: row.reason,\r\n    metrics_snapshot: typeof row.metrics_snapshot === 'string' \r\n      ? JSON.parse(row.metrics_snapshot) \r\n      : row.metrics_snapshot,\r\n    promoted_at: new Date(row.promoted_at),\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// CALLBACK TESTS\r\n// =============================================================================\r\n\r\n/**\r\n * Record a callback test result\r\n */\r\nexport async function recordCallbackTest(params: {\r\n  facilitator_id: string;\r\n  status: 'success' | 'failed' | 'timeout';\r\n  response_code?: number;\r\n  response_time_ms?: number;\r\n  error_message?: string;\r\n}): Promise<void> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres(db)) {\r\n    await (db as any).pool.query(\r\n      `INSERT INTO facilitator_callback_tests \r\n       (id, facilitator_id, status, response_code, response_time_ms, error_message, created_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, $7)`,\r\n      [\r\n        id,\r\n        params.facilitator_id,\r\n        params.status,\r\n        params.response_code || null,\r\n        params.response_time_ms || null,\r\n        params.error_message || null,\r\n        now,\r\n      ]\r\n    );\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO facilitator_callback_tests \r\n      (id, facilitator_id, status, response_code, response_time_ms, error_message, created_at)\r\n      VALUES (?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      params.facilitator_id,\r\n      params.status,\r\n      params.response_code || null,\r\n      params.response_time_ms || null,\r\n      params.error_message || null,\r\n      now\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Get recent callback tests\r\n */\r\nexport async function getRecentCallbackTests(\r\n  facilitator_id: string,\r\n  limit: number = 10\r\n): Promise<CallbackTestRecord[]> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_callback_tests \r\n       WHERE facilitator_id = $1\r\n       ORDER BY created_at DESC\r\n       LIMIT $2`,\r\n      [facilitator_id, limit]\r\n    );\r\n    return result.rows.map(rowToCallbackTest);\r\n  } else {\r\n    const rows = (db as any).prepare(`\r\n      SELECT * FROM facilitator_callback_tests \r\n      WHERE facilitator_id = ?\r\n      ORDER BY created_at DESC\r\n      LIMIT ?\r\n    `).all(facilitator_id, limit);\r\n    return rows.map(rowToCallbackTest);\r\n  }\r\n}\r\n\r\nfunction rowToCallbackTest(row: any): CallbackTestRecord {\r\n  return {\r\n    id: row.id,\r\n    facilitator_id: row.facilitator_id,\r\n    status: row.status,\r\n    response_code: row.response_code,\r\n    response_time_ms: row.response_time_ms,\r\n    error_message: row.error_message,\r\n    created_at: new Date(row.created_at),\r\n  };\r\n}\r\n\r\n","// =============================================================================\r\n// Facilitator Registration Types\r\n// =============================================================================\r\n// Types for self-service facilitator registration, DNS attestation,\r\n// canary traffic deployment, and automatic promotion.\r\n\r\n// =============================================================================\r\n// REGISTRATION\r\n// =============================================================================\r\n\r\n/**\r\n * Request body for POST /api/v1/smf/register\r\n */\r\nexport interface FacilitatorRegistrationRequest {\r\n  /** Human-readable name for the facilitator */\r\n  name: string;\r\n  /** Domain for DNS verification (e.g., \"facilitator.example.com\") */\r\n  domain: string;\r\n  /** DNS TXT proof value (e.g., \"nexflow-verify=abc123xyz\") */\r\n  dns_txt_proof: string;\r\n  /** Callback URL for payment notifications (must be HTTPS) */\r\n  callback_url: string;\r\n  /** Supported blockchain networks (e.g., [\"base:mainnet\", \"polygon:mainnet\"]) */\r\n  supported_chains: string[];\r\n  /** Supported tokens (e.g., [\"USDC\", \"USDT\"]) */\r\n  supported_tokens: string[];\r\n}\r\n\r\n/**\r\n * Response from POST /api/v1/smf/register\r\n */\r\nexport interface FacilitatorRegistrationResponse {\r\n  /** Unique facilitator ID */\r\n  facilitator_id: string;\r\n  /** Current registration status */\r\n  status: RegistrationStatus;\r\n  /** Whether DNS verification is required */\r\n  dns_verification_required: boolean;\r\n  /** DNS record to add for verification */\r\n  dns_record: {\r\n    type: 'TXT';\r\n    name: string;   // e.g., \"_nexflow.facilitator.example.com\"\r\n    value: string;  // dns_txt_proof value\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// DNS VERIFICATION\r\n// =============================================================================\r\n\r\n/**\r\n * Response from GET /api/v1/smf/register/verify?id={facilitator_id}\r\n */\r\nexport interface VerifyDNSResponse {\r\n  /** Facilitator ID */\r\n  facilitator_id: string;\r\n  /** Resulting status after verification attempt */\r\n  status: RegistrationStatus;\r\n  /** When verification was completed (if successful) */\r\n  verified_at?: Date;\r\n  /** Current canary traffic share (0-1) */\r\n  canary_traffic_share: number;\r\n  /** Maximum traffic share cap (0-1) */\r\n  max_traffic_share: number;\r\n  /** Error message if verification failed */\r\n  error?: string;\r\n  /** Next allowed verification attempt (if rate limited) */\r\n  next_attempt_at?: Date;\r\n}\r\n\r\n// =============================================================================\r\n// CANARY METRICS & PROMOTION\r\n// =============================================================================\r\n\r\n/**\r\n * Canary promotion metrics for a facilitator\r\n */\r\nexport interface CanaryPromotionMetrics {\r\n  /** Number of days the facilitator has been running */\r\n  days_running: number;\r\n  /** Average success rate (0-1) */\r\n  success_rate: number;\r\n  /** Average latency in milliseconds */\r\n  avg_latency_ms: number;\r\n  /** Total requests processed */\r\n  requests_processed: number;\r\n  /** Average error rate (0-1) */\r\n  error_rate: number;\r\n  /** When the next promotion review occurs */\r\n  next_review_at: Date;\r\n  /** Whether facilitator is eligible for promotion */\r\n  eligible_for_promotion: boolean;\r\n  /** Reason for promotion eligibility (or why not) */\r\n  promotion_reason?: string;\r\n}\r\n\r\n/**\r\n * Promotion thresholds configuration\r\n */\r\nexport interface PromotionThresholds {\r\n  /** Minimum days running before promotion */\r\n  min_days: number;\r\n  /** Minimum success rate for promotion (0-1) */\r\n  min_success_rate: number;\r\n  /** Maximum error rate allowed (0-1) */\r\n  max_error_rate: number;\r\n  /** Minimum requests processed */\r\n  min_requests: number;\r\n}\r\n\r\n/**\r\n * Default promotion thresholds\r\n */\r\nexport const DEFAULT_PROMOTION_THRESHOLDS: PromotionThresholds = {\r\n  min_days: 7,\r\n  min_success_rate: 0.95,\r\n  max_error_rate: 0.05,\r\n  min_requests: 100,\r\n};\r\n\r\n/**\r\n * Promotion levels configuration\r\n */\r\nexport const PROMOTION_LEVELS: Array<{ share: number; min_requests: number }> = [\r\n  { share: 0.01, min_requests: 0 },      // Initial: 1%\r\n  { share: 0.05, min_requests: 100 },    // Level 1: 5%\r\n  { share: 0.20, min_requests: 500 },    // Level 2: 20%\r\n];\r\n\r\n// =============================================================================\r\n// FACILITATOR STATUS\r\n// =============================================================================\r\n\r\n/**\r\n * Registration status values\r\n */\r\nexport type RegistrationStatus = 'pending' | 'verified' | 'rejected' | 'paused';\r\n\r\n/**\r\n * Full facilitator status response\r\n */\r\nexport interface FacilitatorStatusResponse {\r\n  /** Unique facilitator ID */\r\n  facilitator_id: string;\r\n  /** Human-readable name */\r\n  name: string;\r\n  /** Registered domain */\r\n  domain: string;\r\n  /** Base URL for x402 API */\r\n  base_url?: string;\r\n  /** Registration status */\r\n  registration_status: RegistrationStatus;\r\n  /** When DNS verification was completed */\r\n  verified_at?: Date;\r\n  /** Current canary traffic share (0-1) */\r\n  canary_traffic_share: number;\r\n  /** Maximum traffic share cap (0-1) */\r\n  max_traffic_share: number;\r\n  /** Canary metrics if available */\r\n  canary_metrics?: CanaryPromotionMetrics;\r\n  /** Supported blockchain networks */\r\n  supported_chains: string[];\r\n  /** Supported tokens */\r\n  supported_tokens: string[];\r\n  /** When facilitator was created */\r\n  created_at: Date;\r\n}\r\n\r\n// =============================================================================\r\n// DATABASE ENTITIES\r\n// =============================================================================\r\n\r\n/**\r\n * Facilitator row from database (with registration columns)\r\n */\r\nexport interface FacilitatorRow {\r\n  id: string;\r\n  name: string;\r\n  status: string;\r\n  base_url: string;\r\n  priority: number;\r\n  domain?: string;\r\n  dns_txt_proof?: string;\r\n  callback_url?: string;\r\n  verified_at?: Date;\r\n  registration_status: RegistrationStatus;\r\n  canary_traffic_share: number;\r\n  max_traffic_share: number;\r\n  supported_chains: string;  // JSON string\r\n  supported_tokens: string;  // JSON string\r\n  registered_by?: string;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\n/**\r\n * Verification attempt record\r\n */\r\nexport interface VerificationAttempt {\r\n  id: string;\r\n  facilitator_id: string;\r\n  attempt_type: 'dns_lookup' | 'registration' | 'callback_test';\r\n  status: 'success' | 'failed' | 'rate_limited' | 'cooldown';\r\n  ip_address: string;\r\n  details: Record<string, unknown>;\r\n  created_at: Date;\r\n}\r\n\r\n/**\r\n * Canary metrics record\r\n */\r\nexport interface CanaryMetricsRecord {\r\n  id: string;\r\n  facilitator_id: string;\r\n  period_start: Date;\r\n  period_end: Date;\r\n  requests: number;\r\n  success_rate: number;\r\n  avg_latency_ms: number;\r\n  error_rate: number;\r\n  created_at: Date;\r\n}\r\n\r\n/**\r\n * Promotion history record\r\n */\r\nexport interface FacilitatorPromotion {\r\n  id: string;\r\n  facilitator_id: string;\r\n  from_share: number;\r\n  to_share: number;\r\n  reason: 'auto_promotion' | 'manual' | 'demotion';\r\n  metrics_snapshot: Record<string, unknown>;\r\n  promoted_at: Date;\r\n}\r\n\r\n/**\r\n * Callback test record\r\n */\r\nexport interface CallbackTestRecord {\r\n  id: string;\r\n  facilitator_id: string;\r\n  status: 'success' | 'failed' | 'timeout';\r\n  response_code?: number;\r\n  response_time_ms?: number;\r\n  error_message?: string;\r\n  created_at: Date;\r\n}\r\n\r\n// =============================================================================\r\n// RATE LIMITING\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit configuration\r\n */\r\nexport interface RateLimitConfig {\r\n  /** Maximum attempts per window */\r\n  max_attempts: number;\r\n  /** Window duration in minutes */\r\n  window_minutes: number;\r\n  /** Cooldown between attempts in minutes */\r\n  cooldown_minutes: number;\r\n}\r\n\r\n/**\r\n * Default rate limit configuration\r\n */\r\nexport const DEFAULT_RATE_LIMIT: RateLimitConfig = {\r\n  max_attempts: 5,\r\n  window_minutes: 60,\r\n  cooldown_minutes: 10,\r\n};\r\n\r\n// =============================================================================\r\n// VALIDATION\r\n// =============================================================================\r\n\r\n/**\r\n * Validate registration request\r\n */\r\nexport function isValidRegistrationRequest(body: unknown): body is FacilitatorRegistrationRequest {\r\n  if (!body || typeof body !== 'object') return false;\r\n  const req = body as Record<string, unknown>;\r\n\r\n  // Required string fields\r\n  if (typeof req.name !== 'string' || !req.name.trim()) return false;\r\n  if (typeof req.domain !== 'string' || !req.domain.trim()) return false;\r\n  if (typeof req.dns_txt_proof !== 'string' || !req.dns_txt_proof.trim()) return false;\r\n  if (typeof req.callback_url !== 'string' || !req.callback_url.trim()) return false;\r\n\r\n  // Validate domain format (basic check)\r\n  if (!/^[a-z0-9]([a-z0-9-]*[a-z0-9])?(\\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i.test(req.domain as string)) {\r\n    return false;\r\n  }\r\n\r\n  // Validate callback URL is HTTPS\r\n  try {\r\n    const url = new URL(req.callback_url as string);\r\n    if (url.protocol !== 'https:') return false;\r\n  } catch {\r\n    return false;\r\n  }\r\n\r\n  // Validate dns_txt_proof format (should start with \"nexflow-verify=\")\r\n  if (!(req.dns_txt_proof as string).startsWith('nexflow-verify=')) {\r\n    return false;\r\n  }\r\n\r\n  // Required arrays\r\n  if (!Array.isArray(req.supported_chains) || req.supported_chains.length === 0) return false;\r\n  if (!Array.isArray(req.supported_tokens) || req.supported_tokens.length === 0) return false;\r\n\r\n  // Validate array contents are strings\r\n  if (!req.supported_chains.every((c: unknown) => typeof c === 'string')) return false;\r\n  if (!req.supported_tokens.every((t: unknown) => typeof t === 'string')) return false;\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Generate a DNS proof value\r\n */\r\nexport function generateDNSProof(): string {\r\n  const random = Math.random().toString(36).substring(2, 15);\r\n  return `nexflow-verify=${random}${Date.now().toString(36)}`;\r\n}\r\n\r\n","// =============================================================================\r\n// FacilitatorRegistry Service\r\n// =============================================================================\r\n// Handles facilitator registration, DNS verification, callback validation,\r\n// and automatic canary promotion based on performance metrics.\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport {\r\n  createFacilitatorRegistration,\r\n  getFacilitatorById,\r\n  getFacilitatorByDomain,\r\n  updateFacilitatorStatus,\r\n  updateCanaryShare,\r\n  recordVerificationAttempt,\r\n  getRecentVerificationAttempts,\r\n  recordCanaryMetrics,\r\n  getCanaryMetricsForPeriod,\r\n  recordPromotion,\r\n  recordCallbackTest,\r\n} from '@/db/facilitator-registration';\r\nimport {\r\n  type FacilitatorRegistrationRequest,\r\n  type FacilitatorRegistrationResponse,\r\n  type VerifyDNSResponse,\r\n  type FacilitatorStatusResponse,\r\n  type CanaryPromotionMetrics,\r\n  type FacilitatorRow,\r\n  DEFAULT_RATE_LIMIT,\r\n  DEFAULT_PROMOTION_THRESHOLDS,\r\n  PROMOTION_LEVELS,\r\n} from '@/types/facilitator-registration';\r\n\r\nconst logger = createLogger({ component: 'FacilitatorRegistry' });\r\n\r\n// =============================================================================\r\n// DNS Provider Interface\r\n// =============================================================================\r\n\r\n/**\r\n * DNS provider interface for dependency injection\r\n */\r\nexport interface DNSProvider {\r\n  resolveTxt(hostname: string): Promise<string[][]>;\r\n}\r\n\r\n/**\r\n * Default DNS provider using Node.js dns.promises\r\n */\r\nexport const defaultDNSProvider: DNSProvider = {\r\n  resolveTxt: async (hostname: string): Promise<string[][]> => {\r\n    // Dynamic import to avoid issues in browser environments\r\n    const dns = await import('dns').then(m => m.promises);\r\n    return dns.resolveTxt(hostname);\r\n  },\r\n};\r\n\r\n// =============================================================================\r\n// FacilitatorRegistry Class\r\n// =============================================================================\r\n\r\nexport class FacilitatorRegistry {\r\n  private dnsProvider: DNSProvider;\r\n\r\n  constructor(dnsProvider: DNSProvider = defaultDNSProvider) {\r\n    this.dnsProvider = dnsProvider;\r\n  }\r\n\r\n  // ===========================================================================\r\n  // REGISTRATION\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Register a new facilitator with pending status.\r\n   * Returns DNS record instructions for verification.\r\n   */\r\n  async register(\r\n    params: FacilitatorRegistrationRequest,\r\n    registeredBy: string\r\n  ): Promise<FacilitatorRegistrationResponse> {\r\n    logger.info({ domain: params.domain, name: params.name }, 'Registering new facilitator');\r\n\r\n    // Check domain not already registered\r\n    const existing = await getFacilitatorByDomain(params.domain);\r\n    if (existing) {\r\n      throw new Error('DOMAIN_ALREADY_REGISTERED');\r\n    }\r\n\r\n    // Create registration record\r\n    const facilitator = await createFacilitatorRegistration({\r\n      name: params.name,\r\n      domain: params.domain,\r\n      dns_txt_proof: params.dns_txt_proof,\r\n      callback_url: params.callback_url,\r\n      supported_chains: params.supported_chains,\r\n      supported_tokens: params.supported_tokens,\r\n      registered_by: registeredBy,\r\n    });\r\n\r\n    logger.info({ facilitator_id: facilitator.id, domain: params.domain }, 'Facilitator registered');\r\n\r\n    return {\r\n      facilitator_id: facilitator.id,\r\n      status: 'pending',\r\n      dns_verification_required: true,\r\n      dns_record: {\r\n        type: 'TXT',\r\n        name: `_nexflow.${params.domain}`,\r\n        value: params.dns_txt_proof,\r\n      },\r\n    };\r\n  }\r\n\r\n  // ===========================================================================\r\n  // DNS VERIFICATION\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Verify DNS + callback, transition to verified if both pass.\r\n   * Implements rate limiting + cooldown.\r\n   */\r\n  async verifyDNS(\r\n    facilitator_id: string,\r\n    ipAddress: string\r\n  ): Promise<VerifyDNSResponse> {\r\n    logger.info({ facilitator_id, ipAddress }, 'Starting DNS verification');\r\n\r\n    // Get facilitator\r\n    const facilitator = await getFacilitatorById(facilitator_id);\r\n    if (!facilitator) {\r\n      throw new Error('FACILITATOR_NOT_FOUND');\r\n    }\r\n\r\n    // Already verified? Return success\r\n    if (facilitator.registration_status === 'verified') {\r\n      return {\r\n        facilitator_id,\r\n        status: 'verified',\r\n        verified_at: facilitator.verified_at ? new Date(facilitator.verified_at) : undefined,\r\n        canary_traffic_share: facilitator.canary_traffic_share,\r\n        max_traffic_share: facilitator.max_traffic_share,\r\n      };\r\n    }\r\n\r\n    // Check rate limit\r\n    const rateLimitResult = await this.checkRateLimit(facilitator_id, 'dns_lookup', ipAddress);\r\n    if (rateLimitResult.limited) {\r\n      return {\r\n        facilitator_id,\r\n        status: 'pending',\r\n        canary_traffic_share: facilitator.canary_traffic_share,\r\n        max_traffic_share: facilitator.max_traffic_share,\r\n        error: rateLimitResult.error,\r\n        next_attempt_at: rateLimitResult.next_attempt_at,\r\n      };\r\n    }\r\n\r\n    // Perform DNS lookup\r\n    let dnsValid = false;\r\n    let dnsError: string | undefined;\r\n\r\n    try {\r\n      const dnsName = `_nexflow.${facilitator.domain}`;\r\n      logger.debug({ dnsName }, 'Looking up DNS TXT record');\r\n\r\n      const records = await this.dnsProvider.resolveTxt(dnsName);\r\n\r\n      // Check if dns_txt_proof appears in any TXT record\r\n      dnsValid = records.some((record: string[]) =>\r\n        record.join('').includes(facilitator.dns_txt_proof || '')\r\n      );\r\n\r\n      if (!dnsValid) {\r\n        dnsError = 'DNS TXT record does not match expected proof';\r\n        logger.debug({ dnsName, expected: facilitator.dns_txt_proof, found: records }, 'DNS proof mismatch');\r\n      }\r\n    } catch (error) {\r\n      dnsError = `DNS lookup failed: ${error instanceof Error ? error.message : 'Unknown error'}`;\r\n      logger.debug({ error, domain: facilitator.domain }, 'DNS lookup failed');\r\n    }\r\n\r\n    if (!dnsValid) {\r\n      await recordVerificationAttempt({\r\n        facilitator_id,\r\n        attempt_type: 'dns_lookup',\r\n        status: 'failed',\r\n        ip_address: ipAddress,\r\n        details: { error: dnsError },\r\n      });\r\n\r\n      return {\r\n        facilitator_id,\r\n        status: 'pending',\r\n        canary_traffic_share: facilitator.canary_traffic_share,\r\n        max_traffic_share: facilitator.max_traffic_share,\r\n        error: dnsError,\r\n      };\r\n    }\r\n\r\n    // DNS passed; now validate callback\r\n    const callbackResult = await this.validateCallback(facilitator_id, facilitator.callback_url || '');\r\n\r\n    if (!callbackResult.valid) {\r\n      return {\r\n        facilitator_id,\r\n        status: 'pending',\r\n        canary_traffic_share: facilitator.canary_traffic_share,\r\n        max_traffic_share: facilitator.max_traffic_share,\r\n        error: callbackResult.error,\r\n      };\r\n    }\r\n\r\n    // Both DNS and callback passed; mark as verified\r\n    await recordVerificationAttempt({\r\n      facilitator_id,\r\n      attempt_type: 'dns_lookup',\r\n      status: 'success',\r\n      ip_address: ipAddress,\r\n    });\r\n\r\n    const verifiedAt = new Date();\r\n    await updateFacilitatorStatus(facilitator_id, 'verified', verifiedAt);\r\n\r\n    logger.info({ facilitator_id, domain: facilitator.domain }, 'Facilitator verified');\r\n\r\n    return {\r\n      facilitator_id,\r\n      status: 'verified',\r\n      verified_at: verifiedAt,\r\n      canary_traffic_share: facilitator.canary_traffic_share,\r\n      max_traffic_share: facilitator.max_traffic_share,\r\n    };\r\n  }\r\n\r\n  // ===========================================================================\r\n  // RATE LIMITING\r\n  // ===========================================================================\r\n\r\n  private async checkRateLimit(\r\n    facilitator_id: string,\r\n    attempt_type: string,\r\n    ipAddress: string\r\n  ): Promise<{ limited: boolean; error?: string; next_attempt_at?: Date }> {\r\n    const recentAttempts = await getRecentVerificationAttempts(\r\n      facilitator_id,\r\n      attempt_type,\r\n      DEFAULT_RATE_LIMIT.window_minutes\r\n    );\r\n\r\n    // Max attempts check\r\n    if (recentAttempts.length >= DEFAULT_RATE_LIMIT.max_attempts) {\r\n      await recordVerificationAttempt({\r\n        facilitator_id,\r\n        attempt_type: attempt_type as any,\r\n        status: 'rate_limited',\r\n        ip_address: ipAddress,\r\n      });\r\n\r\n      logger.warn({ facilitator_id, attempts: recentAttempts.length }, 'Rate limit exceeded');\r\n\r\n      return {\r\n        limited: true,\r\n        error: `Rate limit exceeded: max ${DEFAULT_RATE_LIMIT.max_attempts} attempts per hour`,\r\n      };\r\n    }\r\n\r\n    // Cooldown check\r\n    if (recentAttempts.length > 0) {\r\n      const lastAttempt = recentAttempts[0].created_at;\r\n      const minutesSinceLast = (Date.now() - lastAttempt.getTime()) / 60000;\r\n\r\n      if (minutesSinceLast < DEFAULT_RATE_LIMIT.cooldown_minutes) {\r\n        const nextAttemptAt = new Date(\r\n          lastAttempt.getTime() + DEFAULT_RATE_LIMIT.cooldown_minutes * 60000\r\n        );\r\n\r\n        await recordVerificationAttempt({\r\n          facilitator_id,\r\n          attempt_type: attempt_type as any,\r\n          status: 'cooldown',\r\n          ip_address: ipAddress,\r\n          details: { next_attempt_at: nextAttemptAt.toISOString() },\r\n        });\r\n\r\n        logger.debug({ facilitator_id, nextAttemptAt }, 'Cooldown active');\r\n\r\n        return {\r\n          limited: true,\r\n          error: `Cooldown active: wait ${Math.ceil(DEFAULT_RATE_LIMIT.cooldown_minutes - minutesSinceLast)} minutes`,\r\n          next_attempt_at: nextAttemptAt,\r\n        };\r\n      }\r\n    }\r\n\r\n    return { limited: false };\r\n  }\r\n\r\n  // ===========================================================================\r\n  // CALLBACK VALIDATION\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Validate callback URL is reachable and responds correctly.\r\n   */\r\n  private async validateCallback(\r\n    facilitator_id: string,\r\n    callback_url: string\r\n  ): Promise<{ valid: boolean; error?: string }> {\r\n    if (!callback_url) {\r\n      return { valid: false, error: 'No callback URL configured' };\r\n    }\r\n\r\n    logger.debug({ facilitator_id, callback_url }, 'Testing callback URL');\r\n\r\n    try {\r\n      const testPayload = {\r\n        event: 'test_ping',\r\n        timestamp: new Date().toISOString(),\r\n        facilitator_id,\r\n        test: true,\r\n      };\r\n\r\n      const controller = new AbortController();\r\n      const timeoutId = setTimeout(() => controller.abort(), 5000);\r\n\r\n      const startTime = Date.now();\r\n\r\n      try {\r\n        const response = await fetch(callback_url, {\r\n          method: 'POST',\r\n          headers: { \r\n            'Content-Type': 'application/json',\r\n            'User-Agent': 'NexFlow-Verification/1.0',\r\n          },\r\n          body: JSON.stringify(testPayload),\r\n          signal: controller.signal,\r\n        });\r\n\r\n        const responseTime = Date.now() - startTime;\r\n\r\n        if (!response.ok) {\r\n          await recordCallbackTest({\r\n            facilitator_id,\r\n            status: 'failed',\r\n            response_code: response.status,\r\n            response_time_ms: responseTime,\r\n            error_message: `HTTP ${response.status}`,\r\n          });\r\n\r\n          return {\r\n            valid: false,\r\n            error: `Callback returned HTTP ${response.status}`,\r\n          };\r\n        }\r\n\r\n        await recordCallbackTest({\r\n          facilitator_id,\r\n          status: 'success',\r\n          response_code: response.status,\r\n          response_time_ms: responseTime,\r\n        });\r\n\r\n        logger.debug({ facilitator_id, responseTime }, 'Callback test successful');\r\n        return { valid: true };\r\n      } finally {\r\n        clearTimeout(timeoutId);\r\n      }\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      const isTimeout = error instanceof DOMException && error.name === 'AbortError';\r\n\r\n      await recordCallbackTest({\r\n        facilitator_id,\r\n        status: isTimeout ? 'timeout' : 'failed',\r\n        error_message: errorMessage,\r\n      });\r\n\r\n      logger.debug({ facilitator_id, error: errorMessage }, 'Callback test failed');\r\n\r\n      return {\r\n        valid: false,\r\n        error: isTimeout ? 'Callback request timed out (5s)' : `Callback error: ${errorMessage}`,\r\n      };\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // CANARY PROMOTION\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Evaluate if facilitator should be promoted based on canary metrics.\r\n   * Auto-promotion: 1% → 5% → 20% after 7 days of >95% success.\r\n   */\r\n  async evaluateCanaryPromotion(facilitator_id: string): Promise<boolean> {\r\n    logger.debug({ facilitator_id }, 'Evaluating canary promotion');\r\n\r\n    // Get facilitator\r\n    const facilitator = await getFacilitatorById(facilitator_id);\r\n    if (!facilitator) {\r\n      logger.warn({ facilitator_id }, 'Facilitator not found for promotion evaluation');\r\n      return false;\r\n    }\r\n\r\n    // Must be verified\r\n    if (facilitator.registration_status !== 'verified') {\r\n      return false;\r\n    }\r\n\r\n    // Get metrics for last N days\r\n    const metrics = await getCanaryMetricsForPeriod(\r\n      facilitator_id,\r\n      DEFAULT_PROMOTION_THRESHOLDS.min_days\r\n    );\r\n\r\n    // Not enough data\r\n    if (metrics.length < DEFAULT_PROMOTION_THRESHOLDS.min_days) {\r\n      logger.debug({ facilitator_id, days: metrics.length }, 'Not enough data for promotion');\r\n      return false;\r\n    }\r\n\r\n    // Calculate averages\r\n    const avgSuccessRate = metrics.reduce((sum, m) => sum + m.success_rate, 0) / metrics.length;\r\n    const avgErrorRate = metrics.reduce((sum, m) => sum + m.error_rate, 0) / metrics.length;\r\n    const totalRequests = metrics.reduce((sum, m) => sum + m.requests, 0);\r\n\r\n    // Check promotion criteria\r\n    const isPromotionReady =\r\n      avgSuccessRate >= DEFAULT_PROMOTION_THRESHOLDS.min_success_rate &&\r\n      avgErrorRate <= DEFAULT_PROMOTION_THRESHOLDS.max_error_rate &&\r\n      totalRequests >= DEFAULT_PROMOTION_THRESHOLDS.min_requests;\r\n\r\n    if (!isPromotionReady) {\r\n      logger.debug({\r\n        facilitator_id,\r\n        avgSuccessRate,\r\n        avgErrorRate,\r\n        totalRequests,\r\n      }, 'Not eligible for promotion');\r\n      return false;\r\n    }\r\n\r\n    // Determine new share based on current level\r\n    const currentShare = facilitator.canary_traffic_share;\r\n    let newShare = currentShare;\r\n\r\n    // Find next promotion level\r\n    for (let i = 0; i < PROMOTION_LEVELS.length - 1; i++) {\r\n      if (currentShare <= PROMOTION_LEVELS[i].share && totalRequests >= PROMOTION_LEVELS[i + 1].min_requests) {\r\n        newShare = Math.min(PROMOTION_LEVELS[i + 1].share, facilitator.max_traffic_share);\r\n        break;\r\n      }\r\n    }\r\n\r\n    // No promotion available\r\n    if (newShare <= currentShare) {\r\n      logger.debug({ facilitator_id, currentShare }, 'Already at max promotion level');\r\n      return false;\r\n    }\r\n\r\n    // Record promotion\r\n    await recordPromotion({\r\n      facilitator_id,\r\n      from_share: currentShare,\r\n      to_share: newShare,\r\n      reason: 'auto_promotion',\r\n      metrics_snapshot: {\r\n        avg_success_rate: avgSuccessRate,\r\n        avg_error_rate: avgErrorRate,\r\n        total_requests: totalRequests,\r\n        days_running: metrics.length,\r\n      },\r\n    });\r\n\r\n    // Update facilitator\r\n    await updateCanaryShare(facilitator_id, newShare);\r\n\r\n    logger.info({\r\n      facilitator_id,\r\n      from_share: currentShare,\r\n      to_share: newShare,\r\n    }, 'Facilitator promoted');\r\n\r\n    return true;\r\n  }\r\n\r\n  // ===========================================================================\r\n  // STATUS QUERIES\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get facilitator status including canary metrics.\r\n   */\r\n  async getFacilitatorStatus(facilitator_id: string): Promise<FacilitatorStatusResponse> {\r\n    const facilitator = await getFacilitatorById(facilitator_id);\r\n    if (!facilitator) {\r\n      throw new Error('FACILITATOR_NOT_FOUND');\r\n    }\r\n\r\n    // Get recent metrics\r\n    const metrics = await getCanaryMetricsForPeriod(facilitator_id, 7);\r\n\r\n    let canaryMetrics: CanaryPromotionMetrics | undefined;\r\n\r\n    if (metrics.length > 0) {\r\n      const avgSuccessRate = metrics.reduce((sum, m) => sum + m.success_rate, 0) / metrics.length;\r\n      const avgErrorRate = metrics.reduce((sum, m) => sum + m.error_rate, 0) / metrics.length;\r\n      const avgLatency = metrics.reduce((sum, m) => sum + m.avg_latency_ms, 0) / metrics.length;\r\n      const totalRequests = metrics.reduce((sum, m) => sum + m.requests, 0);\r\n\r\n      const isEligible =\r\n        avgSuccessRate >= DEFAULT_PROMOTION_THRESHOLDS.min_success_rate &&\r\n        avgErrorRate <= DEFAULT_PROMOTION_THRESHOLDS.max_error_rate &&\r\n        totalRequests >= DEFAULT_PROMOTION_THRESHOLDS.min_requests &&\r\n        metrics.length >= DEFAULT_PROMOTION_THRESHOLDS.min_days;\r\n\r\n      canaryMetrics = {\r\n        days_running: metrics.length,\r\n        success_rate: avgSuccessRate,\r\n        avg_latency_ms: avgLatency,\r\n        requests_processed: totalRequests,\r\n        error_rate: avgErrorRate,\r\n        next_review_at: new Date(Date.now() + 86400000), // 1 day\r\n        eligible_for_promotion: isEligible,\r\n        promotion_reason: isEligible\r\n          ? `Consistent ${Math.round(avgSuccessRate * 100)}% success over ${metrics.length} days`\r\n          : undefined,\r\n      };\r\n    }\r\n\r\n    return {\r\n      facilitator_id,\r\n      name: facilitator.name,\r\n      domain: facilitator.domain || '',\r\n      base_url: facilitator.base_url,\r\n      registration_status: facilitator.registration_status,\r\n      verified_at: facilitator.verified_at ? new Date(facilitator.verified_at) : undefined,\r\n      canary_traffic_share: facilitator.canary_traffic_share,\r\n      max_traffic_share: facilitator.max_traffic_share,\r\n      canary_metrics: canaryMetrics,\r\n      supported_chains: parseJsonArray(facilitator.supported_chains),\r\n      supported_tokens: parseJsonArray(facilitator.supported_tokens),\r\n      created_at: new Date(facilitator.created_at),\r\n    };\r\n  }\r\n\r\n  // ===========================================================================\r\n  // MANUAL CONTROLS\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Pause a facilitator (stops receiving traffic)\r\n   */\r\n  async pause(facilitator_id: string): Promise<void> {\r\n    const facilitator = await getFacilitatorById(facilitator_id);\r\n    if (!facilitator) {\r\n      throw new Error('FACILITATOR_NOT_FOUND');\r\n    }\r\n\r\n    await updateFacilitatorStatus(facilitator_id, 'paused');\r\n    logger.info({ facilitator_id }, 'Facilitator paused');\r\n  }\r\n\r\n  /**\r\n   * Resume a paused facilitator\r\n   */\r\n  async resume(facilitator_id: string): Promise<void> {\r\n    const facilitator = await getFacilitatorById(facilitator_id);\r\n    if (!facilitator) {\r\n      throw new Error('FACILITATOR_NOT_FOUND');\r\n    }\r\n\r\n    if (facilitator.registration_status !== 'paused') {\r\n      throw new Error('FACILITATOR_NOT_PAUSED');\r\n    }\r\n\r\n    await updateFacilitatorStatus(facilitator_id, 'verified', new Date(facilitator.verified_at || Date.now()));\r\n    logger.info({ facilitator_id }, 'Facilitator resumed');\r\n  }\r\n\r\n  /**\r\n   * Reject a facilitator registration\r\n   */\r\n  async reject(facilitator_id: string, reason?: string): Promise<void> {\r\n    const facilitator = await getFacilitatorById(facilitator_id);\r\n    if (!facilitator) {\r\n      throw new Error('FACILITATOR_NOT_FOUND');\r\n    }\r\n\r\n    await updateFacilitatorStatus(facilitator_id, 'rejected');\r\n    logger.info({ facilitator_id, reason }, 'Facilitator rejected');\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\nfunction parseJsonArray(value: string | null | undefined): string[] {\r\n  if (!value) return [];\r\n  try {\r\n    const parsed = typeof value === 'string' ? JSON.parse(value) : value;\r\n    return Array.isArray(parsed) ? parsed : [];\r\n  } catch {\r\n    return [];\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// SINGLETON INSTANCE\r\n// =============================================================================\r\n\r\nlet registryInstance: FacilitatorRegistry | null = null;\r\n\r\nexport function getFacilitatorRegistry(): FacilitatorRegistry {\r\n  if (!registryInstance) {\r\n    registryInstance = new FacilitatorRegistry();\r\n  }\r\n  return registryInstance;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}