{"version":3,"sources":["../../../packages/sdk/src/errors.ts","../../../packages/sdk/src/webhooks.ts","../../../packages/sdk/src/facilitator.ts","../../../packages/sdk/src/index.ts","../../../src/payments/smfClient.ts","../../../src/db/smf-payments.ts"],"sourcesContent":["// =============================================================================\r\n// SMF SDK Errors\r\n// =============================================================================\r\n\r\n/**\r\n * Error type classification for retry logic\r\n */\r\nexport type SmfErrorType = 'temporary' | 'permanent' | 'unknown';\r\n\r\n/**\r\n * SMF-specific error class with classification metadata\r\n */\r\nexport class SmfError extends Error {\r\n  public readonly type: SmfErrorType;\r\n  public readonly code: string;\r\n  public readonly retryAfterSeconds?: number;\r\n  public readonly field?: string;\r\n\r\n  constructor(\r\n    message: string,\r\n    code: string,\r\n    type: SmfErrorType = 'unknown',\r\n    options?: {\r\n      retryAfterSeconds?: number;\r\n      field?: string;\r\n    }\r\n  ) {\r\n    super(message);\r\n    this.name = 'SmfError';\r\n    this.code = code;\r\n    this.type = type;\r\n    this.retryAfterSeconds = options?.retryAfterSeconds;\r\n    this.field = options?.field;\r\n\r\n    // Maintains proper stack trace for where error was thrown (V8 engines)\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, SmfError);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a temporary error (client should retry)\r\n   */\r\n  static temporary(\r\n    message: string, \r\n    code: string, \r\n    retryAfterSeconds?: number\r\n  ): SmfError {\r\n    return new SmfError(message, code, 'temporary', { retryAfterSeconds });\r\n  }\r\n\r\n  /**\r\n   * Create a permanent error (client should not retry)\r\n   */\r\n  static permanent(message: string, code: string, field?: string): SmfError {\r\n    return new SmfError(message, code, 'permanent', { field });\r\n  }\r\n\r\n  /**\r\n   * Create from API error response\r\n   */\r\n  static fromApiResponse(response: {\r\n    code: string;\r\n    message: string;\r\n    type?: SmfErrorType;\r\n    retryAfterSeconds?: number;\r\n    field?: string;\r\n  }): SmfError {\r\n    return new SmfError(\r\n      response.message,\r\n      response.code,\r\n      response.type || 'unknown',\r\n      {\r\n        retryAfterSeconds: response.retryAfterSeconds,\r\n        field: response.field,\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when webhook signature verification fails\r\n */\r\nexport class InvalidSignatureError extends Error {\r\n  public readonly code = 'invalid_signature';\r\n\r\n  constructor(message: string = 'Invalid webhook signature') {\r\n    super(message);\r\n    this.name = 'InvalidSignatureError';\r\n\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, InvalidSignatureError);\r\n    }\r\n  }\r\n}\r\n\r\n","// =============================================================================\r\n// SMF Webhook Utilities\r\n// =============================================================================\r\n\r\nimport { createHmac, timingSafeEqual } from 'crypto';\r\nimport { InvalidSignatureError } from './errors';\r\n\r\n/**\r\n * Webhook event structure\r\n */\r\nexport interface WebhookEvent {\r\n  id: string;\r\n  type: string;\r\n  createdAt: string;\r\n  data: {\r\n    id: string;\r\n    object: string;\r\n    status?: string;\r\n    amount?: number;\r\n    currency?: string;\r\n    metadata?: Record<string, unknown>;\r\n    [key: string]: unknown;\r\n  };\r\n}\r\n\r\n/**\r\n * Options for webhook signature verification\r\n */\r\nexport interface WebhookVerifyOptions {\r\n  /** Raw request body (as string or Buffer) */\r\n  payload: string | Buffer;\r\n  /** Signature from smf-signature header */\r\n  signature: string;\r\n  /** Unix timestamp from smf-timestamp header */\r\n  timestamp: number;\r\n  /** Webhook signing secret */\r\n  secret: string;\r\n  /** Tolerance in seconds for timestamp validation (default: 300 = 5 minutes) */\r\n  toleranceSeconds?: number;\r\n}\r\n\r\n/**\r\n * Compute HMAC signature for webhook payload\r\n */\r\nfunction computeSignature(\r\n  payload: string | Buffer, \r\n  timestamp: number, \r\n  secret: string\r\n): string {\r\n  const signedPayload = `${timestamp}.${payload}`;\r\n  return createHmac('sha256', secret)\r\n    .update(signedPayload)\r\n    .digest('hex');\r\n}\r\n\r\n/**\r\n * Verify webhook signature and return parsed event\r\n * \r\n * @param options - Verification options\r\n * @returns Parsed and verified webhook event\r\n * @throws InvalidSignatureError if verification fails\r\n * \r\n * @example\r\n * ```typescript\r\n * const event = verifyWebhookSignature({\r\n *   payload: rawBody,\r\n *   signature: req.headers['smf-signature'],\r\n *   timestamp: parseInt(req.headers['smf-timestamp']),\r\n *   secret: process.env.SMF_WEBHOOK_SECRET,\r\n * });\r\n * ```\r\n */\r\nexport function verifyWebhookSignature(options: WebhookVerifyOptions): WebhookEvent {\r\n  const { \r\n    payload, \r\n    signature, \r\n    timestamp, \r\n    secret, \r\n    toleranceSeconds = 300 \r\n  } = options;\r\n\r\n  // Validate timestamp is recent (prevent replay attacks)\r\n  const now = Math.floor(Date.now() / 1000);\r\n  const timestampAge = now - timestamp;\r\n  \r\n  if (timestampAge > toleranceSeconds) {\r\n    throw new InvalidSignatureError(\r\n      `Webhook timestamp too old: ${timestampAge}s (tolerance: ${toleranceSeconds}s)`\r\n    );\r\n  }\r\n\r\n  if (timestampAge < -toleranceSeconds) {\r\n    throw new InvalidSignatureError(\r\n      `Webhook timestamp in future: ${-timestampAge}s ahead`\r\n    );\r\n  }\r\n\r\n  // Compute expected signature\r\n  const expectedSignature = computeSignature(payload, timestamp, secret);\r\n\r\n  // Constant-time comparison to prevent timing attacks\r\n  const signatureBuffer = Buffer.from(signature, 'hex');\r\n  const expectedBuffer = Buffer.from(expectedSignature, 'hex');\r\n\r\n  if (signatureBuffer.length !== expectedBuffer.length) {\r\n    throw new InvalidSignatureError('Signature length mismatch');\r\n  }\r\n\r\n  if (!timingSafeEqual(signatureBuffer, expectedBuffer)) {\r\n    throw new InvalidSignatureError('Signature verification failed');\r\n  }\r\n\r\n  // Parse and return the event\r\n  try {\r\n    const payloadString = typeof payload === 'string' \r\n      ? payload \r\n      : payload.toString('utf-8');\r\n    \r\n    return JSON.parse(payloadString) as WebhookEvent;\r\n  } catch (error) {\r\n    throw new InvalidSignatureError('Failed to parse webhook payload as JSON');\r\n  }\r\n}\r\n\r\n/**\r\n * Generate a webhook signature (for testing purposes)\r\n */\r\nexport function generateWebhookSignature(\r\n  payload: string | Buffer,\r\n  timestamp: number,\r\n  secret: string\r\n): string {\r\n  return computeSignature(payload, timestamp, secret);\r\n}\r\n\r\n","// =============================================================================\r\n// SMF Facilitator Client\r\n// =============================================================================\r\n\r\nimport { SmfError } from './errors';\r\nimport type {\r\n  ChargeRequest,\r\n  ChargeResponse,\r\n  RefundRequest,\r\n  RefundResponse,\r\n  PayoutRequest,\r\n  PayoutResponse,\r\n} from './types';\r\n\r\n// -----------------------------------------------------------------------------\r\n// Configuration Types\r\n// -----------------------------------------------------------------------------\r\n\r\n/**\r\n * Logger interface for SDK\r\n */\r\nexport interface Logger {\r\n  info: (msg: string, meta?: Record<string, unknown>) => void;\r\n  error: (msg: string, meta?: Record<string, unknown>) => void;\r\n  warn: (msg: string, meta?: Record<string, unknown>) => void;\r\n  debug: (msg: string, meta?: Record<string, unknown>) => void;\r\n}\r\n\r\n/**\r\n * Configuration for creating a facilitator client\r\n */\r\nexport interface FacilitatorConfig {\r\n  /** SMF API key (sk_test_... or sk_live_...) */\r\n  apiKey: string;\r\n  /** Operation mode (defaults to 'test', can auto-detect from key prefix) */\r\n  mode?: 'test' | 'live';\r\n  /** Base URL override (optional) */\r\n  baseUrl?: string;\r\n  /** Webhook signing secret (optional, for webhook verification) */\r\n  webhookSecret?: string;\r\n  /** Custom logger implementation (optional) */\r\n  logger?: Logger;\r\n  /** Function to provide correlation ID for requests (optional) */\r\n  correlationIdProvider?: () => string | undefined;\r\n}\r\n\r\n/**\r\n * Facilitator client interface\r\n */\r\nexport interface FacilitatorClient {\r\n  charge: (request: ChargeRequest) => Promise<ChargeResponse>;\r\n  refund: (chargeId: string, request?: RefundRequest) => Promise<RefundResponse>;\r\n  payout: (request: PayoutRequest) => Promise<PayoutResponse>;\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// Default Configuration\r\n// -----------------------------------------------------------------------------\r\n\r\nconst DEFAULT_BASE_URL = 'https://api.smf.nexflowapp.app/v1';\r\nconst DEFAULT_TEST_BASE_URL = 'https://api-test.smf.nexflowapp.app/v1';\r\n\r\n/**\r\n * Default no-op logger\r\n */\r\nconst noopLogger: Logger = {\r\n  info: () => {},\r\n  error: () => {},\r\n  warn: () => {},\r\n  debug: () => {},\r\n};\r\n\r\n// -----------------------------------------------------------------------------\r\n// Facilitator Factory\r\n// -----------------------------------------------------------------------------\r\n\r\n/**\r\n * Create an SMF facilitator client\r\n * \r\n * @param config - Client configuration\r\n * @returns Facilitator client with charge, refund, and payout methods\r\n * \r\n * @example\r\n * ```typescript\r\n * const smf = createFacilitator({\r\n *   apiKey: process.env.SMF_API_KEY!,\r\n *   mode: 'test',\r\n *   webhookSecret: process.env.SMF_WEBHOOK_SECRET,\r\n * });\r\n * \r\n * const charge = await smf.charge({\r\n *   platformId: 'plt_123',\r\n *   merchantId: 'mer_456',\r\n *   amount: 1000,\r\n *   currency: 'USD',\r\n *   paymentMethod: { type: 'card', token: 'tok_xxx' },\r\n * });\r\n * ```\r\n */\r\nexport function createFacilitator(config: FacilitatorConfig): FacilitatorClient {\r\n  const { \r\n    apiKey, \r\n    webhookSecret,\r\n    logger = noopLogger,\r\n    correlationIdProvider,\r\n  } = config;\r\n\r\n  // Auto-detect mode from API key prefix if not specified\r\n  const mode = config.mode ?? (apiKey.startsWith('sk_live_') ? 'live' : 'test');\r\n  \r\n  // Determine base URL\r\n  const baseUrl = config.baseUrl ?? (mode === 'live' ? DEFAULT_BASE_URL : DEFAULT_TEST_BASE_URL);\r\n\r\n  logger.info('SMF client initialized', { mode, baseUrl: baseUrl.replace(/\\/v1$/, '') });\r\n\r\n  /**\r\n   * Make an authenticated API request\r\n   */\r\n  async function apiRequest<T>(\r\n    method: string,\r\n    endpoint: string,\r\n    body?: Record<string, unknown>\r\n  ): Promise<T> {\r\n    const url = `${baseUrl}${endpoint}`;\r\n    const correlationId = correlationIdProvider?.();\r\n\r\n    const headers: Record<string, string> = {\r\n      'Authorization': `Bearer ${apiKey}`,\r\n      'Content-Type': 'application/json',\r\n      'X-SMF-Mode': mode,\r\n    };\r\n\r\n    if (correlationId) {\r\n      headers['X-Correlation-ID'] = correlationId;\r\n    }\r\n\r\n    logger.debug('API request', { method, endpoint, correlationId });\r\n\r\n    try {\r\n      const response = await fetch(url, {\r\n        method,\r\n        headers,\r\n        body: body ? JSON.stringify(body) : undefined,\r\n      });\r\n\r\n      const data = await response.json();\r\n\r\n      if (!response.ok) {\r\n        logger.warn('API error response', { \r\n          status: response.status, \r\n          code: data.code,\r\n          message: data.message,\r\n        });\r\n\r\n        throw SmfError.fromApiResponse({\r\n          code: data.code || 'api_error',\r\n          message: data.message || 'API request failed',\r\n          type: response.status >= 500 ? 'temporary' : 'permanent',\r\n          retryAfterSeconds: data.retryAfter,\r\n          field: data.field,\r\n        });\r\n      }\r\n\r\n      return data as T;\r\n    } catch (error) {\r\n      if (error instanceof SmfError) {\r\n        throw error;\r\n      }\r\n\r\n      // Network or parsing error\r\n      logger.error('API request failed', { \r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n      });\r\n\r\n      throw SmfError.temporary(\r\n        error instanceof Error ? error.message : 'Network error',\r\n        'network_error'\r\n      );\r\n    }\r\n  }\r\n\r\n  return {\r\n    /**\r\n     * Create a charge\r\n     */\r\n    async charge(request: ChargeRequest): Promise<ChargeResponse> {\r\n      logger.info('Creating charge', { \r\n        merchantId: request.merchantId,\r\n        amount: request.amount,\r\n        currency: request.currency,\r\n      });\r\n\r\n      return apiRequest<ChargeResponse>('POST', '/charges', {\r\n        platform_id: request.platformId,\r\n        merchant_id: request.merchantId,\r\n        amount: request.amount,\r\n        currency: request.currency,\r\n        payment_method: {\r\n          type: request.paymentMethod.type,\r\n          token: request.paymentMethod.token,\r\n        },\r\n        idempotency_key: request.idempotencyKey,\r\n        metadata: request.metadata,\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Create a refund\r\n     */\r\n    async refund(chargeId: string, request?: RefundRequest): Promise<RefundResponse> {\r\n      logger.info('Creating refund', { \r\n        chargeId,\r\n        amount: request?.amount ?? 'full',\r\n      });\r\n\r\n      return apiRequest<RefundResponse>('POST', `/charges/${chargeId}/refunds`, {\r\n        amount: request?.amount,\r\n        reason: request?.reason,\r\n        metadata: request?.metadata,\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Create a payout\r\n     */\r\n    async payout(request: PayoutRequest): Promise<PayoutResponse> {\r\n      logger.info('Creating payout', { \r\n        merchantId: request.merchantId,\r\n        amount: request.amount,\r\n        currency: request.currency,\r\n      });\r\n\r\n      return apiRequest<PayoutResponse>('POST', '/payouts', {\r\n        platform_id: request.platformId,\r\n        merchant_id: request.merchantId,\r\n        amount: request.amount,\r\n        currency: request.currency,\r\n        destination: {\r\n          type: request.destination.type,\r\n          id: request.destination.id,\r\n        },\r\n        description: request.description,\r\n        statement_descriptor: request.statementDescriptor,\r\n        metadata: request.metadata,\r\n      });\r\n    },\r\n  };\r\n}\r\n\r\n","// =============================================================================\r\n// @smf/sdk - SMF Drop-In Facilitator SDK\r\n// =============================================================================\r\n/**\r\n * @packageDocumentation\r\n * \r\n * The SMF SDK provides a type-safe interface for integrating payment processing\r\n * into your Node.js/TypeScript applications.\r\n * \r\n * ## Quick Start\r\n * \r\n * ```typescript\r\n * import { createFacilitator, SmfError } from '@smf/sdk';\r\n * \r\n * const smf = createFacilitator({\r\n *   apiKey: process.env.SMF_API_KEY!,\r\n *   mode: 'test', // or 'live' for production\r\n * });\r\n * \r\n * // Create a charge\r\n * try {\r\n *   const charge = await smf.charge({\r\n *     amount: 1000, // $10.00 in cents\r\n *     currency: 'USD',\r\n *     paymentMethod: { type: 'card', token: 'tok_xxx' },\r\n *     orderId: 'order_123',\r\n *     idempotencyKey: 'unique_key_123',\r\n *   });\r\n *   console.log('Charge created:', charge.id);\r\n * } catch (error) {\r\n *   if (error instanceof SmfError) {\r\n *     console.error('Payment failed:', error.code, error.message);\r\n *   }\r\n * }\r\n * ```\r\n * \r\n * ## Features\r\n * \r\n * - **Charges**: Create one-time payments\r\n * - **Refunds**: Full or partial refunds\r\n * - **Payouts**: Send funds to external accounts\r\n * - **Webhooks**: Verify and process webhook events\r\n * \r\n * @module @smf/sdk\r\n */\r\n\r\n// =============================================================================\r\n// CORE FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a new SMF facilitator client.\r\n * \r\n * @example\r\n * ```typescript\r\n * const smf = createFacilitator({\r\n *   apiKey: 'sk_test_xxx',\r\n *   mode: 'test',\r\n *   baseUrl: 'https://api.smf.io', // optional\r\n *   logger: console, // optional\r\n * });\r\n * ```\r\n * \r\n * @see {@link FacilitatorConfig} for configuration options\r\n * @see {@link FacilitatorClient} for available methods\r\n */\r\nexport { createFacilitator } from './facilitator';\r\n\r\n/**\r\n * Configuration options for the SMF facilitator client.\r\n */\r\nexport type { FacilitatorConfig } from './facilitator';\r\n\r\n/**\r\n * The SMF facilitator client interface with all payment methods.\r\n */\r\nexport type { FacilitatorClient } from './facilitator';\r\n\r\n/**\r\n * Logger interface for custom logging implementations.\r\n */\r\nexport type { Logger } from './facilitator';\r\n\r\n// =============================================================================\r\n// ERROR TYPES\r\n// =============================================================================\r\n\r\n/**\r\n * Custom error class for SMF API errors.\r\n * \r\n * Includes error classification (temporary/permanent), error codes,\r\n * and retry information for transient failures.\r\n * \r\n * @example\r\n * ```typescript\r\n * try {\r\n *   await smf.charge({ ... });\r\n * } catch (error) {\r\n *   if (error instanceof SmfError) {\r\n *     if (error.type === 'temporary') {\r\n *       // Retry after delay\r\n *       console.log('Retry after:', error.retryAfterSeconds);\r\n *     } else {\r\n *       // Permanent error, don't retry\r\n *       console.error('Error code:', error.code);\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport { SmfError } from './errors';\r\n\r\n/**\r\n * Error thrown when webhook signature verification fails.\r\n * \r\n * @example\r\n * ```typescript\r\n * try {\r\n *   const event = verifyWebhookSignature({ ... });\r\n * } catch (error) {\r\n *   if (error instanceof InvalidSignatureError) {\r\n *     console.error('Invalid webhook signature');\r\n *     return new Response('Unauthorized', { status: 401 });\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport { InvalidSignatureError } from './errors';\r\n\r\n/**\r\n * SMF error type classification.\r\n * - `temporary`: Transient error, safe to retry\r\n * - `permanent`: Permanent error, do not retry\r\n */\r\nexport type { SmfErrorType } from './errors';\r\n\r\n// =============================================================================\r\n// WEBHOOK UTILITIES\r\n// =============================================================================\r\n\r\n/**\r\n * Verify the signature of an incoming webhook request.\r\n * \r\n * Always verify webhooks before processing to ensure they came from SMF.\r\n * \r\n * @example\r\n * ```typescript\r\n * // In your webhook handler\r\n * const rawBody = await request.text();\r\n * const signature = request.headers.get('x-smf-signature');\r\n * const timestamp = request.headers.get('x-smf-timestamp');\r\n * \r\n * try {\r\n *   const event = verifyWebhookSignature({\r\n *     payload: rawBody,\r\n *     signature: signature!,\r\n *     timestamp: timestamp!,\r\n *     secret: process.env.SMF_WEBHOOK_SECRET!,\r\n *   });\r\n *   \r\n *   // Process the verified event\r\n *   switch (event.type) {\r\n *     case 'payment.succeeded':\r\n *       // Handle successful payment\r\n *       break;\r\n *     case 'refund.completed':\r\n *       // Handle refund\r\n *       break;\r\n *   }\r\n * } catch (error) {\r\n *   if (error instanceof InvalidSignatureError) {\r\n *     return new Response('Unauthorized', { status: 401 });\r\n *   }\r\n * }\r\n * ```\r\n * \r\n * @throws {InvalidSignatureError} If signature is invalid or expired\r\n */\r\nexport { verifyWebhookSignature } from './webhooks';\r\n\r\n/**\r\n * Options for webhook signature verification.\r\n */\r\nexport type { WebhookVerifyOptions } from './webhooks';\r\n\r\n/**\r\n * Webhook event payload structure.\r\n */\r\nexport type { WebhookEvent } from './webhooks';\r\n\r\n// =============================================================================\r\n// REQUEST/RESPONSE TYPES\r\n// =============================================================================\r\n\r\n/**\r\n * Request payload for creating a charge.\r\n * \r\n * @example\r\n * ```typescript\r\n * const chargeRequest: ChargeRequest = {\r\n *   amount: 2500,        // $25.00 in cents\r\n *   currency: 'USD',\r\n *   paymentMethod: {\r\n *     type: 'card',\r\n *     token: 'tok_visa_xxx',\r\n *   },\r\n *   orderId: 'order_abc123',\r\n *   idempotencyKey: 'charge_unique_key',\r\n *   metadata: {\r\n *     customerId: 'cust_123',\r\n *   },\r\n * };\r\n * ```\r\n */\r\nexport type { ChargeRequest } from './types';\r\n\r\n/**\r\n * Response from a successful charge creation.\r\n */\r\nexport type { ChargeResponse } from './types';\r\n\r\n/**\r\n * Request payload for creating a refund.\r\n * \r\n * @example\r\n * ```typescript\r\n * const refundRequest: RefundRequest = {\r\n *   chargeId: 'ch_xxx',\r\n *   amount: 1000, // Optional: partial refund of $10.00\r\n *   reason: 'customer_request',\r\n *   idempotencyKey: 'refund_unique_key',\r\n * };\r\n * ```\r\n */\r\nexport type { RefundRequest } from './types';\r\n\r\n/**\r\n * Response from a successful refund creation.\r\n */\r\nexport type { RefundResponse } from './types';\r\n\r\n/**\r\n * Request payload for creating a payout.\r\n * \r\n * @example\r\n * ```typescript\r\n * const payoutRequest: PayoutRequest = {\r\n *   amount: 50000, // $500.00 in cents\r\n *   currency: 'USD',\r\n *   destination: 'ba_xxx', // Bank account ID\r\n *   description: 'Weekly payout',\r\n *   idempotencyKey: 'payout_unique_key',\r\n * };\r\n * ```\r\n */\r\nexport type { PayoutRequest } from './types';\r\n\r\n/**\r\n * Response from a successful payout creation.\r\n */\r\nexport type { PayoutResponse } from './types';\r\n\r\n/**\r\n * Payment method details for a charge.\r\n */\r\nexport type { PaymentMethod } from './types';\r\n\r\n/**\r\n * Supported payment method types.\r\n */\r\nexport type { PaymentMethodType } from './types';\r\n\r\n/**\r\n * Possible states for a charge.\r\n */\r\nexport type { ChargeStatus } from './types';\r\n\r\n/**\r\n * Possible states for a refund.\r\n */\r\nexport type { RefundStatus } from './types';\r\n\r\n/**\r\n * Possible states for a payout.\r\n */\r\nexport type { PayoutStatus } from './types';\r\n","// =============================================================================\r\n// SMF Drop-In Facilitator Client\r\n// =============================================================================\r\n// Singleton SMF client configured from environment variables.\r\n// This is the single source of truth for SMF SDK initialization.\r\n\r\nimport { AsyncLocalStorage } from 'async_hooks';\r\nimport { createFacilitator, SmfError } from '@smf/sdk';\r\nimport { getOrCreateRequestId } from '@/lib/request-id';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\n// -----------------------------------------------------------------------------\r\n// Environment Configuration\r\n// -----------------------------------------------------------------------------\r\n\r\n/**\r\n * SMF configuration from environment variables\r\n */\r\nexport interface SmfConfig {\r\n  apiKey: string;\r\n  mode: 'test' | 'live';\r\n  baseUrl?: string;\r\n  webhookSecret?: string;\r\n}\r\n\r\n/**\r\n * Get SMF configuration from environment variables with validation\r\n */\r\nfunction getSmfConfig(): SmfConfig {\r\n  const apiKey = process.env.SMF_API_KEY;\r\n  \r\n  if (!apiKey) {\r\n    throw new Error(\r\n      'SMF_API_KEY is not set. Please set it in your environment variables.'\r\n    );\r\n  }\r\n\r\n  const mode = process.env.SMF_MODE === 'live' ? 'live' : 'test';\r\n  const baseUrl = process.env.SMF_BASE_URL;\r\n  const webhookSecret = process.env.SMF_WEBHOOK_SECRET;\r\n\r\n  return {\r\n    apiKey,\r\n    mode,\r\n    baseUrl,\r\n    webhookSecret,\r\n  };\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// Logger Adapter\r\n// -----------------------------------------------------------------------------\r\n\r\nconst smfLogger = createLogger({ component: 'SMF' });\r\n\r\n/**\r\n * Logger implementation for SMF SDK\r\n * Adapts our Pino logger to SMF's logger interface\r\n */\r\nconst logger = {\r\n  info: (msg: string, meta?: Record<string, unknown>) => {\r\n    smfLogger.info({ ...meta }, `[SMF] ${msg}`);\r\n  },\r\n  error: (msg: string, meta?: Record<string, unknown>) => {\r\n    smfLogger.error({ ...meta }, `[SMF] ${msg}`);\r\n  },\r\n  warn: (msg: string, meta?: Record<string, unknown>) => {\r\n    smfLogger.warn({ ...meta }, `[SMF] ${msg}`);\r\n  },\r\n  debug: (msg: string, meta?: Record<string, unknown>) => {\r\n    smfLogger.debug({ ...meta }, `[SMF] ${msg}`);\r\n  },\r\n};\r\n\r\n// -----------------------------------------------------------------------------\r\n// Correlation ID Provider (Thread-Safe)\r\n// -----------------------------------------------------------------------------\r\n\r\n/**\r\n * AsyncLocalStorage for request-scoped correlation IDs.\r\n * This ensures correlation IDs don't leak between concurrent requests,\r\n * unlike the previous module-level variable approach.\r\n */\r\nconst correlationStorage = new AsyncLocalStorage<string>();\r\n\r\n/**\r\n * Provides correlation ID for SMF requests.\r\n * Returns the correlation ID from the current async context,\r\n * ensuring thread-safety in concurrent request handling.\r\n */\r\nfunction correlationIdProvider(): string | undefined {\r\n  return correlationStorage.getStore();\r\n}\r\n\r\n/**\r\n * Run a function with a specific correlation ID in its async context.\r\n * Use this to wrap request handlers for proper correlation tracking.\r\n * \r\n * @example\r\n * ```typescript\r\n * await runWithCorrelationId(requestId, async () => {\r\n *   const smf = getSmfClient();\r\n *   await smf.charge({ ... });\r\n * });\r\n * ```\r\n */\r\nexport function runWithCorrelationId<T>(correlationId: string, fn: () => T): T {\r\n  return correlationStorage.run(correlationId, fn);\r\n}\r\n\r\n/**\r\n * Get the current correlation ID from the async context.\r\n * Returns undefined if not inside a runWithCorrelationId block.\r\n */\r\nexport function getCurrentCorrelationId(): string | undefined {\r\n  return correlationStorage.getStore();\r\n}\r\n\r\n/**\r\n * @deprecated Use runWithCorrelationId() instead for thread-safe operation.\r\n * This function is kept for backward compatibility but does nothing.\r\n */\r\nexport function setSmfCorrelationId(_id: string | undefined): void {\r\n  console.warn(\r\n    '[SMF] setSmfCorrelationId is deprecated. Use runWithCorrelationId() instead.'\r\n  );\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// SMF Client Singleton\r\n// -----------------------------------------------------------------------------\r\n\r\nlet smfInstance: ReturnType<typeof createFacilitator> | null = null;\r\n\r\n/**\r\n * Get the singleton SMF facilitator client\r\n * Lazily initialized on first use\r\n */\r\nexport function getSmfClient(): ReturnType<typeof createFacilitator> {\r\n  if (!smfInstance) {\r\n    const config = getSmfConfig();\r\n    \r\n    smfInstance = createFacilitator({\r\n      apiKey: config.apiKey,\r\n      mode: config.mode,\r\n      baseUrl: config.baseUrl,\r\n      webhookSecret: config.webhookSecret,\r\n      logger,\r\n      correlationIdProvider,\r\n    });\r\n\r\n    smfLogger.info(\r\n      { mode: config.mode, hasBaseUrl: !!config.baseUrl },\r\n      'SMF client initialized'\r\n    );\r\n  }\r\n\r\n  return smfInstance;\r\n}\r\n\r\n/**\r\n * Get SMF client with correlation ID set for request tracing.\r\n * \r\n * IMPORTANT: For thread-safety, wrap your SMF operations in runWithCorrelationId:\r\n * \r\n * @example\r\n * ```typescript\r\n * // Recommended pattern\r\n * const result = await runWithCorrelationId(requestId, async () => {\r\n *   const smf = getSmfClient();\r\n *   return smf.charge({ ... });\r\n * });\r\n * \r\n * // Or use the convenience wrapper\r\n * const result = await withSmfCorrelation(requestId, async (smf) => {\r\n *   return smf.charge({ ... });\r\n * });\r\n * ```\r\n * \r\n * @deprecated Direct usage is deprecated. Use withSmfCorrelation() instead.\r\n */\r\nexport function getSmfWithCorrelation(requestId: string): ReturnType<typeof createFacilitator> {\r\n  // For backward compatibility, we still return the client\r\n  // but the correlation ID will only work if called inside runWithCorrelationId\r\n  if (!correlationStorage.getStore()) {\r\n    smfLogger.warn(\r\n      { requestId },\r\n      'getSmfWithCorrelation called outside of runWithCorrelationId context. ' +\r\n      'Correlation ID may not be properly tracked. Use withSmfCorrelation() instead.'\r\n    );\r\n  }\r\n  return getSmfClient();\r\n}\r\n\r\n/**\r\n * Execute an SMF operation with proper correlation ID tracking.\r\n * This is the recommended way to make SMF calls with request correlation.\r\n * \r\n * @example\r\n * ```typescript\r\n * const charge = await withSmfCorrelation(requestId, async (smf) => {\r\n *   return smf.charge({\r\n *     amount: 1000,\r\n *     currency: 'USD',\r\n *     orderId: 'order-123',\r\n *   });\r\n * });\r\n * ```\r\n */\r\nexport async function withSmfCorrelation<T>(\r\n  correlationId: string,\r\n  fn: (smf: ReturnType<typeof createFacilitator>) => Promise<T>\r\n): Promise<T> {\r\n  return correlationStorage.run(correlationId, async () => {\r\n    const smf = getSmfClient();\r\n    return fn(smf);\r\n  });\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// Configuration Accessors\r\n// -----------------------------------------------------------------------------\r\n\r\n/**\r\n * Get the current SMF mode (test/live)\r\n */\r\nexport function getSmfMode(): 'test' | 'live' {\r\n  return process.env.SMF_MODE === 'live' ? 'live' : 'test';\r\n}\r\n\r\n/**\r\n * Get the webhook secret for signature verification\r\n */\r\nexport function getWebhookSecret(): string | undefined {\r\n  return process.env.SMF_WEBHOOK_SECRET;\r\n}\r\n\r\n/**\r\n * Check if SMF is configured and ready\r\n */\r\nexport function isSmfConfigured(): boolean {\r\n  return !!process.env.SMF_API_KEY;\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// Error Handling Utilities\r\n// -----------------------------------------------------------------------------\r\n\r\n/**\r\n * SMF error type classification\r\n */\r\nexport type SmfErrorType = 'temporary' | 'permanent' | 'unknown';\r\n\r\n/**\r\n * Classify an SMF error for retry logic\r\n */\r\nexport function classifySmfError(error: unknown): {\r\n  type: SmfErrorType;\r\n  code: string;\r\n  message: string;\r\n  retryAfterSeconds?: number;\r\n  httpStatus: number;\r\n} {\r\n  if (error instanceof SmfError) {\r\n    return {\r\n      type: error.type,\r\n      code: error.code,\r\n      message: error.message,\r\n      retryAfterSeconds: error.retryAfterSeconds,\r\n      httpStatus: mapSmfErrorToHttpStatus(error.code, error.type),\r\n    };\r\n  }\r\n\r\n  // Unknown error\r\n  return {\r\n    type: 'unknown',\r\n    code: 'INTERNAL_ERROR',\r\n    message: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n    httpStatus: 500,\r\n  };\r\n}\r\n\r\n/**\r\n * Map SMF error codes to HTTP status codes\r\n */\r\nfunction mapSmfErrorToHttpStatus(code: string, type: SmfErrorType): number {\r\n  // Temporary errors - client can retry\r\n  if (type === 'temporary') {\r\n    switch (code) {\r\n      case 'rate_limit_error':\r\n        return 429;\r\n      case 'processing_error':\r\n      case 'network_error':\r\n        return 503;\r\n      default:\r\n        return 503;\r\n    }\r\n  }\r\n\r\n  // Permanent errors - client should not retry\r\n  switch (code) {\r\n    case 'card_declined':\r\n    case 'insufficient_funds':\r\n    case 'expired_card':\r\n      return 402; // Payment Required\r\n    case 'validation_error':\r\n    case 'invalid_request':\r\n      return 400;\r\n    case 'authentication_error':\r\n      return 401;\r\n    case 'authorization_error':\r\n      return 403;\r\n    case 'not_found':\r\n      return 404;\r\n    case 'idempotency_error':\r\n      return 409; // Conflict\r\n    default:\r\n      return 400;\r\n  }\r\n}\r\n\r\n/**\r\n * User-safe error messages for common SMF error codes\r\n */\r\nexport function getUserFriendlyErrorMessage(code: string): string {\r\n  const messages: Record<string, string> = {\r\n    card_declined: 'Your card was declined. Please try a different payment method.',\r\n    insufficient_funds: 'Insufficient funds. Please use a different payment method.',\r\n    expired_card: 'Your card has expired. Please update your payment information.',\r\n    validation_error: 'Invalid payment details. Please check your information.',\r\n    rate_limit_error: 'Too many requests. Please try again in a moment.',\r\n    processing_error: 'Payment processing temporarily unavailable. Please try again.',\r\n    network_error: 'Network error. Please check your connection and try again.',\r\n    authentication_error: 'Authentication failed. Please contact support.',\r\n    idempotency_error: 'This request has already been processed.',\r\n  };\r\n\r\n  return messages[code] || 'An error occurred processing your payment. Please try again.';\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// Exports\r\n// -----------------------------------------------------------------------------\r\n\r\n// Re-export SDK types for convenience\r\nexport { SmfError } from '@smf/sdk';\r\nexport type { \r\n  ChargeRequest, \r\n  ChargeResponse, \r\n  RefundRequest, \r\n  RefundResponse,\r\n  PayoutRequest,\r\n  PayoutResponse,\r\n} from '@smf/sdk';\r\n\r\n// Default export for convenience\r\nexport const smf = getSmfClient;\r\n\r\n","// =============================================================================\r\n// SMF Payments Database Operations\r\n// =============================================================================\r\n// Database operations for SMF charges, refunds, payouts, and webhook events\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'SMFPaymentsDB' });\r\n\r\n// -----------------------------------------------------------------------------\r\n// Types\r\n// -----------------------------------------------------------------------------\r\n\r\nexport interface SmfCharge {\r\n  id: string;\r\n  smf_charge_id: string;\r\n  platform_id: string;\r\n  merchant_id: string;\r\n  amount: number;\r\n  currency: string;\r\n  status: 'pending' | 'succeeded' | 'failed' | 'requires_action' | 'canceled';\r\n  order_id?: string;\r\n  user_id?: string;\r\n  idempotency_key?: string;\r\n  fees?: Record<string, unknown>;\r\n  payment_method_type?: string;\r\n  metadata?: Record<string, unknown>;\r\n  error_code?: string;\r\n  error_message?: string;\r\n  correlation_id?: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface SmfRefund {\r\n  id: string;\r\n  smf_refund_id: string;\r\n  charge_id: string;\r\n  smf_charge_id: string;\r\n  amount: number;\r\n  currency: string;\r\n  reason?: string;\r\n  status: 'pending' | 'succeeded' | 'failed' | 'canceled';\r\n  correlation_id?: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface SmfPayout {\r\n  id: string;\r\n  smf_payout_id: string;\r\n  platform_id: string;\r\n  merchant_id: string;\r\n  amount: number;\r\n  currency: string;\r\n  destination_type?: string;\r\n  destination_id?: string;\r\n  status: 'pending' | 'in_transit' | 'paid' | 'failed' | 'canceled';\r\n  estimated_arrival?: string;\r\n  correlation_id?: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface SmfWebhookEvent {\r\n  id: string;\r\n  smf_event_id: string;\r\n  event_type: string;\r\n  payload: Record<string, unknown>;\r\n  status: 'received' | 'processing' | 'processed' | 'failed';\r\n  error_message?: string;\r\n  attempts: number;\r\n  received_at: string;\r\n  processed_at?: string;\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// Charge Operations\r\n// -----------------------------------------------------------------------------\r\n\r\n/**\r\n * Create a charge record\r\n */\r\nexport async function createCharge(\r\n  data: Omit<SmfCharge, 'id' | 'created_at' | 'updated_at'>\r\n): Promise<SmfCharge> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO smf_charges (\r\n        id, smf_charge_id, platform_id, merchant_id, amount, currency, status,\r\n        order_id, user_id, idempotency_key, fees, payment_method_type, metadata,\r\n        error_code, error_message, correlation_id, created_at, updated_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        data.smf_charge_id,\r\n        data.platform_id,\r\n        data.merchant_id,\r\n        data.amount,\r\n        data.currency,\r\n        data.status,\r\n        data.order_id || null,\r\n        data.user_id || null,\r\n        data.idempotency_key || null,\r\n        data.fees ? JSON.stringify(data.fees) : null,\r\n        data.payment_method_type || null,\r\n        data.metadata ? JSON.stringify(data.metadata) : null,\r\n        data.error_code || null,\r\n        data.error_message || null,\r\n        data.correlation_id || null,\r\n        now,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite fallback\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO smf_charges (\r\n        id, smf_charge_id, platform_id, merchant_id, amount, currency, status,\r\n        order_id, user_id, idempotency_key, fees, payment_method_type, metadata,\r\n        error_code, error_message, correlation_id, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      data.smf_charge_id,\r\n      data.platform_id,\r\n      data.merchant_id,\r\n      data.amount,\r\n      data.currency,\r\n      data.status,\r\n      data.order_id || null,\r\n      data.user_id || null,\r\n      data.idempotency_key || null,\r\n      data.fees ? JSON.stringify(data.fees) : null,\r\n      data.payment_method_type || null,\r\n      data.metadata ? JSON.stringify(data.metadata) : null,\r\n      data.error_code || null,\r\n      data.error_message || null,\r\n      data.correlation_id || null,\r\n      now,\r\n      now\r\n    );\r\n    return { id, ...data, created_at: now, updated_at: now } as SmfCharge;\r\n  }\r\n}\r\n\r\n/**\r\n * Get charge by ID\r\n */\r\nexport async function getChargeById(id: string): Promise<SmfCharge | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      'SELECT * FROM smf_charges WHERE id = $1',\r\n      [id]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    const stmt = (db as any).prepare('SELECT * FROM smf_charges WHERE id = ?');\r\n    return stmt.get(id) || null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get charge by SMF charge ID\r\n */\r\nexport async function getChargeBySmfId(smfChargeId: string): Promise<SmfCharge | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      'SELECT * FROM smf_charges WHERE smf_charge_id = $1',\r\n      [smfChargeId]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    const stmt = (db as any).prepare('SELECT * FROM smf_charges WHERE smf_charge_id = ?');\r\n    return stmt.get(smfChargeId) || null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get charge by order ID\r\n */\r\nexport async function getChargeByOrderId(orderId: string): Promise<SmfCharge | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      'SELECT * FROM smf_charges WHERE order_id = $1 ORDER BY created_at DESC LIMIT 1',\r\n      [orderId]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    const stmt = (db as any).prepare(\r\n      'SELECT * FROM smf_charges WHERE order_id = ? ORDER BY created_at DESC LIMIT 1'\r\n    );\r\n    return stmt.get(orderId) || null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get charge by idempotency key\r\n */\r\nexport async function getChargeByIdempotencyKey(idempotencyKey: string): Promise<SmfCharge | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      'SELECT * FROM smf_charges WHERE idempotency_key = $1 ORDER BY created_at DESC LIMIT 1',\r\n      [idempotencyKey]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    const stmt = (db as any).prepare(\r\n      'SELECT * FROM smf_charges WHERE idempotency_key = ? ORDER BY created_at DESC LIMIT 1'\r\n    );\r\n    return stmt.get(idempotencyKey) || null;\r\n  }\r\n}\r\n\r\n/**\r\n * Update charge status\r\n */\r\nexport async function updateChargeStatus(\r\n  id: string,\r\n  status: SmfCharge['status'],\r\n  errorCode?: string,\r\n  errorMessage?: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE smf_charges \r\n       SET status = $1, error_code = $2, error_message = $3, updated_at = $4 \r\n       WHERE id = $5`,\r\n      [status, errorCode || null, errorMessage || null, now, id]\r\n    );\r\n  } else {\r\n    const stmt = (db as any).prepare(\r\n      `UPDATE smf_charges \r\n       SET status = ?, error_code = ?, error_message = ?, updated_at = ? \r\n       WHERE id = ?`\r\n    );\r\n    stmt.run(status, errorCode || null, errorMessage || null, now, id);\r\n  }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// Refund Operations\r\n// -----------------------------------------------------------------------------\r\n\r\n/**\r\n * Create a refund record\r\n */\r\nexport async function createRefund(\r\n  data: Omit<SmfRefund, 'id' | 'created_at' | 'updated_at'>\r\n): Promise<SmfRefund> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO smf_refunds (\r\n        id, smf_refund_id, charge_id, smf_charge_id, amount, currency,\r\n        reason, status, correlation_id, created_at, updated_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        data.smf_refund_id,\r\n        data.charge_id,\r\n        data.smf_charge_id,\r\n        data.amount,\r\n        data.currency,\r\n        data.reason || null,\r\n        data.status,\r\n        data.correlation_id || null,\r\n        now,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO smf_refunds (\r\n        id, smf_refund_id, charge_id, smf_charge_id, amount, currency,\r\n        reason, status, correlation_id, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      data.smf_refund_id,\r\n      data.charge_id,\r\n      data.smf_charge_id,\r\n      data.amount,\r\n      data.currency,\r\n      data.reason || null,\r\n      data.status,\r\n      data.correlation_id || null,\r\n      now,\r\n      now\r\n    );\r\n    return { id, ...data, created_at: now, updated_at: now } as SmfRefund;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all refunds for a charge\r\n */\r\nexport async function getRefundsForCharge(chargeId: string): Promise<SmfRefund[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      'SELECT * FROM smf_refunds WHERE charge_id = $1 ORDER BY created_at DESC',\r\n      [chargeId]\r\n    );\r\n    return result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(\r\n      'SELECT * FROM smf_refunds WHERE charge_id = ? ORDER BY created_at DESC'\r\n    );\r\n    return stmt.all(chargeId) || [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get total refunded amount for a charge\r\n */\r\nexport async function getTotalRefundedAmount(chargeId: string): Promise<number> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT COALESCE(SUM(amount), 0) as total \r\n       FROM smf_refunds \r\n       WHERE charge_id = $1 AND status IN ('pending', 'succeeded')`,\r\n      [chargeId]\r\n    );\r\n    return parseInt(result.rows[0]?.total || '0', 10);\r\n  } else {\r\n    const stmt = (db as any).prepare(\r\n      `SELECT COALESCE(SUM(amount), 0) as total \r\n       FROM smf_refunds \r\n       WHERE charge_id = ? AND status IN ('pending', 'succeeded')`\r\n    );\r\n    const row = stmt.get(chargeId) as { total: number } | undefined;\r\n    return row?.total || 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Get refund by SMF refund ID\r\n */\r\nexport async function getRefundBySmfId(smfRefundId: string): Promise<SmfRefund | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      'SELECT * FROM smf_refunds WHERE smf_refund_id = $1',\r\n      [smfRefundId]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    const stmt = (db as any).prepare('SELECT * FROM smf_refunds WHERE smf_refund_id = ?');\r\n    return stmt.get(smfRefundId) || null;\r\n  }\r\n}\r\n\r\n/**\r\n * Update refund status\r\n */\r\nexport async function updateRefundStatus(\r\n  id: string,\r\n  status: SmfRefund['status'],\r\n  errorCode?: string,\r\n  errorMessage?: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE smf_refunds \r\n       SET status = $1, updated_at = $2 \r\n       WHERE id = $3`,\r\n      [status, now, id]\r\n    );\r\n  } else {\r\n    const stmt = (db as any).prepare(\r\n      `UPDATE smf_refunds \r\n       SET status = ?, updated_at = ? \r\n       WHERE id = ?`\r\n    );\r\n    stmt.run(status, now, id);\r\n  }\r\n\r\n  logger.info({ refundId: id, status }, 'Refund status updated');\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// Payout Operations\r\n// -----------------------------------------------------------------------------\r\n\r\n/**\r\n * Create a payout record\r\n */\r\nexport async function createPayout(\r\n  data: Omit<SmfPayout, 'id' | 'created_at' | 'updated_at'>\r\n): Promise<SmfPayout> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO smf_payouts (\r\n        id, smf_payout_id, platform_id, merchant_id, amount, currency,\r\n        destination_type, destination_id, status, estimated_arrival,\r\n        correlation_id, created_at, updated_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        data.smf_payout_id,\r\n        data.platform_id,\r\n        data.merchant_id,\r\n        data.amount,\r\n        data.currency,\r\n        data.destination_type || null,\r\n        data.destination_id || null,\r\n        data.status,\r\n        data.estimated_arrival || null,\r\n        data.correlation_id || null,\r\n        now,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO smf_payouts (\r\n        id, smf_payout_id, platform_id, merchant_id, amount, currency,\r\n        destination_type, destination_id, status, estimated_arrival,\r\n        correlation_id, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      data.smf_payout_id,\r\n      data.platform_id,\r\n      data.merchant_id,\r\n      data.amount,\r\n      data.currency,\r\n      data.destination_type || null,\r\n      data.destination_id || null,\r\n      data.status,\r\n      data.estimated_arrival || null,\r\n      data.correlation_id || null,\r\n      now,\r\n      now\r\n    );\r\n    return { id, ...data, created_at: now, updated_at: now } as SmfPayout;\r\n  }\r\n}\r\n\r\n/**\r\n * Get payout by SMF payout ID\r\n */\r\nexport async function getPayoutBySmfId(smfPayoutId: string): Promise<SmfPayout | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      'SELECT * FROM smf_payouts WHERE smf_payout_id = $1',\r\n      [smfPayoutId]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    const stmt = (db as any).prepare('SELECT * FROM smf_payouts WHERE smf_payout_id = ?');\r\n    return stmt.get(smfPayoutId) || null;\r\n  }\r\n}\r\n\r\n/**\r\n * Update payout status\r\n */\r\nexport async function updatePayoutStatus(\r\n  id: string,\r\n  status: SmfPayout['status'],\r\n  errorCode?: string,\r\n  errorMessage?: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE smf_payouts \r\n       SET status = $1, updated_at = $2 \r\n       WHERE id = $3`,\r\n      [status, now, id]\r\n    );\r\n  } else {\r\n    const stmt = (db as any).prepare(\r\n      `UPDATE smf_payouts \r\n       SET status = ?, updated_at = ? \r\n       WHERE id = ?`\r\n    );\r\n    stmt.run(status, now, id);\r\n  }\r\n\r\n  logger.info({ payoutId: id, status }, 'Payout status updated');\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// Webhook Event Operations\r\n// -----------------------------------------------------------------------------\r\n\r\n/**\r\n * Check if a webhook event has already been processed\r\n */\r\nexport async function isWebhookEventProcessed(smfEventId: string): Promise<boolean> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT 1 FROM smf_webhook_events \r\n       WHERE smf_event_id = $1 AND status IN ('processed', 'processing')`,\r\n      [smfEventId]\r\n    );\r\n    return result.rows.length > 0;\r\n  } else {\r\n    const stmt = (db as any).prepare(\r\n      `SELECT 1 FROM smf_webhook_events \r\n       WHERE smf_event_id = ? AND status IN ('processed', 'processing')`\r\n    );\r\n    return !!stmt.get(smfEventId);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a webhook event record\r\n */\r\nexport async function createWebhookEvent(\r\n  data: Omit<SmfWebhookEvent, 'id' | 'received_at' | 'processed_at' | 'attempts'>\r\n): Promise<SmfWebhookEvent> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO smf_webhook_events (\r\n        id, smf_event_id, event_type, payload, status, error_message, attempts, received_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\r\n      ON CONFLICT (smf_event_id) DO NOTHING\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        data.smf_event_id,\r\n        data.event_type,\r\n        JSON.stringify(data.payload),\r\n        data.status,\r\n        data.error_message || null,\r\n        0,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      INSERT OR IGNORE INTO smf_webhook_events (\r\n        id, smf_event_id, event_type, payload, status, error_message, attempts, received_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      data.smf_event_id,\r\n      data.event_type,\r\n      JSON.stringify(data.payload),\r\n      data.status,\r\n      data.error_message || null,\r\n      0,\r\n      now\r\n    );\r\n    return {\r\n      id,\r\n      ...data,\r\n      attempts: 0,\r\n      received_at: now,\r\n      processed_at: undefined,\r\n    } as SmfWebhookEvent;\r\n  }\r\n}\r\n\r\n/**\r\n * Mark webhook event as processed\r\n */\r\nexport async function markWebhookEventProcessed(\r\n  smfEventId: string,\r\n  error?: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const status = error ? 'failed' : 'processed';\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE smf_webhook_events \r\n       SET status = $1, error_message = $2, processed_at = $3, attempts = attempts + 1\r\n       WHERE smf_event_id = $4`,\r\n      [status, error || null, now, smfEventId]\r\n    );\r\n  } else {\r\n    const stmt = (db as any).prepare(\r\n      `UPDATE smf_webhook_events \r\n       SET status = ?, error_message = ?, processed_at = ?, attempts = attempts + 1\r\n       WHERE smf_event_id = ?`\r\n    );\r\n    stmt.run(status, error || null, now, smfEventId);\r\n  }\r\n}\r\n\r\n/**\r\n * Get webhook event by SMF event ID\r\n */\r\nexport async function getWebhookEventBySmfId(smfEventId: string): Promise<SmfWebhookEvent | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      'SELECT * FROM smf_webhook_events WHERE smf_event_id = $1',\r\n      [smfEventId]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    const stmt = (db as any).prepare('SELECT * FROM smf_webhook_events WHERE smf_event_id = ?');\r\n    return stmt.get(smfEventId) || null;\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}