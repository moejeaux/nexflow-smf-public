{"version":3,"sources":["../../../src/integrations/x402/facilitators/route-context.ts","../../../src/integrations/x402/orchestrator/meta-facilitator.ts"],"sourcesContent":["// =============================================================================\r\n// ROUTE CONTEXT\r\n// =============================================================================\r\n// Normalized request context for SMF routing\r\n// Ensures all facilitators receive consistent, x402-spec-compliant requests\r\n\r\nimport type { PaymentRequirements } from './base-facilitator';\r\n\r\n/**\r\n * RouteContext - Normalized request context for SMF routing\r\n * \r\n * This type ensures all facilitators receive consistent, x402-spec-compliant\r\n * requests regardless of how the request originated (API, SDK, etc.)\r\n */\r\nexport interface RouteContext {\r\n  // Payment details (x402 spec compliant)\r\n  network: string; // Legacy network identifier (e.g., 'base', 'ethereum')\r\n  token: string; // Token address (e.g., '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913')\r\n  amount: string; // Amount in atomic units (string to avoid precision loss)\r\n  \r\n  // CAIP identifiers (preferred for multi-chain)\r\n  networkCAIP?: string; // CAIP-2 network identifier (e.g., 'eip155:8453')\r\n  tokenCAIP?: string; // CAIP-19 asset identifier (e.g., 'eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913')\r\n  \r\n  // x402 version\r\n  x402Version: number; // x402 protocol version (currently 1 or 2)\r\n  \r\n  // Caller identification\r\n  callerId?: string; // Agent/merchant identifier\r\n  clientId?: string; // Client application identifier\r\n  \r\n  // Optional routing preferences\r\n  region?: string; // Geographic region (e.g., 'us-east', 'eu-west')\r\n  riskLevel?: 'low' | 'medium' | 'high'; // Risk assessment level\r\n  watchLevel?: 'normal' | 'enhanced' | 'strict'; // Compliance watch level\r\n  \r\n  // Additional context\r\n  preferences?: {\r\n    priority?: 'cost' | 'speed' | 'reliability' | 'compliance';\r\n    requireKYC?: boolean;\r\n    requireOFAC?: boolean;\r\n    maxLatencyMs?: number;\r\n    maxFeeBps?: number;\r\n  };\r\n  \r\n  // Original payment requirements (for compatibility)\r\n  requirements: PaymentRequirements;\r\n}\r\n\r\n/**\r\n * Convert RouteContext to facilitator request format\r\n * \r\n * This ensures all facilitators receive x402-spec-compliant requests\r\n */\r\nexport function routeContextToFacilitatorRequest(\r\n  context: RouteContext\r\n): {\r\n  version: number;\r\n  amount: string;\r\n  network: string;\r\n  token: string;\r\n  networkCAIP?: string;\r\n  tokenCAIP?: string;\r\n} {\r\n  return {\r\n    version: context.x402Version,\r\n    amount: context.amount,\r\n    network: context.network,\r\n    token: context.token,\r\n    networkCAIP: context.networkCAIP,\r\n    tokenCAIP: context.tokenCAIP,\r\n  };\r\n}\r\n\r\n/**\r\n * Create RouteContext from PaymentRequirements\r\n * \r\n * Normalizes various input formats into consistent RouteContext\r\n */\r\nexport function createRouteContext(\r\n  requirements: PaymentRequirements,\r\n  options?: {\r\n    callerId?: string;\r\n    clientId?: string;\r\n    region?: string;\r\n    riskLevel?: 'low' | 'medium' | 'high';\r\n    watchLevel?: 'normal' | 'enhanced' | 'strict';\r\n    x402Version?: number;\r\n  }\r\n): RouteContext {\r\n  // Extract network (legacy or CAIP)\r\n  const network = requirements.network || requirements.networks?.[0] || '';\r\n  const networkCAIP = requirements.networks?.[0]?.startsWith('eip155:') \r\n    ? requirements.networks[0] \r\n    : undefined;\r\n  \r\n  // Extract token/asset (legacy or CAIP)\r\n  const token = requirements.asset || requirements.assets?.[0] || '';\r\n  const tokenCAIP = requirements.assets?.[0]?.includes('/') \r\n    ? requirements.assets[0] \r\n    : undefined;\r\n  \r\n  return {\r\n    network,\r\n    token,\r\n    amount: requirements.maxAmountRequired || '0',\r\n    networkCAIP,\r\n    tokenCAIP,\r\n    x402Version: options?.x402Version || 1, // Default to v1, upgrade to v2 when ready\r\n    callerId: options?.callerId,\r\n    clientId: options?.clientId,\r\n    region: options?.region,\r\n    riskLevel: options?.riskLevel,\r\n    watchLevel: options?.watchLevel,\r\n    requirements,\r\n  };\r\n}\r\n\r\n","// =============================================================================\r\n// META-FACILITATOR ORCHESTRATION ENGINE\r\n// =============================================================================\r\n// High-level orchestration layer that sits above individual facilitators\r\n// Owns business logic, routing policy, and risk management\r\n\r\nimport { getFacilitatorRouter, type RoutingPreferences, type RoutingPolicy } from '../facilitators/facilitator-router';\r\nimport { type PaymentRequirements, type VerificationResult, type IFacilitator } from '../facilitators/base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { createRoute, updateRouteStatus, createRouteAttempt } from '@/db/smf';\r\nimport { createRouteContext } from '../facilitators/route-context';\r\n\r\n// Re-export for convenience\r\nexport { getFacilitatorRouter };\r\n\r\nconst logger = createLogger({ component: 'MetaFacilitator' });\r\n\r\n/**\r\n * Meta-facilitator orchestration result\r\n */\r\n/**\r\n * Decision trace for routing decisions\r\n * Enables explainer/debugger UI in NexFlow\r\n */\r\nexport interface DecisionTrace {\r\n  timestamp: string;\r\n  reason: string;\r\n  constraints: {\r\n    preferences?: RoutingPreferences;\r\n    policy?: Partial<RoutingPolicy>;\r\n    requirements: PaymentRequirements;\r\n  };\r\n  candidates: Array<{\r\n    facilitatorId: string;\r\n    facilitatorName: string;\r\n    score: number;\r\n    eligible: boolean;\r\n    reasons: string[];\r\n  }>;\r\n  selected: {\r\n    facilitatorId: string;\r\n    score: number;\r\n    alternativesConsidered: number;\r\n  };\r\n}\r\n\r\nexport interface OrchestrationResult extends VerificationResult {\r\n  facilitatorUsed: string;\r\n  routingReason: string;\r\n  alternativesConsidered: number;\r\n  decisionTrace?: DecisionTrace; // Compact decision trace for debugging\r\n  orchestrationMetadata?: {\r\n    cost?: number;\r\n    latency?: number;\r\n    complianceScore?: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Meta-Facilitator\r\n * Orchestrates multiple facilitators with business logic above raw settlement\r\n */\r\nexport class MetaFacilitator {\r\n  private router = getFacilitatorRouter();\r\n\r\n  /**\r\n   * Verify payment with orchestration\r\n   * \r\n   * This is the main entry point for payment verification.\r\n   * It handles:\r\n   * 1. Facilitator selection based on policy\r\n   * 2. Payment routing\r\n   * 3. Failover handling\r\n   * 4. Result aggregation\r\n   * 5. Business logic application\r\n   */\r\n  async verifyPayment(\r\n    payment: string,\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy,\r\n    context?: {\r\n      requestId?: string;\r\n      correlationId?: string;\r\n      clientId?: string;\r\n      agentId?: string;\r\n    }\r\n  ): Promise<OrchestrationResult> {\r\n    const startTime = Date.now();\r\n    let routeId: string | null = null;\r\n\r\n    try {\r\n      // 1. Create route context and route record\r\n      const routeContext = createRouteContext(requirements, {\r\n        callerId: context?.clientId || context?.agentId,\r\n        clientId: context?.clientId,\r\n        x402Version: 1, // Default to v1, can be upgraded\r\n      });\r\n\r\n      // 2. Select best facilitator based on policy\r\n      const facilitator = await this.router.routePayment(requirements, preferences, policy);\r\n\r\n      // 3. Create route record with selected facilitator\r\n      const route = await createRoute({\r\n        request_id: context?.requestId || null,\r\n        correlation_id: context?.correlationId || null,\r\n        client_id: context?.clientId || null,\r\n        agent_id: context?.agentId || null,\r\n        network: routeContext.network,\r\n        token: routeContext.token,\r\n        amount: routeContext.amount,\r\n        selected_facilitator_id: facilitator.id,\r\n        status: 'verifying',\r\n      });\r\n      routeId = route.id;\r\n\r\n      // Log decision trace (compact format)\r\n      logger.info({\r\n        routeId,\r\n        facilitatorId: facilitator.id,\r\n        network: requirements.network,\r\n        asset: requirements.asset,\r\n        settlementMode: requirements.settlementMode,\r\n        preferences: preferences ? {\r\n          priority: preferences.priority,\r\n          jurisdiction: preferences.jurisdiction,\r\n        } : undefined,\r\n      }, 'Routing payment to facilitator');\r\n\r\n      // 3. Verify payment with selected facilitator\r\n      const verifyStartTime = Date.now();\r\n      let result: VerificationResult;\r\n      let attemptResult: 'success' | 'failure' | 'timeout' | 'rate_limited' | 'insufficient_liquidity' | 'invalid_request' | 'network_error' = 'success';\r\n      let errorCode: string | null = null;\r\n      let rawStatus: number | null = null;\r\n\r\n      try {\r\n        result = await facilitator.verify(payment, requirements);\r\n        const verifyLatency = Date.now() - verifyStartTime;\r\n\r\n        // Determine attempt result\r\n        if (!result.success || !result.valid) {\r\n          attemptResult = 'failure';\r\n          errorCode = result.error || 'verification_failed';\r\n        }\r\n\r\n        // Log route attempt\r\n        await createRouteAttempt({\r\n          route_id: routeId,\r\n          facilitator_id: facilitator.id,\r\n          phase: 'verify',\r\n          result: attemptResult,\r\n          latency_ms: verifyLatency,\r\n          error_code: errorCode,\r\n          raw_status: rawStatus,\r\n          is_probe: false,\r\n        });\r\n      } catch (error) {\r\n        const verifyLatency = Date.now() - verifyStartTime;\r\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n\r\n        // Determine error type\r\n        if (errorMessage.includes('timeout') || errorMessage.includes('TIMEOUT')) {\r\n          attemptResult = 'timeout';\r\n        } else if (errorMessage.includes('rate') || errorMessage.includes('429')) {\r\n          attemptResult = 'rate_limited';\r\n          rawStatus = 429;\r\n        } else if (errorMessage.includes('network') || errorMessage.includes('ECONNREFUSED')) {\r\n          attemptResult = 'network_error';\r\n        } else {\r\n          attemptResult = 'failure';\r\n        }\r\n\r\n        errorCode = errorMessage;\r\n\r\n        // Log failed attempt\r\n        await createRouteAttempt({\r\n          route_id: routeId,\r\n          facilitator_id: facilitator.id,\r\n          phase: 'verify',\r\n          result: attemptResult,\r\n          latency_ms: verifyLatency,\r\n          error_code: errorCode,\r\n          raw_status: rawStatus,\r\n          is_probe: false,\r\n        });\r\n\r\n        // Create failure result\r\n        result = {\r\n          success: false,\r\n          valid: false,\r\n          error: errorMessage,\r\n          facilitatorId: facilitator.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // 4. Apply business logic (risk rules, compliance, etc.)\r\n      const orchestrated = this.applyBusinessLogic(result, requirements, policy);\r\n\r\n      // 5. Update route status\r\n      if (orchestrated.success && orchestrated.valid) {\r\n        await updateRouteStatus(routeId, 'settled', new Date().toISOString());\r\n      } else {\r\n        await updateRouteStatus(routeId, 'failed', new Date().toISOString());\r\n      }\r\n\r\n      // 6. Calculate orchestration metadata\r\n      const latency = Date.now() - startTime;\r\n      const metadata = {\r\n        latency,\r\n        complianceScore: this.calculateComplianceScore(result),\r\n      };\r\n\r\n      // 7. Build decision trace (for explainer/debugger UI)\r\n      const eligible = this.router.getFacilitators().filter((f) =>\r\n        f.supports(requirements.network, requirements.asset, requirements.scheme, requirements.settlementMode) && f.config.enabled\r\n      );\r\n      const decisionTrace = await this.buildDecisionTrace(\r\n        facilitator,\r\n        eligible,\r\n        requirements,\r\n        preferences,\r\n        policy\r\n      );\r\n\r\n      return {\r\n        ...orchestrated,\r\n        facilitatorUsed: facilitator.id,\r\n        routingReason: this.getRoutingReason(facilitator, preferences, policy),\r\n        alternativesConsidered: eligible.length - 1,\r\n        decisionTrace,\r\n        orchestrationMetadata: metadata,\r\n      };\r\n    } catch (error) {\r\n      logger.error({ error, requirements, routeId }, 'Orchestration error');\r\n\r\n      // Update route status to failed\r\n      if (routeId) {\r\n        await updateRouteStatus(routeId, 'failed', new Date().toISOString());\r\n      }\r\n\r\n      // Try failover if available\r\n      if (policy?.requireHealthCheck !== false) {\r\n        return await this.handleFailover(payment, requirements, preferences, policy, error, routeId);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply business logic to verification result\r\n   * SMF owns higher-level policy above raw settlement\r\n   */\r\n  private applyBusinessLogic(\r\n    result: VerificationResult,\r\n    requirements: PaymentRequirements,\r\n    policy?: RoutingPolicy\r\n  ): VerificationResult {\r\n    // 1. Risk rules\r\n    if (policy?.riskThreshold !== undefined) {\r\n      const riskScore = this.calculateRiskScore(result);\r\n      if (riskScore > policy.riskThreshold) {\r\n        return {\r\n          ...result,\r\n          valid: false,\r\n          error: `Risk score ${riskScore} exceeds threshold ${policy.riskThreshold}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // 2. Compliance rules\r\n    if (policy?.requireKYC) {\r\n      // Check if KYC is required for this amount\r\n      const amount = BigInt(requirements.maxAmountRequired);\r\n      const kycThreshold = BigInt('1000000000'); // 1000 USDC in smallest units\r\n      \r\n      if (amount > kycThreshold && result.kytStatus !== 'passed') {\r\n        return {\r\n          ...result,\r\n          valid: false,\r\n          error: 'KYC required for this amount',\r\n        };\r\n      }\r\n    }\r\n\r\n    // 3. Jurisdiction rules\r\n    if (policy?.jurisdictionRules) {\r\n      // Apply jurisdiction-specific rules\r\n      // This would integrate with geo-detection\r\n      // For now, pass through\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Calculate risk score (0-100)\r\n   */\r\n  private calculateRiskScore(result: VerificationResult): number {\r\n    let score = 0;\r\n\r\n    // KYT status\r\n    if (result.kytStatus === 'blocked') score += 50;\r\n    else if (result.kytStatus === 'flagged') score += 25;\r\n\r\n    // OFAC status\r\n    if (result.ofacStatus === 'blocked') score += 50;\r\n    else if (result.ofacStatus === 'flagged') score += 25;\r\n\r\n    // Error status\r\n    if (!result.success || !result.valid) score += 30;\r\n\r\n    return Math.min(100, score);\r\n  }\r\n\r\n  /**\r\n   * Calculate compliance score (0-100)\r\n   */\r\n  private calculateComplianceScore(result: VerificationResult): number {\r\n    let score = 100;\r\n\r\n    // Deduct for compliance issues\r\n    if (result.kytStatus === 'blocked') score -= 50;\r\n    else if (result.kytStatus === 'flagged') score -= 25;\r\n\r\n    if (result.ofacStatus === 'blocked') score -= 50;\r\n    else if (result.ofacStatus === 'flagged') score -= 25;\r\n\r\n    return Math.max(0, score);\r\n  }\r\n\r\n  /**\r\n   * Build decision trace for explainer/debugger UI\r\n   * Compact format for logging and future UI display\r\n   */\r\n  private async buildDecisionTrace(\r\n    selected: IFacilitator,\r\n    eligible: IFacilitator[],\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): Promise<DecisionTrace> {\r\n    // Score candidates to get detailed info\r\n    const router = getFacilitatorRouter();\r\n    const scored = await router.scoreFacilitators(\r\n      eligible,\r\n      requirements,\r\n      preferences,\r\n      policy\r\n    );\r\n\r\n    const candidates = eligible.map((f) => {\r\n      const scoredEntry = scored.find((s: any) => s.facilitator.id === f.id);\r\n      const score = scoredEntry?.score || 0;\r\n      const reasons = scoredEntry?.reasons || [];\r\n\r\n      return {\r\n        facilitatorId: f.id,\r\n        facilitatorName: f.name,\r\n        score,\r\n        eligible: true,\r\n        reasons,\r\n      };\r\n    });\r\n\r\n    return {\r\n      timestamp: new Date().toISOString(),\r\n      reason: this.getRoutingReason(selected, preferences, policy),\r\n      constraints: {\r\n        preferences,\r\n        policy: policy ? {\r\n          requireHealthCheck: policy.requireHealthCheck,\r\n          preferCheapest: policy.preferCheapest,\r\n          requireKYC: policy.requireKYC,\r\n        } : undefined,\r\n        requirements,\r\n      },\r\n      candidates,\r\n      selected: {\r\n        facilitatorId: selected.id,\r\n        score: scored.find((s: any) => s.facilitator.id === selected.id)?.score || 100,\r\n        alternativesConsidered: eligible.length - 1,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get routing reason for logging/analytics\r\n   */\r\n  private getRoutingReason(\r\n    facilitator: any,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): string {\r\n    const reasons: string[] = [];\r\n\r\n    if (preferences?.priority === 'cost') reasons.push('cost-optimized');\r\n    if (preferences?.priority === 'speed') reasons.push('speed-optimized');\r\n    if (preferences?.priority === 'compliance') reasons.push('compliance-optimized');\r\n    if (preferences?.priority === 'reliability') reasons.push('reliability-optimized');\r\n    if (preferences?.preferredNetworks) reasons.push('network-preference');\r\n    if (policy?.preferCheapest) reasons.push('cheapest-selected');\r\n    if (facilitator.config.priority === 1) reasons.push('primary-facilitator');\r\n\r\n    return reasons.join(', ') || 'default-routing';\r\n  }\r\n\r\n  /**\r\n   * Handle failover to alternative facilitator\r\n   */\r\n  private async handleFailover(\r\n    payment: string,\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy,\r\n    originalError?: any,\r\n    routeId?: string | null\r\n  ): Promise<OrchestrationResult> {\r\n    logger.warn({ originalError, requirements }, 'Attempting failover');\r\n\r\n    // Get all facilitators\r\n    const facilitators = this.router.getFacilitators();\r\n    const eligible = facilitators.filter((f) =>\r\n      f.supports(requirements.network, requirements.asset, requirements.scheme, requirements.settlementMode) && f.config.enabled\r\n    );\r\n\r\n    // Try each facilitator in order of priority\r\n    for (const facilitator of eligible.sort((a, b) => a.config.priority - b.config.priority)) {\r\n      const attemptStartTime = Date.now();\r\n      try {\r\n        const result = await facilitator.verify(payment, requirements);\r\n        const attemptLatency = Date.now() - attemptStartTime;\r\n        \r\n        // Log failover attempt\r\n        if (routeId) {\r\n          await createRouteAttempt({\r\n            route_id: routeId,\r\n            facilitator_id: facilitator.id,\r\n            phase: 'verify',\r\n            result: result.success && result.valid ? 'success' : 'failure',\r\n            latency_ms: attemptLatency,\r\n            is_probe: false,\r\n            error_code: result.error || null,\r\n            raw_status: null,\r\n          });\r\n        }\r\n        \r\n        if (result.success && result.valid) {\r\n          logger.info({ facilitatorId: facilitator.id, routeId }, 'Failover successful');\r\n          \r\n          // Update route with successful facilitator\r\n          if (routeId) {\r\n            await updateRouteStatus(routeId, 'settled', new Date().toISOString());\r\n          }\r\n          \r\n          return {\r\n            ...result,\r\n            facilitatorUsed: facilitator.id,\r\n            routingReason: 'failover',\r\n            alternativesConsidered: eligible.length - 1,\r\n          };\r\n        }\r\n      } catch (error) {\r\n        const attemptLatency = Date.now() - attemptStartTime;\r\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n        \r\n        // Log failed failover attempt\r\n        if (routeId) {\r\n          let attemptResult: 'timeout' | 'rate_limited' | 'network_error' | 'failure' = 'failure';\r\n          if (errorMessage.includes('timeout')) {\r\n            attemptResult = 'timeout';\r\n          } else if (errorMessage.includes('rate') || errorMessage.includes('429')) {\r\n            attemptResult = 'rate_limited';\r\n          } else if (errorMessage.includes('network') || errorMessage.includes('ECONNREFUSED')) {\r\n            attemptResult = 'network_error';\r\n          }\r\n          \r\n          await createRouteAttempt({\r\n            route_id: routeId,\r\n            facilitator_id: facilitator.id,\r\n            phase: 'verify',\r\n            result: attemptResult,\r\n            latency_ms: attemptLatency,\r\n            is_probe: false,\r\n            error_code: errorMessage,\r\n            raw_status: null,\r\n          });\r\n        }\r\n        \r\n        logger.warn({ facilitatorId: facilitator.id, error, routeId }, 'Failover attempt failed');\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // All facilitators failed\r\n    throw new Error(\r\n      `All facilitators failed. Original error: ${originalError instanceof Error ? originalError.message : 'Unknown error'}`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get orchestrator status\r\n   * Fixed: Aligns health semantics with facilitator health checks\r\n   */\r\n  async getStatus(): Promise<{\r\n    facilitators: number;\r\n    healthy: number;\r\n    networks: string[];\r\n    assets: string[];\r\n    facilitatorDetails: Array<{\r\n      id: string;\r\n      name: string;\r\n      healthy: boolean;\r\n      lastChecked?: string;\r\n    }>;\r\n  }> {\r\n    const facilitators = this.router.getFacilitators();\r\n    \r\n    // Check health of all facilitators (use actual health checks, not cached)\r\n    const healthChecks = await Promise.all(\r\n      facilitators.map(async (f) => {\r\n        try {\r\n          const health = await f.getHealth();\r\n          return {\r\n            id: f.id,\r\n            name: f.name,\r\n            healthy: health.healthy,\r\n            lastChecked: health.lastChecked,\r\n          };\r\n        } catch (error) {\r\n          return {\r\n            id: f.id,\r\n            name: f.name,\r\n            healthy: false,\r\n            lastChecked: new Date().toISOString(),\r\n          };\r\n        }\r\n      })\r\n    );\r\n\r\n    const healthy = healthChecks.filter((h) => h.healthy);\r\n\r\n    const networks = new Set<string>();\r\n    const assets = new Set<string>();\r\n\r\n    facilitators.forEach((f) => {\r\n      f.config.networks.forEach((n) => networks.add(n));\r\n      f.config.assets.forEach((a) => assets.add(a));\r\n    });\r\n\r\n    return {\r\n      facilitators: facilitators.length,\r\n      healthy: healthy.length,\r\n      networks: Array.from(networks),\r\n      assets: Array.from(assets),\r\n      facilitatorDetails: healthChecks,\r\n    };\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet metaFacilitator: MetaFacilitator | null = null;\r\n\r\n/**\r\n * Get meta-facilitator instance\r\n */\r\nexport function getMetaFacilitator(): MetaFacilitator {\r\n  if (!metaFacilitator) {\r\n    metaFacilitator = new MetaFacilitator();\r\n  }\r\n  return metaFacilitator;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}