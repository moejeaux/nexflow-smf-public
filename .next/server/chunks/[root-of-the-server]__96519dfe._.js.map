{"version":3,"sources":["turbopack:///[project]/node_modules/thread-stream/package.json","../../../src/lib/request-id.ts","../../../src/lib/rate-limit-unified.ts","../../../src/lib/rate-limit-store.ts","../../../src/db/query-helper.ts","../../../src/db/metered-endpoints.ts","../../../src/integrations/x402/x402-call-log.ts","../../../src/db/metrics.ts","../../../src/lib/metrics-collector.ts","../../../src/integrations/x402/caip-utils.ts","../../../src/integrations/x402/chain-registry.ts","../../../src/integrations/x402/facilitators/route-context.ts","../../../src/integrations/x402/orchestrator/meta-facilitator.ts","../../../src/integrations/x402/test-verification.ts","../../../src/lib/input-validator.ts","../../../src/integrations/x402/resource-server.ts","../../../src/integrations/x402/discovery-metadata.ts","../../../src/db/webhook-deliveries.ts","../../../src/lib/webhook-delivery.ts"],"sourcesContent":["{\"name\":\"thread-stream\",\"version\":\"3.1.0\",\"description\":\"A streaming way to send data to a Node.js Worker Thread\",\"main\":\"index.js\",\"types\":\"index.d.ts\",\"dependencies\":{\"real-require\":\"^0.2.0\"},\"devDependencies\":{\"@types/node\":\"^20.1.0\",\"@types/tap\":\"^15.0.0\",\"@yao-pkg/pkg\":\"^5.11.5\",\"desm\":\"^1.3.0\",\"fastbench\":\"^1.0.1\",\"husky\":\"^9.0.6\",\"pino-elasticsearch\":\"^8.0.0\",\"sonic-boom\":\"^4.0.1\",\"standard\":\"^17.0.0\",\"tap\":\"^16.2.0\",\"ts-node\":\"^10.8.0\",\"typescript\":\"^5.3.2\",\"why-is-node-running\":\"^2.2.2\"},\"scripts\":{\"build\":\"tsc --noEmit\",\"test\":\"standard && npm run build && npm run transpile && tap \\\"test/**/*.test.*js\\\" && tap --ts test/*.test.*ts\",\"test:ci\":\"standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts\",\"test:ci:js\":\"tap --no-check-coverage --timeout=120 --coverage-report=lcovonly \\\"test/**/*.test.*js\\\"\",\"test:ci:ts\":\"tap --ts --no-check-coverage --coverage-report=lcovonly \\\"test/**/*.test.*ts\\\"\",\"test:yarn\":\"npm run transpile && tap \\\"test/**/*.test.js\\\" --no-check-coverage\",\"transpile\":\"sh ./test/ts/transpile.sh\",\"prepare\":\"husky install\"},\"standard\":{\"ignore\":[\"test/ts/**/*\",\"test/syntax-error.mjs\"]},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/mcollina/thread-stream.git\"},\"keywords\":[\"worker\",\"thread\",\"threads\",\"stream\"],\"author\":\"Matteo Collina <hello@matteocollina.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/mcollina/thread-stream/issues\"},\"homepage\":\"https://github.com/mcollina/thread-stream#readme\"}","// =============================================================================\r\n// Request ID Tracking\r\n// =============================================================================\r\n// Generates and tracks request IDs for request correlation\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { createLogger, type LogContext } from './logger';\r\n\r\nconst REQUEST_ID_HEADER = 'x-request-id';\r\nconst REQUEST_ID_CONTEXT_KEY = 'requestId';\r\n\r\n/**\r\n * Generate a unique request ID (UUID v4 format)\r\n * Edge-compatible using Web Crypto API\r\n */\r\nexport function generateRequestId(): string {\r\n  // Generate UUID v4 format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\r\n  const array = new Uint8Array(16);\r\n  crypto.getRandomValues(array);\r\n  \r\n  // Set version (4) and variant bits\r\n  array[6] = (array[6] & 0x0f) | 0x40; // Version 4\r\n  array[8] = (array[8] & 0x3f) | 0x80; // Variant 10\r\n  \r\n  // Convert to UUID string format\r\n  const hex = Array.from(array)\r\n    .map(b => b.toString(16).padStart(2, '0'))\r\n    .join('');\r\n  \r\n  return [\r\n    hex.substring(0, 8),\r\n    hex.substring(8, 12),\r\n    hex.substring(12, 16),\r\n    hex.substring(16, 20),\r\n    hex.substring(20, 32),\r\n  ].join('-');\r\n}\r\n\r\n/**\r\n * Extract request ID from headers or generate a new one\r\n * \r\n * Trusts x-request-id from trusted sources (configurable via TRUSTED_REQUEST_ID_SOURCES env var)\r\n * Default: trusts all sources (can be restricted to specific IPs/domains)\r\n */\r\nexport function getOrCreateRequestId(request: NextRequest): string {\r\n  const existingId = request.headers.get(REQUEST_ID_HEADER);\r\n  \r\n  if (existingId) {\r\n    // Check if we should trust this request ID\r\n    const trustedSources = process.env.TRUSTED_REQUEST_ID_SOURCES?.split(',') || [];\r\n    const shouldTrust = trustedSources.length === 0 || \r\n      trustedSources.some(source => {\r\n        const origin = request.headers.get('origin') || '';\r\n        const referer = request.headers.get('referer') || '';\r\n        return origin.includes(source) || referer.includes(source);\r\n      });\r\n    \r\n    if (shouldTrust) {\r\n      return existingId;\r\n    }\r\n  }\r\n  \r\n  return generateRequestId();\r\n}\r\n\r\n/**\r\n * Add request ID to response headers\r\n */\r\nexport function addRequestIdToResponse(\r\n  response: NextResponse,\r\n  requestId: string\r\n): NextResponse {\r\n  response.headers.set(REQUEST_ID_HEADER, requestId);\r\n  return response;\r\n}\r\n\r\n/**\r\n * Get request ID from AsyncLocalStorage (if available)\r\n */\r\nexport function getRequestId(): string | undefined {\r\n  // In Next.js, we'll use headers instead of AsyncLocalStorage\r\n  // This is simpler and works with the serverless model\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Create a logger with request ID context\r\n * Uses full Pino logger for structured logging\r\n * Works in both Node.js and Edge runtime (Pino handles Edge compatibility)\r\n */\r\nexport function createRequestLogger(requestId: string, additionalContext?: Record<string, any>) {\r\n  const context: LogContext = { requestId, ...additionalContext };\r\n  const logger = createLogger(context);\r\n  \r\n  return {\r\n    info: (message: string, meta?: LogContext) => {\r\n      logger.info({ ...context, ...meta }, message);\r\n    },\r\n    warn: (message: string, meta?: LogContext) => {\r\n      logger.warn({ ...context, ...meta }, message);\r\n    },\r\n    error: (message: string, meta?: LogContext) => {\r\n      logger.error({ ...context, ...meta }, message);\r\n    },\r\n    debug: (message: string, meta?: LogContext) => {\r\n      logger.debug({ ...context, ...meta }, message);\r\n    },\r\n  };\r\n}\r\n\r\n","// =============================================================================\r\n// UNIFIED RATE LIMITING\r\n// =============================================================================\r\n// Single implementation for both Edge and Node.js environments.\r\n// Supports distributed rate limiting via Redis with in-memory fallback.\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { getRateLimitStore, getEdgeRateLimitStore, type RateLimitStore } from './rate-limit-store';\r\n\r\n// =============================================================================\r\n// TYPES\r\n// =============================================================================\r\n\r\nexport interface RateLimitConfig {\r\n  windowMs: number;\r\n  maxRequests: number;\r\n  identifier: string;\r\n}\r\n\r\nexport interface RateLimitResult {\r\n  allowed: boolean;\r\n  remaining: number;\r\n  resetAt: number;\r\n  limit: number;\r\n}\r\n\r\nexport interface RateLimitTier {\r\n  name: string;\r\n  windowMs: number;\r\n  maxRequests: number;\r\n}\r\n\r\n// =============================================================================\r\n// DEFAULT TIERS\r\n// =============================================================================\r\n\r\nexport const RATE_LIMIT_TIERS: Record<string, RateLimitTier> = {\r\n  // Per-IP global limits\r\n  global: { name: 'global', windowMs: 60 * 60 * 1000, maxRequests: 1000 },\r\n  \r\n  // Per-endpoint limits (per IP, per minute)\r\n  endpoint: { name: 'endpoint', windowMs: 60 * 1000, maxRequests: 100 },\r\n  \r\n  // API key tiers (per hour)\r\n  free: { name: 'free', windowMs: 60 * 60 * 1000, maxRequests: 100 },\r\n  starter: { name: 'starter', windowMs: 60 * 60 * 1000, maxRequests: 1000 },\r\n  pro: { name: 'pro', windowMs: 60 * 60 * 1000, maxRequests: 5000 },\r\n  enterprise: { name: 'enterprise', windowMs: 60 * 60 * 1000, maxRequests: 50000 },\r\n  \r\n  // Cron job rate limiting (per minute)\r\n  cron: { name: 'cron', windowMs: 60 * 1000, maxRequests: 1 },\r\n};\r\n\r\n// =============================================================================\r\n// METRICS TRACKING\r\n// =============================================================================\r\n\r\ninterface RateLimitMetrics {\r\n  requests: Map<string, number>;      // tier:type -> total requests\r\n  blocked: Map<string, number>;       // tier:type -> blocked requests\r\n  latencies: Map<string, number[]>;   // tier:type -> latencies (last 100)\r\n  lastReset: number;\r\n}\r\n\r\nconst metrics: RateLimitMetrics = {\r\n  requests: new Map(),\r\n  blocked: new Map(),\r\n  latencies: new Map(),\r\n  lastReset: Date.now(),\r\n};\r\n\r\nconst MAX_LATENCY_SAMPLES = 100;\r\nconst METRICS_RESET_INTERVAL_MS = 60 * 60 * 1000; // 1 hour\r\n\r\n/**\r\n * Record a rate limit check\r\n */\r\nfunction recordMetric(\r\n  type: string,\r\n  allowed: boolean,\r\n  latencyMs: number\r\n): void {\r\n  // Reset metrics hourly\r\n  const now = Date.now();\r\n  if (now - metrics.lastReset > METRICS_RESET_INTERVAL_MS) {\r\n    metrics.requests.clear();\r\n    metrics.blocked.clear();\r\n    metrics.latencies.clear();\r\n    metrics.lastReset = now;\r\n  }\r\n  \r\n  // Record request\r\n  const key = type;\r\n  metrics.requests.set(key, (metrics.requests.get(key) || 0) + 1);\r\n  \r\n  // Record blocked\r\n  if (!allowed) {\r\n    metrics.blocked.set(key, (metrics.blocked.get(key) || 0) + 1);\r\n  }\r\n  \r\n  // Record latency (keep last N samples)\r\n  let latencies = metrics.latencies.get(key);\r\n  if (!latencies) {\r\n    latencies = [];\r\n    metrics.latencies.set(key, latencies);\r\n  }\r\n  latencies.push(latencyMs);\r\n  if (latencies.length > MAX_LATENCY_SAMPLES) {\r\n    latencies.shift();\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate percentile from sorted array\r\n */\r\nfunction percentile(sorted: number[], p: number): number {\r\n  if (sorted.length === 0) return 0;\r\n  const idx = Math.ceil(sorted.length * p) - 1;\r\n  return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];\r\n}\r\n\r\n/**\r\n * Get rate limit metrics for observability\r\n */\r\nexport function getRateLimitMetrics(): {\r\n  byType: Record<string, {\r\n    total: number;\r\n    blocked: number;\r\n    blockRate: string;\r\n    latency: { p50: number; p95: number; p99: number };\r\n  }>;\r\n  totals: {\r\n    requests: number;\r\n    blocked: number;\r\n    blockRate: string;\r\n  };\r\n  lastReset: string;\r\n} {\r\n  const byType: Record<string, any> = {};\r\n  let totalRequests = 0;\r\n  let totalBlocked = 0;\r\n  \r\n  const types = new Set([\r\n    ...metrics.requests.keys(),\r\n    ...metrics.blocked.keys(),\r\n  ]);\r\n  \r\n  for (const type of types) {\r\n    const requests = metrics.requests.get(type) || 0;\r\n    const blocked = metrics.blocked.get(type) || 0;\r\n    const latencies = metrics.latencies.get(type) || [];\r\n    \r\n    totalRequests += requests;\r\n    totalBlocked += blocked;\r\n    \r\n    // Calculate latency percentiles\r\n    const sorted = [...latencies].sort((a, b) => a - b);\r\n    \r\n    byType[type] = {\r\n      total: requests,\r\n      blocked,\r\n      blockRate: requests > 0 ? ((blocked / requests) * 100).toFixed(2) + '%' : '0%',\r\n      latency: {\r\n        p50: Math.round(percentile(sorted, 0.5)),\r\n        p95: Math.round(percentile(sorted, 0.95)),\r\n        p99: Math.round(percentile(sorted, 0.99)),\r\n      },\r\n    };\r\n  }\r\n  \r\n  return {\r\n    byType,\r\n    totals: {\r\n      requests: totalRequests,\r\n      blocked: totalBlocked,\r\n      blockRate: totalRequests > 0 \r\n        ? ((totalBlocked / totalRequests) * 100).toFixed(2) + '%' \r\n        : '0%',\r\n    },\r\n    lastReset: new Date(metrics.lastReset).toISOString(),\r\n  };\r\n}\r\n\r\n/**\r\n * Reset rate limit metrics (for testing)\r\n */\r\nexport function resetRateLimitMetrics(): void {\r\n  metrics.requests.clear();\r\n  metrics.blocked.clear();\r\n  metrics.latencies.clear();\r\n  metrics.lastReset = Date.now();\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Extract API key from Authorization header\r\n */\r\nexport function extractApiKey(request: NextRequest): string | null {\r\n  const authHeader = request.headers.get('authorization');\r\n  if (!authHeader) return null;\r\n  \r\n  if (authHeader.startsWith('Bearer ')) {\r\n    return authHeader.substring(7).trim();\r\n  }\r\n  return authHeader.trim();\r\n}\r\n\r\n/**\r\n * Get client IP address\r\n */\r\nexport function getClientIp(request: NextRequest): string {\r\n  return (\r\n    request.ip ||\r\n    request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() ||\r\n    request.headers.get('x-real-ip') ||\r\n    'unknown'\r\n  );\r\n}\r\n\r\n/**\r\n * Hash a string for use as rate limit key (don't store full API keys)\r\n */\r\nfunction hashKey(key: string): string {\r\n  // Use first 16 chars as identifier (safe for rate limiting)\r\n  return key.substring(0, 16);\r\n}\r\n\r\n// =============================================================================\r\n// CORE RATE LIMIT CHECK\r\n// =============================================================================\r\n\r\n/**\r\n * Check rate limit against a store\r\n */\r\nasync function checkRateLimitAsync(\r\n  store: RateLimitStore,\r\n  config: RateLimitConfig,\r\n  metricType?: string\r\n): Promise<RateLimitResult> {\r\n  const start = Date.now();\r\n  const entry = await store.increment(config.identifier, config.windowMs);\r\n  \r\n  const allowed = entry.count <= config.maxRequests;\r\n  const remaining = Math.max(0, config.maxRequests - entry.count);\r\n  \r\n  // Record metrics if type provided\r\n  if (metricType) {\r\n    recordMetric(metricType, allowed, Date.now() - start);\r\n  }\r\n  \r\n  return {\r\n    allowed,\r\n    remaining,\r\n    resetAt: entry.resetAt,\r\n    limit: config.maxRequests,\r\n  };\r\n}\r\n\r\n/**\r\n * Synchronous check for Edge runtime\r\n */\r\nfunction checkRateLimitSync(\r\n  store: RateLimitStore,\r\n  config: RateLimitConfig\r\n): RateLimitResult {\r\n  const now = Date.now();\r\n  const key = config.identifier;\r\n  \r\n  // Note: This is a simplified sync version that may not be perfectly accurate\r\n  // but works for Edge runtime where we can't await\r\n  const resetAt = now + config.windowMs;\r\n  \r\n  return {\r\n    allowed: true, // Edge allows through, Node enforces\r\n    remaining: config.maxRequests,\r\n    resetAt,\r\n    limit: config.maxRequests,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API - ASYNC (Node.js)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by API key (Node.js - database lookup)\r\n */\r\nexport async function rateLimitByApiKey(\r\n  request: NextRequest,\r\n  apiKeyRateLimit?: number\r\n): Promise<RateLimitResult | null> {\r\n  const token = extractApiKey(request);\r\n  if (!token) return null;\r\n  \r\n  const store = await getRateLimitStore();\r\n  const limit = apiKeyRateLimit || RATE_LIMIT_TIERS.starter.maxRequests;\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.starter.windowMs,\r\n    maxRequests: limit,\r\n    identifier: `api_key:${hashKey(token)}`,\r\n  }, 'api_key');\r\n}\r\n\r\n/**\r\n * Rate limit by endpoint (Node.js)\r\n */\r\nexport async function rateLimitByEndpoint(\r\n  request: NextRequest,\r\n  endpointId: string,\r\n  maxRequests?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.endpoint.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.endpoint.maxRequests,\r\n    identifier: `endpoint:${endpointId}:${ip}`,\r\n  }, `endpoint:${endpointId}`);\r\n}\r\n\r\n/**\r\n * Rate limit by IP (Node.js)\r\n */\r\nexport async function rateLimitByIp(\r\n  request: NextRequest,\r\n  maxRequests?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.global.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.global.maxRequests,\r\n    identifier: `global:${ip}`,\r\n  }, 'global');\r\n}\r\n\r\n/**\r\n * Rate limit cron job (prevent concurrent runs)\r\n */\r\nexport async function rateLimitCronJob(\r\n  cronId: string,\r\n  intervalMs?: number\r\n): Promise<RateLimitResult> {\r\n  const store = await getRateLimitStore();\r\n  \r\n  return checkRateLimitAsync(store, {\r\n    windowMs: intervalMs || RATE_LIMIT_TIERS.cron.windowMs,\r\n    maxRequests: RATE_LIMIT_TIERS.cron.maxRequests,\r\n    identifier: `cron:${cronId}`,\r\n  }, `cron:${cronId}`);\r\n}\r\n\r\n// =============================================================================\r\n// PUBLIC API - SYNC (Edge Runtime)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by IP (Edge - sync, in-memory only)\r\n */\r\nexport function rateLimitByIpEdge(\r\n  request: NextRequest,\r\n  maxRequests?: number\r\n): RateLimitResult {\r\n  const store = getEdgeRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.global.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.global.maxRequests,\r\n    identifier: `global:${ip}`,\r\n  });\r\n}\r\n\r\n/**\r\n * Rate limit by API key (Edge - sync, default limit only)\r\n */\r\nexport function rateLimitByApiKeyEdge(\r\n  request: NextRequest,\r\n  defaultLimit?: number\r\n): RateLimitResult | null {\r\n  const token = extractApiKey(request);\r\n  if (!token) return null;\r\n  \r\n  const store = getEdgeRateLimitStore();\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.starter.windowMs,\r\n    maxRequests: defaultLimit || RATE_LIMIT_TIERS.starter.maxRequests,\r\n    identifier: `api_key:${hashKey(token)}`,\r\n  });\r\n}\r\n\r\n// =============================================================================\r\n// RESPONSE HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Add rate limit headers to response\r\n */\r\nexport function addRateLimitHeaders(\r\n  response: NextResponse,\r\n  result: RateLimitResult\r\n): NextResponse {\r\n  response.headers.set('X-RateLimit-Limit', result.limit.toString());\r\n  response.headers.set('X-RateLimit-Remaining', result.remaining.toString());\r\n  response.headers.set('X-RateLimit-Reset', new Date(result.resetAt).toISOString());\r\n  return response;\r\n}\r\n\r\n/**\r\n * Create rate limit error response\r\n */\r\nexport function createRateLimitResponse(result: RateLimitResult): NextResponse {\r\n  const resetDate = new Date(result.resetAt).toISOString();\r\n  const retryAfter = Math.ceil((result.resetAt - Date.now()) / 1000);\r\n  \r\n  const response = NextResponse.json(\r\n    {\r\n      error: 'Rate limit exceeded',\r\n      code: 'RATE_LIMIT_EXCEEDED',\r\n      message: `Too many requests. Limit: ${result.limit} per hour. Try again after ${resetDate}`,\r\n      retryAfter,\r\n    },\r\n    { status: 429 }\r\n  );\r\n  \r\n  response.headers.set('Retry-After', retryAfter.toString());\r\n  return addRateLimitHeaders(response, result);\r\n}\r\n\r\n// =============================================================================\r\n// COMPOSITE CHECKS\r\n// =============================================================================\r\n\r\n/**\r\n * Check all rate limits (API key + endpoint + global)\r\n * Returns first exceeded limit, or null if all pass\r\n */\r\nexport async function checkAllRateLimits(\r\n  request: NextRequest,\r\n  options?: {\r\n    endpointId?: string;\r\n    apiKeyRateLimit?: number;\r\n  }\r\n): Promise<{ result: RateLimitResult; type: string } | null> {\r\n  // 1. Global IP limit\r\n  const globalResult = await rateLimitByIp(request);\r\n  if (!globalResult.allowed) {\r\n    return { result: globalResult, type: 'global' };\r\n  }\r\n  \r\n  // 2. API key limit (if authenticated)\r\n  const apiKeyResult = await rateLimitByApiKey(request, options?.apiKeyRateLimit);\r\n  if (apiKeyResult && !apiKeyResult.allowed) {\r\n    return { result: apiKeyResult, type: 'api_key' };\r\n  }\r\n  \r\n  // 3. Endpoint limit (if specified)\r\n  if (options?.endpointId) {\r\n    const endpointResult = await rateLimitByEndpoint(request, options.endpointId);\r\n    if (!endpointResult.allowed) {\r\n      return { result: endpointResult, type: 'endpoint' };\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * Get rate limit info for response headers (async version)\r\n * Returns the most restrictive limit for informational headers\r\n */\r\nexport async function getRateLimitHeaders(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): Promise<RateLimitResult | null> {\r\n  const results: RateLimitResult[] = [];\r\n\r\n  // Global IP limit\r\n  const globalResult = await rateLimitByIp(request);\r\n  results.push(globalResult);\r\n\r\n  // API key limit\r\n  const apiKeyResult = await rateLimitByApiKey(request);\r\n  if (apiKeyResult) {\r\n    results.push(apiKeyResult);\r\n  }\r\n\r\n  // Endpoint limit\r\n  if (endpointId) {\r\n    const endpointResult = await rateLimitByEndpoint(request, endpointId);\r\n    results.push(endpointResult);\r\n  }\r\n\r\n  // Return the most restrictive (lowest remaining)\r\n  if (results.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return results.reduce((min, current) =>\r\n    current.remaining < min.remaining ? current : min\r\n  );\r\n}\r\n\r\n// =============================================================================\r\n// EDGE-COMPATIBLE FUNCTIONS (Sync)\r\n// =============================================================================\r\n\r\n/**\r\n * Rate limit by endpoint (Edge - sync, in-memory only)\r\n */\r\nexport function rateLimitByEndpointEdge(\r\n  request: NextRequest,\r\n  endpointId: string,\r\n  maxRequests?: number\r\n): RateLimitResult {\r\n  const store = getEdgeRateLimitStore();\r\n  const ip = getClientIp(request);\r\n  \r\n  return checkRateLimitSync(store, {\r\n    windowMs: RATE_LIMIT_TIERS.endpoint.windowMs,\r\n    maxRequests: maxRequests || RATE_LIMIT_TIERS.endpoint.maxRequests,\r\n    identifier: `endpoint:${endpointId}:${ip}`,\r\n  });\r\n}\r\n\r\n/**\r\n * Check all rate limits (Edge-compatible, sync version)\r\n * Returns first exceeded limit, or null if all pass\r\n */\r\nexport function checkAllRateLimitsEdge(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): { result: RateLimitResult; type: string } | null {\r\n  // 1. Global IP limit\r\n  const globalResult = rateLimitByIpEdge(request);\r\n  if (!globalResult.allowed) {\r\n    return { result: globalResult, type: 'global' };\r\n  }\r\n  \r\n  // 2. API key limit (Edge uses default limit)\r\n  const apiKeyResult = rateLimitByApiKeyEdge(request);\r\n  if (apiKeyResult && !apiKeyResult.allowed) {\r\n    return { result: apiKeyResult, type: 'api_key' };\r\n  }\r\n  \r\n  // 3. Endpoint limit (if specified)\r\n  if (endpointId) {\r\n    const endpointResult = rateLimitByEndpointEdge(request, endpointId);\r\n    if (!endpointResult.allowed) {\r\n      return { result: endpointResult, type: 'endpoint' };\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * Get rate limit info for response headers (Edge-compatible, sync version)\r\n */\r\nexport function getRateLimitHeadersEdge(\r\n  request: NextRequest,\r\n  endpointId?: string\r\n): RateLimitResult | null {\r\n  const results: RateLimitResult[] = [];\r\n\r\n  // Global IP limit\r\n  results.push(rateLimitByIpEdge(request));\r\n\r\n  // API key limit\r\n  const apiKeyResult = rateLimitByApiKeyEdge(request);\r\n  if (apiKeyResult) {\r\n    results.push(apiKeyResult);\r\n  }\r\n\r\n  // Endpoint limit\r\n  if (endpointId) {\r\n    results.push(rateLimitByEndpointEdge(request, endpointId));\r\n  }\r\n\r\n  // Return the most restrictive (lowest remaining)\r\n  if (results.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return results.reduce((min, current) =>\r\n    current.remaining < min.remaining ? current : min\r\n  );\r\n}\r\n\r\n","// =============================================================================\r\n// RATE LIMIT STORE\r\n// =============================================================================\r\n// Pluggable backing store for rate limiting with Upstash Redis support and in-memory fallback.\r\n// Supports distributed rate limiting across serverless instances.\r\n//\r\n// Environment Variables:\r\n// - UPSTASH_REDIS_REST_URL: Upstash Redis REST URL (from Vercel integration)\r\n// - UPSTASH_REDIS_REST_TOKEN: Upstash Redis REST token (from Vercel integration)\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'RateLimitStore' });\r\n\r\nexport interface RateLimitEntry {\r\n  count: number;\r\n  resetAt: number;\r\n}\r\n\r\nexport interface RateLimitStore {\r\n  get(key: string): Promise<RateLimitEntry | null>;\r\n  set(key: string, entry: RateLimitEntry): Promise<void>;\r\n  increment(key: string, windowMs: number): Promise<RateLimitEntry>;\r\n}\r\n\r\n// =============================================================================\r\n// IN-MEMORY STORE (fallback)\r\n// =============================================================================\r\n\r\nclass InMemoryStore implements RateLimitStore {\r\n  private store = new Map<string, RateLimitEntry>();\r\n  private cleanupInterval: ReturnType<typeof setInterval> | null = null;\r\n\r\n  constructor() {\r\n    // Cleanup every 5 minutes\r\n    if (typeof setInterval !== 'undefined') {\r\n      this.cleanupInterval = setInterval(() => this.cleanup(), 5 * 60 * 1000);\r\n    }\r\n  }\r\n\r\n  private cleanup(): void {\r\n    const now = Date.now();\r\n    const keysToDelete: string[] = [];\r\n    this.store.forEach((value, key) => {\r\n      if (value.resetAt < now) {\r\n        keysToDelete.push(key);\r\n      }\r\n    });\r\n    keysToDelete.forEach(key => this.store.delete(key));\r\n  }\r\n\r\n  async get(key: string): Promise<RateLimitEntry | null> {\r\n    const entry = this.store.get(key);\r\n    if (!entry || entry.resetAt < Date.now()) {\r\n      return null;\r\n    }\r\n    return entry;\r\n  }\r\n\r\n  async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n    this.store.set(key, entry);\r\n  }\r\n\r\n  async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n    const now = Date.now();\r\n    const existing = this.store.get(key);\r\n\r\n    if (!existing || existing.resetAt < now) {\r\n      const entry = { count: 1, resetAt: now + windowMs };\r\n      this.store.set(key, entry);\r\n      return entry;\r\n    }\r\n\r\n    existing.count++;\r\n    this.store.set(key, existing);\r\n    return existing;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// UPSTASH REDIS STORE (distributed)\r\n// =============================================================================\r\n\r\nclass UpstashRedisStore implements RateLimitStore {\r\n  private redis: any;\r\n\r\n  constructor(redisClient: any) {\r\n    this.redis = redisClient;\r\n  }\r\n\r\n  async get(key: string): Promise<RateLimitEntry | null> {\r\n    try {\r\n      const data = await this.redis.get(`ratelimit:${key}`);\r\n      if (!data) return null;\r\n      \r\n      // Upstash returns parsed JSON automatically if it's a JSON string\r\n      const entry = typeof data === 'string' ? JSON.parse(data) : data;\r\n      if (entry.resetAt < Date.now()) return null;\r\n      return entry as RateLimitEntry;\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis GET failed');\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n    try {\r\n      const ttlMs = Math.max(entry.resetAt - Date.now(), 1000);\r\n      const ttlSeconds = Math.ceil(ttlMs / 1000);\r\n      \r\n      await this.redis.set(\r\n        `ratelimit:${key}`,\r\n        JSON.stringify(entry),\r\n        { ex: ttlSeconds }\r\n      );\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis SET failed');\r\n    }\r\n  }\r\n\r\n  async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n    try {\r\n      const redisKey = `ratelimit:${key}`;\r\n      const now = Date.now();\r\n\r\n      // Get current entry\r\n      const data = await this.redis.get(redisKey);\r\n      \r\n      let count = 1;\r\n      let resetAt = now + windowMs;\r\n      \r\n      if (data) {\r\n        const entry = typeof data === 'string' ? JSON.parse(data) : data;\r\n        if (entry.resetAt > now) {\r\n          count = entry.count + 1;\r\n          resetAt = entry.resetAt;\r\n        }\r\n      }\r\n      \r\n      const newEntry = { count, resetAt };\r\n      const ttlMs = resetAt - now;\r\n      const ttlSeconds = Math.ceil(ttlMs / 1000);\r\n      \r\n      await this.redis.set(redisKey, JSON.stringify(newEntry), { ex: ttlSeconds });\r\n      \r\n      return newEntry;\r\n    } catch (error) {\r\n      logger.error({ error, key }, 'Upstash Redis INCR failed');\r\n      // Fallback: return a permissive entry\r\n      return { count: 1, resetAt: Date.now() + windowMs };\r\n    }\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// STORE FACTORY\r\n// =============================================================================\r\n\r\nlet storeInstance: RateLimitStore | null = null;\r\n\r\n/**\r\n * Get the rate limit store singleton.\r\n * Uses Upstash Redis if configured, otherwise falls back to in-memory.\r\n */\r\nexport async function getRateLimitStore(): Promise<RateLimitStore> {\r\n  if (storeInstance) {\r\n    return storeInstance;\r\n  }\r\n\r\n  // Check for Upstash Redis environment variables (set by Vercel integration)\r\n  const upstashUrl = process.env.UPSTASH_REDIS_REST_URL;\r\n  const upstashToken = process.env.UPSTASH_REDIS_REST_TOKEN;\r\n\r\n  if (upstashUrl && upstashToken) {\r\n    try {\r\n      // Dynamic import to avoid build issues\r\n      const { Redis } = await import('@upstash/redis');\r\n      const redis = new Redis({\r\n        url: upstashUrl,\r\n        token: upstashToken,\r\n      });\r\n\r\n      // Test connection\r\n      await redis.ping();\r\n      \r\n      logger.info('Rate limit store using Upstash Redis');\r\n      storeInstance = new UpstashRedisStore(redis);\r\n      return storeInstance;\r\n    } catch (error) {\r\n      logger.warn({ error }, 'Upstash Redis connection failed, falling back to in-memory');\r\n    }\r\n  }\r\n\r\n  // Legacy support: check for REDIS_URL (ioredis)\r\n  const redisUrl = process.env.REDIS_URL;\r\n  if (redisUrl) {\r\n    try {\r\n      const { Redis } = await import('ioredis');\r\n      const redis = new Redis(redisUrl, {\r\n        maxRetriesPerRequest: 3,\r\n        enableReadyCheck: true,\r\n        connectTimeout: 5000,\r\n        lazyConnect: true,\r\n      });\r\n\r\n      await redis.connect();\r\n      logger.info('Rate limit store using Redis (ioredis)');\r\n      \r\n      // Use a simple wrapper that matches UpstashRedisStore behavior\r\n      storeInstance = {\r\n        async get(key: string): Promise<RateLimitEntry | null> {\r\n          const data = await redis.get(`ratelimit:${key}`);\r\n          if (!data) return null;\r\n          const entry = JSON.parse(data) as RateLimitEntry;\r\n          if (entry.resetAt < Date.now()) return null;\r\n          return entry;\r\n        },\r\n        async set(key: string, entry: RateLimitEntry): Promise<void> {\r\n          const ttlMs = Math.max(entry.resetAt - Date.now(), 1000);\r\n          await redis.set(`ratelimit:${key}`, JSON.stringify(entry), 'PX', ttlMs);\r\n        },\r\n        async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\r\n          const now = Date.now();\r\n          const redisKey = `ratelimit:${key}`;\r\n          const data = await redis.get(redisKey);\r\n          \r\n          let count = 1;\r\n          let resetAt = now + windowMs;\r\n          \r\n          if (data) {\r\n            const entry = JSON.parse(data);\r\n            if (entry.resetAt > now) {\r\n              count = entry.count + 1;\r\n              resetAt = entry.resetAt;\r\n            }\r\n          }\r\n          \r\n          const newEntry = { count, resetAt };\r\n          const ttlMs = resetAt - now;\r\n          await redis.set(redisKey, JSON.stringify(newEntry), 'PX', ttlMs);\r\n          return newEntry;\r\n        }\r\n      };\r\n      return storeInstance;\r\n    } catch (error) {\r\n      logger.warn({ error }, 'Redis connection failed, falling back to in-memory');\r\n    }\r\n  }\r\n\r\n  logger.info('Rate limit store using in-memory (non-distributed)');\r\n  storeInstance = new InMemoryStore();\r\n  return storeInstance;\r\n}\r\n\r\n/**\r\n * Synchronous in-memory store for Edge runtime.\r\n * Edge runtime can use Upstash but requires async initialization.\r\n */\r\nexport function getEdgeRateLimitStore(): RateLimitStore {\r\n  // Edge runtime uses in-memory for sync access\r\n  // For async Edge operations, use getRateLimitStore()\r\n  if (!storeInstance) {\r\n    storeInstance = new InMemoryStore();\r\n  }\r\n  return storeInstance;\r\n}\r\n\r\n/**\r\n * Reset the store singleton (for testing)\r\n */\r\nexport function resetRateLimitStore(): void {\r\n  storeInstance = null;\r\n}\r\n","// =============================================================================\r\n// DATABASE QUERY HELPER\r\n// =============================================================================\r\n// Helper functions for executing raw SQL queries that work with both SQLite and PostgreSQL\r\n// This is used for new tables that aren't yet in the adapter interface\r\n\r\nimport { getDb } from './client';\r\n\r\n/**\r\n * Execute a raw SQL query (works with both SQLite and PostgreSQL)\r\n */\r\nexport async function executeQuery<T = any>(\r\n  query: string,\r\n  params: any[] = []\r\n): Promise<T[]> {\r\n  const db = getDb();\r\n  \r\n  // Check if it's PostgreSQL adapter\r\n  if ('pool' in db && typeof (db as any).pool?.query === 'function') {\r\n    const pool = (db as any).pool;\r\n    const result = await pool.query(query, params);\r\n    return result.rows;\r\n  }\r\n  \r\n  // Check if it's SQLite adapter\r\n  if ('db' in db && typeof (db as any).db?.prepare === 'function') {\r\n    const dbInstance = (db as any).db;\r\n    const stmt = dbInstance.prepare(query);\r\n    return stmt.all(...params) as T[];\r\n  }\r\n  \r\n  // Fallback: try direct access\r\n  if (typeof (db as any).query === 'function') {\r\n    const result = await (db as any).query(query, params);\r\n    return result.rows || result;\r\n  }\r\n  \r\n  if (typeof (db as any).prepare === 'function') {\r\n    const stmt = (db as any).prepare(query);\r\n    return stmt.all(...params) as T[];\r\n  }\r\n  \r\n  throw new Error('Unable to execute query: database adapter not recognized');\r\n}\r\n\r\n/**\r\n * Execute a raw SQL query that returns a single row\r\n */\r\nexport async function executeQueryOne<T = any>(\r\n  query: string,\r\n  params: any[] = []\r\n): Promise<T | null> {\r\n  const results = await executeQuery<T>(query, params);\r\n  return results.length > 0 ? results[0] : null;\r\n}\r\n\r\n/**\r\n * Execute a raw SQL query that doesn't return results (INSERT, UPDATE, DELETE)\r\n */\r\nexport async function executeUpdate(\r\n  query: string,\r\n  params: any[] = []\r\n): Promise<{ rowCount?: number; changes?: number }> {\r\n  const db = getDb();\r\n  \r\n  // Check if it's PostgreSQL adapter\r\n  if ('pool' in db && typeof (db as any).pool?.query === 'function') {\r\n    const pool = (db as any).pool;\r\n    const result = await pool.query(query, params);\r\n    return { rowCount: result.rowCount };\r\n  }\r\n  \r\n  // Check if it's SQLite adapter\r\n  if ('db' in db && typeof (db as any).db?.prepare === 'function') {\r\n    const dbInstance = (db as any).db;\r\n    const stmt = dbInstance.prepare(query);\r\n    const result = stmt.run(...params);\r\n    return { changes: (result as any).changes };\r\n  }\r\n  \r\n  // Fallback\r\n  if (typeof (db as any).query === 'function') {\r\n    const result = await (db as any).query(query, params);\r\n    return { rowCount: result.rowCount };\r\n  }\r\n  \r\n  if (typeof (db as any).prepare === 'function') {\r\n    const stmt = (db as any).prepare(query);\r\n    const result = stmt.run(...params);\r\n    return { changes: (result as any).changes };\r\n  }\r\n  \r\n  throw new Error('Unable to execute update: database adapter not recognized');\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n","// =============================================================================\r\n// METERED ENDPOINTS DATABASE\r\n// =============================================================================\r\n// Database layer for metered endpoints, payments, and usage tracking\r\n// Uses adapter pattern: SQLite (dev) or PostgreSQL (prod)\r\n\r\nimport { getDb } from './client';\r\nimport type { DatabaseAdapter } from './adapters/base-adapter';\r\n\r\n// Types\r\nexport interface MeteredEndpoint {\r\n  id: string;\r\n  name: string;\r\n  description?: string;\r\n  upstreamUrl: string;\r\n  price: string; // Price in smallest unit (e.g., 1000000 for 1 USDC)\r\n  network: string; // 'base', 'base-sepolia', etc.\r\n  tokenAddress: string; // USDC address\r\n  tokenSymbol: string; // 'USDC'\r\n  chainId: number;\r\n  recipientAddress: string; // Address that receives payments (must not be blacklisted)\r\n  status: 'active' | 'paused' | 'deleted';\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  createdBy?: string; // User/API key that created it\r\n}\r\n\r\nexport interface Payment {\r\n  id: string;\r\n  endpointId: string;\r\n  txHash: string;\r\n  fromAddress: string;\r\n  toAddress: string;\r\n  amount: string;\r\n  tokenAddress: string;\r\n  network: string;\r\n  verifiedAt: string;\r\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\r\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\r\n  facilitator: string; // 'cdp', 'payai', etc.\r\n}\r\n\r\nexport interface UsageLog {\r\n  id: string;\r\n  endpointId: string;\r\n  paymentId?: string; // Link to payment if payment was required\r\n  timestamp: string;\r\n  method: string; // HTTP method\r\n  path: string;\r\n  statusCode: number;\r\n  responseTime: number; // milliseconds\r\n  units: number; // Usage units (could be 1 per call, or based on response size, etc.)\r\n  ipAddress?: string;\r\n  userAgent?: string;\r\n  // Observability fields\r\n  conversationId?: string; // Conversation/request ID for tracing\r\n  agentId?: string; // Agent ID that made the request\r\n  x402TxHash?: string; // x402 transaction hash\r\n  failureCode?: string; // Error code if request failed\r\n}\r\n\r\n// =============================================================================\r\n// ENDPOINTS CRUD\r\n// =============================================================================\r\n\r\nexport async function createEndpoint(\r\n  endpoint: Omit<MeteredEndpoint, 'id' | 'createdAt' | 'updatedAt'> & { id?: string }\r\n): Promise<MeteredEndpoint> {\r\n  const db = getDb();\r\n  return await db.createEndpoint(endpoint);\r\n}\r\n\r\nexport async function getEndpoint(endpointId: string): Promise<MeteredEndpoint | null> {\r\n  const db = getDb();\r\n  return await db.getEndpoint(endpointId);\r\n}\r\n\r\nexport async function listEndpoints(filters?: { status?: string; createdBy?: string }): Promise<MeteredEndpoint[]> {\r\n  const db = getDb();\r\n  return await db.listEndpoints(filters);\r\n}\r\n\r\nexport async function updateEndpoint(\r\n  endpointId: string,\r\n  updates: Partial<MeteredEndpoint>\r\n): Promise<MeteredEndpoint | null> {\r\n  const db = getDb();\r\n  return await db.updateEndpoint(endpointId, updates);\r\n}\r\n\r\nexport async function deleteEndpoint(endpointId: string): Promise<boolean> {\r\n  const db = getDb();\r\n  return await db.deleteEndpoint(endpointId);\r\n}\r\n\r\n// =============================================================================\r\n// PAYMENTS CRUD\r\n// =============================================================================\r\n\r\nexport async function createPayment(payment: Omit<Payment, 'id' | 'verifiedAt'>): Promise<Payment> {\r\n  const db = getDb();\r\n  return await db.createPayment(payment);\r\n}\r\n\r\nexport async function getPayment(paymentId: string): Promise<Payment | null> {\r\n  const db = getDb();\r\n  return await db.getPayment(paymentId);\r\n}\r\n\r\nexport async function getPaymentByTxHash(txHash: string): Promise<Payment | null> {\r\n  const db = getDb();\r\n  return await db.getPaymentByTxHash(txHash);\r\n}\r\n\r\nexport async function listPayments(filters?: { endpointId?: string; fromAddress?: string }): Promise<Payment[]> {\r\n  const db = getDb();\r\n  return await db.listPayments(filters);\r\n}\r\n\r\nexport async function getPaymentsForEndpoint(endpointId: string, limit: number = 100): Promise<Payment[]> {\r\n  const db = getDb();\r\n  return await db.getPaymentsForEndpoint(endpointId, limit);\r\n}\r\n\r\n// =============================================================================\r\n// USAGE LOGS CRUD\r\n// =============================================================================\r\n\r\nexport async function createUsageLog(log: Omit<UsageLog, 'id' | 'timestamp'>): Promise<UsageLog> {\r\n  const db = getDb();\r\n  return await db.createUsageLog(log);\r\n}\r\n\r\nexport async function listUsageLogs(filters?: { endpointId?: string; paymentId?: string }): Promise<UsageLog[]> {\r\n  const db = getDb();\r\n  return await db.listUsageLogs(filters);\r\n}\r\n\r\nexport async function getUsageStats(\r\n  endpointId: string,\r\n  startDate?: string,\r\n  endDate?: string\r\n): Promise<{\r\n  totalRequests: number;\r\n  totalPayments: number;\r\n  totalRevenue: string;\r\n  averageResponseTime: number;\r\n}> {\r\n  const db = getDb();\r\n  return await db.getUsageStats(endpointId, startDate, endDate);\r\n}\r\n","// =============================================================================\n// X402 CALL LOG\n// =============================================================================\n// Canonical x402 log event interface and logging utilities\n// Maps to UsageLog in database for persistence\n\nimport { createUsageLog, listUsageLogs, type UsageLog } from '@/db/metered-endpoints';\nimport { createLogger } from '@/lib/logger';\n\nconst logger = createLogger({ component: 'X402CallLog' });\n\n/**\n * Canonical x402 call log event\n * This interface represents the complete x402 payment flow for a single API call\n */\nexport interface X402CallLog {\n  id: string;\n  timestamp: string;\n  customerId: string | null;\n  endpointId: string;\n  agentId: string | null;\n  facilitator: string;\n  chainId: string;\n  asset: string;\n  amount: string;\n  status: 'success' | 'failed';\n  errorCode?: string;\n  x402TxHash?: string;\n  latencyMs: number;\n  resource: string;\n}\n\n/**\n * Convert X402CallLog to UsageLog for database persistence\n */\nfunction x402CallLogToUsageLog(x402Log: Omit<X402CallLog, 'id' | 'timestamp'>): Omit<UsageLog, 'id' | 'timestamp'> {\n  return {\n    endpointId: x402Log.endpointId,\n    method: 'POST', // Default for metered endpoints\n    path: new URL(x402Log.resource).pathname,\n    statusCode: x402Log.status === 'success' ? 200 : (x402Log.errorCode === 'PAYMENT_REQUIRED' ? 402 : 400),\n    responseTime: x402Log.latencyMs,\n    units: 1, // 1 unit per call\n    conversationId: x402Log.customerId || undefined,\n    agentId: x402Log.agentId || undefined,\n    x402TxHash: x402Log.x402TxHash || undefined,\n    failureCode: x402Log.status === 'failed' ? (x402Log.errorCode || 'UNKNOWN_ERROR') : undefined,\n  };\n}\n\n/**\n * Convert UsageLog back to X402CallLog for retrieval\n * This reconstructs the X402CallLog from the stored UsageLog\n */\nexport function usageLogToX402CallLog(usageLog: UsageLog, metadata?: {\n  facilitator?: string;\n  chainId?: string;\n  asset?: string;\n  amount?: string;\n  resource?: string;\n}): X402CallLog {\n  // Determine status from statusCode and failureCode\n  const status: 'success' | 'failed' = usageLog.statusCode === 200 && !usageLog.failureCode ? 'success' : 'failed';\n  \n  // Reconstruct resource URL from path\n  const appUrl = process.env.NEXT_PUBLIC_APP_URL;\n  const baseUrl = appUrl || (process.env.NODE_ENV === 'production' ? '' : 'http://localhost:3001');\n  // Ensure path starts with / (fix for paths like \"3001/api/...\" that should be \"/api/...\")\n  const normalizedPath = usageLog.path.startsWith('/') ? usageLog.path : `/${usageLog.path.replace(/^\\d+\\//, '')}`;\n  const resource = metadata?.resource || `${baseUrl}${normalizedPath}`;\n  \n  // Infer facilitator from verify mode if not provided in metadata\n  // This handles cases where facilitator wasn't stored in the database\n  let facilitator = metadata?.facilitator;\n  if (!facilitator) {\n    const verifyMode = process.env.X402_VERIFY_MODE?.toLowerCase();\n    if (verifyMode === 'cdp') {\n      facilitator = 'CDP';\n    } else if (verifyMode === 'test') {\n      facilitator = 'TEST_FACILITATOR';\n    } else {\n      facilitator = 'UNKNOWN';\n    }\n  }\n  \n  return {\n    id: usageLog.id,\n    timestamp: usageLog.timestamp,\n    customerId: usageLog.conversationId || null,\n    endpointId: usageLog.endpointId,\n    agentId: usageLog.agentId || null,\n    facilitator,\n    chainId: metadata?.chainId || 'eip155:8453',\n    asset: metadata?.asset || 'USDC_TEST',\n    amount: metadata?.amount || '10000',\n    status,\n    errorCode: usageLog.failureCode,\n    x402TxHash: usageLog.x402TxHash,\n    latencyMs: usageLog.responseTime,\n    resource,\n  };\n}\n\n/**\n * Query X402CallLog entries from the database\n * Filters by endpointId and optionally limits results\n */\nexport async function getX402CallLogs(\n  endpointId: string,\n  options?: {\n    limit?: number;\n    startDate?: string;\n    endDate?: string;\n  }\n): Promise<X402CallLog[]> {\n  try {\n    const usageLogs = await listUsageLogs({ endpointId });\n    \n    // Sort by timestamp descending (most recent first)\n    usageLogs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n    \n    // Apply date filters if provided\n    let filtered = usageLogs;\n    if (options?.startDate) {\n      filtered = filtered.filter(log => log.timestamp >= options.startDate!);\n    }\n    if (options?.endDate) {\n      filtered = filtered.filter(log => log.timestamp <= options.endDate!);\n    }\n    \n    // Apply limit\n    if (options?.limit) {\n      filtered = filtered.slice(0, options.limit);\n    }\n    \n    // Convert to X402CallLog\n    // Note: We lose some metadata (facilitator, chainId, asset, amount, resource) when converting back\n    // In a production system, we'd store these in the UsageLog or a separate metadata table\n    // For now, we use verify mode and heuristics to reconstruct:\n    // - Infer from X402_VERIFY_MODE first (most reliable) - ALWAYS use this when set\n    // - Test facilitator: if x402TxHash starts with 'TEST_'\n    // - CDP facilitator: if x402TxHash is a real transaction hash (starts with '0x')\n    // - Unknown: only if we can't determine from verify mode or txHash\n    const verifyMode = process.env.X402_VERIFY_MODE?.toLowerCase();\n    return filtered.map(log => {\n      let facilitator: string | undefined;\n      \n      // ALWAYS infer from verify mode first (most reliable)\n      // This ensures that when X402_VERIFY_MODE=cdp, all logs show facilitator: \"CDP\"\n      // even if there's no txHash (e.g., on errors)\n      if (verifyMode === 'cdp') {\n        facilitator = 'CDP';\n      } else if (verifyMode === 'test') {\n        facilitator = 'TEST_FACILITATOR';\n      }\n      \n      // If verify mode didn't set it, use heuristics from txHash as fallback\n      // (This handles cases where verify mode isn't set but we can infer from txHash)\n      if (!facilitator && log.x402TxHash) {\n        if (log.x402TxHash.startsWith('TEST_')) {\n          facilitator = 'TEST_FACILITATOR';\n        } else if (log.x402TxHash.startsWith('0x')) {\n          facilitator = 'CDP';\n        }\n      }\n      \n      // If still not set, usageLogToX402CallLog will infer from verify mode\n      // But we should have set it above if verify mode is configured\n      \n      return usageLogToX402CallLog(log, {\n        facilitator,\n        chainId: 'eip155:8453',\n        asset: 'USDC_TEST',\n        amount: '10000',\n        resource: (() => {\n          const appUrl = process.env.NEXT_PUBLIC_APP_URL;\n          const baseUrl = appUrl || (process.env.NODE_ENV === 'production' ? '' : 'http://localhost:3001');\n          const normalizedPath = log.path.startsWith('/') ? log.path : `/${log.path.replace(/^\\d+\\//, '')}`;\n          return `${baseUrl}${normalizedPath}`;\n        })(),\n      });\n    });\n  } catch (error) {\n    logger.error('Error querying x402 call logs', { error, endpointId });\n    throw error;\n  }\n}\n\n/**\n * Log an x402 call event to the database and structured logger\n * This is the canonical way to record x402 payment flows\n */\nexport async function logX402Call(x402Log: Omit<X402CallLog, 'id' | 'timestamp'>): Promise<X402CallLog> {\n  const timestamp = new Date().toISOString();\n  \n  // Log to structured logger (Pino)\n  logger.info('x402 call', {\n    endpointId: x402Log.endpointId,\n    facilitator: x402Log.facilitator,\n    chainId: x402Log.chainId,\n    asset: x402Log.asset,\n    amount: x402Log.amount,\n    status: x402Log.status,\n    errorCode: x402Log.errorCode,\n    x402TxHash: x402Log.x402TxHash,\n    latencyMs: x402Log.latencyMs,\n    resource: x402Log.resource,\n    customerId: x402Log.customerId,\n    agentId: x402Log.agentId,\n  });\n\n  // Persist to database via UsageLog\n  try {\n    const usageLogData = x402CallLogToUsageLog(x402Log);\n    console.log('X402_LOG_DEBUG', JSON.stringify(usageLogData, null, 2));\n    const usageLog = await createUsageLog(usageLogData);\n    \n    return {\n      id: usageLog.id,\n      timestamp: usageLog.timestamp,\n      customerId: x402Log.customerId,\n      endpointId: x402Log.endpointId,\n      agentId: x402Log.agentId,\n      facilitator: x402Log.facilitator,\n      chainId: x402Log.chainId,\n      asset: x402Log.asset,\n      amount: x402Log.amount,\n      status: x402Log.status,\n      errorCode: x402Log.errorCode,\n      x402TxHash: x402Log.x402TxHash,\n      latencyMs: x402Log.latencyMs,\n      resource: x402Log.resource,\n    };\n  } catch (error) {\n    // Log error but don't fail the request\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const errorDetails = error instanceof Error ? { \n      message: error.message, \n      stack: error.stack,\n      name: error.name \n    } : { error };\n    \n    console.error('X402_LOG_DB_ERROR', {\n      error: errorMessage,\n      errorDetails,\n      x402Log: {\n        endpointId: x402Log.endpointId,\n        status: x402Log.status,\n        facilitator: x402Log.facilitator,\n      }\n    });\n    \n    logger.error('Failed to persist x402 call log', { \n      error: errorMessage,\n      errorDetails,\n      x402Log: {\n        endpointId: x402Log.endpointId,\n        status: x402Log.status,\n        facilitator: x402Log.facilitator,\n      }\n    });\n    \n    // Return log with generated ID (for consistency, even if DB write failed)\n    return {\n      id: `temp-${Date.now()}`,\n      timestamp,\n      ...x402Log,\n    };\n  }\n}\n","// =============================================================================\r\n// METRICS DATABASE\r\n// =============================================================================\r\n// Database operations for metrics storage\r\n\r\nimport { executeQuery, executeQueryOne, executeUpdate } from './query-helper';\r\nimport type { Metric, AggregatedMetric } from '@/lib/metrics-collector';\r\n\r\nexport interface MetricRow {\r\n  id: string;\r\n  name: string;\r\n  value: string; // Stored as numeric in DB, but returned as string for precision\r\n  timestamp: string; // BigInt in DB, string for JS\r\n  tags: string | Record<string, string>; // JSONB in PostgreSQL, TEXT in SQLite\r\n  created_at: string;\r\n}\r\n\r\n/**\r\n * Convert database row to Metric\r\n */\r\nfunction rowToMetric(row: MetricRow): Metric {\r\n  return {\r\n    name: row.name,\r\n    value: parseFloat(row.value),\r\n    timestamp: parseInt(row.timestamp),\r\n    tags: typeof row.tags === 'string' ? JSON.parse(row.tags) : row.tags,\r\n  };\r\n}\r\n\r\n/**\r\n * Record a metric\r\n */\r\nexport async function recordMetric(metric: Metric & { id?: string }): Promise<void> {\r\n  const id = metric.id || `m_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n  const db = require('./client').getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  const query = isPostgres\r\n    ? `INSERT INTO metrics (id, name, value, timestamp, tags, created_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6)`\r\n    : `INSERT INTO metrics (id, name, value, timestamp, tags, created_at)\r\n       VALUES (?, ?, ?, ?, ?, ?)`;\r\n  \r\n  const params = [\r\n    id,\r\n    metric.name,\r\n    metric.value.toString(),\r\n    metric.timestamp.toString(),\r\n    JSON.stringify(metric.tags || {}),\r\n    new Date().toISOString(),\r\n  ];\r\n\r\n  await executeUpdate(query, params);\r\n}\r\n\r\n/**\r\n * Record multiple metrics\r\n */\r\nexport async function recordMetrics(metrics: Metric[]): Promise<void> {\r\n  // Batch insert for better performance\r\n  for (const metric of metrics) {\r\n    await recordMetric(metric);\r\n  }\r\n}\r\n\r\n/**\r\n * Get metrics for a time range\r\n */\r\nexport async function getMetrics(\r\n  name: string,\r\n  startTime?: number,\r\n  endTime?: number,\r\n  tags?: Record<string, string>\r\n): Promise<Metric[]> {\r\n  const db = require('./client').getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  let query = 'SELECT * FROM metrics WHERE name = ';\r\n  const params: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (isPostgres) {\r\n    query += `$${paramIndex++}`;\r\n  } else {\r\n    query += '?';\r\n  }\r\n  params.push(name);\r\n\r\n  if (startTime !== undefined) {\r\n    if (isPostgres) {\r\n      query += ` AND timestamp >= $${paramIndex++}`;\r\n    } else {\r\n      query += ' AND timestamp >= ?';\r\n    }\r\n    params.push(startTime.toString());\r\n  }\r\n\r\n  if (endTime !== undefined) {\r\n    if (isPostgres) {\r\n      query += ` AND timestamp <= $${paramIndex++}`;\r\n    } else {\r\n      query += ' AND timestamp <= ?';\r\n    }\r\n    params.push(endTime.toString());\r\n  }\r\n\r\n  // Tag filtering (simplified - for complex queries, consider using JSONB operators in PostgreSQL)\r\n  if (tags && Object.keys(tags).length > 0) {\r\n    // This is a simplified approach - for production, use proper JSONB queries\r\n    query += ' AND tags IS NOT NULL';\r\n  }\r\n\r\n  query += ' ORDER BY timestamp DESC LIMIT 10000'; // Limit to prevent memory issues\r\n\r\n  const rows = await executeQuery<MetricRow>(query, params);\r\n  return rows.map(rowToMetric);\r\n}\r\n\r\n/**\r\n * Get aggregated metrics\r\n */\r\nexport async function getAggregatedMetrics(\r\n  name: string,\r\n  startTime?: number,\r\n  endTime?: number,\r\n  tags?: Record<string, string>\r\n): Promise<AggregatedMetric | null> {\r\n  const metrics = await getMetrics(name, startTime, endTime, tags);\r\n  \r\n  if (metrics.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  // Filter by tags if provided\r\n  let filtered = metrics;\r\n  if (tags) {\r\n    filtered = metrics.filter(m => {\r\n      if (!m.tags) return false;\r\n      return Object.entries(tags).every(([key, value]) => m.tags![key] === value);\r\n    });\r\n  }\r\n\r\n  if (filtered.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  // Calculate aggregations\r\n  const values = filtered.map(m => m.value).sort((a, b) => a - b);\r\n  const count = values.length;\r\n  const sum = values.reduce((a, b) => a + b, 0);\r\n  const min = values[0];\r\n  const max = values[values.length - 1];\r\n  const average = sum / count;\r\n\r\n  // Calculate percentiles\r\n  const p50Index = Math.floor(count * 0.5);\r\n  const p95Index = Math.floor(count * 0.95);\r\n  const p99Index = Math.floor(count * 0.99);\r\n\r\n  return {\r\n    name,\r\n    count,\r\n    sum,\r\n    min,\r\n    max,\r\n    average,\r\n    p50: values[p50Index] || average,\r\n    p95: values[p95Index] || max,\r\n    p99: values[p99Index] || max,\r\n    tags: tags || filtered[0]?.tags,\r\n  };\r\n}\r\n\r\n/**\r\n * Clean up old metrics (keep only recent ones)\r\n */\r\nexport async function cleanupOldMetrics(olderThanDays: number = 30): Promise<number> {\r\n  const cutoffTime = Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);\r\n  const db = require('./client').getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  const query = isPostgres\r\n    ? `DELETE FROM metrics WHERE timestamp < $1`\r\n    : `DELETE FROM metrics WHERE timestamp < ?`;\r\n  \r\n  const result = await executeUpdate(query, [cutoffTime.toString()]);\r\n  return result.rowCount ?? result.changes ?? 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n","// =============================================================================\r\n// Metrics Collector\r\n// =============================================================================\r\n// Collects and aggregates metrics for monitoring and observability\r\n// In-memory metrics store (can be extended to Redis for distributed systems)\r\n\r\nimport { createLogger } from './logger';\r\nimport * as metricsDb from '@/db/metrics';\r\n\r\nconst logger = createLogger({ component: 'MetricsCollector' });\r\n\r\nexport interface Metric {\r\n  name: string;\r\n  value: number;\r\n  timestamp: number;\r\n  tags?: Record<string, string>;\r\n}\r\n\r\nexport interface AggregatedMetric {\r\n  name: string;\r\n  count: number;\r\n  sum: number;\r\n  min: number;\r\n  max: number;\r\n  average: number;\r\n  p50: number;\r\n  p95: number;\r\n  p99: number;\r\n  tags?: Record<string, string>;\r\n}\r\n\r\n/**\r\n * Record a metric (async, uses database)\r\n */\r\nexport async function recordMetric(metric: Metric): Promise<void> {\r\n  try {\r\n    await metricsDb.recordMetric(metric);\r\n  } catch (error) {\r\n    logger.error('Failed to record metric', { metric, error });\r\n  }\r\n}\r\n\r\n/**\r\n * Record multiple metrics at once (async, uses database)\r\n */\r\nexport async function recordMetrics(metrics: Metric[]): Promise<void> {\r\n  try {\r\n    await metricsDb.recordMetrics(metrics);\r\n  } catch (error) {\r\n    logger.error('Failed to record metrics', { count: metrics.length, error });\r\n  }\r\n}\r\n\r\n/**\r\n * Get aggregated metrics for a time range (async, uses database)\r\n */\r\nexport async function getAggregatedMetrics(\r\n  name: string,\r\n  startTime?: number,\r\n  endTime?: number,\r\n  tags?: Record<string, string>\r\n): Promise<AggregatedMetric | null> {\r\n  return metricsDb.getAggregatedMetrics(name, startTime, endTime, tags);\r\n  \r\n  return {\r\n    name,\r\n    count,\r\n    sum,\r\n    min,\r\n    max,\r\n    average,\r\n    p50,\r\n    p95,\r\n    p99,\r\n    tags,\r\n  };\r\n}\r\n\r\n/**\r\n * Get all metric names\r\n */\r\nexport function getMetricNames(): string[] {\r\n  return Array.from(metricsStore.keys());\r\n}\r\n\r\n/**\r\n * Get recent metrics for a name\r\n */\r\nexport function getRecentMetrics(name: string, limit: number = 100): Metric[] {\r\n  const metrics = metricsStore.get(name);\r\n  if (!metrics) {\r\n    return [];\r\n  }\r\n  \r\n  return metrics.slice(-limit);\r\n}\r\n\r\n/**\r\n * Clear metrics (for testing or reset)\r\n */\r\nexport function clearMetrics(name?: string): void {\r\n  if (name) {\r\n    metricsStore.delete(name);\r\n  } else {\r\n    metricsStore.clear();\r\n  }\r\n}\r\n\r\n/**\r\n * Helper functions for common metrics\r\n */\r\n\r\nexport async function recordRequestMetric(\r\n  endpoint: string,\r\n  method: string,\r\n  statusCode: number,\r\n  durationMs: number,\r\n  tags?: Record<string, string>\r\n): Promise<void> {\r\n  await recordMetric({\r\n    name: 'http.request',\r\n    value: durationMs,\r\n    timestamp: Date.now(),\r\n    tags: {\r\n      endpoint,\r\n      method,\r\n      statusCode: statusCode.toString(),\r\n      ...tags,\r\n    },\r\n  });\r\n  \r\n  // Record status code count\r\n  await recordMetric({\r\n    name: 'http.request.count',\r\n    value: 1,\r\n    timestamp: Date.now(),\r\n    tags: {\r\n      endpoint,\r\n      method,\r\n      statusCode: statusCode.toString(),\r\n      ...tags,\r\n    },\r\n  });\r\n}\r\n\r\nexport async function recordPaymentMetric(\r\n  endpointId: string,\r\n  facilitator: string,\r\n  amount: string,\r\n  success: boolean,\r\n  durationMs: number\r\n): Promise<void> {\r\n  await recordMetric({\r\n    name: 'payment.verification',\r\n    value: durationMs,\r\n    timestamp: Date.now(),\r\n    tags: {\r\n      endpointId,\r\n      facilitator,\r\n      success: success.toString(),\r\n    },\r\n  });\r\n  \r\n  if (success) {\r\n    await recordMetric({\r\n      name: 'payment.amount',\r\n      value: parseFloat(amount) / 1e6, // Convert atomic units to USDC\r\n      timestamp: Date.now(),\r\n      tags: {\r\n        endpointId,\r\n        facilitator,\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport async function recordErrorMetric(\r\n  errorCode: string,\r\n  endpoint?: string,\r\n  tags?: Record<string, string>\r\n): Promise<void> {\r\n  await recordMetric({\r\n    name: 'error.count',\r\n    value: 1,\r\n    timestamp: Date.now(),\r\n    tags: {\r\n      errorCode,\r\n      endpoint: endpoint || 'unknown',\r\n      ...tags,\r\n    },\r\n  });\r\n}\r\n\r\nexport async function recordCircuitBreakerMetric(\r\n  upstreamUrl: string,\r\n  state: 'open' | 'closed' | 'half-open'\r\n): Promise<void> {\r\n  await recordMetric({\r\n    name: 'circuit_breaker.state',\r\n    value: state === 'open' ? 1 : 0,\r\n    timestamp: Date.now(),\r\n    tags: {\r\n      upstreamUrl,\r\n      state,\r\n    },\r\n  });\r\n}\r\n\r\n","// =============================================================================\r\n// CAIP (Chain Agnostic Improvement Proposals) Utilities\r\n// =============================================================================\r\n// Utilities for parsing, formatting, and validating CAIP identifiers\r\n// CAIP-2: Blockchain ID Specification\r\n// CAIP-19: Asset ID Specification\r\n\r\n/**\r\n * CAIP-2 Network Identifier\r\n * Format: <namespace>:<reference>\r\n * Examples:\r\n * - eip155:1 (Ethereum Mainnet)\r\n * - eip155:8453 (Base)\r\n * - eip155:56 (BNB Chain)\r\n * - eip155:137 (Polygon)\r\n * - solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp (Solana Mainnet)\r\n */\r\nexport type CAIPNetworkId = string;\r\n\r\n/**\r\n * CAIP-19 Asset Identifier\r\n * Format: <namespace>:<reference>/<asset_namespace>:<asset_reference>\r\n * Examples:\r\n * - eip155:1/erc20:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 (USDC on Ethereum)\r\n * - eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913 (USDC on Base)\r\n * - eip155:1/slip44:60 (ETH on Ethereum)\r\n */\r\nexport type CAIPAssetId = string;\r\n\r\n/**\r\n * Parsed CAIP-2 Network Identifier\r\n */\r\nexport interface ParsedCAIPNetwork {\r\n  namespace: string; // e.g., 'eip155', 'solana'\r\n  reference: string; // e.g., '8453', '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp'\r\n  chainId?: number; // For EVM chains, the numeric chain ID\r\n}\r\n\r\n/**\r\n * Parsed CAIP-19 Asset Identifier\r\n */\r\nexport interface ParsedCAIPAsset {\r\n  network: ParsedCAIPNetwork;\r\n  assetNamespace: string; // e.g., 'erc20', 'slip44'\r\n  assetReference: string; // e.g., '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', '60'\r\n  address?: string; // For ERC20 tokens, the contract address\r\n}\r\n\r\n/**\r\n * Parse a CAIP-2 network identifier\r\n */\r\nexport function parseCAIPNetwork(caip: CAIPNetworkId): ParsedCAIPNetwork | null {\r\n  try {\r\n    const [namespace, reference] = caip.split(':');\r\n    if (!namespace || !reference) {\r\n      return null;\r\n    }\r\n\r\n    // For EVM chains (eip155), reference is the chain ID\r\n    let chainId: number | undefined;\r\n    if (namespace === 'eip155') {\r\n      chainId = parseInt(reference, 10);\r\n      if (isNaN(chainId)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return {\r\n      namespace,\r\n      reference,\r\n      chainId,\r\n    };\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Format a CAIP-2 network identifier\r\n */\r\nexport function formatCAIPNetwork(namespace: string, reference: string | number): CAIPNetworkId {\r\n  return `${namespace}:${reference}`;\r\n}\r\n\r\n/**\r\n * Parse a CAIP-19 asset identifier\r\n */\r\nexport function parseCAIPAsset(caip: CAIPAssetId): ParsedCAIPAsset | null {\r\n  try {\r\n    const parts = caip.split('/');\r\n    if (parts.length !== 2) {\r\n      return null;\r\n    }\r\n\r\n    const networkPart = parts[0];\r\n    const assetPart = parts[1];\r\n\r\n    const network = parseCAIPNetwork(networkPart);\r\n    if (!network) {\r\n      return null;\r\n    }\r\n\r\n    const [assetNamespace, assetReference] = assetPart.split(':');\r\n    if (!assetNamespace || !assetReference) {\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      network,\r\n      assetNamespace,\r\n      assetReference,\r\n      address: assetNamespace === 'erc20' ? assetReference : undefined,\r\n    };\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Format a CAIP-19 asset identifier\r\n */\r\nexport function formatCAIPAsset(\r\n  network: CAIPNetworkId,\r\n  assetNamespace: string,\r\n  assetReference: string\r\n): CAIPAssetId {\r\n  return `${network}/${assetNamespace}:${assetReference}`;\r\n}\r\n\r\n/**\r\n * Convert legacy network name to CAIP-2\r\n */\r\nexport function networkToCAIP(network: string): CAIPNetworkId | null {\r\n  const networkMap: Record<string, CAIPNetworkId> = {\r\n    ethereum: 'eip155:1',\r\n    mainnet: 'eip155:1',\r\n    base: 'eip155:8453',\r\n    'base-mainnet': 'eip155:8453',\r\n    bnb: 'eip155:56',\r\n    'bnb-chain': 'eip155:56',\r\n    'bsc': 'eip155:56',\r\n    polygon: 'eip155:137',\r\n    'polygon-mainnet': 'eip155:137',\r\n    arbitrum: 'eip155:42161',\r\n    'arbitrum-one': 'eip155:42161',\r\n    optimism: 'eip155:10',\r\n    'optimism-mainnet': 'eip155:10',\r\n    avalanche: 'eip155:43114',\r\n    'avalanche-mainnet': 'eip155:43114',\r\n    solana: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',\r\n    'solana-mainnet': 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',\r\n    // Cronos networks - see https://docs.cronos.org/cronos-x402-facilitator\r\n    cronos: 'eip155:25',\r\n    'cronos-mainnet': 'eip155:25',\r\n    'cronos-testnet': 'eip155:338',\r\n  };\r\n\r\n  const normalized = network.toLowerCase().replace(/_/g, '-');\r\n  return networkMap[normalized] || null;\r\n}\r\n\r\n/**\r\n * Convert CAIP-2 to legacy network name\r\n */\r\nexport function caipToNetwork(caip: CAIPNetworkId): string | null {\r\n  const parsed = parseCAIPNetwork(caip);\r\n  if (!parsed) {\r\n    return null;\r\n  }\r\n\r\n  if (parsed.namespace === 'eip155') {\r\n    const chainIdMap: Record<number, string> = {\r\n      1: 'ethereum',\r\n      8453: 'base',\r\n      56: 'bnb',\r\n      137: 'polygon',\r\n      42161: 'arbitrum',\r\n      10: 'optimism',\r\n      43114: 'avalanche',\r\n      // Cronos networks - see https://docs.cronos.org/cronos-x402-facilitator\r\n      25: 'cronos',\r\n      338: 'cronos-testnet',\r\n    };\r\n    return chainIdMap[parsed.chainId!] || null;\r\n  }\r\n\r\n  if (parsed.namespace === 'solana') {\r\n    return 'solana';\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Get chain ID from CAIP-2 network identifier (EVM only)\r\n */\r\nexport function getChainId(caip: CAIPNetworkId): number | null {\r\n  const parsed = parseCAIPNetwork(caip);\r\n  if (parsed?.namespace === 'eip155' && parsed.chainId) {\r\n    return parsed.chainId;\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Check if CAIP network is EVM-compatible\r\n */\r\nexport function isEVMNetwork(caip: CAIPNetworkId): boolean {\r\n  const parsed = parseCAIPNetwork(caip);\r\n  return parsed?.namespace === 'eip155' || false;\r\n}\r\n\r\n/**\r\n * Check if CAIP network is Solana\r\n */\r\nexport function isSolanaNetwork(caip: CAIPNetworkId): boolean {\r\n  const parsed = parseCAIPNetwork(caip);\r\n  return parsed?.namespace === 'solana' || false;\r\n}\r\n\r\n/**\r\n * Validate CAIP-2 network identifier format\r\n */\r\nexport function validateCAIPNetwork(caip: CAIPNetworkId): boolean {\r\n  return parseCAIPNetwork(caip) !== null;\r\n}\r\n\r\n/**\r\n * Validate CAIP-19 asset identifier format\r\n */\r\nexport function validateCAIPAsset(caip: CAIPAssetId): boolean {\r\n  return parseCAIPAsset(caip) !== null;\r\n}\r\n\r\n/**\r\n * Get token address from CAIP-19 asset identifier (ERC20 only)\r\n */\r\nexport function getTokenAddress(caip: CAIPAssetId): string | null {\r\n  const parsed = parseCAIPAsset(caip);\r\n  if (parsed?.assetNamespace === 'erc20') {\r\n    return parsed.address || null;\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Convert legacy network + token address to CAIP-19\r\n */\r\nexport function tokenToCAIP(network: string, tokenAddress: string): CAIPAssetId | null {\r\n  const networkCAIP = networkToCAIP(network);\r\n  if (!networkCAIP) {\r\n    return null;\r\n  }\r\n  return formatCAIPAsset(networkCAIP, 'erc20', tokenAddress);\r\n}\r\n\r\n/**\r\n * Common CAIP network identifiers\r\n */\r\nexport const CAIP_NETWORKS = {\r\n  ETHEREUM: 'eip155:1',\r\n  BASE: 'eip155:8453',\r\n  BNB_CHAIN: 'eip155:56',\r\n  POLYGON: 'eip155:137',\r\n  ARBITRUM: 'eip155:42161',\r\n  OPTIMISM: 'eip155:10',\r\n  AVALANCHE: 'eip155:43114',\r\n  SOLANA: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',\r\n  // Cronos networks - see https://docs.cronos.org/cronos-x402-facilitator\r\n  CRONOS: 'eip155:25',           // Cronos mainnet (chain ID 25)\r\n  CRONOS_TESTNET: 'eip155:338',  // Cronos testnet (chain ID 338)\r\n} as const;\r\n\r\n/**\r\n * Common CAIP asset identifiers (USDC on various chains)\r\n */\r\nexport const CAIP_ASSETS = {\r\n  USDC_ETHEREUM: 'eip155:1/erc20:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\r\n  USDC_BASE: 'eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\r\n  USDC_POLYGON: 'eip155:137/erc20:0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\r\n  USDC_ARBITRUM: 'eip155:42161/erc20:0xaf88d065e77c8cC2239327C5EDb3A432268e5831',\r\n  USDC_OPTIMISM: 'eip155:10/erc20:0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85',\r\n  ETH_ETHEREUM: 'eip155:1/slip44:60',\r\n} as const;\r\n\r\n\r\n\r\n\r\n\r\n","// =============================================================================\r\n// CHAIN REGISTRY\r\n// =============================================================================\r\n// Registry of supported blockchain networks with metadata\r\n\r\nimport { CAIP_NETWORKS, type CAIPNetworkId } from './caip-utils';\r\n\r\n/**\r\n * Network metadata\r\n */\r\nexport interface NetworkMetadata {\r\n  caip: CAIPNetworkId;\r\n  name: string;\r\n  displayName: string;\r\n  chainId: number | null; // For EVM chains\r\n  nativeCurrency: {\r\n    name: string;\r\n    symbol: string;\r\n    decimals: number;\r\n  };\r\n  rpcUrls?: string[];\r\n  blockExplorers?: {\r\n    name: string;\r\n    url: string;\r\n  }[];\r\n  isTestnet: boolean;\r\n  isEVM: boolean;\r\n  isSolana: boolean;\r\n  supportsEIP1559?: boolean; // For EVM chains\r\n  averageGasPrice?: string; // In wei/gwei\r\n  averageBlockTime?: number; // In seconds\r\n}\r\n\r\n/**\r\n * Chain Registry\r\n * \r\n * Central registry of all supported blockchain networks\r\n */\r\nexport class ChainRegistry {\r\n  private networks: Map<CAIPNetworkId, NetworkMetadata> = new Map();\r\n\r\n  constructor() {\r\n    this.registerDefaultNetworks();\r\n  }\r\n\r\n  /**\r\n   * Register a network\r\n   */\r\n  register(network: NetworkMetadata): void {\r\n    this.networks.set(network.caip, network);\r\n  }\r\n\r\n  /**\r\n   * Get network metadata by CAIP identifier\r\n   */\r\n  get(caip: CAIPNetworkId): NetworkMetadata | undefined {\r\n    return this.networks.get(caip);\r\n  }\r\n\r\n  /**\r\n   * Get network by legacy name\r\n   */\r\n  getByLegacyName(name: string): NetworkMetadata | undefined {\r\n    for (const network of this.networks.values()) {\r\n      if (network.name.toLowerCase() === name.toLowerCase()) {\r\n        return network;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Get all registered networks\r\n   */\r\n  getAll(): NetworkMetadata[] {\r\n    return Array.from(this.networks.values());\r\n  }\r\n\r\n  /**\r\n   * Get all EVM networks\r\n   */\r\n  getEVMs(): NetworkMetadata[] {\r\n    return Array.from(this.networks.values()).filter((n) => n.isEVM);\r\n  }\r\n\r\n  /**\r\n   * Get all Solana networks\r\n   */\r\n  getSolanas(): NetworkMetadata[] {\r\n    return Array.from(this.networks.values()).filter((n) => n.isSolana);\r\n  }\r\n\r\n  /**\r\n   * Check if network is registered\r\n   */\r\n  has(caip: CAIPNetworkId): boolean {\r\n    return this.networks.has(caip);\r\n  }\r\n\r\n  /**\r\n   * Register default networks\r\n   */\r\n  private registerDefaultNetworks(): void {\r\n    // Ethereum Mainnet\r\n    this.register({\r\n      caip: CAIP_NETWORKS.ETHEREUM,\r\n      name: 'ethereum',\r\n      displayName: 'Ethereum',\r\n      chainId: 1,\r\n      nativeCurrency: {\r\n        name: 'Ether',\r\n        symbol: 'ETH',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://eth.llamarpc.com'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Etherscan',\r\n          url: 'https://etherscan.io',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '30000000000', // 30 gwei\r\n      averageBlockTime: 12,\r\n    });\r\n\r\n    // Base\r\n    this.register({\r\n      caip: CAIP_NETWORKS.BASE,\r\n      name: 'base',\r\n      displayName: 'Base',\r\n      chainId: 8453,\r\n      nativeCurrency: {\r\n        name: 'Ether',\r\n        symbol: 'ETH',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://mainnet.base.org'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'BaseScan',\r\n          url: 'https://basescan.org',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '1000000', // 0.001 gwei (very cheap)\r\n      averageBlockTime: 2,\r\n    });\r\n\r\n    // BNB Chain\r\n    this.register({\r\n      caip: CAIP_NETWORKS.BNB_CHAIN,\r\n      name: 'bnb',\r\n      displayName: 'BNB Chain',\r\n      chainId: 56,\r\n      nativeCurrency: {\r\n        name: 'BNB',\r\n        symbol: 'BNB',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://bsc-dataseed.binance.org'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'BscScan',\r\n          url: 'https://bscscan.com',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: false,\r\n      averageGasPrice: '3000000000', // 3 gwei\r\n      averageBlockTime: 3,\r\n    });\r\n\r\n    // Polygon\r\n    this.register({\r\n      caip: CAIP_NETWORKS.POLYGON,\r\n      name: 'polygon',\r\n      displayName: 'Polygon',\r\n      chainId: 137,\r\n      nativeCurrency: {\r\n        name: 'MATIC',\r\n        symbol: 'MATIC',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://polygon-rpc.com'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'PolygonScan',\r\n          url: 'https://polygonscan.com',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '30000000000', // 30 gwei\r\n      averageBlockTime: 2,\r\n    });\r\n\r\n    // Arbitrum One\r\n    this.register({\r\n      caip: CAIP_NETWORKS.ARBITRUM,\r\n      name: 'arbitrum',\r\n      displayName: 'Arbitrum One',\r\n      chainId: 42161,\r\n      nativeCurrency: {\r\n        name: 'Ether',\r\n        symbol: 'ETH',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://arb1.arbitrum.io/rpc'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Arbiscan',\r\n          url: 'https://arbiscan.io',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '100000000', // 0.1 gwei\r\n      averageBlockTime: 0.25,\r\n    });\r\n\r\n    // Optimism\r\n    this.register({\r\n      caip: CAIP_NETWORKS.OPTIMISM,\r\n      name: 'optimism',\r\n      displayName: 'Optimism',\r\n      chainId: 10,\r\n      nativeCurrency: {\r\n        name: 'Ether',\r\n        symbol: 'ETH',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://mainnet.optimism.io'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Optimistic Etherscan',\r\n          url: 'https://optimistic.etherscan.io',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '1000000', // 0.001 gwei\r\n      averageBlockTime: 2,\r\n    });\r\n\r\n    // Avalanche\r\n    this.register({\r\n      caip: CAIP_NETWORKS.AVALANCHE,\r\n      name: 'avalanche',\r\n      displayName: 'Avalanche',\r\n      chainId: 43114,\r\n      nativeCurrency: {\r\n        name: 'AVAX',\r\n        symbol: 'AVAX',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://api.avax.network/ext/bc/C/rpc'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Snowtrace',\r\n          url: 'https://snowtrace.io',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '25000000000', // 25 nAVAX\r\n      averageBlockTime: 2,\r\n    });\r\n\r\n    // Solana Mainnet (placeholder - full support when SDK available)\r\n    this.register({\r\n      caip: CAIP_NETWORKS.SOLANA,\r\n      name: 'solana',\r\n      displayName: 'Solana',\r\n      chainId: null,\r\n      nativeCurrency: {\r\n        name: 'SOL',\r\n        symbol: 'SOL',\r\n        decimals: 9,\r\n      },\r\n      rpcUrls: ['https://api.mainnet-beta.solana.com'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Solana Explorer',\r\n          url: 'https://explorer.solana.com',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: false,\r\n      isSolana: true,\r\n      averageBlockTime: 0.4,\r\n    });\r\n\r\n    // Cronos Mainnet\r\n    // Cronos x402 facilitator: https://docs.cronos.org/cronos-x402-facilitator\r\n    this.register({\r\n      caip: CAIP_NETWORKS.CRONOS,\r\n      name: 'cronos',\r\n      displayName: 'Cronos',\r\n      chainId: 25,\r\n      nativeCurrency: {\r\n        name: 'CRO',\r\n        symbol: 'CRO',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://evm.cronos.org'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Cronoscan',\r\n          url: 'https://cronoscan.com',\r\n        },\r\n      ],\r\n      isTestnet: false,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '5000000000000', // 5000 gwei\r\n      averageBlockTime: 6,\r\n    });\r\n\r\n    // Cronos Testnet\r\n    this.register({\r\n      caip: CAIP_NETWORKS.CRONOS_TESTNET,\r\n      name: 'cronos-testnet',\r\n      displayName: 'Cronos Testnet',\r\n      chainId: 338,\r\n      nativeCurrency: {\r\n        name: 'Test CRO',\r\n        symbol: 'TCRO',\r\n        decimals: 18,\r\n      },\r\n      rpcUrls: ['https://evm-t3.cronos.org'],\r\n      blockExplorers: [\r\n        {\r\n          name: 'Cronos Testnet Explorer',\r\n          url: 'https://testnet.cronoscan.com',\r\n        },\r\n      ],\r\n      isTestnet: true,\r\n      isEVM: true,\r\n      isSolana: false,\r\n      supportsEIP1559: true,\r\n      averageGasPrice: '5000000000000', // 5000 gwei\r\n      averageBlockTime: 6,\r\n    });\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet chainRegistry: ChainRegistry | null = null;\r\n\r\n/**\r\n * Get chain registry instance\r\n */\r\nexport function getChainRegistry(): ChainRegistry {\r\n  if (!chainRegistry) {\r\n    chainRegistry = new ChainRegistry();\r\n  }\r\n  return chainRegistry;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","// =============================================================================\r\n// ROUTE CONTEXT\r\n// =============================================================================\r\n// Normalized request context for SMF routing\r\n// Ensures all facilitators receive consistent, x402-spec-compliant requests\r\n\r\nimport type { PaymentRequirements } from './base-facilitator';\r\n\r\n/**\r\n * RouteContext - Normalized request context for SMF routing\r\n * \r\n * This type ensures all facilitators receive consistent, x402-spec-compliant\r\n * requests regardless of how the request originated (API, SDK, etc.)\r\n */\r\nexport interface RouteContext {\r\n  // Payment details (x402 spec compliant)\r\n  network: string; // Legacy network identifier (e.g., 'base', 'ethereum')\r\n  token: string; // Token address (e.g., '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913')\r\n  amount: string; // Amount in atomic units (string to avoid precision loss)\r\n  \r\n  // CAIP identifiers (preferred for multi-chain)\r\n  networkCAIP?: string; // CAIP-2 network identifier (e.g., 'eip155:8453')\r\n  tokenCAIP?: string; // CAIP-19 asset identifier (e.g., 'eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913')\r\n  \r\n  // x402 version\r\n  x402Version: number; // x402 protocol version (currently 1 or 2)\r\n  \r\n  // Caller identification\r\n  callerId?: string; // Agent/merchant identifier\r\n  clientId?: string; // Client application identifier\r\n  \r\n  // Optional routing preferences\r\n  region?: string; // Geographic region (e.g., 'us-east', 'eu-west')\r\n  riskLevel?: 'low' | 'medium' | 'high'; // Risk assessment level\r\n  watchLevel?: 'normal' | 'enhanced' | 'strict'; // Compliance watch level\r\n  \r\n  // Additional context\r\n  preferences?: {\r\n    priority?: 'cost' | 'speed' | 'reliability' | 'compliance';\r\n    requireKYC?: boolean;\r\n    requireOFAC?: boolean;\r\n    maxLatencyMs?: number;\r\n    maxFeeBps?: number;\r\n  };\r\n  \r\n  // Original payment requirements (for compatibility)\r\n  requirements: PaymentRequirements;\r\n}\r\n\r\n/**\r\n * Convert RouteContext to facilitator request format\r\n * \r\n * This ensures all facilitators receive x402-spec-compliant requests\r\n */\r\nexport function routeContextToFacilitatorRequest(\r\n  context: RouteContext\r\n): {\r\n  version: number;\r\n  amount: string;\r\n  network: string;\r\n  token: string;\r\n  networkCAIP?: string;\r\n  tokenCAIP?: string;\r\n} {\r\n  return {\r\n    version: context.x402Version,\r\n    amount: context.amount,\r\n    network: context.network,\r\n    token: context.token,\r\n    networkCAIP: context.networkCAIP,\r\n    tokenCAIP: context.tokenCAIP,\r\n  };\r\n}\r\n\r\n/**\r\n * Create RouteContext from PaymentRequirements\r\n * \r\n * Normalizes various input formats into consistent RouteContext\r\n */\r\nexport function createRouteContext(\r\n  requirements: PaymentRequirements,\r\n  options?: {\r\n    callerId?: string;\r\n    clientId?: string;\r\n    region?: string;\r\n    riskLevel?: 'low' | 'medium' | 'high';\r\n    watchLevel?: 'normal' | 'enhanced' | 'strict';\r\n    x402Version?: number;\r\n  }\r\n): RouteContext {\r\n  // Extract network (legacy or CAIP)\r\n  const network = requirements.network || requirements.networks?.[0] || '';\r\n  const networkCAIP = requirements.networks?.[0]?.startsWith('eip155:') \r\n    ? requirements.networks[0] \r\n    : undefined;\r\n  \r\n  // Extract token/asset (legacy or CAIP)\r\n  const token = requirements.asset || requirements.assets?.[0] || '';\r\n  const tokenCAIP = requirements.assets?.[0]?.includes('/') \r\n    ? requirements.assets[0] \r\n    : undefined;\r\n  \r\n  return {\r\n    network,\r\n    token,\r\n    amount: requirements.maxAmountRequired || '0',\r\n    networkCAIP,\r\n    tokenCAIP,\r\n    x402Version: options?.x402Version || 1, // Default to v1, upgrade to v2 when ready\r\n    callerId: options?.callerId,\r\n    clientId: options?.clientId,\r\n    region: options?.region,\r\n    riskLevel: options?.riskLevel,\r\n    watchLevel: options?.watchLevel,\r\n    requirements,\r\n  };\r\n}\r\n\r\n","// =============================================================================\r\n// META-FACILITATOR ORCHESTRATION ENGINE\r\n// =============================================================================\r\n// High-level orchestration layer that sits above individual facilitators\r\n// Owns business logic, routing policy, and risk management\r\n\r\nimport { getFacilitatorRouter, type RoutingPreferences, type RoutingPolicy } from '../facilitators/facilitator-router';\r\nimport { type PaymentRequirements, type VerificationResult, type IFacilitator } from '../facilitators/base-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { createRoute, updateRouteStatus, createRouteAttempt } from '@/db/smf';\r\nimport { createRouteContext } from '../facilitators/route-context';\r\n\r\n// Re-export for convenience\r\nexport { getFacilitatorRouter };\r\n\r\nconst logger = createLogger({ component: 'MetaFacilitator' });\r\n\r\n/**\r\n * Meta-facilitator orchestration result\r\n */\r\n/**\r\n * Decision trace for routing decisions\r\n * Enables explainer/debugger UI in NexFlow\r\n */\r\nexport interface DecisionTrace {\r\n  timestamp: string;\r\n  reason: string;\r\n  constraints: {\r\n    preferences?: RoutingPreferences;\r\n    policy?: Partial<RoutingPolicy>;\r\n    requirements: PaymentRequirements;\r\n  };\r\n  candidates: Array<{\r\n    facilitatorId: string;\r\n    facilitatorName: string;\r\n    score: number;\r\n    eligible: boolean;\r\n    reasons: string[];\r\n  }>;\r\n  selected: {\r\n    facilitatorId: string;\r\n    score: number;\r\n    alternativesConsidered: number;\r\n  };\r\n}\r\n\r\nexport interface OrchestrationResult extends VerificationResult {\r\n  facilitatorUsed: string;\r\n  routingReason: string;\r\n  alternativesConsidered: number;\r\n  decisionTrace?: DecisionTrace; // Compact decision trace for debugging\r\n  orchestrationMetadata?: {\r\n    cost?: number;\r\n    latency?: number;\r\n    complianceScore?: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Meta-Facilitator\r\n * Orchestrates multiple facilitators with business logic above raw settlement\r\n */\r\nexport class MetaFacilitator {\r\n  private router = getFacilitatorRouter();\r\n\r\n  /**\r\n   * Verify payment with orchestration\r\n   * \r\n   * This is the main entry point for payment verification.\r\n   * It handles:\r\n   * 1. Facilitator selection based on policy\r\n   * 2. Payment routing\r\n   * 3. Failover handling\r\n   * 4. Result aggregation\r\n   * 5. Business logic application\r\n   */\r\n  async verifyPayment(\r\n    payment: string,\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy,\r\n    context?: {\r\n      requestId?: string;\r\n      correlationId?: string;\r\n      clientId?: string;\r\n      agentId?: string;\r\n    }\r\n  ): Promise<OrchestrationResult> {\r\n    const startTime = Date.now();\r\n    let routeId: string | null = null;\r\n\r\n    try {\r\n      // 1. Create route context and route record\r\n      const routeContext = createRouteContext(requirements, {\r\n        callerId: context?.clientId || context?.agentId,\r\n        clientId: context?.clientId,\r\n        x402Version: 1, // Default to v1, can be upgraded\r\n      });\r\n\r\n      // 2. Select best facilitator based on policy\r\n      const facilitator = await this.router.routePayment(requirements, preferences, policy);\r\n\r\n      // 3. Create route record with selected facilitator\r\n      const route = await createRoute({\r\n        request_id: context?.requestId || null,\r\n        correlation_id: context?.correlationId || null,\r\n        client_id: context?.clientId || null,\r\n        agent_id: context?.agentId || null,\r\n        network: routeContext.network,\r\n        token: routeContext.token,\r\n        amount: routeContext.amount,\r\n        selected_facilitator_id: facilitator.id,\r\n        status: 'verifying',\r\n      });\r\n      routeId = route.id;\r\n\r\n      // Log decision trace (compact format)\r\n      logger.info({\r\n        routeId,\r\n        facilitatorId: facilitator.id,\r\n        network: requirements.network,\r\n        asset: requirements.asset,\r\n        settlementMode: requirements.settlementMode,\r\n        preferences: preferences ? {\r\n          priority: preferences.priority,\r\n          jurisdiction: preferences.jurisdiction,\r\n        } : undefined,\r\n      }, 'Routing payment to facilitator');\r\n\r\n      // 3. Verify payment with selected facilitator\r\n      const verifyStartTime = Date.now();\r\n      let result: VerificationResult;\r\n      let attemptResult: 'success' | 'failure' | 'timeout' | 'rate_limited' | 'insufficient_liquidity' | 'invalid_request' | 'network_error' = 'success';\r\n      let errorCode: string | null = null;\r\n      let rawStatus: number | null = null;\r\n\r\n      try {\r\n        result = await facilitator.verify(payment, requirements);\r\n        const verifyLatency = Date.now() - verifyStartTime;\r\n\r\n        // Determine attempt result\r\n        if (!result.success || !result.valid) {\r\n          attemptResult = 'failure';\r\n          errorCode = result.error || 'verification_failed';\r\n        }\r\n\r\n        // Log route attempt\r\n        await createRouteAttempt({\r\n          route_id: routeId,\r\n          facilitator_id: facilitator.id,\r\n          phase: 'verify',\r\n          result: attemptResult,\r\n          latency_ms: verifyLatency,\r\n          error_code: errorCode,\r\n          raw_status: rawStatus,\r\n          is_probe: false,\r\n        });\r\n      } catch (error) {\r\n        const verifyLatency = Date.now() - verifyStartTime;\r\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n\r\n        // Determine error type\r\n        if (errorMessage.includes('timeout') || errorMessage.includes('TIMEOUT')) {\r\n          attemptResult = 'timeout';\r\n        } else if (errorMessage.includes('rate') || errorMessage.includes('429')) {\r\n          attemptResult = 'rate_limited';\r\n          rawStatus = 429;\r\n        } else if (errorMessage.includes('network') || errorMessage.includes('ECONNREFUSED')) {\r\n          attemptResult = 'network_error';\r\n        } else {\r\n          attemptResult = 'failure';\r\n        }\r\n\r\n        errorCode = errorMessage;\r\n\r\n        // Log failed attempt\r\n        await createRouteAttempt({\r\n          route_id: routeId,\r\n          facilitator_id: facilitator.id,\r\n          phase: 'verify',\r\n          result: attemptResult,\r\n          latency_ms: verifyLatency,\r\n          error_code: errorCode,\r\n          raw_status: rawStatus,\r\n          is_probe: false,\r\n        });\r\n\r\n        // Create failure result\r\n        result = {\r\n          success: false,\r\n          valid: false,\r\n          error: errorMessage,\r\n          facilitatorId: facilitator.id,\r\n          verifiedAt: new Date().toISOString(),\r\n        };\r\n      }\r\n\r\n      // 4. Apply business logic (risk rules, compliance, etc.)\r\n      const orchestrated = this.applyBusinessLogic(result, requirements, policy);\r\n\r\n      // 5. Update route status\r\n      if (orchestrated.success && orchestrated.valid) {\r\n        await updateRouteStatus(routeId, 'settled', new Date().toISOString());\r\n      } else {\r\n        await updateRouteStatus(routeId, 'failed', new Date().toISOString());\r\n      }\r\n\r\n      // 6. Calculate orchestration metadata\r\n      const latency = Date.now() - startTime;\r\n      const metadata = {\r\n        latency,\r\n        complianceScore: this.calculateComplianceScore(result),\r\n      };\r\n\r\n      // 7. Build decision trace (for explainer/debugger UI)\r\n      const eligible = this.router.getFacilitators().filter((f) =>\r\n        f.supports(requirements.network, requirements.asset, requirements.scheme, requirements.settlementMode) && f.config.enabled\r\n      );\r\n      const decisionTrace = await this.buildDecisionTrace(\r\n        facilitator,\r\n        eligible,\r\n        requirements,\r\n        preferences,\r\n        policy\r\n      );\r\n\r\n      return {\r\n        ...orchestrated,\r\n        facilitatorUsed: facilitator.id,\r\n        routingReason: this.getRoutingReason(facilitator, preferences, policy),\r\n        alternativesConsidered: eligible.length - 1,\r\n        decisionTrace,\r\n        orchestrationMetadata: metadata,\r\n      };\r\n    } catch (error) {\r\n      logger.error({ error, requirements, routeId }, 'Orchestration error');\r\n\r\n      // Update route status to failed\r\n      if (routeId) {\r\n        await updateRouteStatus(routeId, 'failed', new Date().toISOString());\r\n      }\r\n\r\n      // Try failover if available\r\n      if (policy?.requireHealthCheck !== false) {\r\n        return await this.handleFailover(payment, requirements, preferences, policy, error, routeId);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply business logic to verification result\r\n   * SMF owns higher-level policy above raw settlement\r\n   */\r\n  private applyBusinessLogic(\r\n    result: VerificationResult,\r\n    requirements: PaymentRequirements,\r\n    policy?: RoutingPolicy\r\n  ): VerificationResult {\r\n    // 1. Risk rules\r\n    if (policy?.riskThreshold !== undefined) {\r\n      const riskScore = this.calculateRiskScore(result);\r\n      if (riskScore > policy.riskThreshold) {\r\n        return {\r\n          ...result,\r\n          valid: false,\r\n          error: `Risk score ${riskScore} exceeds threshold ${policy.riskThreshold}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // 2. Compliance rules\r\n    if (policy?.requireKYC) {\r\n      // Check if KYC is required for this amount\r\n      const amount = BigInt(requirements.maxAmountRequired);\r\n      const kycThreshold = BigInt('1000000000'); // 1000 USDC in smallest units\r\n      \r\n      if (amount > kycThreshold && result.kytStatus !== 'passed') {\r\n        return {\r\n          ...result,\r\n          valid: false,\r\n          error: 'KYC required for this amount',\r\n        };\r\n      }\r\n    }\r\n\r\n    // 3. Jurisdiction rules\r\n    if (policy?.jurisdictionRules) {\r\n      // Apply jurisdiction-specific rules\r\n      // This would integrate with geo-detection\r\n      // For now, pass through\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Calculate risk score (0-100)\r\n   */\r\n  private calculateRiskScore(result: VerificationResult): number {\r\n    let score = 0;\r\n\r\n    // KYT status\r\n    if (result.kytStatus === 'blocked') score += 50;\r\n    else if (result.kytStatus === 'flagged') score += 25;\r\n\r\n    // OFAC status\r\n    if (result.ofacStatus === 'blocked') score += 50;\r\n    else if (result.ofacStatus === 'flagged') score += 25;\r\n\r\n    // Error status\r\n    if (!result.success || !result.valid) score += 30;\r\n\r\n    return Math.min(100, score);\r\n  }\r\n\r\n  /**\r\n   * Calculate compliance score (0-100)\r\n   */\r\n  private calculateComplianceScore(result: VerificationResult): number {\r\n    let score = 100;\r\n\r\n    // Deduct for compliance issues\r\n    if (result.kytStatus === 'blocked') score -= 50;\r\n    else if (result.kytStatus === 'flagged') score -= 25;\r\n\r\n    if (result.ofacStatus === 'blocked') score -= 50;\r\n    else if (result.ofacStatus === 'flagged') score -= 25;\r\n\r\n    return Math.max(0, score);\r\n  }\r\n\r\n  /**\r\n   * Build decision trace for explainer/debugger UI\r\n   * Compact format for logging and future UI display\r\n   */\r\n  private async buildDecisionTrace(\r\n    selected: IFacilitator,\r\n    eligible: IFacilitator[],\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): Promise<DecisionTrace> {\r\n    // Score candidates to get detailed info\r\n    const router = getFacilitatorRouter();\r\n    const scored = await router.scoreFacilitators(\r\n      eligible,\r\n      requirements,\r\n      preferences,\r\n      policy\r\n    );\r\n\r\n    const candidates = eligible.map((f) => {\r\n      const scoredEntry = scored.find((s: any) => s.facilitator.id === f.id);\r\n      const score = scoredEntry?.score || 0;\r\n      const reasons = scoredEntry?.reasons || [];\r\n\r\n      return {\r\n        facilitatorId: f.id,\r\n        facilitatorName: f.name,\r\n        score,\r\n        eligible: true,\r\n        reasons,\r\n      };\r\n    });\r\n\r\n    return {\r\n      timestamp: new Date().toISOString(),\r\n      reason: this.getRoutingReason(selected, preferences, policy),\r\n      constraints: {\r\n        preferences,\r\n        policy: policy ? {\r\n          requireHealthCheck: policy.requireHealthCheck,\r\n          preferCheapest: policy.preferCheapest,\r\n          requireKYC: policy.requireKYC,\r\n        } : undefined,\r\n        requirements,\r\n      },\r\n      candidates,\r\n      selected: {\r\n        facilitatorId: selected.id,\r\n        score: scored.find((s: any) => s.facilitator.id === selected.id)?.score || 100,\r\n        alternativesConsidered: eligible.length - 1,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get routing reason for logging/analytics\r\n   */\r\n  private getRoutingReason(\r\n    facilitator: any,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy\r\n  ): string {\r\n    const reasons: string[] = [];\r\n\r\n    if (preferences?.priority === 'cost') reasons.push('cost-optimized');\r\n    if (preferences?.priority === 'speed') reasons.push('speed-optimized');\r\n    if (preferences?.priority === 'compliance') reasons.push('compliance-optimized');\r\n    if (preferences?.priority === 'reliability') reasons.push('reliability-optimized');\r\n    if (preferences?.preferredNetworks) reasons.push('network-preference');\r\n    if (policy?.preferCheapest) reasons.push('cheapest-selected');\r\n    if (facilitator.config.priority === 1) reasons.push('primary-facilitator');\r\n\r\n    return reasons.join(', ') || 'default-routing';\r\n  }\r\n\r\n  /**\r\n   * Handle failover to alternative facilitator\r\n   */\r\n  private async handleFailover(\r\n    payment: string,\r\n    requirements: PaymentRequirements,\r\n    preferences?: RoutingPreferences,\r\n    policy?: RoutingPolicy,\r\n    originalError?: any,\r\n    routeId?: string | null\r\n  ): Promise<OrchestrationResult> {\r\n    logger.warn({ originalError, requirements }, 'Attempting failover');\r\n\r\n    // Get all facilitators\r\n    const facilitators = this.router.getFacilitators();\r\n    const eligible = facilitators.filter((f) =>\r\n      f.supports(requirements.network, requirements.asset, requirements.scheme, requirements.settlementMode) && f.config.enabled\r\n    );\r\n\r\n    // Try each facilitator in order of priority\r\n    for (const facilitator of eligible.sort((a, b) => a.config.priority - b.config.priority)) {\r\n      const attemptStartTime = Date.now();\r\n      try {\r\n        const result = await facilitator.verify(payment, requirements);\r\n        const attemptLatency = Date.now() - attemptStartTime;\r\n        \r\n        // Log failover attempt\r\n        if (routeId) {\r\n          await createRouteAttempt({\r\n            route_id: routeId,\r\n            facilitator_id: facilitator.id,\r\n            phase: 'verify',\r\n            result: result.success && result.valid ? 'success' : 'failure',\r\n            latency_ms: attemptLatency,\r\n            is_probe: false,\r\n            error_code: result.error || null,\r\n            raw_status: null,\r\n          });\r\n        }\r\n        \r\n        if (result.success && result.valid) {\r\n          logger.info({ facilitatorId: facilitator.id, routeId }, 'Failover successful');\r\n          \r\n          // Update route with successful facilitator\r\n          if (routeId) {\r\n            await updateRouteStatus(routeId, 'settled', new Date().toISOString());\r\n          }\r\n          \r\n          return {\r\n            ...result,\r\n            facilitatorUsed: facilitator.id,\r\n            routingReason: 'failover',\r\n            alternativesConsidered: eligible.length - 1,\r\n          };\r\n        }\r\n      } catch (error) {\r\n        const attemptLatency = Date.now() - attemptStartTime;\r\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n        \r\n        // Log failed failover attempt\r\n        if (routeId) {\r\n          let attemptResult: 'timeout' | 'rate_limited' | 'network_error' | 'failure' = 'failure';\r\n          if (errorMessage.includes('timeout')) {\r\n            attemptResult = 'timeout';\r\n          } else if (errorMessage.includes('rate') || errorMessage.includes('429')) {\r\n            attemptResult = 'rate_limited';\r\n          } else if (errorMessage.includes('network') || errorMessage.includes('ECONNREFUSED')) {\r\n            attemptResult = 'network_error';\r\n          }\r\n          \r\n          await createRouteAttempt({\r\n            route_id: routeId,\r\n            facilitator_id: facilitator.id,\r\n            phase: 'verify',\r\n            result: attemptResult,\r\n            latency_ms: attemptLatency,\r\n            is_probe: false,\r\n            error_code: errorMessage,\r\n            raw_status: null,\r\n          });\r\n        }\r\n        \r\n        logger.warn({ facilitatorId: facilitator.id, error, routeId }, 'Failover attempt failed');\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // All facilitators failed\r\n    throw new Error(\r\n      `All facilitators failed. Original error: ${originalError instanceof Error ? originalError.message : 'Unknown error'}`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get orchestrator status\r\n   * Fixed: Aligns health semantics with facilitator health checks\r\n   */\r\n  async getStatus(): Promise<{\r\n    facilitators: number;\r\n    healthy: number;\r\n    networks: string[];\r\n    assets: string[];\r\n    facilitatorDetails: Array<{\r\n      id: string;\r\n      name: string;\r\n      healthy: boolean;\r\n      lastChecked?: string;\r\n    }>;\r\n  }> {\r\n    const facilitators = this.router.getFacilitators();\r\n    \r\n    // Check health of all facilitators (use actual health checks, not cached)\r\n    const healthChecks = await Promise.all(\r\n      facilitators.map(async (f) => {\r\n        try {\r\n          const health = await f.getHealth();\r\n          return {\r\n            id: f.id,\r\n            name: f.name,\r\n            healthy: health.healthy,\r\n            lastChecked: health.lastChecked,\r\n          };\r\n        } catch (error) {\r\n          return {\r\n            id: f.id,\r\n            name: f.name,\r\n            healthy: false,\r\n            lastChecked: new Date().toISOString(),\r\n          };\r\n        }\r\n      })\r\n    );\r\n\r\n    const healthy = healthChecks.filter((h) => h.healthy);\r\n\r\n    const networks = new Set<string>();\r\n    const assets = new Set<string>();\r\n\r\n    facilitators.forEach((f) => {\r\n      f.config.networks.forEach((n) => networks.add(n));\r\n      f.config.assets.forEach((a) => assets.add(a));\r\n    });\r\n\r\n    return {\r\n      facilitators: facilitators.length,\r\n      healthy: healthy.length,\r\n      networks: Array.from(networks),\r\n      assets: Array.from(assets),\r\n      facilitatorDetails: healthChecks,\r\n    };\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet metaFacilitator: MetaFacilitator | null = null;\r\n\r\n/**\r\n * Get meta-facilitator instance\r\n */\r\nexport function getMetaFacilitator(): MetaFacilitator {\r\n  if (!metaFacilitator) {\r\n    metaFacilitator = new MetaFacilitator();\r\n  }\r\n  return metaFacilitator;\r\n}\r\n\r\n","// =============================================================================\r\n// TEST-ONLY X402 VERIFICATION\r\n// =============================================================================\r\n// Fake x402 verification helper for safe testing without real funds\r\n// DO NOT USE IN PRODUCTION - This bypasses all real payment verification\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'TestX402Verification' });\r\n\r\n/**\r\n * Test-only verification result\r\n */\r\nexport interface TestVerificationResult {\r\n  success: boolean;\r\n  x402TxHash?: string;\r\n  facilitator?: string;\r\n  errorCode?: string;\r\n}\r\n\r\n/**\r\n * Test token header name\r\n */\r\nexport const TEST_TOKEN_HEADER = 'x-easepay-test-token';\r\n\r\n/**\r\n * Test token value that enables fake verification\r\n */\r\nexport const TEST_TOKEN_VALUE = 'demo-ok';\r\n\r\n/**\r\n * Verify payment in test mode only\r\n * \r\n * Checks for test header or config flag and returns fake success\r\n * DO NOT call real CDP/x402 verify in this path\r\n * \r\n * @param request - Next.js request object\r\n * @returns Test verification result\r\n */\r\nexport function verifyPaymentTestOnly(request: NextRequest): TestVerificationResult {\r\n  // Check for test token header\r\n  const testToken = request.headers.get(TEST_TOKEN_HEADER) || \r\n                    request.headers.get(TEST_TOKEN_HEADER.toUpperCase());\r\n  \r\n  // Check for config flag (environment variable)\r\n  const testModeEnabled = process.env.X402_TEST_MODE === 'true' || \r\n                         process.env.EASEPAY_TEST_MODE === 'true';\r\n  \r\n  if (testToken === TEST_TOKEN_VALUE || testModeEnabled) {\r\n    logger.info('Test payment verification passed', {\r\n      testToken: testToken === TEST_TOKEN_VALUE ? 'present' : 'missing',\r\n      testModeEnabled,\r\n    });\r\n    \r\n    return {\r\n      success: true,\r\n      x402TxHash: 'TEST_TX_HASH',\r\n      facilitator: 'TEST_FACILITATOR',\r\n    };\r\n  }\r\n  \r\n  // No test token or flag - payment required\r\n  logger.info('Test payment verification failed - no test token', {\r\n    testToken: testToken || 'missing',\r\n    testModeEnabled,\r\n  });\r\n  \r\n  return {\r\n    success: false,\r\n    errorCode: 'PAYMENT_REQUIRED',\r\n  };\r\n}\r\n\r\n/**\r\n * Check if test mode is enabled\r\n */\r\nexport function isTestModeEnabled(): boolean {\r\n  return process.env.X402_TEST_MODE === 'true' || \r\n         process.env.EASEPAY_TEST_MODE === 'true';\r\n}\r\n\r\n\r\n","// =============================================================================\r\n// INPUT VALIDATION & SANITIZATION\r\n// =============================================================================\r\n// Comprehensive input validation and sanitization for all API inputs\r\n\r\nimport { createLogger } from './logger';\r\n\r\nconst logger = createLogger({ component: 'InputValidator' });\r\n\r\nexport interface ValidationResult {\r\n  valid: boolean;\r\n  errors: string[];\r\n  sanitized?: any;\r\n}\r\n\r\n/**\r\n * Validate and sanitize endpoint ID\r\n */\r\nexport function validateEndpointId(endpointId: string): ValidationResult {\r\n  const errors: string[] = [];\r\n\r\n  // Check format: ep_<timestamp>_<random>\r\n  if (!endpointId || typeof endpointId !== 'string') {\r\n    errors.push('Endpoint ID must be a string');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // Allow formats:\r\n  // - ep_<digits>_<alphanumeric> (standard format)\r\n  // - ep_<alphanumeric>_<alphanumeric> (descriptive format like ep_url_enrich_demo_v1)\r\n  // - ep_<alphanumeric> (simple format)\r\n  if (!/^ep_[a-z0-9_]+$/i.test(endpointId)) {\r\n    errors.push('Invalid endpoint ID format');\r\n  }\r\n\r\n  if (endpointId.length > 100) {\r\n    errors.push('Endpoint ID too long');\r\n  }\r\n\r\n  // Sanitize: remove any non-alphanumeric characters except underscore and dash\r\n  const sanitized = endpointId.replace(/[^a-z0-9_-]/gi, '');\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    sanitized: errors.length === 0 ? sanitized : undefined,\r\n  };\r\n}\r\n\r\n/**\r\n * Validate and sanitize API key token\r\n */\r\nexport function validateApiKeyToken(token: string): ValidationResult {\r\n  const errors: string[] = [];\r\n\r\n  if (!token || typeof token !== 'string') {\r\n    errors.push('API key must be a string');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // Check format: nf_live_... or nf_test_...\r\n  if (!token.startsWith('nf_live_') && !token.startsWith('nf_test_')) {\r\n    errors.push('Invalid API key format');\r\n  }\r\n\r\n  if (token.length < 20 || token.length > 200) {\r\n    errors.push('API key length invalid');\r\n  }\r\n\r\n  // Sanitize: only allow alphanumeric, underscore, dash\r\n  const sanitized = token.replace(/[^a-z0-9_-]/gi, '');\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    sanitized: errors.length === 0 ? sanitized : undefined,\r\n  };\r\n}\r\n\r\n/**\r\n * Validate and sanitize payment header\r\n * \r\n * x402 payment headers have format: \"x402 <base64-encoded-json>\"\r\n * The base64 content contains the payment authorization and signature\r\n */\r\nexport function validatePaymentHeader(header: string): ValidationResult {\r\n  const errors: string[] = [];\r\n\r\n  if (!header || typeof header !== 'string') {\r\n    errors.push('Payment header must be a string');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // Length check - x402 headers can be large due to signatures\r\n  if (header.length > 10000) {\r\n    errors.push('Payment header too long');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  if (header.length < 10) {\r\n    errors.push('Payment header too short');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // Check for suspicious patterns (XSS, etc.)\r\n  if (header.includes('<script') || header.includes('javascript:')) {\r\n    errors.push('Suspicious content in payment header');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // x402 headers should start with \"x402 \" prefix\r\n  const hasX402Prefix = /^x402\\s+/i.test(header);\r\n  \r\n  // Extract base64 portion\r\n  const cleanHeader = hasX402Prefix \r\n    ? header.replace(/^x402\\s+/i, '').trim()\r\n    : header.trim();\r\n\r\n  // Validate base64 format (allow standard base64 chars plus URL-safe variants)\r\n  // Base64 can contain: A-Z, a-z, 0-9, +, /, =\r\n  // URL-safe base64 can also contain: -, _\r\n  if (cleanHeader.length > 0 && !/^[A-Za-z0-9+/=_-]+$/.test(cleanHeader)) {\r\n    // Log what characters are invalid for debugging\r\n    const invalidChars = cleanHeader.split('').filter(c => !/[A-Za-z0-9+/=_-]/.test(c));\r\n    logger.warn('Invalid characters in payment header base64', { \r\n      invalidChars: [...new Set(invalidChars)].slice(0, 10),\r\n      headerLength: header.length,\r\n      hasX402Prefix,\r\n    });\r\n    errors.push('Invalid base64 format in payment header');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // Verify it's decodable base64 (optional strict check)\r\n  try {\r\n    if (cleanHeader.length > 0) {\r\n      const decoded = Buffer.from(cleanHeader, 'base64').toString('utf-8');\r\n      // Should be valid JSON\r\n      JSON.parse(decoded);\r\n    }\r\n  } catch (e) {\r\n    // Don't fail validation, just log - the parser will handle this\r\n    logger.debug('Payment header base64 decode check failed (non-blocking)', {\r\n      error: e instanceof Error ? e.message : 'Unknown',\r\n    });\r\n  }\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    sanitized: header, // Return original header, let parser handle decoding\r\n  };\r\n}\r\n\r\n/**\r\n * Validate and sanitize request body\r\n */\r\nexport function validateRequestBody(body: any, schema?: {\r\n  required?: string[];\r\n  maxSize?: number;\r\n  allowedFields?: string[];\r\n}): ValidationResult {\r\n  const errors: string[] = [];\r\n\r\n  if (!body || typeof body !== 'object') {\r\n    errors.push('Request body must be an object');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  // Check size\r\n  const bodySize = JSON.stringify(body).length;\r\n  if (schema?.maxSize && bodySize > schema.maxSize) {\r\n    errors.push(`Request body too large: ${bodySize} bytes (max: ${schema.maxSize})`);\r\n  }\r\n\r\n  // Check required fields\r\n  if (schema?.required) {\r\n    for (const field of schema.required) {\r\n      if (!(field in body)) {\r\n        errors.push(`Required field missing: ${field}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Filter allowed fields\r\n  let sanitized = body;\r\n  if (schema?.allowedFields) {\r\n    sanitized = {};\r\n    for (const field of schema.allowedFields) {\r\n      if (field in body) {\r\n        sanitized[field] = sanitizeValue(body[field]);\r\n      }\r\n    }\r\n  } else {\r\n    // Sanitize all values\r\n    sanitized = sanitizeObject(body);\r\n  }\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    sanitized: errors.length === 0 ? sanitized : undefined,\r\n  };\r\n}\r\n\r\n/**\r\n * Sanitize a value (recursive)\r\n */\r\nfunction sanitizeValue(value: any): any {\r\n  if (typeof value === 'string') {\r\n    return sanitizeString(value);\r\n  } else if (Array.isArray(value)) {\r\n    return value.map(sanitizeValue);\r\n  } else if (value && typeof value === 'object') {\r\n    return sanitizeObject(value);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * Sanitize a string\r\n */\r\nfunction sanitizeString(str: string): string {\r\n  // Remove null bytes\r\n  str = str.replace(/\\0/g, '');\r\n  \r\n  // Remove control characters (except newline, tab, carriage return)\r\n  str = str.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, '');\r\n  \r\n  // Trim whitespace\r\n  str = str.trim();\r\n  \r\n  return str;\r\n}\r\n\r\n/**\r\n * Sanitize an object\r\n */\r\nfunction sanitizeObject(obj: Record<string, any>): Record<string, any> {\r\n  const sanitized: Record<string, any> = {};\r\n  \r\n  for (const [key, value] of Object.entries(obj)) {\r\n    // Sanitize key\r\n    const cleanKey = sanitizeString(key);\r\n    \r\n    // Skip if key is empty after sanitization\r\n    if (!cleanKey) continue;\r\n    \r\n    // Sanitize value\r\n    sanitized[cleanKey] = sanitizeValue(value);\r\n  }\r\n  \r\n  return sanitized;\r\n}\r\n\r\n/**\r\n * Validate URL parameter\r\n */\r\nexport function validateUrlParam(param: string, type: 'string' | 'number' | 'uuid' | 'endpointId'): ValidationResult {\r\n  const errors: string[] = [];\r\n\r\n  if (!param || typeof param !== 'string') {\r\n    errors.push(`Parameter must be a string`);\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  switch (type) {\r\n    case 'number':\r\n      if (!/^\\d+$/.test(param)) {\r\n        errors.push('Parameter must be a number');\r\n      }\r\n      break;\r\n    case 'uuid':\r\n      if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(param)) {\r\n        errors.push('Parameter must be a valid UUID');\r\n      }\r\n      break;\r\n    case 'endpointId':\r\n      return validateEndpointId(param);\r\n    case 'string':\r\n      if (param.length > 1000) {\r\n        errors.push('Parameter too long');\r\n      }\r\n      break;\r\n  }\r\n\r\n  const sanitized = sanitizeString(param);\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    sanitized: errors.length === 0 ? sanitized : undefined,\r\n  };\r\n}\r\n\r\n","// =============================================================================\r\n// X402 RESOURCE SERVER WITH BAZAAR EXTENSION\r\n// =============================================================================\r\n// Official x402 SDK integration with Bazaar discovery support\r\n// Note: @x402 packages may not be available - this module will handle missing dependencies gracefully\r\n\r\nimport { getCDPFacilitator } from './cdp-facilitator';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'X402ResourceServer' });\r\n\r\n// Lazy load x402 packages to handle missing dependencies\r\nlet x402ResourceServer: any;\r\nlet HTTPFacilitatorClient: any;\r\nlet bazaarResourceServerExtension: any;\r\nlet registerExactEvmScheme: any;\r\n\r\nasync function loadX402Packages() {\r\n  if (!x402ResourceServer) {\r\n    try {\r\n      const x402Core = await import('@x402/core/server');\r\n      const x402Http = await import('@x402/core/http');\r\n      const x402Bazaar = await import('@x402/extensions/bazaar');\r\n      const x402EVM = await import('@x402/evm/exact/server');\r\n      \r\n      x402ResourceServer = x402Core.x402ResourceServer;\r\n      HTTPFacilitatorClient = x402Http.HTTPFacilitatorClient;\r\n      bazaarResourceServerExtension = x402Bazaar.bazaarResourceServerExtension;\r\n      registerExactEvmScheme = x402EVM.registerExactEvmScheme;\r\n    } catch (error) {\r\n      logger.warn({ error }, 'x402 packages not available - discovery features will be limited');\r\n      throw new Error('x402 packages not installed');\r\n    }\r\n  }\r\n  return { x402ResourceServer, HTTPFacilitatorClient, bazaarResourceServerExtension, registerExactEvmScheme };\r\n}\r\n\r\n/**\r\n * CDP Facilitator Client Adapter\r\n * \r\n * Adapts our custom CDP facilitator to the SDK's HTTPFacilitatorClient interface\r\n * This class is only used when x402 packages are available\r\n */\r\nclass CDPFacilitatorClientAdapter {\r\n  private cdpFacilitator: ReturnType<typeof getCDPFacilitator>;\r\n  private baseClient: any;\r\n\r\n  constructor() {\r\n    // Will be initialized when x402 packages are loaded\r\n    this.cdpFacilitator = getCDPFacilitator();\r\n  }\r\n\r\n  async initialize(HTTPFacilitatorClient: any) {\r\n    // Initialize with CDP facilitator URL (not used directly, but required by base class)\r\n    this.baseClient = new HTTPFacilitatorClient({\r\n      url: process.env.CDP_FACILITATOR_URL || 'https://api.cdp.coinbase.com/platform/v2/x402',\r\n    });\r\n    Object.setPrototypeOf(this, this.baseClient.constructor.prototype);\r\n  }\r\n\r\n  /**\r\n   * Override verify method to use our CDP facilitator\r\n   */\r\n  async verify(payment: string, paymentPayload: any, paymentRequirements?: any): Promise<any> {\r\n    try {\r\n      const result = await this.cdpFacilitator.verifyPaymentWithRetry({\r\n        payment,\r\n        paymentPayload,\r\n        paymentRequirements,\r\n      });\r\n\r\n      if (result.success && result.valid) {\r\n        return {\r\n          isValid: true,\r\n          transactionHash: result.transactionHash,\r\n          kytStatus: result.kytStatus,\r\n          ofacStatus: result.ofacStatus,\r\n        };\r\n      } else {\r\n        return {\r\n          isValid: false,\r\n          invalidReason: result.error,\r\n          errorMessage: result.error,\r\n        };\r\n      }\r\n    } catch (error) {\r\n      logger.error({ error }, 'CDP facilitator verification error');\r\n      return {\r\n        isValid: false,\r\n        invalidReason: error instanceof Error ? error.message : 'Verification failed',\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton resource server instance\r\nlet resourceServer: any | null = null;\r\n\r\n/**\r\n * Get or create the x402 resource server with Bazaar extension\r\n * \r\n * Enhanced to support multi-chain (all EVM chains via Exact scheme)\r\n * Returns null if x402 packages are not available\r\n */\r\nexport async function getX402ResourceServer() {\r\n  try {\r\n    const { x402ResourceServer: X402ResourceServer, HTTPFacilitatorClient: HTTPClient, bazaarResourceServerExtension: bazaarExt, registerExactEvmScheme: registerScheme } = await loadX402Packages();\r\n    \r\n    if (!resourceServer) {\r\n      // Create facilitator client adapter\r\n      const facilitatorClient = new CDPFacilitatorClientAdapter();\r\n      await facilitatorClient.initialize(HTTPClient);\r\n\r\n      // Create resource server\r\n      resourceServer = new X402ResourceServer(facilitatorClient);\r\n\r\n      // Register Exact EVM scheme (supports all EVM chains)\r\n      // The SDK's registerExactEvmScheme should handle multiple chains automatically\r\n      registerScheme(resourceServer);\r\n\r\n      // Register Bazaar extension for discovery\r\n      resourceServer.registerExtension(bazaarExt);\r\n\r\n    // Log supported networks (async import to avoid blocking)\r\n    import('./chain-registry')\r\n      .then(({ getChainRegistry }) => {\r\n        const chainRegistry = getChainRegistry();\r\n        const evmNetworks = chainRegistry.getEVMs();\r\n        logger.info(\r\n          {\r\n            supportedNetworks: evmNetworks.map((n) => ({\r\n              caip: n.caip,\r\n              name: n.name,\r\n              chainId: n.chainId,\r\n            })),\r\n          },\r\n          'x402 Resource Server initialized with Bazaar extension and multi-chain support'\r\n        );\r\n      })\r\n      .catch(() => {\r\n        logger.info('x402 Resource Server initialized with Bazaar extension');\r\n      });\r\n    }\r\n\r\n    return resourceServer;\r\n  } catch (error) {\r\n    logger.warn({ error }, 'x402 resource server not available - discovery endpoint may not function');\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get facilitator client adapter (for direct use if needed)\r\n */\r\nexport function getFacilitatorClientAdapter() {\r\n  return new CDPFacilitatorClientAdapter();\r\n}\r\n\r\n","// =============================================================================\n// DISCOVERY METADATA HELPERS\n// =============================================================================\n// Helpers for declaring Bazaar discovery metadata\n// Note: @x402 packages may not be available - this module handles missing dependencies gracefully\n\nimport type { MeteredEndpoint } from '@/db/metered-endpoints';\n\n// Lazy load x402 packages\nasync function loadBazaarExtension() {\n  try {\n    const { declareDiscoveryExtension } = await import('@x402/extensions/bazaar');\n    return declareDiscoveryExtension;\n  } catch (error) {\n    // Return a stub function if package is not available\n    return (config: any) => ({\n      ...config,\n      _stub: true,\n    });\n  }\n}\n\n/**\n * Create discovery metadata for a metered endpoint\n * \n * This enables the endpoint to be discovered in the x402 Bazaar\n */\nexport async function createDiscoveryMetadata(endpoint: MeteredEndpoint) {\n  // Determine if this is a GET or POST endpoint based on typical usage\n  // Most metered endpoints are POST, but we can make it configurable later\n  const method = 'POST';\n  const bodyType = 'json'; // Most endpoints accept JSON\n\n  // Create output schema based on endpoint description\n  // This is a generic schema - can be customized per endpoint\n  const outputSchema = {\n    type: 'object',\n    properties: {\n      data: {\n        type: 'object',\n        description: 'Response data from upstream service',\n      },\n      timestamp: {\n        type: 'string',\n        format: 'date-time',\n        description: 'Response timestamp',\n      },\n    },\n  };\n\n  // Example output based on endpoint type\n  const outputExample: any = {\n    data: {},\n    timestamp: new Date().toISOString(),\n  };\n\n  // If endpoint has a specific description, use it to create better examples\n  if (endpoint.description?.toLowerCase().includes('revenue')) {\n    outputExample.data = {\n      revenue: 0.01,\n      currency: 'USDC',\n      period: 'daily',\n    };\n  } else if (endpoint.description?.toLowerCase().includes('health')) {\n    outputExample.data = {\n      status: 'healthy',\n      uptime: 99.9,\n    };\n  }\n\n  // Declare discovery extension\n  const declareExt = await loadBazaarExtension();\n  return declareExt({\n    // Input schema (for POST endpoints with body)\n    inputSchema: {\n      type: 'object',\n      properties: {\n        // Generic input - can be customized per endpoint\n      },\n      additionalProperties: true, // Allow any additional properties\n    },\n    bodyType: bodyType,\n    // Output schema and example\n    output: {\n      example: outputExample,\n      schema: outputSchema,\n    },\n  });\n}\n\n/**\n * Get discovery metadata for endpoint listing\n */\nexport function getEndpointDiscoveryInfo(endpoint: MeteredEndpoint) {\n  const isProduction = process.env.NODE_ENV === 'production';\n  const appUrl = process.env.NEXT_PUBLIC_APP_URL;\n  if (isProduction && !appUrl) {\n    throw new Error('NEXT_PUBLIC_APP_URL must be set in production');\n  }\n  const baseUrl = appUrl || 'http://localhost:3001';\n  const resourceUrl = `${baseUrl}/api/v1/metered/${endpoint.id}`;\n\n  return {\n    url: resourceUrl,\n    type: 'http',\n    method: 'POST',\n    x402Version: 1,\n    accepts: [\n      {\n        scheme: 'exact',\n        network: endpoint.network,\n        maxAmountRequired: endpoint.price,\n        asset: endpoint.tokenAddress,\n        payTo: endpoint.recipientAddress,\n        resource: resourceUrl,\n        description: endpoint.description || endpoint.name || 'Metered API endpoint',\n        mimeType: 'application/json',\n        maxTimeoutSeconds: 300,\n      },\n    ],\n    metadata: {\n      name: endpoint.name,\n      description: endpoint.description,\n      category: 'api',\n      provider: 'NexFlow',\n    },\n    lastUpdated: new Date(endpoint.updatedAt).getTime() / 1000,\n  };\n}\n\n","// =============================================================================\r\n// WEBHOOK DELIVERIES DATABASE\r\n// =============================================================================\r\n// Database operations for webhook delivery logs\r\n\r\nimport { executeQuery, executeQueryOne, executeUpdate } from './query-helper';\r\n\r\nexport interface WebhookDeliveryRow {\r\n  id: string;\r\n  webhook_config_id: string;\r\n  event_id: string;\r\n  event_type: string;\r\n  url: string;\r\n  payload: string;\r\n  signature: string;\r\n  status: string;\r\n  attempts: number;\r\n  max_attempts: number;\r\n  next_retry_at: string | null;\r\n  last_attempt_at: string | null;\r\n  last_response_code: number | null;\r\n  last_response_body: string | null;\r\n  error_message: string | null;\r\n  delivered_at: string | null;\r\n  created_at: string;\r\n}\r\n\r\n/**\r\n * Create webhook delivery record\r\n */\r\nexport async function createDeliveryRecord(data: {\r\n  webhookConfigId: string;\r\n  eventId: string;\r\n  eventType: string;\r\n  url: string;\r\n  payload: string;\r\n  signature: string;\r\n  maxAttempts?: number;\r\n}): Promise<string> {\r\n  const id = `wd_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n  const { getDb } = await import('./client');\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  const query = isPostgres\r\n    ? `INSERT INTO webhook_deliveries (id, webhook_config_id, event_id, event_type, url, payload, signature, status, attempts, max_attempts, created_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)`\r\n    : `INSERT INTO webhook_deliveries (id, webhook_config_id, event_id, event_type, url, payload, signature, status, attempts, max_attempts, created_at)\r\n       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;\r\n  \r\n  const params = [\r\n    id,\r\n    data.webhookConfigId,\r\n    data.eventId,\r\n    data.eventType,\r\n    data.url,\r\n    data.payload,\r\n    data.signature,\r\n    'pending',\r\n    0,\r\n    data.maxAttempts || 3,\r\n    new Date().toISOString(),\r\n  ];\r\n\r\n  await executeUpdate(query, params);\r\n  return id;\r\n}\r\n\r\n/**\r\n * Update delivery attempt\r\n */\r\nexport async function updateDeliveryAttempt(\r\n  webhookConfigId: string,\r\n  eventId: string,\r\n  updates: {\r\n    attempt: number;\r\n    lastAttemptAt: string;\r\n  }\r\n): Promise<void> {\r\n  const { getDb } = await import('./client');\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  const query = isPostgres\r\n    ? `UPDATE webhook_deliveries \r\n       SET attempts = $1, last_attempt_at = $2 \r\n       WHERE webhook_config_id = $3 AND event_id = $4`\r\n    : `UPDATE webhook_deliveries \r\n       SET attempts = ?, last_attempt_at = ? \r\n       WHERE webhook_config_id = ? AND event_id = ?`;\r\n  \r\n  await executeUpdate(query, [\r\n    updates.attempt,\r\n    updates.lastAttemptAt,\r\n    webhookConfigId,\r\n    eventId,\r\n  ]);\r\n}\r\n\r\n/**\r\n * Mark delivery as successful\r\n */\r\nexport async function markDeliverySuccess(\r\n  webhookConfigId: string,\r\n  eventId: string,\r\n  result: {\r\n    statusCode?: number;\r\n    responseBody?: string;\r\n  }\r\n): Promise<void> {\r\n  const { getDb } = await import('./client');\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  const now = new Date().toISOString();\r\n  \r\n  const query = isPostgres\r\n    ? `UPDATE webhook_deliveries \r\n       SET status = 'delivered', delivered_at = $1, last_response_code = $2, last_response_body = $3\r\n       WHERE webhook_config_id = $4 AND event_id = $5`\r\n    : `UPDATE webhook_deliveries \r\n       SET status = 'delivered', delivered_at = ?, last_response_code = ?, last_response_body = ?\r\n       WHERE webhook_config_id = ? AND event_id = ?`;\r\n  \r\n  await executeUpdate(query, [\r\n    now,\r\n    result.statusCode || null,\r\n    result.responseBody || null,\r\n    webhookConfigId,\r\n    eventId,\r\n  ]);\r\n}\r\n\r\n/**\r\n * Mark delivery as failed\r\n */\r\nexport async function markDeliveryFailed(\r\n  webhookConfigId: string,\r\n  eventId: string,\r\n  result: {\r\n    attempt: number;\r\n    statusCode?: number;\r\n    responseBody?: string;\r\n    errorMessage?: string;\r\n    nextRetryAt?: string;\r\n  }\r\n): Promise<void> {\r\n  const { getDb } = await import('./client');\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  const status = result.nextRetryAt ? 'pending' : 'failed';\r\n  \r\n  const query = isPostgres\r\n    ? `UPDATE webhook_deliveries \r\n       SET status = $1, attempts = $2, last_response_code = $3, last_response_body = $4, \r\n           error_message = $5, next_retry_at = $6, last_attempt_at = $7\r\n       WHERE webhook_config_id = $8 AND event_id = $9`\r\n    : `UPDATE webhook_deliveries \r\n       SET status = ?, attempts = ?, last_response_code = ?, last_response_body = ?, \r\n           error_message = ?, next_retry_at = ?, last_attempt_at = ?\r\n       WHERE webhook_config_id = ? AND event_id = ?`;\r\n  \r\n  await executeUpdate(query, [\r\n    status,\r\n    result.attempt,\r\n    result.statusCode || null,\r\n    result.responseBody || null,\r\n    result.errorMessage || null,\r\n    result.nextRetryAt || null,\r\n    new Date().toISOString(),\r\n    webhookConfigId,\r\n    eventId,\r\n  ]);\r\n}\r\n\r\n/**\r\n * List webhook deliveries with optional filters\r\n */\r\nexport async function listWebhookDeliveries(\r\n  filters?: {\r\n    webhookConfigId?: string;\r\n    eventType?: string;\r\n    status?: string;\r\n    limit?: number;\r\n  }\r\n): Promise<WebhookDeliveryRow[]> {\r\n  const { getDb } = await import('./client');\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  \r\n  let query = 'SELECT * FROM webhook_deliveries WHERE 1=1';\r\n  const params: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (filters?.webhookConfigId) {\r\n    if (isPostgres) {\r\n      query += ` AND webhook_config_id = $${paramIndex++}`;\r\n    } else {\r\n      query += ' AND webhook_config_id = ?';\r\n    }\r\n    params.push(filters.webhookConfigId);\r\n  }\r\n\r\n  if (filters?.eventType) {\r\n    if (isPostgres) {\r\n      query += ` AND event_type = $${paramIndex++}`;\r\n    } else {\r\n      query += ' AND event_type = ?';\r\n    }\r\n    params.push(filters.eventType);\r\n  }\r\n\r\n  if (filters?.status) {\r\n    if (isPostgres) {\r\n      query += ` AND status = $${paramIndex++}`;\r\n    } else {\r\n      query += ' AND status = ?';\r\n    }\r\n    params.push(filters.status);\r\n  }\r\n\r\n  query += ' ORDER BY created_at DESC';\r\n\r\n  if (filters?.limit) {\r\n    query += ` LIMIT ${filters.limit}`;\r\n  } else {\r\n    query += ' LIMIT 100';\r\n  }\r\n\r\n  return executeQuery<WebhookDeliveryRow>(query, params);\r\n}\r\n\r\n/**\r\n * Get delivery records for a webhook\r\n */\r\nexport async function getDeliveryRecords(\r\n  webhookConfigId: string,\r\n  filters?: {\r\n    status?: string;\r\n    limit?: number;\r\n  }\r\n): Promise<WebhookDeliveryRow[]> {\r\n  return listWebhookDeliveries({\r\n    webhookConfigId,\r\n    ...filters,\r\n  });\r\n}\r\n\r\n/**\r\n * Get delivery record by ID\r\n */\r\nexport async function getDeliveryRecord(id: string): Promise<WebhookDeliveryRow | null> {\r\n  const { getDb } = await import('./client');\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  const query = isPostgres\r\n    ? 'SELECT * FROM webhook_deliveries WHERE id = $1'\r\n    : 'SELECT * FROM webhook_deliveries WHERE id = ?';\r\n  \r\n  return executeQueryOne<WebhookDeliveryRow>(query, [id]);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n","// =============================================================================\r\n// Webhook Delivery System\r\n// =============================================================================\r\n// Handles webhook event delivery with retry logic, HMAC signing, and status tracking\r\n//\r\n// Features:\r\n// - Exponential backoff with jitter\r\n// - Dead letter queue (DLQ) for failed webhooks\r\n// - Delivery metrics tracking\r\n// - Circuit breaker per endpoint\r\n// - Structured logging\r\n\r\nimport crypto from 'crypto';\r\nimport { createLogger } from './logger';\r\nimport * as webhookDeliveriesDb from '@/db/webhook-deliveries';\r\n\r\n// Lazy import to avoid blocking if bullmq is not available\r\nasync function getWebhookQueue() {\r\n  try {\r\n    const { enqueueWebhookDelivery } = await import('./webhook-queue');\r\n    return enqueueWebhookDelivery;\r\n  } catch (error) {\r\n    logger.warn('Webhook queue not available (bullmq may not be installed)', { error });\r\n    return null;\r\n  }\r\n}\r\n\r\nconst logger = createLogger({ component: 'WebhookDelivery' });\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\nexport const WEBHOOK_CONFIG = {\r\n  /** Maximum number of delivery attempts */\r\n  maxAttempts: parseInt(process.env.WEBHOOK_MAX_ATTEMPTS || '5', 10),\r\n  \r\n  /** Base delay for exponential backoff (ms) */\r\n  baseDelay: parseInt(process.env.WEBHOOK_BASE_DELAY_MS || '1000', 10),\r\n  \r\n  /** Maximum delay between retries (ms) */\r\n  maxDelay: parseInt(process.env.WEBHOOK_MAX_DELAY_MS || '300000', 10), // 5 minutes\r\n  \r\n  /** Request timeout (ms) */\r\n  requestTimeout: parseInt(process.env.WEBHOOK_TIMEOUT_MS || '10000', 10),\r\n  \r\n  /** Enable dead letter queue for failed webhooks */\r\n  enableDLQ: process.env.WEBHOOK_ENABLE_DLQ !== 'false',\r\n  \r\n  /** Jitter factor (0-1) for randomizing delays */\r\n  jitterFactor: parseFloat(process.env.WEBHOOK_JITTER_FACTOR || '0.2'),\r\n};\r\n\r\n// =============================================================================\r\n// METRICS\r\n// =============================================================================\r\n\r\ninterface WebhookMetrics {\r\n  delivered: number;\r\n  failed: number;\r\n  retried: number;\r\n  dlqCount: number;\r\n  byEndpoint: Map<string, { delivered: number; failed: number }>;\r\n  lastReset: number;\r\n}\r\n\r\nconst metrics: WebhookMetrics = {\r\n  delivered: 0,\r\n  failed: 0,\r\n  retried: 0,\r\n  dlqCount: 0,\r\n  byEndpoint: new Map(),\r\n  lastReset: Date.now(),\r\n};\r\n\r\nconst METRICS_RESET_INTERVAL = 60 * 60 * 1000; // 1 hour\r\n\r\nfunction recordDeliveryMetric(url: string, success: boolean, isRetry: boolean = false): void {\r\n  // Reset metrics hourly\r\n  if (Date.now() - metrics.lastReset > METRICS_RESET_INTERVAL) {\r\n    metrics.delivered = 0;\r\n    metrics.failed = 0;\r\n    metrics.retried = 0;\r\n    metrics.byEndpoint.clear();\r\n    metrics.lastReset = Date.now();\r\n  }\r\n  \r\n  if (success) {\r\n    metrics.delivered++;\r\n  } else {\r\n    metrics.failed++;\r\n  }\r\n  \r\n  if (isRetry) {\r\n    metrics.retried++;\r\n  }\r\n  \r\n  // Track by endpoint (use hostname only)\r\n  try {\r\n    const hostname = new URL(url).hostname;\r\n    const endpointMetrics = metrics.byEndpoint.get(hostname) || { delivered: 0, failed: 0 };\r\n    if (success) {\r\n      endpointMetrics.delivered++;\r\n    } else {\r\n      endpointMetrics.failed++;\r\n    }\r\n    metrics.byEndpoint.set(hostname, endpointMetrics);\r\n  } catch {\r\n    // Invalid URL, skip endpoint tracking\r\n  }\r\n}\r\n\r\n/**\r\n * Get webhook delivery metrics\r\n */\r\nexport function getWebhookMetrics(): {\r\n  delivered: number;\r\n  failed: number;\r\n  retried: number;\r\n  dlqCount: number;\r\n  successRate: string;\r\n  byEndpoint: Record<string, { delivered: number; failed: number; successRate: string }>;\r\n  lastReset: string;\r\n} {\r\n  const total = metrics.delivered + metrics.failed;\r\n  const byEndpoint: Record<string, any> = {};\r\n  \r\n  metrics.byEndpoint.forEach((stats, hostname) => {\r\n    const endpointTotal = stats.delivered + stats.failed;\r\n    byEndpoint[hostname] = {\r\n      ...stats,\r\n      successRate: endpointTotal > 0 \r\n        ? ((stats.delivered / endpointTotal) * 100).toFixed(2) + '%'\r\n        : '0%',\r\n    };\r\n  });\r\n  \r\n  return {\r\n    delivered: metrics.delivered,\r\n    failed: metrics.failed,\r\n    retried: metrics.retried,\r\n    dlqCount: metrics.dlqCount,\r\n    successRate: total > 0 \r\n      ? ((metrics.delivered / total) * 100).toFixed(2) + '%'\r\n      : '0%',\r\n    byEndpoint,\r\n    lastReset: new Date(metrics.lastReset).toISOString(),\r\n  };\r\n}\r\n\r\nexport type WebhookEventType =\r\n  | 'payment.verified'\r\n  | 'payment.failed'\r\n  | 'usage.recorded'\r\n  | 'session.completed'\r\n  | 'endpoint.created'\r\n  | 'endpoint.updated'\r\n  | 'endpoint.deleted';\r\n\r\nexport interface WebhookEvent {\r\n  id: string;\r\n  event: WebhookEventType;\r\n  timestamp: string;\r\n  data: Record<string, any>;\r\n}\r\n\r\nexport interface WebhookConfig {\r\n  id: string;\r\n  endpointId?: string; // Optional: webhook for specific endpoint\r\n  url: string;\r\n  secret: string; // For HMAC signing\r\n  events: WebhookEventType[];\r\n  enabled: boolean;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\nexport interface WebhookDelivery {\r\n  id: string;\r\n  webhookConfigId: string;\r\n  eventId: string;\r\n  url: string;\r\n  payload: string;\r\n  signature: string;\r\n  status: 'pending' | 'delivered' | 'failed';\r\n  attempts: number;\r\n  maxAttempts: number;\r\n  nextRetryAt?: string;\r\n  lastAttemptAt?: string;\r\n  lastResponseCode?: number;\r\n  lastResponseBody?: string;\r\n  deliveredAt?: string;\r\n  createdAt: string;\r\n}\r\n\r\n/**\r\n * Generate HMAC signature for webhook payload\r\n */\r\nexport function generateWebhookSignature(\r\n  payload: string,\r\n  secret: string\r\n): string {\r\n  return crypto\r\n    .createHmac('sha256', secret)\r\n    .update(payload)\r\n    .digest('hex');\r\n}\r\n\r\n/**\r\n * Verify webhook signature\r\n */\r\nexport function verifyWebhookSignature(\r\n  payload: string,\r\n  signature: string,\r\n  secret: string\r\n): boolean {\r\n  const expectedSignature = generateWebhookSignature(payload, secret);\r\n  return crypto.timingSafeEqual(\r\n    Buffer.from(signature),\r\n    Buffer.from(expectedSignature)\r\n  );\r\n}\r\n\r\n/**\r\n * Create webhook event\r\n */\r\nexport function createWebhookEvent(\r\n  event: WebhookEventType,\r\n  data: Record<string, any>\r\n): WebhookEvent {\r\n  return {\r\n    id: `evt_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,\r\n    event,\r\n    timestamp: new Date().toISOString(),\r\n    data,\r\n  };\r\n}\r\n\r\n/**\r\n * Deliver webhook event with enhanced error handling and metrics\r\n */\r\nexport async function deliverWebhook(\r\n  config: WebhookConfig,\r\n  event: WebhookEvent,\r\n  attempt: number = 1\r\n): Promise<{ \r\n  success: boolean; \r\n  statusCode?: number; \r\n  error?: string;\r\n  retryable?: boolean;\r\n  retryDelay?: number;\r\n}> {\r\n  const payload = JSON.stringify(event);\r\n  const signature = generateWebhookSignature(payload, config.secret);\r\n  const isRetry = attempt > 1;\r\n  \r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    const response = await fetch(config.url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'X-Webhook-Signature': signature,\r\n        'X-Webhook-Event': event.event,\r\n        'X-Webhook-Timestamp': event.timestamp,\r\n        'X-Webhook-Delivery-Id': event.id,\r\n        'X-Webhook-Attempt': attempt.toString(),\r\n        'User-Agent': 'NexFlow-Webhooks/1.0',\r\n      },\r\n      body: payload,\r\n      signal: AbortSignal.timeout(WEBHOOK_CONFIG.requestTimeout),\r\n    });\r\n    \r\n    const responseBody = await response.text().catch(() => '');\r\n    const latencyMs = Date.now() - startTime;\r\n    \r\n    if (response.ok) {\r\n      recordDeliveryMetric(config.url, true, isRetry);\r\n      \r\n      logger.info({\r\n        webhookConfigId: config.id,\r\n        eventId: event.id,\r\n        eventType: event.event,\r\n        statusCode: response.status,\r\n        latencyMs,\r\n        attempt,\r\n      }, 'Webhook delivered successfully');\r\n      \r\n      return {\r\n        success: true,\r\n        statusCode: response.status,\r\n      };\r\n    } else {\r\n      const retryable = isRetryableStatus(response.status);\r\n      const retryDelay = retryable ? calculateRetryDelay(attempt - 1) : undefined;\r\n      \r\n      recordDeliveryMetric(config.url, false, isRetry);\r\n      \r\n      logger.warn({\r\n        webhookConfigId: config.id,\r\n        eventId: event.id,\r\n        eventType: event.event,\r\n        statusCode: response.status,\r\n        responseBody: responseBody.substring(0, 200),\r\n        latencyMs,\r\n        attempt,\r\n        retryable,\r\n        retryDelay,\r\n      }, 'Webhook delivery failed');\r\n      \r\n      return {\r\n        success: false,\r\n        statusCode: response.status,\r\n        error: `HTTP ${response.status}: ${responseBody.substring(0, 100)}`,\r\n        retryable,\r\n        retryDelay,\r\n      };\r\n    }\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n    const retryable = error instanceof Error && isRetryableError(error);\r\n    const retryDelay = retryable ? calculateRetryDelay(attempt - 1) : undefined;\r\n    const latencyMs = Date.now() - startTime;\r\n    \r\n    recordDeliveryMetric(config.url, false, isRetry);\r\n    \r\n    logger.error({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      eventType: event.event,\r\n      error: errorMessage,\r\n      latencyMs,\r\n      attempt,\r\n      retryable,\r\n      retryDelay,\r\n    }, 'Webhook delivery error');\r\n    \r\n    return {\r\n      success: false,\r\n      error: errorMessage,\r\n      retryable,\r\n      retryDelay,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate next retry delay with exponential backoff and jitter\r\n * \r\n * Formula: delay = min(maxDelay, baseDelay * 2^attempt) * (1 + random * jitter)\r\n * \r\n * @param attempt - Current attempt number (0-indexed)\r\n * @returns Delay in milliseconds\r\n */\r\nfunction calculateRetryDelay(attempt: number): number {\r\n  const { baseDelay, maxDelay, jitterFactor } = WEBHOOK_CONFIG;\r\n  \r\n  // Exponential backoff\r\n  const exponentialDelay = baseDelay * Math.pow(2, attempt);\r\n  const cappedDelay = Math.min(exponentialDelay, maxDelay);\r\n  \r\n  // Add jitter (random variance to prevent thundering herd)\r\n  const jitter = 1 + (Math.random() * jitterFactor * 2 - jitterFactor);\r\n  \r\n  return Math.round(cappedDelay * jitter);\r\n}\r\n\r\n/**\r\n * Determine if an HTTP status code is retryable\r\n */\r\nfunction isRetryableStatus(statusCode: number): boolean {\r\n  // Retry on server errors (5xx) and some client errors\r\n  if (statusCode >= 500 && statusCode < 600) return true;\r\n  if (statusCode === 408) return true; // Request Timeout\r\n  if (statusCode === 429) return true; // Too Many Requests\r\n  return false;\r\n}\r\n\r\n/**\r\n * Determine if an error is retryable\r\n */\r\nfunction isRetryableError(error: Error): boolean {\r\n  const message = error.message.toLowerCase();\r\n  return (\r\n    message.includes('timeout') ||\r\n    message.includes('econnrefused') ||\r\n    message.includes('econnreset') ||\r\n    message.includes('enotfound') ||\r\n    message.includes('socket hang up') ||\r\n    message.includes('network')\r\n  );\r\n}\r\n\r\n/**\r\n * Queue webhook for delivery with retry logic (uses BullMQ)\r\n */\r\nexport async function queueWebhookDelivery(\r\n  config: WebhookConfig,\r\n  event: WebhookEvent\r\n): Promise<void> {\r\n  try {\r\n    const payload = JSON.stringify(event);\r\n    const signature = generateWebhookSignature(payload, config.secret);\r\n    \r\n    // Create delivery record in database\r\n    await webhookDeliveriesDb.createDeliveryRecord({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      eventType: event.event,\r\n      url: config.url,\r\n      payload,\r\n      signature,\r\n      maxAttempts: WEBHOOK_CONFIG.maxAttempts,\r\n    });\r\n    \r\n    // Enqueue job in BullMQ (lazy import)\r\n    const enqueueWebhookDelivery = await getWebhookQueue();\r\n    if (enqueueWebhookDelivery) {\r\n      await enqueueWebhookDelivery({\r\n        webhookConfigId: config.id,\r\n        eventId: event.id,\r\n        eventType: event.event,\r\n        url: config.url,\r\n        payload,\r\n        signature,\r\n      });\r\n      \r\n      logger.info({\r\n        webhookConfigId: config.id,\r\n        eventId: event.id,\r\n        eventType: event.event,\r\n        url: config.url,\r\n        maxAttempts: WEBHOOK_CONFIG.maxAttempts,\r\n      }, 'Webhook queued for delivery');\r\n    } else {\r\n      // Fallback: deliver with retry logic inline\r\n      logger.warn({\r\n        webhookConfigId: config.id,\r\n        eventId: event.id,\r\n      }, 'Webhook queue not available, delivering with inline retry');\r\n      \r\n      await deliverWithRetry(config, event);\r\n    }\r\n  } catch (error) {\r\n    logger.error({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      error,\r\n    }, 'Failed to queue webhook delivery');\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Deliver webhook with retry logic (inline, without queue)\r\n */\r\nasync function deliverWithRetry(\r\n  config: WebhookConfig,\r\n  event: WebhookEvent\r\n): Promise<void> {\r\n  let attempt = 1;\r\n  \r\n  while (attempt <= WEBHOOK_CONFIG.maxAttempts) {\r\n    const result = await deliverWebhook(config, event, attempt);\r\n    \r\n    if (result.success) {\r\n      return;\r\n    }\r\n    \r\n    // Check if we should retry\r\n    if (!result.retryable || attempt >= WEBHOOK_CONFIG.maxAttempts) {\r\n      // No retry - check if should go to DLQ\r\n      if (WEBHOOK_CONFIG.enableDLQ) {\r\n        await sendToDeadLetterQueue(config, event, result.error || 'Unknown error', attempt);\r\n      }\r\n      \r\n      logger.error({\r\n        webhookConfigId: config.id,\r\n        eventId: event.id,\r\n        eventType: event.event,\r\n        attempts: attempt,\r\n        error: result.error,\r\n        sentToDLQ: WEBHOOK_CONFIG.enableDLQ,\r\n      }, 'Webhook delivery failed permanently');\r\n      \r\n      return;\r\n    }\r\n    \r\n    // Wait before retry\r\n    const delay = result.retryDelay || calculateRetryDelay(attempt - 1);\r\n    logger.info({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      attempt,\r\n      nextAttempt: attempt + 1,\r\n      delayMs: delay,\r\n    }, 'Scheduling webhook retry');\r\n    \r\n    await new Promise(resolve => setTimeout(resolve, delay));\r\n    attempt++;\r\n  }\r\n}\r\n\r\n/**\r\n * Send failed webhook to dead letter queue for manual review\r\n */\r\nasync function sendToDeadLetterQueue(\r\n  config: WebhookConfig,\r\n  event: WebhookEvent,\r\n  error: string,\r\n  attempts: number\r\n): Promise<void> {\r\n  metrics.dlqCount++;\r\n  \r\n  try {\r\n    await webhookDeliveriesDb.markDeliveryFailed({\r\n      eventId: event.id,\r\n      webhookConfigId: config.id,\r\n      error,\r\n      attempts,\r\n      sentToDLQ: true,\r\n    });\r\n    \r\n    logger.warn({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      eventType: event.event,\r\n      error,\r\n      attempts,\r\n    }, 'Webhook sent to dead letter queue');\r\n  } catch (dlqError) {\r\n    logger.error({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      dlqError,\r\n    }, 'Failed to send webhook to dead letter queue');\r\n  }\r\n}\r\n\r\n/**\r\n * Attempt webhook delivery with retry logic (used by BullMQ worker)\r\n */\r\nasync function attemptWebhookDelivery(\r\n  config: WebhookConfig,\r\n  event: WebhookEvent,\r\n  delivery: Omit<WebhookDelivery, 'id' | 'createdAt'>\r\n): Promise<void> {\r\n  delivery.attempts++;\r\n  const result = await deliverWebhook(config, event, delivery.attempts);\r\n  \r\n  delivery.lastAttemptAt = new Date().toISOString();\r\n  delivery.lastResponseCode = result.statusCode;\r\n  \r\n  if (result.success) {\r\n    delivery.status = 'delivered';\r\n    delivery.deliveredAt = new Date().toISOString();\r\n    \r\n    logger.info({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      attempts: delivery.attempts,\r\n    }, 'Webhook delivered');\r\n    \r\n    return;\r\n  }\r\n  \r\n  // Check if we should retry\r\n  const canRetry = result.retryable && delivery.attempts < delivery.maxAttempts;\r\n  \r\n  if (!canRetry) {\r\n    delivery.status = 'failed';\r\n    \r\n    // Send to DLQ if enabled\r\n    if (WEBHOOK_CONFIG.enableDLQ) {\r\n      await sendToDeadLetterQueue(config, event, result.error || 'Unknown error', delivery.attempts);\r\n    }\r\n    \r\n    logger.error({\r\n      webhookConfigId: config.id,\r\n      eventId: event.id,\r\n      attempts: delivery.attempts,\r\n      maxAttempts: delivery.maxAttempts,\r\n      error: result.error,\r\n      retryable: result.retryable,\r\n      sentToDLQ: WEBHOOK_CONFIG.enableDLQ,\r\n    }, 'Webhook delivery failed after max attempts');\r\n    \r\n    return;\r\n  }\r\n  \r\n  // Schedule retry\r\n  const retryDelay = result.retryDelay || calculateRetryDelay(delivery.attempts - 1);\r\n  delivery.nextRetryAt = new Date(Date.now() + retryDelay).toISOString();\r\n  delivery.status = 'pending';\r\n  \r\n  logger.info({\r\n    webhookConfigId: config.id,\r\n    eventId: event.id,\r\n    attempts: delivery.attempts,\r\n    maxAttempts: delivery.maxAttempts,\r\n    nextRetryAt: delivery.nextRetryAt,\r\n    retryDelayMs: retryDelay,\r\n  }, 'Webhook scheduled for retry');\r\n  \r\n  // Schedule retry (in production, BullMQ handles this)\r\n  setTimeout(async () => {\r\n    await attemptWebhookDelivery(config, event, delivery);\r\n  }, retryDelay);\r\n}\r\n\r\n/**\r\n * Get webhook configs for an event type\r\n */\r\nexport async function getWebhookConfigsForEvent(\r\n  eventType: WebhookEventType,\r\n  endpointId?: string\r\n): Promise<WebhookConfig[]> {\r\n  try {\r\n    const { getWebhookConfigs } = await import('./webhook-config-store');\r\n    const allConfigs = await getWebhookConfigs({\r\n      endpointId: endpointId || undefined,\r\n      enabled: true,\r\n    });\r\n    \r\n    return allConfigs.filter(config => {\r\n      if (!config.enabled) return false;\r\n      if (!config.events.includes(eventType)) return false;\r\n      if (endpointId && config.endpointId && config.endpointId !== endpointId) return false;\r\n      return true;\r\n    });\r\n  } catch (error) {\r\n    logger.error('Failed to get webhook configs', { eventType, endpointId, error });\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Trigger webhook for an event\r\n */\r\nexport async function triggerWebhook(\r\n  eventType: WebhookEventType,\r\n  data: Record<string, any>,\r\n  endpointId?: string\r\n): Promise<void> {\r\n  try {\r\n    const event = createWebhookEvent(eventType, data);\r\n    const configs = await getWebhookConfigsForEvent(eventType, endpointId);\r\n    \r\n    // Filter enabled configs\r\n    const enabledConfigs = configs.filter(c => c.enabled);\r\n    \r\n    // Filter by endpoint if specified\r\n    const relevantConfigs = endpointId\r\n      ? enabledConfigs.filter(c => !c.endpointId || c.endpointId === endpointId)\r\n      : enabledConfigs.filter(c => !c.endpointId);\r\n    \r\n    // Queue delivery for each config\r\n    for (const config of relevantConfigs) {\r\n      await queueWebhookDelivery(config, event);\r\n    }\r\n    \r\n    logger.info('Webhooks triggered', {\r\n      eventType,\r\n      endpointId,\r\n      configCount: relevantConfigs.length,\r\n    });\r\n  } catch (error) {\r\n    logger.error('Failed to trigger webhook', {\r\n      eventType,\r\n      endpointId,\r\n      error,\r\n    });\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}