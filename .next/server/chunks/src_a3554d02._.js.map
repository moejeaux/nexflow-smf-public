{"version":3,"sources":["../../../src/db/smf.ts","../../../src/integrations/x402/facilitators/base-facilitator.ts","../../../src/services/facilitator-metrics-reader.ts"],"sourcesContent":["// =============================================================================\r\n// SMF DATABASE OPERATIONS\r\n// =============================================================================\r\n// Database operations for Smart Meta-Facilitator routing, attempts, and health\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'SMFDatabase' });\r\n\r\nexport interface Facilitator {\r\n  id: string;\r\n  name: string;\r\n  status: 'active' | 'disabled' | 'testing';\r\n  base_url: string;\r\n  priority: number;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface FacilitatorCapability {\r\n  id: string;\r\n  facilitator_id: string;\r\n  network: string;\r\n  token: string;\r\n  min_amount: string;\r\n  max_amount: string | null;\r\n  fee_bps: number;\r\n  regions: string[] | null;\r\n  supports_deferred: boolean;\r\n  supports_subscriptions: boolean;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface Route {\r\n  id: string;\r\n  request_id: string | null;\r\n  correlation_id: string | null;\r\n  client_id: string | null;\r\n  agent_id: string | null;\r\n  network: string;\r\n  token: string;\r\n  amount: string;\r\n  selected_facilitator_id: string;\r\n  status: 'planned' | 'verifying' | 'settling' | 'settled' | 'failed';\r\n  created_at: string;\r\n  updated_at: string;\r\n  completed_at: string | null;\r\n}\r\n\r\nexport interface RouteAttempt {\r\n  id: string;\r\n  route_id: string;\r\n  facilitator_id: string;\r\n  phase: 'verify' | 'settle';\r\n  result: 'success' | 'failure' | 'timeout' | 'rate_limited' | 'insufficient_liquidity' | 'invalid_request' | 'network_error';\r\n  latency_ms: number;\r\n  error_code: string | null;\r\n  raw_status: number | null;\r\n  is_probe: boolean;\r\n  created_at: string;\r\n}\r\n\r\nexport interface FacilitatorHealthSnapshot {\r\n  id: string;\r\n  facilitator_id: string;\r\n  network: string;\r\n  token: string;\r\n  window_start: string;\r\n  window_end: string;\r\n  success_rate: number;\r\n  p50_latency_ms: number | null;\r\n  p95_latency_ms: number | null;\r\n  p99_latency_ms: number | null;\r\n  error_rate: number;\r\n  last_error_type: string | null;\r\n  status: 'healthy' | 'degraded' | 'down';\r\n  created_at: string;\r\n}\r\n\r\n/**\r\n * Create a route record\r\n */\r\nexport async function createRoute(route: Omit<Route, 'id' | 'created_at' | 'updated_at' | 'completed_at'>): Promise<Route> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO routes (\r\n        id, request_id, correlation_id, client_id, agent_id, network, token, amount,\r\n        selected_facilitator_id, status, created_at, updated_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        route.request_id,\r\n        route.correlation_id,\r\n        route.client_id,\r\n        route.agent_id,\r\n        route.network,\r\n        route.token,\r\n        route.amount,\r\n        route.selected_facilitator_id,\r\n        route.status,\r\n        now,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO routes (\r\n        id, request_id, correlation_id, client_id, agent_id, network, token, amount,\r\n        selected_facilitator_id, status, created_at, updated_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      route.request_id,\r\n      route.correlation_id,\r\n      route.client_id,\r\n      route.agent_id,\r\n      route.network,\r\n      route.token,\r\n      route.amount,\r\n      route.selected_facilitator_id,\r\n      route.status,\r\n      now,\r\n      now\r\n    );\r\n    return {\r\n      id,\r\n      ...route,\r\n      created_at: now,\r\n      updated_at: now,\r\n      completed_at: null,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update route status\r\n */\r\nexport async function updateRouteStatus(\r\n  routeId: string,\r\n  status: Route['status'],\r\n  completedAt?: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `UPDATE routes SET status = $1, updated_at = $2, completed_at = $3 WHERE id = $4`,\r\n      [status, now, completedAt || null, routeId]\r\n    );\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(\r\n      `UPDATE routes SET status = ?, updated_at = ?, completed_at = ? WHERE id = ?`\r\n    );\r\n    stmt.run(status, now, completedAt || null, routeId);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a route attempt record\r\n */\r\nexport async function createRouteAttempt(\r\n  attempt: Omit<RouteAttempt, 'id' | 'created_at'>\r\n): Promise<RouteAttempt> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO route_attempts (\r\n        id, route_id, facilitator_id, phase, result, latency_ms, error_code, raw_status, is_probe, created_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        attempt.route_id,\r\n        attempt.facilitator_id,\r\n        attempt.phase,\r\n        attempt.result,\r\n        attempt.latency_ms,\r\n        attempt.error_code,\r\n        attempt.raw_status,\r\n        attempt.is_probe ?? false,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO route_attempts (\r\n        id, route_id, facilitator_id, phase, result, latency_ms, error_code, raw_status, is_probe, created_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      attempt.route_id,\r\n      attempt.facilitator_id,\r\n      attempt.phase,\r\n      attempt.result,\r\n      attempt.latency_ms,\r\n      attempt.error_code,\r\n      attempt.raw_status,\r\n      attempt.is_probe ?? false,\r\n      now\r\n    );\r\n    return {\r\n      id,\r\n      ...attempt,\r\n      created_at: now,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get facilitator capabilities\r\n */\r\nexport async function getFacilitatorCapabilities(\r\n  facilitatorId?: string,\r\n  network?: string,\r\n  token?: string\r\n): Promise<FacilitatorCapability[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let query = 'SELECT * FROM facilitator_capabilities WHERE 1=1';\r\n  const params: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (facilitatorId) {\r\n    if (isPostgres) {\r\n      query += ` AND facilitator_id = $${paramIndex++}`;\r\n      params.push(facilitatorId);\r\n    } else {\r\n      query += ` AND facilitator_id = ?`;\r\n      params.push(facilitatorId);\r\n    }\r\n  }\r\n\r\n  if (network) {\r\n    if (isPostgres) {\r\n      query += ` AND network = $${paramIndex++}`;\r\n      params.push(network);\r\n    } else {\r\n      query += ` AND network = ?`;\r\n      params.push(network);\r\n    }\r\n  }\r\n\r\n  if (token) {\r\n    if (isPostgres) {\r\n      query += ` AND token = $${paramIndex++}`;\r\n      params.push(token);\r\n    } else {\r\n      query += ` AND token = ?`;\r\n      params.push(token);\r\n    }\r\n  }\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, params);\r\n    return result.rows;\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(query);\r\n    const rows = stmt.all(...params);\r\n    return rows;\r\n  }\r\n}\r\n\r\n/**\r\n * Get latest health snapshot for a facilitator/network/token\r\n */\r\nexport async function getLatestHealthSnapshot(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string\r\n): Promise<FacilitatorHealthSnapshot | null> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_health_snapshots\r\n       WHERE facilitator_id = $1 AND network = $2 AND token = $3\r\n       ORDER BY window_end DESC\r\n       LIMIT 1`,\r\n      [facilitatorId, network, token]\r\n    );\r\n    return result.rows[0] || null;\r\n  } else {\r\n    // SQLite\r\n    const stmt = (db as any).prepare(\r\n      `SELECT * FROM facilitator_health_snapshots\r\n       WHERE facilitator_id = ? AND network = ? AND token = ?\r\n       ORDER BY window_end DESC\r\n       LIMIT 1`\r\n    );\r\n    const row = stmt.get(facilitatorId, network, token);\r\n    return row || null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get route attempts for health aggregation\r\n */\r\nexport async function getRouteAttemptsForHealth(\r\n  facilitatorId: string,\r\n  network: string,\r\n  token: string,\r\n  windowStart: string,\r\n  windowEnd: string,\r\n  includeProbes: boolean = true\r\n): Promise<RouteAttempt[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  // Build probe route_id pattern for matching\r\n  const probePattern = `probe-${facilitatorId}-${network}-${token}%`;\r\n\r\n  if (isPostgres) {\r\n    // For probes, route_id starts with \"probe-{facilitatorId}-{network}-{token}\"\r\n    // For real routes, we join with routes table\r\n    // Note: Cast route_id to TEXT for LIKE comparison (UUID doesn't support LIKE directly)\r\n    const result = await (db as any).pool.query(\r\n      `SELECT ra.* FROM route_attempts ra\r\n       LEFT JOIN routes r ON (ra.route_id::text = r.id::text AND ra.is_probe = false)\r\n       WHERE ra.facilitator_id = $1\r\n         AND (\r\n           (ra.is_probe = true AND ra.route_id::text LIKE $2)\r\n           OR (ra.is_probe = false AND r.network = $3 AND r.token = $4)\r\n         )\r\n         AND ra.created_at >= $5\r\n         AND ra.created_at < $6\r\n       ORDER BY ra.created_at`,\r\n      [facilitatorId, probePattern, network, token, windowStart, windowEnd]\r\n    );\r\n    return result.rows;\r\n  } else {\r\n    // SQLite - similar logic\r\n    const stmt = (db as any).prepare(\r\n      `SELECT ra.* FROM route_attempts ra\r\n       LEFT JOIN routes r ON (ra.route_id = r.id AND ra.is_probe = 0)\r\n       WHERE ra.facilitator_id = ?\r\n         AND (\r\n           (ra.is_probe = 1 AND ra.route_id LIKE ?)\r\n           OR (ra.is_probe = 0 AND r.network = ? AND r.token = ?)\r\n         )\r\n         AND ra.created_at >= ?\r\n         AND ra.created_at < ?\r\n       ORDER BY ra.created_at`\r\n    );\r\n    const rows = stmt.all(facilitatorId, probePattern, network, token, windowStart, windowEnd);\r\n    return rows;\r\n  }\r\n}\r\n\r\n/**\r\n * Create or update health snapshot\r\n */\r\nexport async function upsertHealthSnapshot(\r\n  snapshot: Omit<FacilitatorHealthSnapshot, 'id' | 'created_at'>\r\n): Promise<FacilitatorHealthSnapshot> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const now = new Date().toISOString();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    // Use ON CONFLICT for upsert\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO facilitator_health_snapshots (\r\n        id, facilitator_id, network, token, window_start, window_end,\r\n        success_rate, p50_latency_ms, p95_latency_ms, p99_latency_ms,\r\n        error_rate, last_error_type, status, created_at\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\r\n      ON CONFLICT (facilitator_id, network, token, window_end)\r\n      DO UPDATE SET\r\n        success_rate = EXCLUDED.success_rate,\r\n        p50_latency_ms = EXCLUDED.p50_latency_ms,\r\n        p95_latency_ms = EXCLUDED.p95_latency_ms,\r\n        p99_latency_ms = EXCLUDED.p99_latency_ms,\r\n        error_rate = EXCLUDED.error_rate,\r\n        last_error_type = EXCLUDED.last_error_type,\r\n        status = EXCLUDED.status\r\n      RETURNING *`,\r\n      [\r\n        id,\r\n        snapshot.facilitator_id,\r\n        snapshot.network,\r\n        snapshot.token,\r\n        snapshot.window_start,\r\n        snapshot.window_end,\r\n        snapshot.success_rate,\r\n        snapshot.p50_latency_ms,\r\n        snapshot.p95_latency_ms,\r\n        snapshot.p99_latency_ms,\r\n        snapshot.error_rate,\r\n        snapshot.last_error_type,\r\n        snapshot.status,\r\n        now,\r\n      ]\r\n    );\r\n    return result.rows[0];\r\n  } else {\r\n    // SQLite - simple insert (no upsert for now)\r\n    const stmt = (db as any).prepare(`\r\n      INSERT INTO facilitator_health_snapshots (\r\n        id, facilitator_id, network, token, window_start, window_end,\r\n        success_rate, p50_latency_ms, p95_latency_ms, p99_latency_ms,\r\n        error_rate, last_error_type, status, created_at\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      snapshot.facilitator_id,\r\n      snapshot.network,\r\n      snapshot.token,\r\n      snapshot.window_start,\r\n      snapshot.window_end,\r\n      snapshot.success_rate,\r\n      snapshot.p50_latency_ms,\r\n      snapshot.p95_latency_ms,\r\n      snapshot.p99_latency_ms,\r\n      snapshot.error_rate,\r\n      snapshot.last_error_type,\r\n      snapshot.status,\r\n      now\r\n    );\r\n    return {\r\n      id,\r\n      ...snapshot,\r\n      created_at: now,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Record facilitator probe event arguments\r\n */\r\nexport interface RecordFacilitatorProbeEventArgs {\r\n  probe_config_id: string;\r\n  facilitator_id: string;\r\n  network: string;\r\n  token: string;\r\n  result: 'success' | 'failure';\r\n  error_code: string | null;\r\n  facilitator_status: number | null;\r\n  facilitator_error_code: string | null;\r\n  latency_ms: number;\r\n}\r\n\r\n/**\r\n * Record a facilitator probe event for analytics\r\n */\r\nexport async function recordFacilitatorProbeEvent(event: RecordFacilitatorProbeEventArgs): Promise<void> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `INSERT INTO facilitator_probe_events (\r\n        probe_config_id, facilitator_id, network, token, result,\r\n        error_code, facilitator_status, facilitator_error_code, latency_ms\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,\r\n      [\r\n        event.probe_config_id,\r\n        event.facilitator_id,\r\n        event.network,\r\n        event.token,\r\n        event.result,\r\n        event.error_code,\r\n        event.facilitator_status,\r\n        event.facilitator_error_code,\r\n        event.latency_ms,\r\n      ]\r\n    );\r\n  } else {\r\n    // SQLite - table might not exist, skip silently\r\n    logger.warn('facilitator_probe_events table not available in SQLite');\r\n  }\r\n}\r\n\r\n","// =============================================================================\n// FACILITATOR ABSTRACTION LAYER\n// =============================================================================\n// Base interface and types for pluggable x402 facilitators\n// Enables multi-facilitator orchestration and routing\n\nimport { createLogger } from '@/lib/logger';\n\nconst logger = createLogger({ component: 'BaseFacilitator' });\n\n/**\n * CAIP-2 Network Identifier (e.g., \"eip155:8453\" for Base)\n * CAIP-19 Asset Identifier (e.g., \"eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\" for USDC on Base)\n */\nexport type CAIPNetworkId = string; // e.g., \"eip155:8453\", \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\", \"bip122:000000000019d6689c085ae165831e93\"\nexport type CAIPAssetId = string; // e.g., \"eip155:8453/erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\"\n\n/**\n * Settlement mode for payments\n */\nexport type SettlementMode = 'immediate' | 'deferred' | 'batch';\n\n/**\n * Payment requirements for x402 payment verification\n * Extended to support CAIP identifiers and settlement modes\n */\nexport interface PaymentRequirements {\n  scheme: string; // 'exact', 'x402', etc.\n  network: string; // Legacy: 'base', 'ethereum', 'solana', etc.\n  networks?: CAIPNetworkId[]; // CAIP-2 network identifiers (multi-network support)\n  maxAmountRequired: string; // Amount in smallest units\n  resource: string; // Resource URL\n  description?: string;\n  mimeType?: string;\n  payTo: string; // Recipient address\n  maxTimeoutSeconds?: number;\n  asset: string; // Legacy: Token address\n  assets?: CAIPAssetId[]; // CAIP-19 asset identifiers (multi-asset support)\n  settlementMode?: SettlementMode; // 'immediate', 'deferred', or 'batch'\n}\n\n/**\n * Payment verification result\n */\nexport interface VerificationResult {\n  success: boolean;\n  valid: boolean;\n  transactionHash?: string;\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\n  error?: string;\n  errorDetails?: Record<string, any>;\n  facilitatorId: string; // Which facilitator verified this\n  verifiedAt: string; // ISO timestamp\n}\n\n/**\n * Facilitator health status\n */\nexport interface FacilitatorHealth {\n  healthy: boolean;\n  latency?: number; // ms\n  lastChecked: string; // ISO timestamp\n  error?: string;\n  capabilities: {\n    networks: string[];\n    assets: string[];\n    schemes: string[];\n  };\n}\n\n/**\n * Pricing information for a facilitator\n */\nexport interface PricingInfo {\n  network: string;\n  asset: string;\n  baseFee?: string; // Base fee in smallest units\n  percentageFee?: number; // Percentage fee (0-1)\n  estimatedGas?: string; // Estimated gas cost\n  currency: string; // Fee currency\n}\n\n/**\n * Facilitator configuration\n */\nexport interface FacilitatorConfig {\n  id: string;\n  name: string;\n  enabled: boolean;\n  priority: number; // Lower = higher priority\n  networks: string[]; // Legacy: Supported networks\n  networksCAIP?: CAIPNetworkId[]; // CAIP-2 network identifiers\n  assets: string[]; // Legacy: Supported assets\n  assetsCAIP?: CAIPAssetId[]; // CAIP-19 asset identifiers\n  schemes: string[]; // Supported schemes ('exact', 'x402', etc.)\n  settlementModes?: SettlementMode[]; // Supported settlement modes\n  healthCheckUrl?: string;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Base facilitator interface\n * All facilitators must implement this interface\n */\nexport interface IFacilitator {\n  /**\n   * Unique identifier for this facilitator\n   */\n  readonly id: string;\n\n  /**\n   * Human-readable name\n   */\n  readonly name: string;\n\n  /**\n   * Facilitator configuration\n   */\n  readonly config: FacilitatorConfig;\n\n  /**\n   * Verify an x402 payment\n   */\n  verify(\n    payment: string,\n    requirements: PaymentRequirements\n  ): Promise<VerificationResult>;\n\n  /**\n   * Check facilitator health\n   */\n  getHealth(): Promise<FacilitatorHealth>;\n\n  /**\n   * Get pricing information for a network/asset combination\n   */\n  getPricing(network: string, asset: string): Promise<PricingInfo | null>;\n\n  /**\n   * Check if facilitator supports a given network/asset/scheme\n   * Extended to support settlement modes\n   */\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean;\n\n  /**\n   * Check if facilitator supports a CAIP-2 network identifier\n   */\n  supportsCAIPNetwork(caip: CAIPNetworkId): boolean;\n\n  /**\n   * Check if facilitator supports a CAIP-19 asset identifier\n   */\n  supportsCAIPAsset(caip: CAIPAssetId): boolean;\n}\n\n/**\n * Base facilitator class with common functionality\n */\nexport abstract class BaseFacilitator implements IFacilitator {\n  abstract readonly id: string;\n  abstract readonly name: string;\n  abstract readonly config: FacilitatorConfig;\n\n  protected getLogger() {\n    return logger.child({ facilitator: this.constructor.name });\n  }\n\n  /**\n   * Verify payment (must be implemented by subclasses)\n   */\n  abstract verify(\n    payment: string,\n    requirements: PaymentRequirements\n  ): Promise<VerificationResult>;\n\n  /**\n   * Get health status (must be implemented by subclasses)\n   */\n  abstract getHealth(): Promise<FacilitatorHealth>;\n\n  /**\n   * Get pricing (default implementation returns null)\n   */\n  async getPricing(network: string, asset: string): Promise<PricingInfo | null> {\n    // Default: no pricing info available\n    return null;\n  }\n\n  /**\n   * Check if facilitator supports network/asset/scheme\n   * Enhanced to support both legacy and CAIP identifiers\n   */\n  supports(network: string, asset: string, scheme: string, settlementMode?: SettlementMode): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n\n    // Check scheme support\n    if (!this.config.schemes.includes(scheme)) {\n      return false;\n    }\n\n    // Check settlement mode support\n    if (settlementMode && this.config.settlementModes && !this.config.settlementModes.includes(settlementMode)) {\n      return false;\n    }\n\n    // Check network support (legacy or CAIP)\n    const supportsNetwork = \n      this.config.networks.includes(network) ||\n      (this.config.networksCAIP && this.config.networksCAIP.includes(network as CAIPNetworkId));\n\n    if (!supportsNetwork) {\n      return false;\n    }\n\n    // Check asset support (legacy or CAIP)\n    const supportsAsset = \n      this.config.assets.includes(asset) ||\n      (this.config.assetsCAIP && this.config.assetsCAIP.includes(asset as CAIPAssetId));\n\n    return supportsAsset;\n  }\n\n  /**\n   * Check if facilitator supports a CAIP-2 network identifier\n   */\n  supportsCAIPNetwork(caip: CAIPNetworkId): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n    return this.config.networksCAIP?.includes(caip) || false;\n  }\n\n  /**\n   * Check if facilitator supports a CAIP-19 asset identifier\n   */\n  supportsCAIPAsset(caip: CAIPAssetId): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n    return this.config.assetsCAIP?.includes(caip) || false;\n  }\n\n  /**\n   * Validate payment requirements\n   * Enhanced to support CAIP identifiers\n   */\n  protected validateRequirements(\n    requirements: PaymentRequirements\n  ): { valid: boolean; error?: string } {\n    // Check network (legacy or CAIP)\n    const hasNetwork = \n      !!requirements.network || \n      (requirements.networks && requirements.networks.length > 0);\n    \n    if (!hasNetwork) {\n      return { valid: false, error: 'Network is required' };\n    }\n\n    // Check asset (legacy or CAIP)\n    const hasAsset = \n      !!requirements.asset || \n      (requirements.assets && requirements.assets.length > 0);\n    \n    if (!hasAsset) {\n      return { valid: false, error: 'Asset is required' };\n    }\n\n    if (!requirements.payTo) {\n      return { valid: false, error: 'Recipient address (payTo) is required' };\n    }\n    if (!requirements.maxAmountRequired) {\n      return { valid: false, error: 'Amount is required' };\n    }\n\n    // Check support (use legacy network/asset for supports() check, or check CAIP directly)\n    const networkToCheck = requirements.network || (requirements.networks?.[0] || '');\n    const assetToCheck = requirements.asset || (requirements.assets?.[0] || '');\n    \n    // Check CAIP support if CAIP identifiers are provided\n    if (requirements.networks && requirements.networks.length > 0) {\n      const supportsAnyNetwork = requirements.networks.some((n) => \n        this.supportsCAIPNetwork(n) || this.config.networks.includes(n)\n      );\n      if (!supportsAnyNetwork) {\n        return {\n          valid: false,\n          error: `Facilitator ${this.id} does not support any of the requested networks: ${requirements.networks.join(', ')}`,\n        };\n      }\n    }\n\n    if (requirements.assets && requirements.assets.length > 0) {\n      const supportsAnyAsset = requirements.assets.some((a) => \n        this.supportsCAIPAsset(a) || this.config.assets.includes(a)\n      );\n      if (!supportsAnyAsset) {\n        return {\n          valid: false,\n          error: `Facilitator ${this.id} does not support any of the requested assets: ${requirements.assets.join(', ')}`,\n        };\n      }\n    }\n\n    // Check legacy support\n    if (!this.supports(networkToCheck, assetToCheck, requirements.scheme, requirements.settlementMode)) {\n      return {\n        valid: false,\n        error: `Facilitator ${this.id} does not support ${networkToCheck}/${assetToCheck}/${requirements.scheme}`,\n      };\n    }\n    return { valid: true };\n  }\n}\n\n","// =============================================================================\n// FACILITATOR METRICS READER\n// =============================================================================\n// Read-side helper for SMF to access facilitator path metrics\n// Used by the SMF router to inform routing decisions\n//\n// Scoring blends two data sources:\n// 1. x402scan: Observability metrics (success rate, latency, confidence)\n// 2. Scattering: Activity metrics (volume, tx count, unique buyers)\n\nimport { createLogger } from '@/lib/logger';\nimport {\n  type FacilitatorPathMetrics,\n  type FacilitatorSummary,\n  type FacilitatorPathMetricsTimeframe,\n} from '@/infra/x402scan/types';\nimport {\n  loadAllMetrics,\n  loadAllSummaries,\n  getSummary,\n  getMetricsForFacilitator,\n} from './facilitator-metrics-service';\nimport {\n  getScatteringMetricsForFacilitator,\n  computeActivityScore,\n} from './facilitator-volume-service';\nimport type { ScatteringFacilitatorMetrics } from '@/infra/scattering/types';\n\nconst logger = createLogger({ component: 'FacilitatorMetricsReader' });\n\n// =============================================================================\n// FRESHNESS & CONFIDENCE CONFIGURATION\n// =============================================================================\n\n/**\n * Configuration for determining when metrics are trustworthy\n * These thresholds prevent routing decisions based on stale or thin data\n */\nexport interface MetricsTrustConfig {\n  /** Maximum age of data to trust (hours) */\n  maxDataAgeHours: number;\n  /** Minimum invocations for high confidence scoring */\n  minInvocationsHighConfidence: number;\n  /** Minimum invocations to use data at all */\n  minInvocationsMinimum: number;\n  /** Penalty multiplier for low confidence data (0-1) */\n  lowConfidencePenalty: number;\n}\n\n/**\n * Default trust configuration\n * Can be overridden via environment variables\n */\nexport const DEFAULT_TRUST_CONFIG: MetricsTrustConfig = {\n  maxDataAgeHours: parseFloat(process.env.METRICS_MAX_AGE_HOURS ?? '4'),\n  minInvocationsHighConfidence: parseInt(process.env.METRICS_MIN_INVOCATIONS_HIGH ?? '1000', 10),\n  minInvocationsMinimum: parseInt(process.env.METRICS_MIN_INVOCATIONS ?? '100', 10),\n  lowConfidencePenalty: parseFloat(process.env.METRICS_LOW_CONFIDENCE_PENALTY ?? '0.5'),\n};\n\n/**\n * Check if metrics should be trusted for routing decisions\n */\nexport function shouldTrustMetrics(\n  dataAgeHours: number,\n  invocations: number,\n  config: MetricsTrustConfig = DEFAULT_TRUST_CONFIG\n): { trust: boolean; confidence: 'high' | 'medium' | 'low' | 'none'; reason: string } {\n  // Data too old\n  if (dataAgeHours > config.maxDataAgeHours) {\n    return {\n      trust: false,\n      confidence: 'none',\n      reason: `data-stale:${dataAgeHours.toFixed(1)}h-old`,\n    };\n  }\n\n  // Not enough data\n  if (invocations < config.minInvocationsMinimum) {\n    return {\n      trust: false,\n      confidence: 'none',\n      reason: `insufficient-data:${invocations}-invocations`,\n    };\n  }\n\n  // High confidence\n  if (invocations >= config.minInvocationsHighConfidence) {\n    return {\n      trust: true,\n      confidence: 'high',\n      reason: `high-confidence:${invocations}-invocations`,\n    };\n  }\n\n  // Medium confidence\n  return {\n    trust: true,\n    confidence: 'medium',\n    reason: `medium-confidence:${invocations}-invocations`,\n  };\n}\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface GetBestPathsParams {\n  /** Facilitator ID (NexFlow format, e.g., \"cdp\", \"payai\") */\n  facilitatorId: string;\n  \n  /** Network filter (optional) */\n  network?: string;\n  \n  /** Timeframe to consider (default: \"1d\") */\n  timeframe?: FacilitatorPathMetricsTimeframe;\n  \n  /** Maximum number of results */\n  limit?: number;\n}\n\nexport interface FacilitatorScoreParams {\n  /** Facilitator ID */\n  facilitatorId: string;\n  \n  /** Timeframe to consider */\n  timeframe?: FacilitatorPathMetricsTimeframe;\n}\n\nexport interface FacilitatorScore {\n  facilitatorId: string;\n  score: number;             // 0-100, higher is better\n  successRate: number;       // 0-1\n  avgLatencyMs?: number;\n  p95LatencyMs?: number;\n  totalInvocations: number;\n  dataFreshness: number;     // hours since last data\n  confidence: 'high' | 'medium' | 'low' | 'none';  // based on data availability\n  reasons: string[];\n  // Scattering activity metrics\n  scatteringActivityScore?: number;    // 0-1 activity score from Scattering\n  scatteringVolume3d?: number;         // 3-day volume in USD\n  scatteringTxCount3d?: number;        // 3-day transaction count\n  scatteringUniqueBuyers3d?: number;   // 3-day unique buyers\n  scatteringLowActivity?: boolean;     // true if below thresholds\n}\n\nexport interface FacilitatorRanking {\n  rankings: FacilitatorScore[];\n  timestamp: string;\n  timeframe: FacilitatorPathMetricsTimeframe;\n}\n\n// =============================================================================\n// SCORING WEIGHTS & CONFIGURATION\n// =============================================================================\n\n/**\n * Scattering score weight (0-1)\n * Controls how much Scattering activity metrics influence the final score\n * Default: 0.2 (20%) - configurable via SCATTERING_SCORE_WEIGHT env var\n */\nconst SCATTERING_SCORE_WEIGHT = parseFloat(process.env.SCATTERING_SCORE_WEIGHT ?? '0.2');\n\n/**\n * Minimum thresholds for Scattering data to be considered meaningful\n * Below these thresholds, activity is flagged as \"low\" and doesn't boost score\n */\nconst SCATTERING_MIN_TX_COUNT_3D = parseInt(process.env.SCATTERING_MIN_TX_COUNT ?? '100', 10);\nconst SCATTERING_MIN_VOLUME_USD_3D = parseFloat(process.env.SCATTERING_MIN_VOLUME ?? '100');\n\n/**\n * x402scan score weight (the remainder after Scattering)\n * x402scan measures reliability (success rate, latency, confidence)\n */\nconst X402SCAN_SCORE_WEIGHT = 1 - SCATTERING_SCORE_WEIGHT;\n\n/**\n * Internal weights for x402scan sub-components\n * These are applied to the x402scan portion of the score\n */\nconst SCORING_WEIGHTS = {\n  successRate: 50,     // 50% weight on success rate\n  latency: 30,         // 30% weight on latency\n  volume: 10,          // 10% weight on volume (more volume = more confidence)\n  freshness: 10,       // 10% weight on data freshness\n};\n\n// =============================================================================\n// QUERY FUNCTIONS\n// =============================================================================\n\n/**\n * Get best performing facilitator paths\n * Sorted by success rate, then by latency\n */\nexport async function getBestFacilitatorPaths(\n  params: GetBestPathsParams\n): Promise<FacilitatorPathMetrics[]> {\n  const timeframe = params.timeframe ?? '1d';\n  const limit = params.limit ?? 10;\n\n  try {\n    const metrics = await getMetricsForFacilitator(params.facilitatorId, timeframe);\n\n    if (metrics.length === 0) {\n      logger.debug({\n        facilitatorId: params.facilitatorId,\n        timeframe,\n        msg: 'No metrics found for facilitator',\n      });\n      return [];\n    }\n\n    // Sort by success rate (descending), then by latency (ascending)\n    const sorted = [...metrics].sort((a, b) => {\n      // Primary: higher success rate is better\n      const successRateDiff = (1 - b.errorRate) - (1 - a.errorRate);\n      if (Math.abs(successRateDiff) > 0.01) {\n        return successRateDiff > 0 ? 1 : -1;\n      }\n\n      // Secondary: lower latency is better\n      const aLatency = a.p95LatencyMs ?? a.avgLatencyMs ?? Infinity;\n      const bLatency = b.p95LatencyMs ?? b.avgLatencyMs ?? Infinity;\n      return aLatency - bLatency;\n    });\n\n    return sorted.slice(0, limit);\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId: params.facilitatorId,\n      msg: 'Failed to get best facilitator paths',\n    });\n    return [];\n  }\n}\n\n/**\n * Calculate a composite score for a facilitator blending:\n * 1. x402scan: reliability metrics (success rate, latency, confidence)\n * 2. Scattering: activity metrics (volume, tx count, unique buyers)\n * \n * Score is 0-100, higher is better\n * \n * The blend is controlled by SCATTERING_SCORE_WEIGHT (default 0.2):\n * - x402scan contributes (1 - SCATTERING_SCORE_WEIGHT) * x402scanScore\n * - Scattering contributes SCATTERING_SCORE_WEIGHT * scatteringScore\n */\nexport async function getFacilitatorScore(\n  params: FacilitatorScoreParams\n): Promise<FacilitatorScore | null> {\n  const timeframe = params.timeframe ?? '1d';\n  const reasons: string[] = [];\n\n  try {\n    // ==========================================================================\n    // PART 1: x402scan reliability metrics\n    // ==========================================================================\n    const summary = await getSummary(params.facilitatorId, timeframe);\n    \n    let x402scanScore = 50; // Default neutral\n    let successRate = 0;\n    let hoursOld = Infinity;\n    let totalInvocations = 0;\n    let avgLatencyMs: number | undefined;\n    let p95LatencyMs: number | undefined;\n    let hasX402scanData = false;\n\n    if (summary) {\n      hasX402scanData = true;\n      \n      // Calculate success rate score (0-50)\n      successRate = 1 - summary.overallErrorRate;\n      const successRateScore = successRate * SCORING_WEIGHTS.successRate;\n      reasons.push(`success-rate:${(successRate * 100).toFixed(1)}%`);\n\n      // Calculate latency score (0-30)\n      let latencyScore = SCORING_WEIGHTS.latency;\n      const p95 = summary.avgP90LatencyMs ?? summary.avgP99LatencyMs;\n      if (p95 !== undefined) {\n        const normalizedLatency = Math.min(p95, 2000) / 2000;\n        latencyScore = (1 - normalizedLatency) * SCORING_WEIGHTS.latency;\n        reasons.push(`p95-latency:${p95.toFixed(0)}ms`);\n        p95LatencyMs = summary.avgP90LatencyMs;\n      } else {\n        latencyScore = SCORING_WEIGHTS.latency * 0.5;\n        reasons.push('latency:unknown');\n      }\n\n      // Calculate volume score (0-10)\n      const volumeThreshold = 1000;\n      const volumeRatio = Math.min(summary.totalInvocations / volumeThreshold, 1);\n      const volumeScore = volumeRatio * SCORING_WEIGHTS.volume;\n      totalInvocations = summary.totalInvocations;\n      reasons.push(`x402scan:${summary.totalInvocations}/${summary.totalInvocations >= 1000 ? 'high' : summary.totalInvocations >= 100 ? 'medium' : 'low'}-confidence`);\n\n      // Calculate freshness score (0-10)\n      const fetchedAt = new Date(summary.fetchedAt);\n      hoursOld = (Date.now() - fetchedAt.getTime()) / (1000 * 60 * 60);\n      const freshnessRatio = Math.max(0, 1 - hoursOld / 24);\n      const freshnessScore = freshnessRatio * SCORING_WEIGHTS.freshness;\n\n      x402scanScore = successRateScore + latencyScore + volumeScore + freshnessScore;\n      avgLatencyMs = summary.avgP50LatencyMs;\n    } else {\n      reasons.push('x402scan:no-data');\n    }\n\n    // ==========================================================================\n    // PART 2: Scattering activity metrics\n    // ==========================================================================\n    let scatteringActivityScore = 0;\n    let scatteringVolume3d: number | undefined;\n    let scatteringTxCount3d: number | undefined;\n    let scatteringUniqueBuyers3d: number | undefined;\n    let scatteringLowActivity = false;\n    let hasScatteringData = false;\n\n    try {\n      const scattering = await getScatteringMetricsForFacilitator(params.facilitatorId);\n      \n      if (scattering) {\n        hasScatteringData = true;\n        scatteringVolume3d = scattering.volumeUsd3d;\n        scatteringTxCount3d = scattering.txCount3d;\n        scatteringUniqueBuyers3d = scattering.uniqueBuyers3d;\n\n        // Check for low activity guardrail\n        const isLowActivity = \n          scattering.txCount3d < SCATTERING_MIN_TX_COUNT_3D &&\n          scattering.volumeUsd3d < SCATTERING_MIN_VOLUME_USD_3D;\n\n        if (isLowActivity) {\n          scatteringLowActivity = true;\n          scatteringActivityScore = 0.1; // Minimal score for low activity\n          reasons.push(`scattering-low-activity:${scattering.txCount3d}tx/$${scattering.volumeUsd3d.toFixed(0)}`);\n        } else {\n          // Compute normalized activity score (0-1)\n          scatteringActivityScore = computeActivityScore(scattering);\n          reasons.push(`scattering-activity:${scatteringActivityScore.toFixed(2)}`);\n        }\n      } else {\n        reasons.push('scattering:no-data');\n      }\n    } catch (error) {\n      logger.debug({\n        error: error instanceof Error ? error.message : 'Unknown',\n        facilitatorId: params.facilitatorId,\n        msg: 'Failed to fetch Scattering metrics for scoring',\n      });\n      reasons.push('scattering:error');\n    }\n\n    // ==========================================================================\n    // PART 3: Blend x402scan and Scattering scores\n    // ==========================================================================\n    let finalScore: number;\n    \n    if (hasX402scanData && hasScatteringData) {\n      // Both sources available - blend according to weights\n      // x402scan score is 0-100, Scattering score is 0-1 (convert to 0-100)\n      finalScore = (X402SCAN_SCORE_WEIGHT * x402scanScore) + \n                   (SCATTERING_SCORE_WEIGHT * scatteringActivityScore * 100);\n    } else if (hasX402scanData) {\n      // Only x402scan - use full weight\n      finalScore = x402scanScore;\n    } else if (hasScatteringData) {\n      // Only Scattering - convert to 0-100 scale\n      finalScore = scatteringActivityScore * 100;\n    } else {\n      // No data - neutral score\n      finalScore = 50;\n    }\n\n    // ==========================================================================\n    // PART 4: Determine confidence level\n    // ==========================================================================\n    let confidence: 'high' | 'medium' | 'low' | 'none' = 'none';\n    \n    if (hasX402scanData) {\n      if (totalInvocations >= 1000 && hoursOld < 6) {\n        confidence = 'high';\n      } else if (totalInvocations >= 100 && hoursOld < 24) {\n        confidence = 'medium';\n      } else {\n        confidence = 'low';\n      }\n    } else if (hasScatteringData && !scatteringLowActivity) {\n      // Scattering-only data provides some confidence\n      confidence = scatteringActivityScore > 0.5 ? 'medium' : 'low';\n    }\n\n    return {\n      facilitatorId: params.facilitatorId,\n      score: Math.round(finalScore),\n      successRate,\n      avgLatencyMs,\n      p95LatencyMs,\n      totalInvocations,\n      dataFreshness: hoursOld,\n      confidence,\n      reasons,\n      // Scattering fields\n      scatteringActivityScore: hasScatteringData ? scatteringActivityScore : undefined,\n      scatteringVolume3d,\n      scatteringTxCount3d,\n      scatteringUniqueBuyers3d,\n      scatteringLowActivity: scatteringLowActivity || undefined,\n    };\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId: params.facilitatorId,\n      msg: 'Failed to get facilitator score',\n    });\n    return null;\n  }\n}\n\n/**\n * Rank multiple facilitators by their x402scan-derived score\n * Enforces freshness and confidence thresholds - only returns trusted scores\n * \n * @param facilitatorIds - List of facilitator IDs to rank\n * @param timeframe - Timeframe for metrics (default: '1d')\n * @param config - Trust configuration (default: DEFAULT_TRUST_CONFIG)\n */\nexport async function rankFacilitators(\n  facilitatorIds: string[],\n  timeframe: FacilitatorPathMetricsTimeframe = '1d',\n  config: MetricsTrustConfig = DEFAULT_TRUST_CONFIG\n): Promise<FacilitatorRanking> {\n  const scores: FacilitatorScore[] = [];\n  const untrusted: Array<{ id: string; reason: string }> = [];\n\n  for (const id of facilitatorIds) {\n    const score = await getFacilitatorScore({ facilitatorId: id, timeframe });\n    \n    if (!score) {\n      untrusted.push({ id, reason: 'no-data' });\n      continue;\n    }\n\n    // Check if metrics meet trust thresholds\n    const trustCheck = shouldTrustMetrics(\n      score.dataFreshness,\n      score.totalInvocations,\n      config\n    );\n\n    if (!trustCheck.trust) {\n      untrusted.push({ id, reason: trustCheck.reason });\n      // Still include in rankings but with penalized score\n      scores.push({\n        ...score,\n        score: score.score * config.lowConfidencePenalty, // Heavy penalty\n        confidence: 'low',\n        reasons: [...score.reasons, `untrusted:${trustCheck.reason}`],\n      });\n      continue;\n    }\n\n    // Apply confidence-based adjustments\n    if (trustCheck.confidence === 'medium') {\n      // Slight penalty for medium confidence\n      scores.push({\n        ...score,\n        score: score.score * 0.9, // 10% penalty\n        confidence: 'medium',\n        reasons: [...score.reasons, trustCheck.reason],\n      });\n    } else {\n      // High confidence - use score as-is\n      scores.push({\n        ...score,\n        reasons: [...score.reasons, trustCheck.reason],\n      });\n    }\n  }\n\n  // Log untrusted facilitators for visibility\n  if (untrusted.length > 0) {\n    logger.debug({\n      untrusted,\n      trusted: scores.filter((s) => s.confidence !== 'low').map((s) => s.facilitatorId),\n      msg: 'Facilitator metrics trust check results',\n    });\n  }\n\n  // Sort by score descending\n  scores.sort((a, b) => b.score - a.score);\n\n  return {\n    rankings: scores,\n    timestamp: new Date().toISOString(),\n    timeframe,\n  };\n}\n\n/**\n * Get recommended facilitator for a given context\n * Uses x402scan data to inform the recommendation\n * Falls back to default candidate when metrics are stale/missing\n */\nexport async function getRecommendedFacilitator(\n  candidateIds: string[],\n  options?: {\n    network?: string;\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    prioritize?: 'latency' | 'reliability' | 'balanced';\n    trustConfig?: MetricsTrustConfig;\n  }\n): Promise<{\n  recommended: string | null;\n  ranking: FacilitatorRanking;\n  reason: string;\n  usedFallback: boolean;\n}> {\n  const timeframe = options?.timeframe ?? '1d';\n  const trustConfig = options?.trustConfig ?? DEFAULT_TRUST_CONFIG;\n  const ranking = await rankFacilitators(candidateIds, timeframe, trustConfig);\n\n  // Check if we have any trusted rankings\n  const trustedRankings = ranking.rankings.filter((r) => r.confidence !== 'low');\n\n  if (trustedRankings.length === 0) {\n    // No trusted data - fall back to first candidate\n    logger.warn({\n      candidates: candidateIds,\n      rankings: ranking.rankings.map((r) => ({\n        id: r.facilitatorId,\n        confidence: r.confidence,\n        reasons: r.reasons,\n      })),\n      msg: 'No trusted x402scan data available, using fallback',\n    });\n\n    return {\n      recommended: candidateIds[0] ?? null,\n      ranking,\n      reason: 'No trusted x402scan data (stale or insufficient), using default order',\n      usedFallback: true,\n    };\n  }\n\n  const prioritize = options?.prioritize ?? 'balanced';\n  let recommended: FacilitatorScore;\n\n  switch (prioritize) {\n    case 'latency':\n      // Sort by latency (ascending), filter out unknown latency, only trusted\n      const byLatency = trustedRankings\n        .filter((r) => r.p95LatencyMs !== undefined)\n        .sort((a, b) => (a.p95LatencyMs ?? Infinity) - (b.p95LatencyMs ?? Infinity));\n      recommended = byLatency[0] ?? trustedRankings[0];\n      break;\n\n    case 'reliability':\n      // Sort by success rate (descending), only trusted\n      const byReliability = [...trustedRankings].sort((a, b) => b.successRate - a.successRate);\n      recommended = byReliability[0];\n      break;\n\n    case 'balanced':\n    default:\n      // Use overall score from trusted rankings\n      recommended = trustedRankings[0];\n      break;\n  }\n\n  return {\n    recommended: recommended.facilitatorId,\n    ranking,\n    reason: `Selected ${recommended.facilitatorId} with score ${recommended.score} ` +\n      `(${recommended.confidence} confidence, ${recommended.reasons.slice(0, 3).join(', ')})`,\n    usedFallback: false,\n  };\n}\n\n/**\n * Check if a facilitator should be avoided based on recent performance\n */\nexport async function shouldAvoidFacilitator(\n  facilitatorId: string,\n  threshold: {\n    maxErrorRate?: number;    // Default: 0.2 (20%)\n    minInvocations?: number;  // Default: 10\n  } = {}\n): Promise<{\n  avoid: boolean;\n  reason?: string;\n}> {\n  const maxErrorRate = threshold.maxErrorRate ?? 0.2;\n  const minInvocations = threshold.minInvocations ?? 10;\n\n  try {\n    const score = await getFacilitatorScore({ facilitatorId, timeframe: '1d' });\n\n    if (!score) {\n      return { avoid: false, reason: 'No data available' };\n    }\n\n    // Not enough data to make a decision\n    if (score.totalInvocations < minInvocations) {\n      return { avoid: false, reason: `Insufficient data (${score.totalInvocations} invocations)` };\n    }\n\n    // Check error rate\n    const errorRate = 1 - score.successRate;\n    if (errorRate > maxErrorRate) {\n      return {\n        avoid: true,\n        reason: `Error rate ${(errorRate * 100).toFixed(1)}% exceeds threshold ${(maxErrorRate * 100).toFixed(1)}%`,\n      };\n    }\n\n    return { avoid: false };\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n      facilitatorId,\n      msg: 'Failed to check if facilitator should be avoided',\n    });\n    return { avoid: false, reason: 'Error checking metrics' };\n  }\n}\n\n/**\n * Get all available facilitator summaries\n * Useful for dashboard/monitoring\n */\nexport async function getAllFacilitatorSummaries(): Promise<Record<string, FacilitatorSummary>> {\n  return loadAllSummaries();\n}\n\n// =============================================================================\n// SMF EXPLAINER\n// =============================================================================\n\n/**\n * Structured explanation for SMF routing decisions\n */\nexport interface FacilitatorExplanation {\n  facilitatorId: string;\n  selected: boolean;\n  score: number;\n  confidence: 'high' | 'medium' | 'low' | 'none';\n  shortReason: string;      // One-line summary\n  detailedReasons: string[];\n  metrics: {\n    successRate?: number;\n    errorRate?: number;\n    p95LatencyMs?: number;\n    invocations?: number;\n    dataAgeHours?: number;\n  };\n}\n\n/**\n * Get a structured explanation for why a facilitator was/wasn't selected\n * Used by SMF to provide transparent routing decisions\n * \n * @example\n * const explanation = await getFacilitatorExplainer('cdp', { timeframe: '1d' });\n * console.log(explanation.shortReason);\n * // \"cdp: 98.5% success, 185ms p95, high confidence (12K invocations)\"\n */\nexport async function getFacilitatorExplainer(\n  facilitatorId: string,\n  options?: {\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    wasSelected?: boolean;\n  }\n): Promise<FacilitatorExplanation> {\n  const timeframe = options?.timeframe ?? '1d';\n  const wasSelected = options?.wasSelected ?? false;\n\n  const score = await getFacilitatorScore({ facilitatorId, timeframe });\n\n  if (!score) {\n    return {\n      facilitatorId,\n      selected: wasSelected,\n      score: 50,\n      confidence: 'low',\n      shortReason: `${facilitatorId}: no x402scan data available`,\n      detailedReasons: ['No observability data from x402scan'],\n      metrics: {},\n    };\n  }\n\n  // Build short reason string\n  const successPct = (score.successRate * 100).toFixed(1);\n  const latencyStr = score.p95LatencyMs ? `${score.p95LatencyMs.toFixed(0)}ms p95` : 'latency unknown';\n  const volumeStr = score.totalInvocations >= 1000 \n    ? `${(score.totalInvocations / 1000).toFixed(1)}K invocations`\n    : `${score.totalInvocations} invocations`;\n\n  const shortReason = `${facilitatorId}: ${successPct}% success, ${latencyStr}, ${score.confidence} confidence (${volumeStr})`;\n\n  // Build detailed reasons\n  const detailedReasons: string[] = [];\n  \n  if (score.successRate >= 0.99) {\n    detailedReasons.push(`Excellent success rate: ${successPct}%`);\n  } else if (score.successRate >= 0.95) {\n    detailedReasons.push(`Good success rate: ${successPct}%`);\n  } else if (score.successRate >= 0.90) {\n    detailedReasons.push(`Acceptable success rate: ${successPct}%`);\n  } else {\n    detailedReasons.push(` Low success rate: ${successPct}%`);\n  }\n\n  if (score.p95LatencyMs !== undefined) {\n    if (score.p95LatencyMs < 200) {\n      detailedReasons.push(`Fast response times: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    } else if (score.p95LatencyMs < 500) {\n      detailedReasons.push(`Moderate latency: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    } else {\n      detailedReasons.push(` High latency: ${score.p95LatencyMs.toFixed(0)}ms p95`);\n    }\n  }\n\n  if (score.confidence === 'high') {\n    detailedReasons.push(`High confidence: ${volumeStr}, data ${score.dataFreshness.toFixed(1)}h old`);\n  } else if (score.confidence === 'medium') {\n    detailedReasons.push(`Medium confidence: ${volumeStr}`);\n  } else {\n    detailedReasons.push(`Low confidence: limited data (${volumeStr})`);\n  }\n\n  if (score.dataFreshness > 12) {\n    detailedReasons.push(` Data is ${score.dataFreshness.toFixed(1)} hours old`);\n  }\n\n  return {\n    facilitatorId,\n    selected: wasSelected,\n    score: score.score,\n    confidence: score.confidence,\n    shortReason,\n    detailedReasons,\n    metrics: {\n      successRate: score.successRate,\n      errorRate: 1 - score.successRate,\n      p95LatencyMs: score.p95LatencyMs,\n      invocations: score.totalInvocations,\n      dataAgeHours: score.dataFreshness,\n    },\n  };\n}\n\n/**\n * Get explanations for multiple facilitators (for comparison)\n */\nexport async function getMultipleFacilitatorExplanations(\n  facilitatorIds: string[],\n  options?: {\n    timeframe?: FacilitatorPathMetricsTimeframe;\n    selectedId?: string;\n  }\n): Promise<FacilitatorExplanation[]> {\n  const explanations: FacilitatorExplanation[] = [];\n\n  for (const id of facilitatorIds) {\n    const explanation = await getFacilitatorExplainer(id, {\n      timeframe: options?.timeframe,\n      wasSelected: id === options?.selectedId,\n    });\n    explanations.push(explanation);\n  }\n\n  // Sort by score descending\n  return explanations.sort((a, b) => b.score - a.score);\n}\n\n"],"names":[],"mappings":"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"}