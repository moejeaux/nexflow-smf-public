{"version":3,"sources":["../../../src/lib/time-utils.ts","../../../src/db/anomalies.ts","../../../src/types/anomaly-detection.ts","../../../src/services/smf/anomaly-detector.ts","../../../src/app/api/cron/evaluate-anomalies/route.ts","../../../node_modules/next/src/build/templates/app-route.ts"],"sourcesContent":["// =============================================================================\r\n// TIME UTILITIES\r\n// =============================================================================\r\n// Helper functions for time-based operations like tumbling windows.\r\n\r\n/**\r\n * Get the start of the current tumbling window.\r\n * \r\n * @param date - Current date/time\r\n * @param windowSizeMinutes - Window size in minutes (default: 5)\r\n * @returns Start of the current window\r\n * \r\n * @example\r\n * // If now is 12:07:30 and windowSize=5, returns 12:05:00\r\n * getWindowStart(new Date('2024-01-01T12:07:30'), 5)\r\n */\r\nexport function getWindowStart(date: Date, windowSizeMinutes: number = 5): Date {\r\n  const ms = date.getTime();\r\n  const windowMs = windowSizeMinutes * 60 * 1000;\r\n  const windowStart = Math.floor(ms / windowMs) * windowMs;\r\n  return new Date(windowStart);\r\n}\r\n\r\n/**\r\n * Get the end of the current tumbling window.\r\n * \r\n * @param date - Current date/time\r\n * @param windowSizeMinutes - Window size in minutes (default: 5)\r\n * @returns End of the current window\r\n */\r\nexport function getWindowEnd(date: Date, windowSizeMinutes: number = 5): Date {\r\n  const windowStart = getWindowStart(date, windowSizeMinutes);\r\n  return new Date(windowStart.getTime() + windowSizeMinutes * 60 * 1000);\r\n}\r\n\r\n/**\r\n * Check if a given date is within the current window.\r\n * \r\n * @param date - Date to check\r\n * @param windowSizeMinutes - Window size in minutes (default: 5)\r\n * @returns True if date is in current window\r\n */\r\nexport function isInCurrentWindow(date: Date, windowSizeMinutes: number = 5): boolean {\r\n  const now = new Date();\r\n  const currentWindowStart = getWindowStart(now, windowSizeMinutes);\r\n  const currentWindowEnd = getWindowEnd(now, windowSizeMinutes);\r\n  \r\n  return date >= currentWindowStart && date < currentWindowEnd;\r\n}\r\n\r\n/**\r\n * Get minutes elapsed since a given timestamp.\r\n * \r\n * @param since - Starting timestamp\r\n * @param now - Current time (default: Date.now())\r\n * @returns Minutes elapsed\r\n */\r\nexport function minutesSince(since: Date, now: Date = new Date()): number {\r\n  return (now.getTime() - since.getTime()) / 60000;\r\n}\r\n\r\n/**\r\n * Add minutes to a date.\r\n * \r\n * @param date - Starting date\r\n * @param minutes - Minutes to add\r\n * @returns New date\r\n */\r\nexport function addMinutes(date: Date, minutes: number): Date {\r\n  return new Date(date.getTime() + minutes * 60 * 1000);\r\n}\r\n\r\n/**\r\n * Format duration in a human-readable way.\r\n * \r\n * @param ms - Duration in milliseconds\r\n * @returns Human-readable string (e.g., \"5m 30s\")\r\n */\r\nexport function formatDuration(ms: number): string {\r\n  if (ms < 1000) {\r\n    return `${ms}ms`;\r\n  }\r\n  \r\n  const seconds = Math.floor(ms / 1000);\r\n  if (seconds < 60) {\r\n    return `${seconds}s`;\r\n  }\r\n  \r\n  const minutes = Math.floor(seconds / 60);\r\n  const remainingSeconds = seconds % 60;\r\n  \r\n  if (minutes < 60) {\r\n    return remainingSeconds > 0 ? `${minutes}m ${remainingSeconds}s` : `${minutes}m`;\r\n  }\r\n  \r\n  const hours = Math.floor(minutes / 60);\r\n  const remainingMinutes = minutes % 60;\r\n  \r\n  return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;\r\n}\r\n\r\n","// =============================================================================\r\n// ANOMALY DETECTION DATABASE HELPERS\r\n// =============================================================================\r\n// Query helpers for anomaly detection, circuit breaker state, and metric buffers.\r\n\r\nimport { getDb, isPostgres } from './client';\r\nimport { getWindowStart } from '@/lib/time-utils';\r\nimport type {\r\n  AnomalyWindow,\r\n  CircuitBreaker,\r\n  CircuitBreakerEvent,\r\n  CircuitBreakerState,\r\n  MetricBufferEntry,\r\n  RecordMetricParams,\r\n  WindowMetrics,\r\n  WindowStatus,\r\n} from '@/types/anomaly-detection';\r\n\r\n// =============================================================================\r\n// METRIC BUFFER OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Record a single routing outcome metric into the buffer.\r\n * Fast path: accumulates metrics until window closes.\r\n */\r\nexport async function recordMetricInBuffer(\r\n  params: RecordMetricParams\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const windowStart = getWindowStart(new Date());\r\n\r\n  if (isPostgres(db)) {\r\n    // PostgreSQL: UPSERT with atomic increments\r\n    await (db as any).pool.query(\r\n      `INSERT INTO anomaly_metric_buffer \r\n       (facilitator_id, chain_id, window_start, request_count, error_count, \r\n        latency_sum, latency_count, max_gas_price, last_updated_at)\r\n       VALUES ($1, $2, $3, 1, $4, $5, 1, $6, current_timestamp)\r\n       ON CONFLICT (facilitator_id, chain_id) DO UPDATE SET\r\n         request_count = anomaly_metric_buffer.request_count + 1,\r\n         error_count = anomaly_metric_buffer.error_count + $4,\r\n         latency_sum = anomaly_metric_buffer.latency_sum + $5,\r\n         latency_count = anomaly_metric_buffer.latency_count + 1,\r\n         max_gas_price = GREATEST(anomaly_metric_buffer.max_gas_price, COALESCE($6, 0)),\r\n         last_updated_at = current_timestamp`,\r\n      [\r\n        params.facilitator_id,\r\n        params.chain_id,\r\n        windowStart,\r\n        params.success ? 0 : 1,\r\n        params.latency_ms,\r\n        params.gas_price_gwei || 0,\r\n      ]\r\n    );\r\n  } else {\r\n    // SQLite: Check if exists, then insert or update\r\n    const existing = (db as any).prepare(\r\n      `SELECT * FROM anomaly_metric_buffer \r\n       WHERE facilitator_id = ? AND chain_id = ?`\r\n    ).get(params.facilitator_id, params.chain_id);\r\n\r\n    if (existing) {\r\n      (db as any).prepare(\r\n        `UPDATE anomaly_metric_buffer SET\r\n         request_count = request_count + 1,\r\n         error_count = error_count + ?,\r\n         latency_sum = latency_sum + ?,\r\n         latency_count = latency_count + 1,\r\n         max_gas_price = MAX(max_gas_price, ?),\r\n         last_updated_at = datetime('now')\r\n         WHERE facilitator_id = ? AND chain_id = ?`\r\n      ).run(\r\n        params.success ? 0 : 1,\r\n        params.latency_ms,\r\n        params.gas_price_gwei || 0,\r\n        params.facilitator_id,\r\n        params.chain_id\r\n      );\r\n    } else {\r\n      (db as any).prepare(\r\n        `INSERT INTO anomaly_metric_buffer \r\n         (facilitator_id, chain_id, window_start, request_count, error_count,\r\n          latency_sum, latency_count, max_gas_price, last_updated_at)\r\n         VALUES (?, ?, ?, 1, ?, ?, 1, ?, datetime('now'))`\r\n      ).run(\r\n        params.facilitator_id,\r\n        params.chain_id,\r\n        windowStart.toISOString(),\r\n        params.success ? 0 : 1,\r\n        params.latency_ms,\r\n        params.gas_price_gwei || 0\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get buffer metrics for a facilitator+chain.\r\n */\r\nexport async function getBufferMetrics(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<MetricBufferEntry | null> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM anomaly_metric_buffer \r\n       WHERE facilitator_id = $1 AND chain_id = $2`,\r\n      [facilitator_id, chain_id]\r\n    );\r\n    if (result.rows.length === 0) return null;\r\n    return mapBufferRow(result.rows[0]);\r\n  } else {\r\n    const row = (db as any).prepare(\r\n      `SELECT * FROM anomaly_metric_buffer \r\n       WHERE facilitator_id = ? AND chain_id = ?`\r\n    ).get(facilitator_id, chain_id);\r\n    if (!row) return null;\r\n    return mapBufferRow(row);\r\n  }\r\n}\r\n\r\n/**\r\n * Get all active buffers (recently updated).\r\n */\r\nexport async function getActiveBuffers(\r\n  minutesBack: number = 10\r\n): Promise<MetricBufferEntry[]> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM anomaly_metric_buffer \r\n       WHERE last_updated_at > current_timestamp - interval '${minutesBack} minutes'`\r\n    );\r\n    return result.rows.map(mapBufferRow);\r\n  } else {\r\n    const cutoff = new Date(Date.now() - minutesBack * 60000).toISOString();\r\n    const rows = (db as any).prepare(\r\n      `SELECT * FROM anomaly_metric_buffer \r\n       WHERE last_updated_at > ?`\r\n    ).all(cutoff);\r\n    return rows.map(mapBufferRow);\r\n  }\r\n}\r\n\r\n/**\r\n * Clear buffer metrics after window close.\r\n */\r\nexport async function clearBufferMetrics(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    await (db as any).pool.query(\r\n      `DELETE FROM anomaly_metric_buffer \r\n       WHERE facilitator_id = $1 AND chain_id = $2`,\r\n      [facilitator_id, chain_id]\r\n    );\r\n  } else {\r\n    (db as any).prepare(\r\n      `DELETE FROM anomaly_metric_buffer \r\n       WHERE facilitator_id = ? AND chain_id = ?`\r\n    ).run(facilitator_id, chain_id);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// ANOMALY WINDOW OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Record evaluated window metrics.\r\n */\r\nexport async function recordWindowMetrics(\r\n  params: WindowMetrics\r\n): Promise<AnomalyWindow> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO facilitator_anomalies \r\n       (id, facilitator_id, chain_id, window_start, window_end, request_count, \r\n        error_count, avg_latency_ms, max_gas_price_gwei, status, created_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, current_timestamp)\r\n       RETURNING *`,\r\n      [\r\n        id,\r\n        params.facilitator_id,\r\n        params.chain_id,\r\n        params.window_start,\r\n        params.window_end,\r\n        params.request_count,\r\n        params.error_count,\r\n        params.avg_latency_ms,\r\n        params.max_gas_price_gwei || null,\r\n        params.status,\r\n      ]\r\n    );\r\n    return mapAnomalyRow(result.rows[0]);\r\n  } else {\r\n    (db as any).prepare(\r\n      `INSERT INTO facilitator_anomalies \r\n       (id, facilitator_id, chain_id, window_start, window_end, request_count,\r\n        error_count, avg_latency_ms, max_gas_price_gwei, status, created_at)\r\n       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))`\r\n    ).run(\r\n      id,\r\n      params.facilitator_id,\r\n      params.chain_id,\r\n      params.window_start.toISOString(),\r\n      params.window_end.toISOString(),\r\n      params.request_count,\r\n      params.error_count,\r\n      params.avg_latency_ms,\r\n      params.max_gas_price_gwei || null,\r\n      params.status\r\n    );\r\n    \r\n    const row = (db as any).prepare(\r\n      `SELECT * FROM facilitator_anomalies WHERE id = ?`\r\n    ).get(id);\r\n    return mapAnomalyRow(row);\r\n  }\r\n}\r\n\r\n/**\r\n * Get recent anomaly windows for a facilitator+chain.\r\n */\r\nexport async function getRecentAnomalyWindows(\r\n  facilitator_id: string,\r\n  chain_id: string,\r\n  windowsCount: number = 5\r\n): Promise<AnomalyWindow[]> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_anomalies \r\n       WHERE facilitator_id = $1 AND chain_id = $2\r\n       ORDER BY window_end DESC LIMIT $3`,\r\n      [facilitator_id, chain_id, windowsCount]\r\n    );\r\n    return result.rows.map(mapAnomalyRow);\r\n  } else {\r\n    const rows = (db as any).prepare(\r\n      `SELECT * FROM facilitator_anomalies \r\n       WHERE facilitator_id = ? AND chain_id = ?\r\n       ORDER BY window_end DESC LIMIT ?`\r\n    ).all(facilitator_id, chain_id, windowsCount);\r\n    return rows.map(mapAnomalyRow);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// CIRCUIT BREAKER OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Get or create circuit breaker for facilitator+chain.\r\n * Creates with CLOSED state if doesn't exist.\r\n */\r\nexport async function getOrCreateCircuitBreaker(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<CircuitBreaker> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    // Try to get existing\r\n    const existing = await (db as any).pool.query(\r\n      `SELECT * FROM facilitator_circuit_breakers \r\n       WHERE facilitator_id = $1 AND chain_id = $2`,\r\n      [facilitator_id, chain_id]\r\n    );\r\n\r\n    if (existing.rows.length > 0) {\r\n      return mapCircuitBreakerRow(existing.rows[0]);\r\n    }\r\n\r\n    // Create new with CLOSED state\r\n    const id = crypto.randomUUID();\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO facilitator_circuit_breakers \r\n       (id, facilitator_id, chain_id, state, last_changed_at)\r\n       VALUES ($1, $2, $3, 'CLOSED', current_timestamp)\r\n       RETURNING *`,\r\n      [id, facilitator_id, chain_id]\r\n    );\r\n    return mapCircuitBreakerRow(result.rows[0]);\r\n  } else {\r\n    const existing = (db as any).prepare(\r\n      `SELECT * FROM facilitator_circuit_breakers \r\n       WHERE facilitator_id = ? AND chain_id = ?`\r\n    ).get(facilitator_id, chain_id);\r\n\r\n    if (existing) {\r\n      return mapCircuitBreakerRow(existing);\r\n    }\r\n\r\n    const id = crypto.randomUUID();\r\n    (db as any).prepare(\r\n      `INSERT INTO facilitator_circuit_breakers \r\n       (id, facilitator_id, chain_id, state, last_changed_at)\r\n       VALUES (?, ?, ?, 'CLOSED', datetime('now'))`\r\n    ).run(id, facilitator_id, chain_id);\r\n\r\n    const row = (db as any).prepare(\r\n      `SELECT * FROM facilitator_circuit_breakers WHERE id = ?`\r\n    ).get(id);\r\n    return mapCircuitBreakerRow(row);\r\n  }\r\n}\r\n\r\n/**\r\n * Get circuit breaker state for facilitator+chain.\r\n * Returns null if not found.\r\n */\r\nexport async function getCircuitBreakerState(\r\n  facilitator_id: string,\r\n  chain_id: string\r\n): Promise<CircuitBreakerState | null> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT state FROM facilitator_circuit_breakers \r\n       WHERE facilitator_id = $1 AND chain_id = $2`,\r\n      [facilitator_id, chain_id]\r\n    );\r\n    return result.rows.length > 0 ? result.rows[0].state : null;\r\n  } else {\r\n    const row = (db as any).prepare(\r\n      `SELECT state FROM facilitator_circuit_breakers \r\n       WHERE facilitator_id = ? AND chain_id = ?`\r\n    ).get(facilitator_id, chain_id);\r\n    return row ? row.state : null;\r\n  }\r\n}\r\n\r\n/**\r\n * Update circuit breaker state.\r\n */\r\nexport async function updateCircuitBreakerState(\r\n  params: {\r\n    facilitator_id: string;\r\n    chain_id: string;\r\n    state: CircuitBreakerState;\r\n    opened_at?: Date | null;\r\n    half_opened_at?: Date | null;\r\n  }\r\n): Promise<void> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    await (db as any).pool.query(\r\n      `UPDATE facilitator_circuit_breakers \r\n       SET state = $1, opened_at = $2, half_opened_at = $3, last_changed_at = current_timestamp\r\n       WHERE facilitator_id = $4 AND chain_id = $5`,\r\n      [\r\n        params.state,\r\n        params.opened_at || null,\r\n        params.half_opened_at || null,\r\n        params.facilitator_id,\r\n        params.chain_id,\r\n      ]\r\n    );\r\n  } else {\r\n    (db as any).prepare(\r\n      `UPDATE facilitator_circuit_breakers \r\n       SET state = ?, opened_at = ?, half_opened_at = ?, last_changed_at = datetime('now')\r\n       WHERE facilitator_id = ? AND chain_id = ?`\r\n    ).run(\r\n      params.state,\r\n      params.opened_at?.toISOString() || null,\r\n      params.half_opened_at?.toISOString() || null,\r\n      params.facilitator_id,\r\n      params.chain_id\r\n    );\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// CIRCUIT BREAKER EVENTS\r\n// =============================================================================\r\n\r\n/**\r\n * Record circuit breaker state change event.\r\n */\r\nexport async function recordCircuitBreakerEvent(\r\n  params: {\r\n    facilitator_id: string;\r\n    chain_id: string;\r\n    old_state: CircuitBreakerState | null;\r\n    new_state: CircuitBreakerState;\r\n    reason: string;\r\n    metrics_snapshot: Record<string, unknown>;\r\n  }\r\n): Promise<CircuitBreakerEvent> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const metricsJson = JSON.stringify(params.metrics_snapshot);\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `INSERT INTO circuit_breaker_events \r\n       (id, facilitator_id, chain_id, old_state, new_state, reason, \r\n        metrics_snapshot, created_at)\r\n       VALUES ($1, $2, $3, $4, $5, $6, $7, current_timestamp)\r\n       RETURNING *`,\r\n      [\r\n        id,\r\n        params.facilitator_id,\r\n        params.chain_id,\r\n        params.old_state,\r\n        params.new_state,\r\n        params.reason,\r\n        metricsJson,\r\n      ]\r\n    );\r\n    return mapEventRow(result.rows[0]);\r\n  } else {\r\n    (db as any).prepare(\r\n      `INSERT INTO circuit_breaker_events \r\n       (id, facilitator_id, chain_id, old_state, new_state, reason,\r\n        metrics_snapshot, created_at)\r\n       VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'))`\r\n    ).run(\r\n      id,\r\n      params.facilitator_id,\r\n      params.chain_id,\r\n      params.old_state,\r\n      params.new_state,\r\n      params.reason,\r\n      metricsJson\r\n    );\r\n\r\n    const row = (db as any).prepare(\r\n      `SELECT * FROM circuit_breaker_events WHERE id = ?`\r\n    ).get(id);\r\n    return mapEventRow(row);\r\n  }\r\n}\r\n\r\n/**\r\n * Mark notification as sent for an event.\r\n */\r\nexport async function markNotificationSent(\r\n  eventId: string,\r\n  error?: string\r\n): Promise<void> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    await (db as any).pool.query(\r\n      `UPDATE circuit_breaker_events \r\n       SET notification_sent = 1, notification_error = $1\r\n       WHERE id = $2`,\r\n      [error || null, eventId]\r\n    );\r\n  } else {\r\n    (db as any).prepare(\r\n      `UPDATE circuit_breaker_events \r\n       SET notification_sent = 1, notification_error = ?\r\n       WHERE id = ?`\r\n    ).run(error || null, eventId);\r\n  }\r\n}\r\n\r\n/**\r\n * Get recent CB events for a facilitator.\r\n */\r\nexport async function getRecentCircuitBreakerEvents(\r\n  facilitator_id: string,\r\n  limit: number = 10\r\n): Promise<CircuitBreakerEvent[]> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT * FROM circuit_breaker_events \r\n       WHERE facilitator_id = $1\r\n       ORDER BY created_at DESC LIMIT $2`,\r\n      [facilitator_id, limit]\r\n    );\r\n    return result.rows.map(mapEventRow);\r\n  } else {\r\n    const rows = (db as any).prepare(\r\n      `SELECT * FROM circuit_breaker_events \r\n       WHERE facilitator_id = ?\r\n       ORDER BY created_at DESC LIMIT ?`\r\n    ).all(facilitator_id, limit);\r\n    return rows.map(mapEventRow);\r\n  }\r\n}\r\n\r\n/**\r\n * Get facilitator callback URL.\r\n */\r\nexport async function getFacilitatorCallbackUrl(\r\n  facilitator_id: string\r\n): Promise<string | null> {\r\n  const db = getDb();\r\n\r\n  if (isPostgres(db)) {\r\n    const result = await (db as any).pool.query(\r\n      `SELECT callback_url FROM facilitators WHERE id = $1`,\r\n      [facilitator_id]\r\n    );\r\n    return result.rows[0]?.callback_url || null;\r\n  } else {\r\n    const row = (db as any).prepare(\r\n      `SELECT callback_url FROM facilitators WHERE id = ?`\r\n    ).get(facilitator_id);\r\n    return row?.callback_url || null;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// ROW MAPPERS\r\n// =============================================================================\r\n\r\nfunction mapBufferRow(row: any): MetricBufferEntry {\r\n  return {\r\n    facilitator_id: row.facilitator_id,\r\n    chain_id: row.chain_id,\r\n    window_start: new Date(row.window_start),\r\n    request_count: row.request_count,\r\n    error_count: row.error_count,\r\n    latency_sum: row.latency_sum,\r\n    latency_count: row.latency_count,\r\n    max_gas_price: row.max_gas_price || 0,\r\n    last_updated_at: new Date(row.last_updated_at),\r\n  };\r\n}\r\n\r\nfunction mapAnomalyRow(row: any): AnomalyWindow {\r\n  return {\r\n    id: row.id,\r\n    facilitator_id: row.facilitator_id,\r\n    chain_id: row.chain_id,\r\n    window_start: new Date(row.window_start),\r\n    window_end: new Date(row.window_end),\r\n    request_count: row.request_count,\r\n    error_count: row.error_count,\r\n    avg_latency_ms: row.avg_latency_ms,\r\n    max_gas_price_gwei: row.max_gas_price_gwei,\r\n    status: row.status as WindowStatus,\r\n    created_at: new Date(row.created_at),\r\n  };\r\n}\r\n\r\nfunction mapCircuitBreakerRow(row: any): CircuitBreaker {\r\n  return {\r\n    id: row.id,\r\n    facilitator_id: row.facilitator_id,\r\n    chain_id: row.chain_id,\r\n    state: row.state as CircuitBreakerState,\r\n    opened_at: row.opened_at ? new Date(row.opened_at) : null,\r\n    half_opened_at: row.half_opened_at ? new Date(row.half_opened_at) : null,\r\n    last_changed_at: new Date(row.last_changed_at),\r\n  };\r\n}\r\n\r\nfunction mapEventRow(row: any): CircuitBreakerEvent {\r\n  return {\r\n    id: row.id,\r\n    facilitator_id: row.facilitator_id,\r\n    chain_id: row.chain_id,\r\n    old_state: row.old_state as CircuitBreakerState | null,\r\n    new_state: row.new_state as CircuitBreakerState,\r\n    reason: row.reason,\r\n    metrics_snapshot: row.metrics_snapshot,\r\n    notification_sent: row.notification_sent,\r\n    notification_error: row.notification_error,\r\n    created_at: new Date(row.created_at),\r\n  };\r\n}\r\n\r\n","// =============================================================================\r\n// Anomaly Detection & Circuit Breaker Types\r\n// =============================================================================\r\n// Types for real-time anomaly detection with circuit breaker pattern.\r\n// SMF automatically detects degraded facilitators and adjusts routing.\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\n/**\r\n * Anomaly detection thresholds\r\n */\r\nexport interface AnomalyThresholds {\r\n  /** Error rate threshold for 'anomalous' (e.g., 0.5 = 50%) */\r\n  error_rate_anomalous: number;\r\n  /** Error rate threshold for 'suspect' (e.g., 0.3 = 30%) */\r\n  error_rate_suspect: number;\r\n  /** Latency threshold for 'anomalous' in ms (e.g., 2000) */\r\n  latency_ms_anomalous: number;\r\n  /** Latency threshold for 'suspect' in ms (e.g., 1500) */\r\n  latency_ms_suspect: number;\r\n  /** Gas price threshold for 'anomalous' in gwei (e.g., 150) */\r\n  gas_price_gwei_anomalous: number;\r\n  /** Gas price threshold for 'suspect' in gwei (e.g., 100) */\r\n  gas_price_gwei_suspect: number;\r\n  /** Minimum requests required for evaluation */\r\n  min_request_threshold: number;\r\n}\r\n\r\n/**\r\n * Default anomaly thresholds\r\n */\r\nexport const DEFAULT_ANOMALY_THRESHOLDS: AnomalyThresholds = {\r\n  error_rate_anomalous: 0.5,      // 50% errors = anomalous\r\n  error_rate_suspect: 0.3,        // 30% errors = suspect\r\n  latency_ms_anomalous: 2000,     // >2s = anomalous\r\n  latency_ms_suspect: 1500,       // >1.5s = suspect\r\n  gas_price_gwei_anomalous: 150,  // >150 gwei = anomalous\r\n  gas_price_gwei_suspect: 100,    // >100 gwei = suspect\r\n  min_request_threshold: 50,      // Need 50+ requests to evaluate\r\n};\r\n\r\n/**\r\n * Circuit breaker configuration\r\n */\r\nexport interface CircuitBreakerConfig {\r\n  /** Minutes to wait in OPEN before trying HALF_OPEN */\r\n  cooldown_minutes: number;\r\n  /** Minutes to wait in HALF_OPEN for recovery */\r\n  half_open_recovery_window_minutes: number;\r\n  /** Consecutive normal windows needed to recover */\r\n  recovery_success_threshold: number;\r\n  /** Traffic share for HALF_OPEN probe (0-1) */\r\n  half_open_probe_share: number;\r\n}\r\n\r\n/**\r\n * Default circuit breaker configuration\r\n */\r\nexport const DEFAULT_CB_CONFIG: CircuitBreakerConfig = {\r\n  cooldown_minutes: 5,                      // 5 min before recovery attempt\r\n  half_open_recovery_window_minutes: 10,    // 10 min to prove recovery\r\n  recovery_success_threshold: 2,            // 2 normal windows to close\r\n  half_open_probe_share: 0.05,              // 5% probe traffic\r\n};\r\n\r\n// =============================================================================\r\n// METRIC TYPES\r\n// =============================================================================\r\n\r\n/**\r\n * Window classification status\r\n */\r\nexport type WindowStatus = 'normal' | 'suspect' | 'anomalous';\r\n\r\n/**\r\n * Circuit breaker state\r\n */\r\nexport type CircuitBreakerState = 'CLOSED' | 'OPEN' | 'HALF_OPEN';\r\n\r\n/**\r\n * Metric buffer entry (accumulating metrics between window closes)\r\n */\r\nexport interface MetricBufferEntry {\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  window_start: Date;\r\n  request_count: number;\r\n  error_count: number;\r\n  latency_sum: number;\r\n  latency_count: number;\r\n  max_gas_price: number;\r\n  last_updated_at: Date;\r\n}\r\n\r\n/**\r\n * Evaluated window metrics\r\n */\r\nexport interface WindowMetrics {\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  window_start: Date;\r\n  window_end: Date;\r\n  request_count: number;\r\n  error_count: number;\r\n  avg_latency_ms: number;\r\n  max_gas_price_gwei: number;\r\n  status: WindowStatus;\r\n}\r\n\r\n/**\r\n * Parameters for recording a single metric\r\n */\r\nexport interface RecordMetricParams {\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  success: boolean;\r\n  latency_ms: number;\r\n  gas_price_gwei?: number;\r\n}\r\n\r\n// =============================================================================\r\n// DATABASE ENTITIES\r\n// =============================================================================\r\n\r\n/**\r\n * Anomaly window row from database\r\n */\r\nexport interface AnomalyWindow {\r\n  id: string;\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  window_start: Date;\r\n  window_end: Date;\r\n  request_count: number;\r\n  error_count: number;\r\n  avg_latency_ms: number;\r\n  max_gas_price_gwei: number | null;\r\n  status: WindowStatus;\r\n  created_at: Date;\r\n}\r\n\r\n/**\r\n * Circuit breaker row from database\r\n */\r\nexport interface CircuitBreaker {\r\n  id: string;\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  state: CircuitBreakerState;\r\n  opened_at: Date | null;\r\n  half_opened_at: Date | null;\r\n  last_changed_at: Date;\r\n}\r\n\r\n/**\r\n * Circuit breaker event row from database\r\n */\r\nexport interface CircuitBreakerEvent {\r\n  id: string;\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  old_state: CircuitBreakerState | null;\r\n  new_state: CircuitBreakerState;\r\n  reason: string;\r\n  metrics_snapshot: string;  // JSON string\r\n  notification_sent: number;  // 0 or 1\r\n  notification_error: string | null;\r\n  created_at: Date;\r\n}\r\n\r\n// =============================================================================\r\n// API RESPONSES\r\n// =============================================================================\r\n\r\n/**\r\n * Anomaly evaluation result\r\n */\r\nexport interface AnomalyEvaluationResult {\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  window_status: WindowStatus;\r\n  cb_state: CircuitBreakerState;\r\n  cb_changed: boolean;\r\n  metrics: {\r\n    request_count: number;\r\n    error_count: number;\r\n    error_rate: number;\r\n    avg_latency_ms: number;\r\n    max_gas_price_gwei: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Cron job result\r\n */\r\nexport interface EvaluateAnomaliesResult {\r\n  success: boolean;\r\n  facilitators_evaluated: number;\r\n  cb_events_triggered: number;\r\n  timestamp: string;\r\n  errors?: string[];\r\n}\r\n\r\n/**\r\n * Circuit breaker status for API\r\n */\r\nexport interface CircuitBreakerStatus {\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  state: CircuitBreakerState;\r\n  opened_at: Date | null;\r\n  half_opened_at: Date | null;\r\n  last_changed_at: Date;\r\n  recent_windows: {\r\n    window_end: Date;\r\n    status: WindowStatus;\r\n    error_rate: number;\r\n    avg_latency_ms: number;\r\n  }[];\r\n}\r\n\r\n// =============================================================================\r\n// WEBHOOK NOTIFICATION\r\n// =============================================================================\r\n\r\n/**\r\n * Webhook payload for CB state change\r\n */\r\nexport interface CircuitBreakerWebhookPayload {\r\n  event: 'circuit_breaker_state_changed';\r\n  timestamp: string;\r\n  facilitator_id: string;\r\n  chain_id: string;\r\n  old_state: CircuitBreakerState | null;\r\n  new_state: CircuitBreakerState;\r\n  reason: string;\r\n  action_required: string;\r\n  metrics?: {\r\n    error_rate: number;\r\n    avg_latency_ms: number;\r\n    max_gas_price_gwei: number;\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Get human-readable action description for CB state\r\n */\r\nexport function getActionRequired(newState: CircuitBreakerState): string {\r\n  switch (newState) {\r\n    case 'OPEN':\r\n      return 'Investigate facilitator health; receiving 0% traffic until recovery';\r\n    case 'HALF_OPEN':\r\n      return 'Testing recovery; receiving 5% probe traffic';\r\n    case 'CLOSED':\r\n      return 'Recovered to normal; back to full routing';\r\n    default:\r\n      return 'Unknown state';\r\n  }\r\n}\r\n\r\n/**\r\n * Get traffic share for CB state\r\n */\r\nexport function getTrafficShareForState(state: CircuitBreakerState): number {\r\n  switch (state) {\r\n    case 'OPEN':\r\n      return 0;           // 0% traffic\r\n    case 'HALF_OPEN':\r\n      return 0.05;        // 5% probe traffic\r\n    case 'CLOSED':\r\n      return 1;           // Normal traffic\r\n    default:\r\n      return 1;\r\n  }\r\n}\r\n\r\n","// =============================================================================\r\n// ANOMALY DETECTOR SERVICE\r\n// =============================================================================\r\n// Real-time anomaly detection with circuit breaker pattern for SMF routing.\r\n// Automatically detects degraded facilitators and adjusts traffic accordingly.\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport { getWindowStart, minutesSince } from '@/lib/time-utils';\r\nimport {\r\n  recordMetricInBuffer,\r\n  getBufferMetrics,\r\n  clearBufferMetrics,\r\n  recordWindowMetrics,\r\n  getRecentAnomalyWindows,\r\n  getOrCreateCircuitBreaker,\r\n  updateCircuitBreakerState,\r\n  recordCircuitBreakerEvent,\r\n  markNotificationSent,\r\n  getFacilitatorCallbackUrl,\r\n} from '@/db/anomalies';\r\nimport {\r\n  type AnomalyThresholds,\r\n  type CircuitBreakerConfig,\r\n  type CircuitBreakerEvent,\r\n  type CircuitBreakerState,\r\n  type RecordMetricParams,\r\n  type WindowMetrics,\r\n  type WindowStatus,\r\n  type CircuitBreakerWebhookPayload,\r\n  DEFAULT_ANOMALY_THRESHOLDS,\r\n  DEFAULT_CB_CONFIG,\r\n  getActionRequired,\r\n} from '@/types/anomaly-detection';\r\n\r\nconst logger = createLogger({ component: 'AnomalyDetector' });\r\n\r\n// =============================================================================\r\n// ANOMALY DETECTOR CLASS\r\n// =============================================================================\r\n\r\nexport class AnomalyDetector {\r\n  private thresholds: AnomalyThresholds;\r\n  private cbConfig: CircuitBreakerConfig;\r\n\r\n  constructor(\r\n    thresholds?: Partial<AnomalyThresholds>,\r\n    cbConfig?: Partial<CircuitBreakerConfig>\r\n  ) {\r\n    this.thresholds = { ...DEFAULT_ANOMALY_THRESHOLDS, ...thresholds };\r\n    this.cbConfig = { ...DEFAULT_CB_CONFIG, ...cbConfig };\r\n  }\r\n\r\n  // ===========================================================================\r\n  // METRIC RECORDING\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Record a single routing outcome metric.\r\n   * Called from routing layer after each payment attempt.\r\n   * Fast path: accumulates in DB buffer until window closes.\r\n   */\r\n  async recordMetric(params: RecordMetricParams): Promise<void> {\r\n    try {\r\n      await recordMetricInBuffer(params);\r\n    } catch (error) {\r\n      // Log but don't fail routing on metric recording errors\r\n      logger.warn(\r\n        { error, facilitator_id: params.facilitator_id, chain_id: params.chain_id },\r\n        'Failed to record metric'\r\n      );\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // WINDOW EVALUATION\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Close current window, evaluate anomalies, update CB state.\r\n   * Called by cron job every 5 minutes.\r\n   */\r\n  async closeAndEvaluateWindow(\r\n    facilitator_id: string,\r\n    chain_id: string\r\n  ): Promise<CircuitBreakerEvent | null> {\r\n    // Get metrics from buffer\r\n    const buffer = await getBufferMetrics(facilitator_id, chain_id);\r\n\r\n    if (!buffer || buffer.request_count === 0) {\r\n      // No metrics in this window\r\n      return null;\r\n    }\r\n\r\n    const now = new Date();\r\n    const windowStart = buffer.window_start;\r\n\r\n    // Compute aggregates\r\n    const avg_latency_ms = buffer.latency_count > 0\r\n      ? buffer.latency_sum / buffer.latency_count\r\n      : 0;\r\n\r\n    // Classify window status\r\n    const status = this.classifyWindow({\r\n      request_count: buffer.request_count,\r\n      error_count: buffer.error_count,\r\n      avg_latency_ms,\r\n      max_gas_price_gwei: buffer.max_gas_price,\r\n    });\r\n\r\n    // Record metrics to DB\r\n    const windowMetrics: WindowMetrics = {\r\n      facilitator_id,\r\n      chain_id,\r\n      window_start: windowStart,\r\n      window_end: now,\r\n      request_count: buffer.request_count,\r\n      error_count: buffer.error_count,\r\n      avg_latency_ms,\r\n      max_gas_price_gwei: buffer.max_gas_price,\r\n      status,\r\n    };\r\n\r\n    await recordWindowMetrics(windowMetrics);\r\n\r\n    logger.info({\r\n      facilitator_id,\r\n      chain_id,\r\n      status,\r\n      request_count: buffer.request_count,\r\n      error_rate: buffer.error_count / buffer.request_count,\r\n      avg_latency_ms,\r\n    }, 'Window evaluated');\r\n\r\n    // Update CB state based on classification\r\n    const event = await this.updateCircuitBreakerState(\r\n      facilitator_id,\r\n      chain_id,\r\n      status,\r\n      windowMetrics\r\n    );\r\n\r\n    // Clear buffer for next window\r\n    await clearBufferMetrics(facilitator_id, chain_id);\r\n\r\n    return event;\r\n  }\r\n\r\n  /**\r\n   * Classify a window as normal/suspect/anomalous based on thresholds.\r\n   */\r\n  classifyWindow(metrics: {\r\n    request_count: number;\r\n    error_count: number;\r\n    avg_latency_ms: number;\r\n    max_gas_price_gwei: number;\r\n  }): WindowStatus {\r\n    // Insufficient data: treat as normal\r\n    if (metrics.request_count < this.thresholds.min_request_threshold) {\r\n      return 'normal';\r\n    }\r\n\r\n    const error_rate = metrics.error_count / metrics.request_count;\r\n\r\n    // Check anomalous conditions (highest priority)\r\n    if (\r\n      error_rate > this.thresholds.error_rate_anomalous ||\r\n      metrics.avg_latency_ms > this.thresholds.latency_ms_anomalous ||\r\n      metrics.max_gas_price_gwei > this.thresholds.gas_price_gwei_anomalous\r\n    ) {\r\n      return 'anomalous';\r\n    }\r\n\r\n    // Check suspect conditions\r\n    if (\r\n      error_rate > this.thresholds.error_rate_suspect ||\r\n      metrics.avg_latency_ms > this.thresholds.latency_ms_suspect ||\r\n      metrics.max_gas_price_gwei > this.thresholds.gas_price_gwei_suspect\r\n    ) {\r\n      return 'suspect';\r\n    }\r\n\r\n    return 'normal';\r\n  }\r\n\r\n  // ===========================================================================\r\n  // CIRCUIT BREAKER STATE MACHINE\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Update CB state based on window classification.\r\n   * Implements state machine with cooldown + recovery logic.\r\n   */\r\n  private async updateCircuitBreakerState(\r\n    facilitator_id: string,\r\n    chain_id: string,\r\n    current_status: WindowStatus,\r\n    metrics: WindowMetrics\r\n  ): Promise<CircuitBreakerEvent | null> {\r\n    const cb = await getOrCreateCircuitBreaker(facilitator_id, chain_id);\r\n    const now = new Date();\r\n    let newState = cb.state;\r\n    let reason = '';\r\n\r\n    // STATE MACHINE LOGIC\r\n    if (cb.state === 'CLOSED') {\r\n      // CLOSED → OPEN if anomalous\r\n      if (current_status === 'anomalous') {\r\n        newState = 'OPEN';\r\n        reason = 'anomalous_metrics_detected';\r\n        logger.warn({\r\n          facilitator_id,\r\n          chain_id,\r\n          metrics: {\r\n            error_rate: metrics.error_count / metrics.request_count,\r\n            avg_latency_ms: metrics.avg_latency_ms,\r\n            max_gas_price_gwei: metrics.max_gas_price_gwei,\r\n          },\r\n        }, 'Opening circuit breaker');\r\n      }\r\n    } else if (cb.state === 'OPEN') {\r\n      // OPEN → HALF_OPEN after cooldown (5 min default)\r\n      if (cb.opened_at) {\r\n        const minutesInOpen = minutesSince(cb.opened_at, now);\r\n        if (minutesInOpen >= this.cbConfig.cooldown_minutes) {\r\n          newState = 'HALF_OPEN';\r\n          reason = 'cooldown_expired_attempting_recovery';\r\n          logger.info({\r\n            facilitator_id,\r\n            chain_id,\r\n            minutes_in_open: minutesInOpen,\r\n          }, 'Circuit breaker moving to HALF_OPEN');\r\n        }\r\n      }\r\n    } else if (cb.state === 'HALF_OPEN') {\r\n      // HALF_OPEN logic\r\n      if (current_status === 'anomalous') {\r\n        // Failed recovery; back to OPEN\r\n        newState = 'OPEN';\r\n        reason = 'recovery_failed_anomalous_metrics';\r\n        logger.warn({ facilitator_id, chain_id }, 'Recovery failed, reopening circuit');\r\n      } else if (current_status === 'normal') {\r\n        // Check for consecutive normal windows\r\n        const recentWindows = await getRecentAnomalyWindows(\r\n          facilitator_id,\r\n          chain_id,\r\n          this.cbConfig.recovery_success_threshold\r\n        );\r\n\r\n        const consecutiveNormal = recentWindows.filter(\r\n          w => w.status === 'normal'\r\n        ).length;\r\n\r\n        if (consecutiveNormal >= this.cbConfig.recovery_success_threshold) {\r\n          // Recovered; return to CLOSED\r\n          newState = 'CLOSED';\r\n          reason = 'recovery_succeeded';\r\n          logger.info({\r\n            facilitator_id,\r\n            chain_id,\r\n            consecutive_normal: consecutiveNormal,\r\n          }, 'Circuit breaker recovered to CLOSED');\r\n        } else {\r\n          // Check if recovery window expired (10 min default)\r\n          if (cb.half_opened_at) {\r\n            const minutesInHalfOpen = minutesSince(cb.half_opened_at, now);\r\n            if (minutesInHalfOpen >= this.cbConfig.half_open_recovery_window_minutes) {\r\n              newState = 'OPEN';\r\n              reason = 'recovery_window_expired_insufficient_successes';\r\n              logger.warn({\r\n                facilitator_id,\r\n                chain_id,\r\n                consecutive_normal: consecutiveNormal,\r\n                required: this.cbConfig.recovery_success_threshold,\r\n              }, 'Recovery window expired');\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // If state changed, update and record event\r\n    if (newState !== cb.state) {\r\n      await updateCircuitBreakerState({\r\n        facilitator_id,\r\n        chain_id,\r\n        state: newState,\r\n        opened_at: newState === 'OPEN' ? now : (cb.state === 'OPEN' ? cb.opened_at : null),\r\n        half_opened_at: newState === 'HALF_OPEN' ? now : null,\r\n      });\r\n\r\n      const event = await recordCircuitBreakerEvent({\r\n        facilitator_id,\r\n        chain_id,\r\n        old_state: cb.state,\r\n        new_state: newState,\r\n        reason,\r\n        metrics_snapshot: {\r\n          status: current_status,\r\n          request_count: metrics.request_count,\r\n          error_count: metrics.error_count,\r\n          error_rate: metrics.request_count > 0 \r\n            ? metrics.error_count / metrics.request_count \r\n            : 0,\r\n          avg_latency_ms: metrics.avg_latency_ms,\r\n          max_gas_price_gwei: metrics.max_gas_price_gwei,\r\n          time: now.toISOString(),\r\n        },\r\n      });\r\n\r\n      // Notify facilitator asynchronously (don't block)\r\n      this.notifyFacilitatorOfStateChange(\r\n        facilitator_id,\r\n        chain_id,\r\n        cb.state,\r\n        newState,\r\n        reason,\r\n        event.id,\r\n        metrics\r\n      ).catch(err => {\r\n        logger.warn({ err, facilitator_id }, 'Failed to send webhook notification');\r\n      });\r\n\r\n      return event;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  // ===========================================================================\r\n  // WEBHOOK NOTIFICATIONS\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Notify facilitator of CB state change via webhook.\r\n   */\r\n  private async notifyFacilitatorOfStateChange(\r\n    facilitator_id: string,\r\n    chain_id: string,\r\n    old_state: CircuitBreakerState,\r\n    new_state: CircuitBreakerState,\r\n    reason: string,\r\n    eventId: string,\r\n    metrics: WindowMetrics\r\n  ): Promise<void> {\r\n    try {\r\n      // Get facilitator callback URL\r\n      const callbackUrl = await getFacilitatorCallbackUrl(facilitator_id);\r\n\r\n      if (!callbackUrl) {\r\n        return; // No callback URL configured\r\n      }\r\n\r\n      const payload: CircuitBreakerWebhookPayload = {\r\n        event: 'circuit_breaker_state_changed',\r\n        timestamp: new Date().toISOString(),\r\n        facilitator_id,\r\n        chain_id,\r\n        old_state,\r\n        new_state,\r\n        reason,\r\n        action_required: getActionRequired(new_state),\r\n        metrics: {\r\n          error_rate: metrics.request_count > 0 \r\n            ? metrics.error_count / metrics.request_count \r\n            : 0,\r\n          avg_latency_ms: metrics.avg_latency_ms,\r\n          max_gas_price_gwei: metrics.max_gas_price_gwei,\r\n        },\r\n      };\r\n\r\n      // POST with timeout\r\n      const controller = new AbortController();\r\n      const timeout = setTimeout(() => controller.abort(), 5000);\r\n\r\n      const response = await fetch(callbackUrl, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify(payload),\r\n        signal: controller.signal,\r\n      });\r\n\r\n      clearTimeout(timeout);\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Callback returned ${response.status}`);\r\n      }\r\n\r\n      // Mark event as notified\r\n      await markNotificationSent(eventId);\r\n\r\n      logger.info({\r\n        facilitator_id,\r\n        chain_id,\r\n        old_state,\r\n        new_state,\r\n      }, 'Webhook notification sent');\r\n    } catch (error) {\r\n      const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n      logger.warn({\r\n        facilitator_id,\r\n        chain_id,\r\n        error: errorMsg,\r\n      }, 'Failed to notify facilitator');\r\n\r\n      // Mark event with error\r\n      await markNotificationSent(eventId, errorMsg);\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // STATE QUERIES\r\n  // ===========================================================================\r\n\r\n  /**\r\n   * Get current CB state for a facilitator+chain.\r\n   */\r\n  async getCircuitBreakerState(\r\n    facilitator_id: string,\r\n    chain_id: string\r\n  ): Promise<CircuitBreakerState> {\r\n    const cb = await getOrCreateCircuitBreaker(facilitator_id, chain_id);\r\n    return cb.state;\r\n  }\r\n\r\n  /**\r\n   * Get full CB info for a facilitator+chain.\r\n   */\r\n  async getCircuitBreaker(\r\n    facilitator_id: string,\r\n    chain_id: string\r\n  ) {\r\n    return getOrCreateCircuitBreaker(facilitator_id, chain_id);\r\n  }\r\n\r\n  /**\r\n   * Get configuration values (for testing/debugging)\r\n   */\r\n  getConfig() {\r\n    return {\r\n      thresholds: this.thresholds,\r\n      cbConfig: this.cbConfig,\r\n    };\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// SINGLETON INSTANCE\r\n// =============================================================================\r\n\r\nlet anomalyDetectorInstance: AnomalyDetector | null = null;\r\n\r\n/**\r\n * Get the singleton AnomalyDetector instance.\r\n */\r\nexport function getAnomalyDetector(): AnomalyDetector {\r\n  if (!anomalyDetectorInstance) {\r\n    anomalyDetectorInstance = new AnomalyDetector();\r\n  }\r\n  return anomalyDetectorInstance;\r\n}\r\n\r\n/**\r\n * Reset the singleton (for testing)\r\n */\r\nexport function resetAnomalyDetector(): void {\r\n  anomalyDetectorInstance = null;\r\n}\r\n\r\n","// =============================================================================\r\n// VERCEL CRON ENDPOINT: Anomaly Evaluation\r\n// =============================================================================\r\n// GET /api/cron/evaluate-anomalies\r\n// Closes metric windows, evaluates anomalies, and updates circuit breaker states.\r\n// Called by Vercel Cron every 5 minutes (schedule: \"*/5 * * * *\")\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { withCronJobTracking, type CronJobContext } from '@/lib/cron-job-wrapper';\r\nimport { getAnomalyDetector } from '@/services/smf/anomaly-detector';\r\nimport { getActiveBuffers } from '@/db/anomalies';\r\nimport type { EvaluateAnomaliesResult } from '@/types/anomaly-detection';\r\n\r\nconst logger = createLogger({ component: 'AnomalyEvaluationCron' });\r\n\r\n// =============================================================================\r\n// CRON HANDLER\r\n// =============================================================================\r\n\r\nasync function evaluateAnomaliesHandler(\r\n  _request: NextRequest,\r\n  context: CronJobContext\r\n): Promise<EvaluateAnomaliesResult> {\r\n  const { runId, requestId } = context;\r\n\r\n  logger.info({ runId, requestId }, 'Starting anomaly evaluation job');\r\n\r\n  const anomalyDetector = getAnomalyDetector();\r\n  const errors: string[] = [];\r\n\r\n  try {\r\n    // Get all facilitators with recent metric activity\r\n    const activeBuffers = await getActiveBuffers(10);\r\n\r\n    if (activeBuffers.length === 0) {\r\n      logger.info({ runId, requestId }, 'No active metric buffers to evaluate');\r\n      return {\r\n        success: true,\r\n        facilitators_evaluated: 0,\r\n        cb_events_triggered: 0,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    }\r\n\r\n    let evaluatedCount = 0;\r\n    let eventsTriggered = 0;\r\n\r\n    // Evaluate each facilitator+chain combination\r\n    for (const buffer of activeBuffers) {\r\n      try {\r\n        const event = await anomalyDetector.closeAndEvaluateWindow(\r\n          buffer.facilitator_id,\r\n          buffer.chain_id\r\n        );\r\n\r\n        evaluatedCount++;\r\n        if (event) {\r\n          eventsTriggered++;\r\n          logger.info({\r\n            runId,\r\n            facilitator_id: buffer.facilitator_id,\r\n            chain_id: buffer.chain_id,\r\n            old_state: event.old_state,\r\n            new_state: event.new_state,\r\n            reason: event.reason,\r\n          }, 'Circuit breaker state changed');\r\n        }\r\n      } catch (error) {\r\n        const errMsg = `${buffer.facilitator_id}/${buffer.chain_id}: ${error instanceof Error ? error.message : 'Unknown error'}`;\r\n        errors.push(errMsg);\r\n        logger.error({\r\n          runId,\r\n          facilitator_id: buffer.facilitator_id,\r\n          chain_id: buffer.chain_id,\r\n          error,\r\n        }, 'Failed to evaluate anomaly window');\r\n      }\r\n    }\r\n\r\n    logger.info({\r\n      runId,\r\n      requestId,\r\n      facilitators_evaluated: evaluatedCount,\r\n      cb_events_triggered: eventsTriggered,\r\n      errors_count: errors.length,\r\n    }, 'Anomaly evaluation job completed');\r\n\r\n    return {\r\n      success: errors.length === 0,\r\n      facilitators_evaluated: evaluatedCount,\r\n      cb_events_triggered: eventsTriggered,\r\n      timestamp: new Date().toISOString(),\r\n      errors: errors.length > 0 ? errors : undefined,\r\n    };\r\n  } catch (error) {\r\n    const errMsg = error instanceof Error ? error.message : 'Unknown error';\r\n    logger.error({ runId, requestId, error }, 'Anomaly evaluation job failed');\r\n\r\n    return {\r\n      success: false,\r\n      facilitators_evaluated: 0,\r\n      cb_events_triggered: 0,\r\n      timestamp: new Date().toISOString(),\r\n      errors: [errMsg],\r\n    };\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// EXPORTS\r\n// =============================================================================\r\n\r\nexport const dynamic = 'force-dynamic';\r\nexport const maxDuration = 60;\r\n\r\nexport const GET = withCronJobTracking(evaluateAnomaliesHandler, {\r\n  jobId: 'evaluate-anomalies',\r\n  enabledEnvVar: 'ANOMALY_EVALUATION_ENABLED',\r\n  timeout: 55000, // 55s (leave buffer for wrapper overhead)\r\n  minInterval: 4 * 60 * 1000, // 4 minutes (schedule is every 5 minutes)\r\n});\r\n\r\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n"],"names":["AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","addRequestMeta","getRequestMeta","getTracer","SpanKind","setReferenceManifestsSingleton","createServerModuleMap","normalizeAppPath","NodeNextRequest","NodeNextResponse","NextRequestAdapter","signalFromNodeResponse","BaseServerSpan","getRevalidateReason","sendResponse","fromNodeOutgoingHttpHeaders","toNodeOutgoingHttpHeaders","getCacheControlHeader","INFINITE_CACHE","NEXT_CACHE_TAGS_HEADER","NoFallbackError","CachedRouteKind","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks","handler","req","res","ctx","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","params","nextConfig","parsedUrl","isDraftMode","prerenderManifest","routerServerContext","isOnDemandRevalidate","revalidateOnlyGenerated","resolvedPathname","clientReferenceManifest","serverActionsManifest","normalizedSrcPage","isIsr","Boolean","dynamicRoutes","routes","render404","isPrerendered","prerenderInfo","fallback","experimental","adapterPath","cacheKey","supportsDynamicResponse","isStaticGeneration","serverModuleMap","method","tracer","activeSpan","getActiveScopeSpan","context","renderOpts","authInterrupts","cacheComponents","incrementalCache","cacheLifeProfiles","cacheLife","onClose","cb","on","onAfterTaskError","undefined","onInstrumentationRequestError","error","_request","errorContext","onRequestError","sharedContext","nodeNextReq","nodeNextRes","nextReq","fromNodeNextRequest","invokeRouteModule","span","handle","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","isMinimalMode","MINIMAL_MODE","handleResponse","currentSpan","cacheEntry","responseGenerator","previousCacheEntry","setHeader","response","fetchMetrics","pendingWaitUntil","cacheTags","collectedTags","blob","headers","type","revalidate","collectedRevalidate","expire","collectedExpire","value","status","body","Buffer","from","arrayBuffer","cacheControl","err","isStale","routerKind","routePath","routeType","revalidateReason","routeKind","isFallback","isRoutePPREnabled","Error","isMiss","delete","getHeader","set","Response","withPropagatedContext","trace","spanName","SERVER","attributes","url"],"mappings":"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","ignoreList":[5]}