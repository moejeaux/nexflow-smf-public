module.exports=[93695,(e,t,r)=>{t.exports=e.x("next/dist/shared/lib/no-fallback-error.external.js",()=>require("next/dist/shared/lib/no-fallback-error.external.js"))},22734,(e,t,r)=>{t.exports=e.x("fs",()=>require("fs"))},30056,e=>e.a(async(t,r)=>{try{let t=await e.y("pg");e.n(t),r()}catch(e){r(e)}},!0),14747,(e,t,r)=>{t.exports=e.x("path",()=>require("path"))},70406,(e,t,r)=>{t.exports=e.x("next/dist/compiled/@opentelemetry/api",()=>require("next/dist/compiled/@opentelemetry/api"))},18622,(e,t,r)=>{t.exports=e.x("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js",()=>require("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js"))},56704,(e,t,r)=>{t.exports=e.x("next/dist/server/app-render/work-async-storage.external.js",()=>require("next/dist/server/app-render/work-async-storage.external.js"))},32319,(e,t,r)=>{t.exports=e.x("next/dist/server/app-render/work-unit-async-storage.external.js",()=>require("next/dist/server/app-render/work-unit-async-storage.external.js"))},24725,(e,t,r)=>{t.exports=e.x("next/dist/server/app-render/after-task-async-storage.external.js",()=>require("next/dist/server/app-render/after-task-async-storage.external.js"))},24361,(e,t,r)=>{t.exports=e.x("util",()=>require("util"))},87769,(e,t,r)=>{t.exports=e.x("node:events",()=>require("node:events"))},49719,(e,t,r)=>{t.exports=e.x("assert",()=>require("assert"))},27699,(e,t,r)=>{t.exports=e.x("events",()=>require("events"))},92509,(e,t,r)=>{t.exports=e.x("url",()=>require("url"))},874,(e,t,r)=>{t.exports=e.x("buffer",()=>require("buffer"))},62562,(e,t,r)=>{t.exports=e.x("module",()=>require("module"))},50227,(e,t,r)=>{t.exports=e.x("node:path",()=>require("node:path"))},94346,e=>{e.v({name:"thread-stream",version:"3.1.0",description:"A streaming way to send data to a Node.js Worker Thread",main:"index.js",types:"index.d.ts",dependencies:{"real-require":"^0.2.0"},devDependencies:{"@types/node":"^20.1.0","@types/tap":"^15.0.0","@yao-pkg/pkg":"^5.11.5",desm:"^1.3.0",fastbench:"^1.0.1",husky:"^9.0.6","pino-elasticsearch":"^8.0.0","sonic-boom":"^4.0.1",standard:"^17.0.0",tap:"^16.2.0","ts-node":"^10.8.0",typescript:"^5.3.2","why-is-node-running":"^2.2.2"},scripts:{build:"tsc --noEmit",test:'standard && npm run build && npm run transpile && tap "test/**/*.test.*js" && tap --ts test/*.test.*ts',"test:ci":"standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts","test:ci:js":'tap --no-check-coverage --timeout=120 --coverage-report=lcovonly "test/**/*.test.*js"',"test:ci:ts":'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',"test:yarn":'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',transpile:"sh ./test/ts/transpile.sh",prepare:"husky install"},standard:{ignore:["test/ts/**/*","test/syntax-error.mjs"]},repository:{type:"git",url:"git+https://github.com/mcollina/thread-stream.git"},keywords:["worker","thread","threads","stream"],author:"Matteo Collina <hello@matteocollina.com>",license:"MIT",bugs:{url:"https://github.com/mcollina/thread-stream/issues"},homepage:"https://github.com/mcollina/thread-stream#readme"})},37702,(e,t,r)=>{t.exports=e.x("worker_threads",()=>require("worker_threads"))},60526,(e,t,r)=>{t.exports=e.x("node:os",()=>require("node:os"))},77652,(e,t,r)=>{t.exports=e.x("node:diagnostics_channel",()=>require("node:diagnostics_channel"))},54799,(e,t,r)=>{t.exports=e.x("crypto",()=>require("crypto"))},68237,e=>e.a(async(t,r)=>{try{var a=e.i(54799),n=e.i(24924),s=t([n]);function i(e){return a.default.createHash("sha256").update(e).digest("hex")}async function o(e){let t,r=(0,n.getDb)(),s=`key_${Date.now()}_${Math.random().toString(36).substring(2,9)}`,o=(t=a.default.randomBytes(32).toString("base64url"),`nf_live_${t}`),u=i(o),l=new Date().toISOString(),c={id:s,keyHash:u,name:e.name,role:e.role||"user",userId:e.userId,rateLimit:e.rateLimit||1e3,expiresAt:e.expiresAt,createdAt:l,updatedAt:l};return await r.createApiKey(c),{...c,token:o}}async function u(e){let t=(0,n.getDb)();return await t.findApiKeyByHash(e)}async function l(e){let t=i(e);return await u(t)}async function c(e,t){let r=(0,n.getDb)();await r.updateApiKeyLastUsed(e,t)}async function p(e){let t=(0,n.getDb)();return await t.revokeApiKey(e)}async function d(e){let t=(0,n.getDb)();return await t.listApiKeys(e)}async function m(e,t,r){let a=(0,n.getDb)();await a.updateApiKeyX402DemoAllowance(e,t,r)}function _(e){let t=e.x402DemoCallsUsed||0,r=e.x402DemoCallsLimit||200,a=BigInt(e.x402DemoAmountUsed||"0"),n=BigInt(e.x402DemoAmountLimit||"1000000");return t>=r?{hasAllowance:!1,callsRemaining:0,amountRemaining:"0",reason:"Calls limit reached"}:a>=n?{hasAllowance:!1,callsRemaining:r-t,amountRemaining:"0",reason:"Amount limit reached"}:{hasAllowance:!0,callsRemaining:r-t,amountRemaining:(n-a).toString()}}async function y(e,t,r){let a=(0,n.getDb)();await a.updateApiKeyX402DemoLimits(e,t,r)}async function g(e){return(await d()).find(t=>t.id===e)||null}[n]=s.then?(await s)():s,e.s(["createApiKey",()=>o,"findApiKeyById",()=>g,"findApiKeyByToken",()=>l,"hasX402DemoAllowance",()=>_,"listApiKeys",()=>d,"revokeApiKey",()=>p,"updateApiKeyLastUsed",()=>c,"updateApiKeyX402DemoAllowance",()=>m,"updateApiKeyX402DemoLimits",()=>y]),r()}catch(e){r(e)}},!1),79832,e=>e.a(async(t,r)=>{try{var a=e.i(89171),n=e.i(68237),s=t([n]);function i(e){let t=e.headers.get("x-api-key");if(t)return t.trim();let r=e.headers.get("authorization");return r?r.startsWith("Bearer ")?r.substring(7).trim():r.trim():null}async function o(e){let t=i(e);if(!t)return{error:"Authentication required",status:401};if(!t.startsWith("nf_live_")&&!t.startsWith("nf_test_"))return{error:"Invalid API key format",status:401};let r=await (0,n.findApiKeyByToken)(t);if(!r)return{error:"Invalid API key",status:401};if(r.expiresAt&&new Date(r.expiresAt)<new Date)return{error:"API key has expired",status:401};let a=e.ip||e.headers.get("x-forwarded-for")?.split(",")[0]?.trim()||e.headers.get("x-real-ip")||void 0;return(0,n.updateApiKeyLastUsed)(r.id,a).catch(e=>{console.error("[auth] Failed to update last used:",e)}),{apiKey:r}}async function u(e,t="user"){var r;let n,s=await o(e);return"error"in s?{response:a.NextResponse.json({error:s.error,code:"UNAUTHORIZED"},{status:s.status})}:(r=s.apiKey,(n={"read-only":1,user:2,admin:3})[r.role]>=n[t])?{apiKey:s.apiKey}:{response:a.NextResponse.json({error:"Insufficient permissions",code:"FORBIDDEN",details:`Required role: ${t}, your role: ${s.apiKey.role}`},{status:403})}}[n]=s.then?(await s)():s,e.s(["authenticateRequest",()=>o,"extractApiKey",()=>i,"requireAuth",()=>u]),r()}catch(e){r(e)}},!1),36080,e=>e.a(async(t,r)=>{try{var a=e.i(24924),n=e.i(50377),s=t([a]);async function i(e){let t=(0,a.getDb)(),r=crypto.randomUUID();return"pool"in t?(await t.query(`INSERT INTO cron_job_runs (id, job_id, status, trigger_source, attempt_number, input_params, metadata)
       VALUES ($1, $2, 'running', $3, $4, $5, $6)
       RETURNING *`,[r,e.jobId,e.triggerSource||"cron",e.attemptNumber||1,e.inputParams?JSON.stringify(e.inputParams):null,e.metadata?JSON.stringify(e.metadata):null])).rows[0]:(t.prepare(`INSERT INTO cron_job_runs (id, job_id, status, trigger_source, attempt_number, input_params, metadata, started_at, created_at)
       VALUES (?, ?, 'running', ?, ?, ?, ?, datetime('now'), datetime('now'))`).run(r,e.jobId,e.triggerSource||"cron",e.attemptNumber||1,e.inputParams?JSON.stringify(e.inputParams):null,e.metadata?JSON.stringify(e.metadata):null),t.prepare("SELECT * FROM cron_job_runs WHERE id = ?").get(r))}async function o(e){let t=(0,a.getDb)();"pool"in t?await t.query(`UPDATE cron_job_runs
       SET status = $1,
           completed_at = now(),
           duration_ms = EXTRACT(EPOCH FROM (now() - started_at)) * 1000,
           output_summary = $2,
           error_message = $3,
           error_stack = $4
       WHERE id = $5`,[e.status,e.outputSummary?JSON.stringify(e.outputSummary):null,e.errorMessage||null,e.errorStack||null,e.runId]):t.prepare(`UPDATE cron_job_runs
       SET status = ?,
           completed_at = datetime('now'),
           duration_ms = (julianday('now') - julianday(started_at)) * 86400000,
           output_summary = ?,
           error_message = ?,
           error_stack = ?
       WHERE id = ?`).run(e.status,e.outputSummary?JSON.stringify(e.outputSummary):null,e.errorMessage||null,e.errorStack||null,e.runId),await u(e)}async function u(e){let t,r=(0,a.getDb)();if("pool"in r){let a=await r.query("SELECT job_id FROM cron_job_runs WHERE id = $1",[e.runId]);if(0===a.rows.length)return;t=a.rows[0].job_id}else{let a=r.prepare("SELECT job_id FROM cron_job_runs WHERE id = ?").get(e.runId);if(!a)return;t=a.job_id}"completed"===e.status?"pool"in r?await r.query(`UPDATE cron_job_config
         SET consecutive_failures = 0, last_success_at = now(), updated_at = now()
         WHERE job_id = $1`,[t]):r.prepare(`UPDATE cron_job_config
         SET consecutive_failures = 0, last_success_at = datetime('now'), updated_at = datetime('now')
         WHERE job_id = ?`).run(t):("failed"===e.status||"timeout"===e.status)&&("pool"in r?await r.query(`UPDATE cron_job_config
         SET consecutive_failures = consecutive_failures + 1, last_failure_at = now(), updated_at = now()
         WHERE job_id = $1`,[t]):r.prepare(`UPDATE cron_job_config
         SET consecutive_failures = consecutive_failures + 1, last_failure_at = datetime('now'), updated_at = datetime('now')
         WHERE job_id = ?`).run(t))}async function l(e,t=20){let r=(0,a.getDb)();return"pool"in r?(await r.query(`SELECT * FROM cron_job_runs
       WHERE job_id = $1
       ORDER BY started_at DESC
       LIMIT $2`,[e,t])).rows:r.prepare(`SELECT * FROM cron_job_runs
       WHERE job_id = ?
       ORDER BY started_at DESC
       LIMIT ?`).all(e,t)}async function c(e=50){let t=(0,a.getDb)();return"pool"in t?(await t.query(`SELECT * FROM cron_job_runs
       ORDER BY started_at DESC
       LIMIT $1`,[e])).rows:t.prepare(`SELECT * FROM cron_job_runs
       ORDER BY started_at DESC
       LIMIT ?`).all(e)}async function p(e){let t=(0,a.getDb)();return"pool"in t?(await t.query("SELECT * FROM cron_job_config WHERE job_id = $1",[e])).rows[0]||null:t.prepare("SELECT * FROM cron_job_config WHERE job_id = ?").get(e)}async function d(){let e=(0,a.getDb)();return"pool"in e?(await e.query("SELECT * FROM cron_job_config ORDER BY job_id")).rows:e.prepare("SELECT * FROM cron_job_config ORDER BY job_id").all()}async function m(e=3){let t=(0,a.getDb)();return"pool"in t?(await t.query(`SELECT * FROM cron_job_config
       WHERE consecutive_failures >= $1 AND alert_on_failure = true
       ORDER BY consecutive_failures DESC`,[e])).rows:t.prepare(`SELECT * FROM cron_job_config
       WHERE consecutive_failures >= ? AND alert_on_failure = 1
       ORDER BY consecutive_failures DESC`).all(e)}[a]=s.then?(await s)():s,(0,n.createLogger)({component:"CronJobDb"}),e.s(["completeJobRun",()=>o,"createJobRun",()=>i,"getAllJobConfigs",()=>d,"getAllRecentRuns",()=>c,"getFailingJobs",()=>m,"getJobConfig",()=>p,"getRecentJobRuns",()=>l]),r()}catch(e){r(e)}},!1)];

//# sourceMappingURL=%5Broot-of-the-server%5D__c269c2ef._.js.map