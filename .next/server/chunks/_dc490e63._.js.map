{"version":3,"sources":["../../../src/agents/routing-tuner.ts","../../../src/agents/pricing-tuner.ts","../../../src/agents/scout-tuner.ts","../../../src/agents/coordinator.ts","../../../src/db/routing-experiments.ts","../../../src/agents/bandit-routing.ts","../../../src/app/api/cron/coord/route.ts","../../../node_modules/next/src/build/templates/app-route.ts"],"sourcesContent":["// =============================================================================\r\n// ROUTING TUNER AGENT\r\n// =============================================================================\r\n// Analyzes facilitator performance and proposes routing changes\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  WorldState,\r\n  FacilitatorState,\r\n  AgentRecommendation,\r\n  RoutingTunerOutput,\r\n} from './types';\r\n\r\nconst logger = createLogger({ component: 'RoutingTuner' });\r\n\r\n// =============================================================================\r\n// CONFIGURATION (can be overridden via env vars)\r\n// =============================================================================\r\n\r\nexport const ROUTING_TUNER_CONFIG = {\r\n  // Thresholds for deprioritization\r\n  deprioritizeSuccessRateThreshold: parseFloat(\r\n    process.env.ROUTING_TUNER_DEPRIORITIZE_SUCCESS_RATE || '0.85'\r\n  ),\r\n  deprioritizeLatencyThresholdMs: parseInt(\r\n    process.env.ROUTING_TUNER_DEPRIORITIZE_LATENCY_MS || '3000', 10\r\n  ),\r\n  \r\n  // Thresholds for promotion\r\n  promoteSuccessRateThreshold: parseFloat(\r\n    process.env.ROUTING_TUNER_PROMOTE_SUCCESS_RATE || '0.98'\r\n  ),\r\n  promoteLatencyThresholdMs: parseInt(\r\n    process.env.ROUTING_TUNER_PROMOTE_LATENCY_MS || '500', 10\r\n  ),\r\n  \r\n  // Minimum data requirements\r\n  minInvocationsForDecision: parseInt(\r\n    process.env.ROUTING_TUNER_MIN_INVOCATIONS || '100', 10\r\n  ),\r\n  \r\n  // Confidence thresholds\r\n  highConfidenceThreshold: parseFloat(\r\n    process.env.ROUTING_TUNER_HIGH_CONFIDENCE || '0.8'\r\n  ),\r\n  mediumConfidenceThreshold: parseFloat(\r\n    process.env.ROUTING_TUNER_MEDIUM_CONFIDENCE || '0.5'\r\n  ),\r\n  \r\n  // How many top performers to track\r\n  topPerformersCount: parseInt(\r\n    process.env.ROUTING_TUNER_TOP_PERFORMERS || '3', 10\r\n  ),\r\n};\r\n\r\n// =============================================================================\r\n// ROUTING TUNER\r\n// =============================================================================\r\n\r\n/**\r\n * Run the routing tuner to analyze facilitator performance\r\n */\r\nexport async function runRoutingTuner(worldState: WorldState): Promise<RoutingTunerOutput> {\r\n  const recommendations: AgentRecommendation[] = [];\r\n  const now = new Date();\r\n\r\n  logger.info({ facilitatorCount: worldState.facilitators.length, msg: 'Running routing tuner' });\r\n\r\n  // 1. Identify top performers\r\n  const sortedByScore = [...worldState.facilitators]\r\n    .filter((f) => f.totalInvocations >= ROUTING_TUNER_CONFIG.minInvocationsForDecision)\r\n    .sort((a, b) => b.score - a.score);\r\n\r\n  const topPerformers = sortedByScore\r\n    .slice(0, ROUTING_TUNER_CONFIG.topPerformersCount)\r\n    .map((f) => f.id);\r\n\r\n  // 2. Identify underperformers (low success rate or high latency)\r\n  const underperformers: string[] = [];\r\n  const newContenders: string[] = [];\r\n\r\n  for (const facilitator of worldState.facilitators) {\r\n    const analysis = analyzeFacilitator(facilitator);\r\n\r\n    // Check if facilitator should be deprioritized\r\n    if (analysis.shouldDeprioritize && analysis.deprioritizeReasonCode) {\r\n      underperformers.push(facilitator.id);\r\n      \r\n      recommendations.push(createDeprioritizeRecommendation(\r\n        facilitator,\r\n        analysis.deprioritizeReasons,\r\n        analysis.deprioritizeReasonCode,\r\n        analysis.confidence,\r\n        now\r\n      ));\r\n    }\r\n\r\n    // Check if facilitator should be promoted\r\n    if (analysis.shouldPromote && !topPerformers.includes(facilitator.id)) {\r\n      newContenders.push(facilitator.id);\r\n      \r\n      recommendations.push(createPromoteRecommendation(\r\n        facilitator,\r\n        analysis.promoteReasons,\r\n        analysis.confidence,\r\n        now\r\n      ));\r\n    }\r\n  }\r\n\r\n  // 3. Check for risk anomalies that need routing changes\r\n  for (const anomaly of worldState.riskAnomalies) {\r\n    if (anomaly.severity === 'critical' && anomaly.facilitatorId) {\r\n      // Check if we already have a recommendation for this facilitator\r\n      const existingRec = recommendations.find(\r\n        (r) => r.facilitatorId === anomaly.facilitatorId && r.type === 'FACILITATOR_DEPRIORITIZE'\r\n      );\r\n\r\n      if (!existingRec) {\r\n        const reasonCode: DeprioritizeReasonCode = 'risk_anomaly';\r\n        \r\n        // Log the risk anomaly deprioritization\r\n        logger.info({\r\n          facilitatorId: anomaly.facilitatorId,\r\n          reason: reasonCode,\r\n          type: 'FACILITATOR_DEPRIORITIZE',\r\n          priority: 'critical',\r\n          confidence: 0.9,\r\n          anomalyId: anomaly.id,\r\n          anomalyType: anomaly.type,\r\n          anomalyDescription: anomaly.description,\r\n          msg: 'Routing tuner deprioritized facilitator',\r\n        });\r\n\r\n        recommendations.push({\r\n          id: crypto.randomUUID(),\r\n          createdAt: now,\r\n          agent: 'routing_tuner',\r\n          type: 'FACILITATOR_DEPRIORITIZE',\r\n          facilitatorId: anomaly.facilitatorId,\r\n          priority: 'critical',\r\n          confidence: 0.9,\r\n          details: {\r\n            reason: reasonCode,\r\n            anomalyId: anomaly.id,\r\n            anomalyType: anomaly.type,\r\n            metrics: anomaly.metrics,\r\n          },\r\n          reasoning: `Critical risk anomaly detected: ${anomaly.description}`,\r\n          status: 'PENDING',\r\n          expiresAt: new Date(now.getTime() + 24 * 60 * 60 * 1000), // Expires in 24h\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  const output: RoutingTunerOutput = {\r\n    recommendations,\r\n    analysis: {\r\n      topPerformers,\r\n      underperformers,\r\n      newContenders,\r\n    },\r\n  };\r\n\r\n  logger.info({\r\n    topPerformers,\r\n    underperformers,\r\n    newContenders,\r\n    recommendationCount: recommendations.length,\r\n    msg: 'Routing tuner completed',\r\n  });\r\n\r\n  return output;\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\n// Reason codes for deprioritization (for structured logging and querying)\r\nexport type DeprioritizeReasonCode =\r\n  | 'low_success_rate'\r\n  | 'high_latency'\r\n  | 'degraded_status'\r\n  | 'down_status'\r\n  | 'risk_anomaly'\r\n  | 'multiple_issues';\r\n\r\ninterface FacilitatorAnalysis {\r\n  shouldDeprioritize: boolean;\r\n  deprioritizeReasons: string[];\r\n  deprioritizeReasonCode: DeprioritizeReasonCode | null;\r\n  shouldPromote: boolean;\r\n  promoteReasons: string[];\r\n  confidence: number;\r\n}\r\n\r\n/**\r\n * Analyze a single facilitator\r\n */\r\nfunction analyzeFacilitator(facilitator: FacilitatorState): FacilitatorAnalysis {\r\n  const deprioritizeReasons: string[] = [];\r\n  const promoteReasons: string[] = [];\r\n  const issueFlags: DeprioritizeReasonCode[] = [];\r\n\r\n  // Determine confidence based on data\r\n  let confidence = 0;\r\n  if (facilitator.confidence === 'high') {\r\n    confidence = ROUTING_TUNER_CONFIG.highConfidenceThreshold + 0.1;\r\n  } else if (facilitator.confidence === 'medium') {\r\n    confidence = ROUTING_TUNER_CONFIG.mediumConfidenceThreshold + 0.2;\r\n  } else if (facilitator.confidence === 'low') {\r\n    confidence = ROUTING_TUNER_CONFIG.mediumConfidenceThreshold;\r\n  } else {\r\n    confidence = 0.3; // Low confidence for no data\r\n  }\r\n\r\n  // Not enough data to make decisions\r\n  if (facilitator.totalInvocations < ROUTING_TUNER_CONFIG.minInvocationsForDecision) {\r\n    return {\r\n      shouldDeprioritize: false,\r\n      deprioritizeReasons: [],\r\n      deprioritizeReasonCode: null,\r\n      shouldPromote: false,\r\n      promoteReasons: [],\r\n      confidence: 0.2,\r\n    };\r\n  }\r\n\r\n  // Check for deprioritization\r\n  if (facilitator.successRate < ROUTING_TUNER_CONFIG.deprioritizeSuccessRateThreshold) {\r\n    deprioritizeReasons.push(\r\n      `Success rate ${(facilitator.successRate * 100).toFixed(1)}% below threshold ${ROUTING_TUNER_CONFIG.deprioritizeSuccessRateThreshold * 100}%`\r\n    );\r\n    issueFlags.push('low_success_rate');\r\n  }\r\n\r\n  if (facilitator.avgLatencyMs > ROUTING_TUNER_CONFIG.deprioritizeLatencyThresholdMs) {\r\n    deprioritizeReasons.push(\r\n      `Average latency ${facilitator.avgLatencyMs}ms exceeds threshold ${ROUTING_TUNER_CONFIG.deprioritizeLatencyThresholdMs}ms`\r\n    );\r\n    issueFlags.push('high_latency');\r\n  }\r\n\r\n  if (facilitator.status === 'down') {\r\n    deprioritizeReasons.push(`Facilitator status is down`);\r\n    issueFlags.push('down_status');\r\n  } else if (facilitator.status === 'degraded') {\r\n    deprioritizeReasons.push(`Facilitator status is degraded`);\r\n    issueFlags.push('degraded_status');\r\n  }\r\n\r\n  // Check for promotion\r\n  if (\r\n    facilitator.successRate >= ROUTING_TUNER_CONFIG.promoteSuccessRateThreshold &&\r\n    facilitator.avgLatencyMs <= ROUTING_TUNER_CONFIG.promoteLatencyThresholdMs\r\n  ) {\r\n    promoteReasons.push(\r\n      `Excellent performance: ${(facilitator.successRate * 100).toFixed(1)}% success, ${facilitator.avgLatencyMs}ms latency`\r\n    );\r\n  }\r\n\r\n  if (facilitator.score >= 90) {\r\n    promoteReasons.push(`High composite score: ${facilitator.score.toFixed(1)}`);\r\n  }\r\n\r\n  // Determine primary reason code\r\n  let deprioritizeReasonCode: DeprioritizeReasonCode | null = null;\r\n  if (issueFlags.length > 1) {\r\n    deprioritizeReasonCode = 'multiple_issues';\r\n  } else if (issueFlags.length === 1) {\r\n    deprioritizeReasonCode = issueFlags[0];\r\n  }\r\n\r\n  return {\r\n    shouldDeprioritize: deprioritizeReasons.length > 0,\r\n    deprioritizeReasons,\r\n    deprioritizeReasonCode,\r\n    shouldPromote: promoteReasons.length > 0 && deprioritizeReasons.length === 0,\r\n    promoteReasons,\r\n    confidence,\r\n  };\r\n}\r\n\r\n/**\r\n * Create a deprioritize recommendation\r\n */\r\nfunction createDeprioritizeRecommendation(\r\n  facilitator: FacilitatorState,\r\n  reasons: string[],\r\n  reasonCode: DeprioritizeReasonCode,\r\n  confidence: number,\r\n  now: Date\r\n): AgentRecommendation {\r\n  // Determine priority based on severity\r\n  let priority: 'low' | 'medium' | 'high' | 'critical' = 'medium';\r\n  if (facilitator.successRate < 0.5 || facilitator.status === 'down') {\r\n    priority = 'critical';\r\n  } else if (facilitator.successRate < 0.7) {\r\n    priority = 'high';\r\n  }\r\n\r\n  // Log the deprioritization decision\r\n  logger.info({\r\n    facilitatorId: facilitator.id,\r\n    reason: reasonCode,\r\n    type: 'FACILITATOR_DEPRIORITIZE',\r\n    priority,\r\n    confidence,\r\n    successRate: facilitator.successRate,\r\n    avgLatencyMs: facilitator.avgLatencyMs,\r\n    status: facilitator.status,\r\n    triggeredConditions: reasons,\r\n    msg: 'Routing tuner deprioritized facilitator',\r\n  });\r\n\r\n  return {\r\n    id: crypto.randomUUID(),\r\n    createdAt: now,\r\n    agent: 'routing_tuner',\r\n    type: 'FACILITATOR_DEPRIORITIZE',\r\n    facilitatorId: facilitator.id,\r\n    priority,\r\n    confidence,\r\n    details: {\r\n      // Primary reason code for easy querying\r\n      reason: reasonCode,\r\n      // Metrics snapshot at decision time\r\n      metricsSnapshot: {\r\n        timestamp: now.toISOString(),\r\n        score: facilitator.score,\r\n        successRate: facilitator.successRate,\r\n        avgLatencyMs: facilitator.avgLatencyMs,\r\n        p95LatencyMs: facilitator.p95LatencyMs,\r\n        totalInvocations: facilitator.totalInvocations,\r\n        trustTier: facilitator.trustTier,\r\n        status: facilitator.status,\r\n        confidence: facilitator.confidence,\r\n      },\r\n      // Thresholds used for decision\r\n      thresholdsUsed: {\r\n        deprioritizeSuccessRate: ROUTING_TUNER_CONFIG.deprioritizeSuccessRateThreshold,\r\n        deprioritizeLatencyMs: ROUTING_TUNER_CONFIG.deprioritizeLatencyThresholdMs,\r\n        minInvocations: ROUTING_TUNER_CONFIG.minInvocationsForDecision,\r\n      },\r\n      // Conditions that triggered this recommendation\r\n      triggeredConditions: reasons,\r\n      // Whether facilitator is currently routable\r\n      isCurrentlyRoutable: facilitator.status !== 'down' && facilitator.status !== 'degraded',\r\n    },\r\n    reasoning: `Recommend deprioritizing ${facilitator.id}: ${reasons.join('; ')}`,\r\n    status: 'PENDING',\r\n    expiresAt: new Date(now.getTime() + 24 * 60 * 60 * 1000), // Expires in 24h\r\n  };\r\n}\r\n\r\n/**\r\n * Create a promote recommendation\r\n */\r\nfunction createPromoteRecommendation(\r\n  facilitator: FacilitatorState,\r\n  reasons: string[],\r\n  confidence: number,\r\n  now: Date\r\n): AgentRecommendation {\r\n  return {\r\n    id: crypto.randomUUID(),\r\n    createdAt: now,\r\n    agent: 'routing_tuner',\r\n    type: 'FACILITATOR_PROMOTE',\r\n    facilitatorId: facilitator.id,\r\n    priority: 'low',\r\n    confidence,\r\n    details: {\r\n      // Metrics snapshot at decision time\r\n      metricsSnapshot: {\r\n        timestamp: now.toISOString(),\r\n        score: facilitator.score,\r\n        successRate: facilitator.successRate,\r\n        avgLatencyMs: facilitator.avgLatencyMs,\r\n        p95LatencyMs: facilitator.p95LatencyMs,\r\n        totalInvocations: facilitator.totalInvocations,\r\n        trustTier: facilitator.trustTier,\r\n        status: facilitator.status,\r\n        confidence: facilitator.confidence,\r\n      },\r\n      // Thresholds used for decision\r\n      thresholdsUsed: {\r\n        promoteSuccessRate: ROUTING_TUNER_CONFIG.promoteSuccessRateThreshold,\r\n        promoteLatencyMs: ROUTING_TUNER_CONFIG.promoteLatencyThresholdMs,\r\n        minInvocations: ROUTING_TUNER_CONFIG.minInvocationsForDecision,\r\n      },\r\n      // Conditions that triggered this recommendation\r\n      triggeredConditions: reasons,\r\n    },\r\n    reasoning: `Recommend promoting ${facilitator.id}: ${reasons.join('; ')}`,\r\n    status: 'PENDING',\r\n    expiresAt: new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000), // Expires in 7 days\r\n  };\r\n}\r\n\r\n","// =============================================================================\r\n// PRICING TUNER AGENT (STUB)\r\n// =============================================================================\r\n// Analyzes resource pricing and proposes adjustments\r\n// \r\n// TODO: This is a stub implementation. Future enhancements:\r\n// - Integrate with metered endpoints to get pricing data\r\n// - Analyze cost vs. usage patterns\r\n// - Propose price changes based on market conditions\r\n// - Factor in facilitator fees\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  WorldState,\r\n  AgentRecommendation,\r\n  PricingTunerOutput,\r\n} from './types';\r\n\r\nconst logger = createLogger({ component: 'PricingTuner' });\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nconst PRICING_TUNER_CONFIG = {\r\n  // Minimum margin to maintain over facilitator fees\r\n  minMarginBps: 50, // 0.5%\r\n  \r\n  // Maximum price increase per adjustment\r\n  maxPriceIncreasePct: 20,\r\n  \r\n  // Minimum usage to consider for price changes\r\n  minUsageForPricing: 100,\r\n};\r\n\r\n// =============================================================================\r\n// PRICING TUNER\r\n// =============================================================================\r\n\r\n/**\r\n * Run the pricing tuner to analyze resource pricing\r\n * \r\n * NOTE: This is a stub implementation. Currently returns no recommendations.\r\n * \r\n * Future implementation should:\r\n * 1. Query metered endpoints to get current pricing\r\n * 2. Analyze usage patterns and revenue\r\n * 3. Compare against facilitator fees\r\n * 4. Propose price adjustments to optimize for usage or revenue\r\n */\r\nexport async function runPricingTuner(worldState: WorldState): Promise<PricingTunerOutput> {\r\n  const recommendations: AgentRecommendation[] = [];\r\n\r\n  logger.info({ msg: 'Running pricing tuner (stub)' });\r\n\r\n  // TODO: Implement actual pricing analysis\r\n  // For now, just log that this is a stub\r\n  \r\n  // Example of what future implementation might look like:\r\n  /*\r\n  const endpoints = await getMeteredEndpoints();\r\n  \r\n  for (const endpoint of endpoints) {\r\n    const usage = await getEndpointUsage(endpoint.id, '7d');\r\n    const facilitatorCost = calculateFacilitatorCost(endpoint, worldState.facilitators);\r\n    const currentMargin = endpoint.priceUsd - facilitatorCost;\r\n    \r\n    if (currentMargin < PRICING_TUNER_CONFIG.minMarginBps / 100) {\r\n      recommendations.push({\r\n        id: crypto.randomUUID(),\r\n        createdAt: new Date(),\r\n        agent: 'pricing_tuner',\r\n        type: 'PRICING_CHANGE',\r\n        resourceId: endpoint.id,\r\n        priority: 'medium',\r\n        confidence: 0.7,\r\n        details: {\r\n          currentPrice: endpoint.priceUsd,\r\n          suggestedPrice: facilitatorCost * 1.1, // 10% margin\r\n          facilitatorCost,\r\n          usage7d: usage.totalCalls,\r\n        },\r\n        reasoning: `Margin below minimum threshold. Suggest price increase.`,\r\n        status: 'PENDING',\r\n      });\r\n    }\r\n  }\r\n  */\r\n\r\n  const output: PricingTunerOutput = {\r\n    recommendations,\r\n    analysis: {\r\n      resourcesReviewed: 0, // TODO: Count actual resources reviewed\r\n      priceChangesProposed: recommendations.length,\r\n    },\r\n  };\r\n\r\n  logger.info({\r\n    recommendationCount: recommendations.length,\r\n    msg: 'Pricing tuner completed (stub)',\r\n  });\r\n\r\n  return output;\r\n}\r\n\r\n","// =============================================================================\r\n// SCOUT TUNER AGENT\r\n// =============================================================================\r\n// Evaluates newly discovered facilitators and proposes onboarding\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  WorldState,\r\n  PendingFacilitator,\r\n  AgentRecommendation,\r\n  ScoutTunerOutput,\r\n} from './types';\r\n\r\nconst logger = createLogger({ component: 'ScoutTuner' });\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\nconst SCOUT_TUNER_CONFIG = {\r\n  // Minimum external score to consider onboarding\r\n  minExternalScoreForOnboarding: 60,\r\n  \r\n  // Maximum pending duration before requiring evaluation\r\n  maxPendingDurationDays: 7,\r\n  \r\n  // Required networks for onboarding (must support at least one)\r\n  requiredNetworks: ['eip155:8453'], // Base mainnet\r\n  \r\n  // Required assets for onboarding (must support at least one)\r\n  requiredAssets: ['USDC'],\r\n};\r\n\r\n// =============================================================================\r\n// SCOUT TUNER\r\n// =============================================================================\r\n\r\n/**\r\n * Run the scout tuner to evaluate pending facilitators\r\n */\r\nexport async function runScoutTuner(worldState: WorldState): Promise<ScoutTunerOutput> {\r\n  const recommendations: AgentRecommendation[] = [];\r\n  const now = new Date();\r\n\r\n  const readyForOnboarding: string[] = [];\r\n  const rejected: string[] = [];\r\n\r\n  logger.info({\r\n    pendingCount: worldState.pendingFacilitators.length,\r\n    msg: 'Running scout tuner',\r\n  });\r\n\r\n  for (const pending of worldState.pendingFacilitators) {\r\n    const evaluation = evaluatePendingFacilitator(pending, worldState, now);\r\n\r\n    if (evaluation.readyForOnboarding) {\r\n      readyForOnboarding.push(pending.id);\r\n      \r\n      // Extract probe stats for logging and metadata\r\n      const probeStats = pending.probeStats || {};\r\n      \r\n      // Log the onboarding recommendation with observable stats\r\n      logger.info({\r\n        type: 'FACILITATOR_ONBOARD',\r\n        watchlistId: pending.id,\r\n        facilitatorName: pending.name,\r\n        source: pending.source,\r\n        avgLatencyMs: probeStats.avgLatencyMs,\r\n        successRate: probeStats.successRate,\r\n        healthScore: probeStats.healthScore,\r\n        lastProbeAt: probeStats.lastProbeAt?.toISOString(),\r\n        lastHttpStatus: probeStats.lastHttpStatus,\r\n        externalScore: pending.externalScore,\r\n        confidence: evaluation.confidence,\r\n        priority: evaluation.priority,\r\n        msg: 'Scout tuner recommends onboarding facilitator',\r\n      });\r\n      \r\n      recommendations.push({\r\n        id: crypto.randomUUID(),\r\n        createdAt: now,\r\n        agent: 'scout_tuner',\r\n        type: 'FACILITATOR_ONBOARD',\r\n        facilitatorId: pending.id,\r\n        priority: evaluation.priority,\r\n        confidence: evaluation.confidence,\r\n        details: {\r\n          name: pending.name,\r\n          source: pending.source,\r\n          discoveredAt: pending.discoveredAt.toISOString(),\r\n          externalScore: pending.externalScore,\r\n          networks: pending.networks,\r\n          assets: pending.assets,\r\n          evaluationReasons: evaluation.reasons,\r\n          // Probe stats metadata for observability\r\n          probeStats: {\r\n            watchlistId: pending.id,\r\n            avgLatencyMs: probeStats.avgLatencyMs,\r\n            successRate: probeStats.successRate,\r\n            healthScore: probeStats.healthScore,\r\n            lastProbeAt: probeStats.lastProbeAt?.toISOString(),\r\n            lastHttpStatus: probeStats.lastHttpStatus,\r\n            probeCount: probeStats.probeCount,\r\n          },\r\n        },\r\n        reasoning: `Recommend onboarding ${pending.name}: ${evaluation.reasons.join('; ')}`,\r\n        status: 'PENDING',\r\n        expiresAt: new Date(now.getTime() + 14 * 24 * 60 * 60 * 1000), // Expires in 14 days\r\n      });\r\n    } else if (evaluation.shouldReject) {\r\n      rejected.push(pending.id);\r\n      \r\n      // We don't create a formal recommendation for rejections,\r\n      // but we could log or track them\r\n      logger.info({\r\n        facilitatorId: pending.id,\r\n        reasons: evaluation.rejectionReasons,\r\n        msg: 'Pending facilitator rejected',\r\n      });\r\n    }\r\n    // Otherwise, leave in pending state for more data\r\n  }\r\n\r\n  // Check for stale pending facilitators that need attention\r\n  const stalePending = worldState.pendingFacilitators.filter((p) => {\r\n    const daysPending = (now.getTime() - p.discoveredAt.getTime()) / (24 * 60 * 60 * 1000);\r\n    return daysPending > SCOUT_TUNER_CONFIG.maxPendingDurationDays;\r\n  });\r\n\r\n  if (stalePending.length > 0) {\r\n    recommendations.push({\r\n      id: crypto.randomUUID(),\r\n      createdAt: now,\r\n      agent: 'scout_tuner',\r\n      type: 'RISK_ALERT',\r\n      priority: 'low',\r\n      confidence: 0.8,\r\n      details: {\r\n        staleFacilitatorIds: stalePending.map((p) => p.id),\r\n        staleFacilitatorNames: stalePending.map((p) => p.name),\r\n        maxAgeDays: Math.max(\r\n          ...stalePending.map(\r\n            (p) => (now.getTime() - p.discoveredAt.getTime()) / (24 * 60 * 60 * 1000)\r\n          )\r\n        ),\r\n      },\r\n      reasoning: `${stalePending.length} facilitator(s) have been pending evaluation for more than ${SCOUT_TUNER_CONFIG.maxPendingDurationDays} days`,\r\n      status: 'PENDING',\r\n    });\r\n  }\r\n\r\n  const output: ScoutTunerOutput = {\r\n    recommendations,\r\n    analysis: {\r\n      pendingEvaluated: worldState.pendingFacilitators.length,\r\n      readyForOnboarding,\r\n      rejected,\r\n    },\r\n  };\r\n\r\n  logger.info({\r\n    pendingEvaluated: worldState.pendingFacilitators.length,\r\n    readyForOnboarding,\r\n    rejected,\r\n    recommendationCount: recommendations.length,\r\n    msg: 'Scout tuner completed',\r\n  });\r\n\r\n  return output;\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\ninterface PendingEvaluation {\r\n  readyForOnboarding: boolean;\r\n  shouldReject: boolean;\r\n  priority: 'low' | 'medium' | 'high' | 'critical';\r\n  confidence: number;\r\n  reasons: string[];\r\n  rejectionReasons: string[];\r\n}\r\n\r\n/**\r\n * Evaluate a pending facilitator for onboarding\r\n */\r\nfunction evaluatePendingFacilitator(\r\n  pending: PendingFacilitator,\r\n  worldState: WorldState,\r\n  now: Date\r\n): PendingEvaluation {\r\n  const reasons: string[] = [];\r\n  const rejectionReasons: string[] = [];\r\n  let confidence = 0.5;\r\n  let readyForOnboarding = false;\r\n  let shouldReject = false;\r\n  let priority: 'low' | 'medium' | 'high' | 'critical' = 'low';\r\n\r\n  // Check external score\r\n  if (pending.externalScore !== undefined) {\r\n    if (pending.externalScore >= SCOUT_TUNER_CONFIG.minExternalScoreForOnboarding) {\r\n      reasons.push(`External score ${pending.externalScore} meets threshold`);\r\n      confidence += 0.2;\r\n    } else {\r\n      rejectionReasons.push(\r\n        `External score ${pending.externalScore} below threshold ${SCOUT_TUNER_CONFIG.minExternalScoreForOnboarding}`\r\n      );\r\n    }\r\n  } else {\r\n    // No external score - lower confidence\r\n    reasons.push('No external score available - manual review recommended');\r\n    confidence -= 0.1;\r\n  }\r\n\r\n  // Check network support\r\n  const hasRequiredNetwork = pending.networks.length === 0 || // Unknown = might support\r\n    pending.networks.some((n) => SCOUT_TUNER_CONFIG.requiredNetworks.includes(n));\r\n  \r\n  if (hasRequiredNetwork) {\r\n    if (pending.networks.length > 0) {\r\n      reasons.push(`Supports required network(s): ${pending.networks.join(', ')}`);\r\n      confidence += 0.1;\r\n    }\r\n  } else {\r\n    rejectionReasons.push(\r\n      `Does not support required networks. Has: ${pending.networks.join(', ')}`\r\n    );\r\n  }\r\n\r\n  // Check asset support\r\n  const hasRequiredAsset = pending.assets.length === 0 || // Unknown = might support\r\n    pending.assets.some((a) => SCOUT_TUNER_CONFIG.requiredAssets.includes(a));\r\n  \r\n  if (hasRequiredAsset) {\r\n    if (pending.assets.length > 0) {\r\n      reasons.push(`Supports required asset(s): ${pending.assets.join(', ')}`);\r\n      confidence += 0.1;\r\n    }\r\n  } else {\r\n    rejectionReasons.push(\r\n      `Does not support required assets. Has: ${pending.assets.join(', ')}`\r\n    );\r\n  }\r\n\r\n  // Check if from trusted source\r\n  if (pending.source === 'bazaar') {\r\n    reasons.push('Discovered from Bazaar marketplace');\r\n    confidence += 0.1;\r\n    priority = 'medium';\r\n  }\r\n\r\n  // Check how long it's been pending\r\n  const daysPending = (now.getTime() - pending.discoveredAt.getTime()) / (24 * 60 * 60 * 1000);\r\n  if (daysPending > 30) {\r\n    rejectionReasons.push(`Stale: pending for ${Math.round(daysPending)} days without progress`);\r\n  }\r\n\r\n  // Check for existing similar facilitators\r\n  // If we already have many high-performing facilitators, lower priority\r\n  const highPerformers = worldState.facilitators.filter((f) => f.score >= 80);\r\n  if (highPerformers.length >= 3) {\r\n    reasons.push('Multiple high-performing facilitators already available');\r\n    priority = 'low';\r\n    confidence -= 0.1;\r\n  } else {\r\n    reasons.push('Could fill gap in facilitator coverage');\r\n    priority = 'medium';\r\n    confidence += 0.1;\r\n  }\r\n\r\n  // Determine final decision\r\n  confidence = Math.max(0.1, Math.min(0.95, confidence)); // Clamp to [0.1, 0.95]\r\n\r\n  if (rejectionReasons.length > 0 && reasons.length === 0) {\r\n    shouldReject = true;\r\n  } else if (reasons.length > 0 && rejectionReasons.length === 0 && confidence >= 0.5) {\r\n    readyForOnboarding = true;\r\n  }\r\n  // Otherwise, leave in pending state\r\n\r\n  return {\r\n    readyForOnboarding,\r\n    shouldReject,\r\n    priority,\r\n    confidence,\r\n    reasons,\r\n    rejectionReasons,\r\n  };\r\n}\r\n\r\n","// =============================================================================\r\n// COORDINATOR / SUPER-AGENT\r\n// =============================================================================\r\n// Main orchestration agent that coordinates sub-agents and builds world state\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport { getCircuitBreaker } from '@/lib/circuit-breaker';\r\nimport { rankFacilitators, getFacilitatorScore } from '@/services/facilitator-metrics-reader';\r\nimport { getMetaFacilitator } from '@/integrations/x402/orchestrator/meta-facilitator';\r\nimport { getActiveWatchlistItems } from '@/db/x402-watchlist';\r\nimport { createRecommendations } from '@/db/agent-recommendations';\r\nimport { runRoutingTuner } from './routing-tuner';\r\nimport { runPricingTuner } from './pricing-tuner';\r\nimport { runScoutTuner } from './scout-tuner';\r\nimport type {\r\n  WorldState,\r\n  FacilitatorState,\r\n  PendingFacilitator,\r\n  RiskAnomaly,\r\n  CoordinatorOutput,\r\n  AgentRecommendation,\r\n} from './types';\r\n\r\nconst logger = createLogger({ component: 'Coordinator' });\r\n\r\n// =============================================================================\r\n// CIRCUIT BREAKERS\r\n// =============================================================================\r\n\r\nconst metricsCircuitBreaker = getCircuitBreaker({\r\n  name: 'coordinator-metrics',\r\n  failureThreshold: 3,\r\n  successThreshold: 2,\r\n  resetTimeout: 60000, // 1 minute\r\n  failureWindow: 300000, // 5 minutes\r\n  requestTimeout: 30000, // 30 seconds\r\n});\r\n\r\nconst metaFacilitatorCircuitBreaker = getCircuitBreaker({\r\n  name: 'coordinator-meta-facilitator',\r\n  failureThreshold: 3,\r\n  successThreshold: 2,\r\n  resetTimeout: 60000,\r\n  failureWindow: 300000,\r\n  requestTimeout: 20000,\r\n});\r\n\r\nconst watchlistCircuitBreaker = getCircuitBreaker({\r\n  name: 'coordinator-watchlist',\r\n  failureThreshold: 5,\r\n  successThreshold: 2,\r\n  resetTimeout: 30000,\r\n  failureWindow: 120000,\r\n  requestTimeout: 10000,\r\n});\r\n\r\n// =============================================================================\r\n// WORLD STATE CACHE\r\n// =============================================================================\r\n\r\ninterface CachedWorldState {\r\n  state: WorldState;\r\n  cachedAt: Date;\r\n}\r\n\r\n/** In-memory cache for the last successful world state */\r\nlet worldStateCache: CachedWorldState | null = null;\r\n\r\n/** Maximum age for cached world state (5 minutes) */\r\nconst WORLD_STATE_CACHE_TTL_MS = 5 * 60 * 1000;\r\n\r\n/**\r\n * Get cached world state if available and not too stale\r\n */\r\nfunction getCachedWorldState(): WorldState | null {\r\n  if (!worldStateCache) {\r\n    return null;\r\n  }\r\n  \r\n  const age = Date.now() - worldStateCache.cachedAt.getTime();\r\n  if (age > WORLD_STATE_CACHE_TTL_MS) {\r\n    logger.info({\r\n      cacheAgeMs: age,\r\n      ttlMs: WORLD_STATE_CACHE_TTL_MS,\r\n      msg: 'World state cache expired',\r\n    });\r\n    return null;\r\n  }\r\n  \r\n  return worldStateCache.state;\r\n}\r\n\r\n/**\r\n * Update the world state cache\r\n */\r\nfunction updateWorldStateCache(state: WorldState): void {\r\n  worldStateCache = {\r\n    state,\r\n    cachedAt: new Date(),\r\n  };\r\n  logger.info({ msg: 'World state cache updated' });\r\n}\r\n\r\n/**\r\n * Get circuit breaker stats for monitoring\r\n */\r\nexport function getCoordinatorCircuitBreakerStats() {\r\n  return {\r\n    metrics: metricsCircuitBreaker.getStats(),\r\n    metaFacilitator: metaFacilitatorCircuitBreaker.getStats(),\r\n    watchlist: watchlistCircuitBreaker.getStats(),\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// CONFIGURATION\r\n// =============================================================================\r\n\r\nconst COORDINATOR_CONFIG = {\r\n  // Thresholds for anomaly detection\r\n  successRateWarningThreshold: 0.9, // Below this triggers warning\r\n  successRateCriticalThreshold: 0.7, // Below this triggers critical\r\n  latencyWarningThresholdMs: 2000,\r\n  latencyCriticalThresholdMs: 5000,\r\n  \r\n  // Default facilitator IDs to monitor (from registry)\r\n  defaultFacilitatorIds: ['cdp', 'payai', 'x402rs', 'dexter'],\r\n};\r\n\r\n// =============================================================================\r\n// WORLD STATE BUILDER\r\n// =============================================================================\r\n\r\n/**\r\n * Build the current world state by reading from metrics and services.\r\n * Uses circuit breakers for external API calls and caches successful builds.\r\n */\r\nexport async function buildWorldState(): Promise<WorldState> {\r\n  const timestamp = new Date();\r\n  \r\n  logger.info({ msg: 'Building world state for coordinator' });\r\n\r\n  // 1. Get facilitator rankings and scores (with circuit breaker)\r\n  const rankings = await metricsCircuitBreaker.execute(() =>\r\n    rankFacilitators(\r\n      COORDINATOR_CONFIG.defaultFacilitatorIds,\r\n      '1d'\r\n    )\r\n  );\r\n\r\n  // 2. Get meta-facilitator status for health info (with circuit breaker)\r\n  const metaFacilitator = getMetaFacilitator();\r\n  const status = await metaFacilitatorCircuitBreaker.execute(() =>\r\n    metaFacilitator.getStatus()\r\n  );\r\n\r\n  // 3. Build facilitator states\r\n  const facilitators: FacilitatorState[] = [];\r\n  \r\n  for (const ranking of rankings.rankings) {\r\n    const healthDetail = status.facilitatorDetails.find(\r\n      (d) => d.id === ranking.facilitatorId\r\n    );\r\n\r\n    // Determine if facilitator is currently routable\r\n    const isHealthy = healthDetail?.healthy ?? false;\r\n    const hasData = ranking.confidence !== 'none';\r\n    const notBlocked = ranking.successRate > 0.1; // Not completely failing\r\n    const isRoutable = isHealthy && hasData && notBlocked;\r\n    \r\n    let nonRoutableReason: string | undefined;\r\n    if (!isRoutable) {\r\n      const reasons: string[] = [];\r\n      if (!isHealthy) reasons.push('failing health check');\r\n      if (!hasData) reasons.push('no performance data');\r\n      if (!notBlocked) reasons.push('success rate critically low');\r\n      nonRoutableReason = reasons.join(', ');\r\n    }\r\n\r\n    facilitators.push({\r\n      id: ranking.facilitatorId,\r\n      name: healthDetail?.name || ranking.facilitatorId,\r\n      score: ranking.score,\r\n      successRate: ranking.successRate,\r\n      avgLatencyMs: ranking.avgLatencyMs || 0,\r\n      p95LatencyMs: ranking.p95LatencyMs,\r\n      totalInvocations: ranking.totalInvocations,\r\n      confidence: ranking.confidence,\r\n      trustTier: mapConfidenceToTier(ranking.confidence),\r\n      status: healthDetail?.healthy ? 'healthy' : 'unknown',\r\n      networks: status.networks,\r\n      assets: status.assets,\r\n      feeBps: 0, // TODO: Get from capabilities table\r\n      // TODO: Compute deltas from historical data\r\n      scoreDelta24h: undefined,\r\n      successRateDelta24h: undefined,\r\n      // Routing eligibility\r\n      isRoutable,\r\n      nonRoutableReason,\r\n    });\r\n  }\r\n\r\n  // 4. Get pending facilitators from watchlist\r\n  const pendingFacilitators = await getPendingFacilitators();\r\n\r\n  // 5. Detect risk anomalies\r\n  const riskAnomalies = detectRiskAnomalies(facilitators);\r\n\r\n  // 6. Build aggregates\r\n  const aggregates = computeAggregates(facilitators);\r\n\r\n  // 7. Build recent decisions summary\r\n  const recentDecisions = facilitators.map((f) => ({\r\n    facilitatorId: f.id,\r\n    routeCount: f.totalInvocations,\r\n    successCount: Math.round(f.totalInvocations * f.successRate),\r\n    avgLatencyMs: f.avgLatencyMs,\r\n  }));\r\n\r\n  const worldState: WorldState = {\r\n    timestamp,\r\n    facilitators,\r\n    pendingFacilitators,\r\n    riskAnomalies,\r\n    aggregates,\r\n    recentDecisions,\r\n  };\r\n\r\n  logger.info({\r\n    facilitatorCount: facilitators.length,\r\n    pendingCount: pendingFacilitators.length,\r\n    anomalyCount: riskAnomalies.length,\r\n    msg: 'World state built',\r\n  });\r\n\r\n  // Cache the successful world state for fallback\r\n  updateWorldStateCache(worldState);\r\n\r\n  return worldState;\r\n}\r\n\r\n// =============================================================================\r\n// COORDINATOR TICK\r\n// =============================================================================\r\n\r\n/**\r\n * Run a single coordinator tick\r\n * This is the main entry point called by the cron\r\n */\r\nexport async function runCoordinatorTick(): Promise<CoordinatorOutput> {\r\n  const runId = crypto.randomUUID();\r\n  const startedAt = new Date();\r\n  const errors: string[] = [];\r\n\r\n  logger.info({ runId, msg: 'Starting coordinator tick' });\r\n\r\n  // 1. Build world state (with fallback to cached state)\r\n  let worldState: WorldState;\r\n  let usedCachedState = false;\r\n  try {\r\n    worldState = await buildWorldState();\r\n  } catch (error) {\r\n    const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n    errors.push(`World state build failed: ${errorMsg}`);\r\n    logger.error({ runId, error: errorMsg, msg: 'World state build failed' });\r\n    \r\n    // Try to use cached world state as fallback\r\n    const cachedState = getCachedWorldState();\r\n    if (cachedState) {\r\n      worldState = cachedState;\r\n      usedCachedState = true;\r\n      logger.warn({\r\n        runId,\r\n        cachedAt: worldStateCache?.cachedAt,\r\n        msg: 'Using cached world state as fallback',\r\n      });\r\n    } else {\r\n      // No cache available - return early with error\r\n      logger.error({ runId, msg: 'No cached world state available for fallback' });\r\n      return {\r\n        runId,\r\n        startedAt,\r\n        completedAt: new Date(),\r\n        worldState: createEmptyWorldState(),\r\n        routingTuner: { recommendations: [], analysis: { topPerformers: [], underperformers: [], newContenders: [] } },\r\n        pricingTuner: { recommendations: [], analysis: { resourcesReviewed: 0, priceChangesProposed: 0 } },\r\n        scoutTuner: { recommendations: [], analysis: { pendingEvaluated: 0, readyForOnboarding: [], rejected: [] } },\r\n        totalRecommendations: 0,\r\n        errors,\r\n      };\r\n    }\r\n  }\r\n\r\n  // 2. Run routing tuner\r\n  let routingTunerOutput;\r\n  try {\r\n    routingTunerOutput = await runRoutingTuner(worldState);\r\n    logger.info({\r\n      runId,\r\n      recommendations: routingTunerOutput.recommendations.length,\r\n      msg: 'Routing tuner completed',\r\n    });\r\n  } catch (error) {\r\n    const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n    errors.push(`Routing tuner failed: ${errorMsg}`);\r\n    logger.error({ runId, error: errorMsg, msg: 'Routing tuner failed' });\r\n    routingTunerOutput = {\r\n      recommendations: [],\r\n      analysis: { topPerformers: [], underperformers: [], newContenders: [] },\r\n    };\r\n  }\r\n\r\n  // 3. Run pricing tuner\r\n  let pricingTunerOutput;\r\n  try {\r\n    pricingTunerOutput = await runPricingTuner(worldState);\r\n    logger.info({\r\n      runId,\r\n      recommendations: pricingTunerOutput.recommendations.length,\r\n      msg: 'Pricing tuner completed',\r\n    });\r\n  } catch (error) {\r\n    const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n    errors.push(`Pricing tuner failed: ${errorMsg}`);\r\n    logger.error({ runId, error: errorMsg, msg: 'Pricing tuner failed' });\r\n    pricingTunerOutput = {\r\n      recommendations: [],\r\n      analysis: { resourcesReviewed: 0, priceChangesProposed: 0 },\r\n    };\r\n  }\r\n\r\n  // 4. Run scout tuner\r\n  let scoutTunerOutput;\r\n  try {\r\n    scoutTunerOutput = await runScoutTuner(worldState);\r\n    logger.info({\r\n      runId,\r\n      recommendations: scoutTunerOutput.recommendations.length,\r\n      msg: 'Scout tuner completed',\r\n    });\r\n  } catch (error) {\r\n    const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n    errors.push(`Scout tuner failed: ${errorMsg}`);\r\n    logger.error({ runId, error: errorMsg, msg: 'Scout tuner failed' });\r\n    scoutTunerOutput = {\r\n      recommendations: [],\r\n      analysis: { pendingEvaluated: 0, readyForOnboarding: [], rejected: [] },\r\n    };\r\n  }\r\n\r\n  // 5. Aggregate all recommendations\r\n  const allRecommendations: AgentRecommendation[] = [\r\n    ...routingTunerOutput.recommendations,\r\n    ...pricingTunerOutput.recommendations,\r\n    ...scoutTunerOutput.recommendations,\r\n  ];\r\n\r\n  // 6. Persist recommendations\r\n  if (allRecommendations.length > 0) {\r\n    try {\r\n      await createRecommendations(\r\n        allRecommendations.map((rec) => ({\r\n          agent: rec.agent,\r\n          type: rec.type,\r\n          facilitatorId: rec.facilitatorId,\r\n          resourceId: rec.resourceId,\r\n          priority: rec.priority,\r\n          confidence: rec.confidence,\r\n          details: rec.details,\r\n          reasoning: rec.reasoning,\r\n          expiresAt: rec.expiresAt,\r\n        }))\r\n      );\r\n      logger.info({\r\n        runId,\r\n        count: allRecommendations.length,\r\n        msg: 'Recommendations persisted',\r\n      });\r\n    } catch (error) {\r\n      const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n      errors.push(`Failed to persist recommendations: ${errorMsg}`);\r\n      logger.error({ runId, error: errorMsg, msg: 'Failed to persist recommendations' });\r\n    }\r\n  }\r\n\r\n  const completedAt = new Date();\r\n\r\n  const output: CoordinatorOutput = {\r\n    runId,\r\n    startedAt,\r\n    completedAt,\r\n    worldState,\r\n    routingTuner: routingTunerOutput,\r\n    pricingTuner: pricingTunerOutput,\r\n    scoutTuner: scoutTunerOutput,\r\n    totalRecommendations: allRecommendations.length,\r\n    errors,\r\n  };\r\n\r\n  logger.info({\r\n    runId,\r\n    durationMs: completedAt.getTime() - startedAt.getTime(),\r\n    totalRecommendations: allRecommendations.length,\r\n    errorCount: errors.length,\r\n    usedCachedState,\r\n    msg: 'Coordinator tick completed',\r\n  });\r\n\r\n  return output;\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Get pending facilitators from watchlist (with circuit breaker)\r\n */\r\nasync function getPendingFacilitators(): Promise<PendingFacilitator[]> {\r\n  try {\r\n    const watchlist = await watchlistCircuitBreaker.execute(() =>\r\n      getActiveWatchlistItems()\r\n    );\r\n    \r\n    // Filter for facilitator discovery items that haven't been fully onboarded\r\n    const facilitatorItems = watchlist.filter(\r\n      (item) => item.category === 'facilitator_discovery' || item.category === 'bazaar_discovery'\r\n    );\r\n\r\n    // Map to PendingFacilitator format\r\n    // TODO: Cross-reference with facilitator registry to find truly new ones\r\n    return facilitatorItems.map((item) => {\r\n      // Compute a simple health score from HTTP status\r\n      // 200-299 = healthy (100), 300-399 = redirect (80), 400-499 = client error (20), 500+ = server error (0)\r\n      let healthScore: number | undefined;\r\n      if (item.last_http_status !== null) {\r\n        if (item.last_http_status >= 200 && item.last_http_status < 300) {\r\n          healthScore = 100;\r\n        } else if (item.last_http_status >= 300 && item.last_http_status < 400) {\r\n          healthScore = 80;\r\n        } else if (item.last_http_status >= 400 && item.last_http_status < 500) {\r\n          healthScore = 20;\r\n        } else {\r\n          healthScore = 0;\r\n        }\r\n      }\r\n\r\n      // Compute success rate from HTTP status (simple: 2xx = success)\r\n      const successRate = item.last_http_status !== null \r\n        ? (item.last_http_status >= 200 && item.last_http_status < 300 ? 1.0 : 0.0)\r\n        : undefined;\r\n\r\n      return {\r\n        id: `watchlist-${item.id}`,\r\n        name: item.root_domain,\r\n        discoveredAt: new Date(item.created_at),\r\n        source: item.category === 'bazaar_discovery' ? 'bazaar' : 'watchlist',\r\n        networks: [], // TODO: Parse from watchlist metadata\r\n        assets: [],\r\n        status: 'pending_evaluation' as const,\r\n        probeStats: {\r\n          healthScore,\r\n          successRate,\r\n          lastProbeAt: item.last_checked_at ? new Date(item.last_checked_at) : undefined,\r\n          lastHttpStatus: item.last_http_status ?? undefined,\r\n          // avgLatencyMs not available from watchlist - would need probe events\r\n        },\r\n      };\r\n    });\r\n  } catch (error) {\r\n    logger.warn({ error, msg: 'Failed to get pending facilitators from watchlist' });\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Detect risk anomalies from facilitator states\r\n */\r\nfunction detectRiskAnomalies(facilitators: FacilitatorState[]): RiskAnomaly[] {\r\n  const anomalies: RiskAnomaly[] = [];\r\n\r\n  for (const f of facilitators) {\r\n    // Check success rate\r\n    if (f.successRate < COORDINATOR_CONFIG.successRateCriticalThreshold) {\r\n      anomalies.push({\r\n        id: `anomaly-${f.id}-success-critical`,\r\n        detectedAt: new Date(),\r\n        type: 'high_error_rate',\r\n        facilitatorId: f.id,\r\n        severity: 'critical',\r\n        description: `Facilitator ${f.id} has critical error rate: ${((1 - f.successRate) * 100).toFixed(1)}%`,\r\n        metrics: { successRate: f.successRate, threshold: COORDINATOR_CONFIG.successRateCriticalThreshold },\r\n        resolved: false,\r\n      });\r\n    } else if (f.successRate < COORDINATOR_CONFIG.successRateWarningThreshold) {\r\n      anomalies.push({\r\n        id: `anomaly-${f.id}-success-warning`,\r\n        detectedAt: new Date(),\r\n        type: 'high_error_rate',\r\n        facilitatorId: f.id,\r\n        severity: 'medium',\r\n        description: `Facilitator ${f.id} has elevated error rate: ${((1 - f.successRate) * 100).toFixed(1)}%`,\r\n        metrics: { successRate: f.successRate, threshold: COORDINATOR_CONFIG.successRateWarningThreshold },\r\n        resolved: false,\r\n      });\r\n    }\r\n\r\n    // Check latency\r\n    if (f.avgLatencyMs > COORDINATOR_CONFIG.latencyCriticalThresholdMs) {\r\n      anomalies.push({\r\n        id: `anomaly-${f.id}-latency-critical`,\r\n        detectedAt: new Date(),\r\n        type: 'latency_spike',\r\n        facilitatorId: f.id,\r\n        severity: 'high',\r\n        description: `Facilitator ${f.id} has critical latency: ${f.avgLatencyMs}ms`,\r\n        metrics: { avgLatencyMs: f.avgLatencyMs, threshold: COORDINATOR_CONFIG.latencyCriticalThresholdMs },\r\n        resolved: false,\r\n      });\r\n    } else if (f.avgLatencyMs > COORDINATOR_CONFIG.latencyWarningThresholdMs) {\r\n      anomalies.push({\r\n        id: `anomaly-${f.id}-latency-warning`,\r\n        detectedAt: new Date(),\r\n        type: 'latency_spike',\r\n        facilitatorId: f.id,\r\n        severity: 'medium',\r\n        description: `Facilitator ${f.id} has elevated latency: ${f.avgLatencyMs}ms`,\r\n        metrics: { avgLatencyMs: f.avgLatencyMs, threshold: COORDINATOR_CONFIG.latencyWarningThresholdMs },\r\n        resolved: false,\r\n      });\r\n    }\r\n  }\r\n\r\n  return anomalies;\r\n}\r\n\r\n/**\r\n * Compute aggregate metrics\r\n */\r\nfunction computeAggregates(facilitators: FacilitatorState[]): WorldState['aggregates'] {\r\n  const totalRoutes = facilitators.reduce((sum, f) => sum + f.totalInvocations, 0);\r\n  \r\n  const weightedSuccessSum = facilitators.reduce(\r\n    (sum, f) => sum + f.successRate * f.totalInvocations,\r\n    0\r\n  );\r\n  const avgSuccessRate = totalRoutes > 0 ? weightedSuccessSum / totalRoutes : 0;\r\n\r\n  const weightedLatencySum = facilitators.reduce(\r\n    (sum, f) => sum + f.avgLatencyMs * f.totalInvocations,\r\n    0\r\n  );\r\n  const avgLatency = totalRoutes > 0 ? weightedLatencySum / totalRoutes : 0;\r\n\r\n  return {\r\n    totalRoutesLast24h: totalRoutes,\r\n    successRateLast24h: avgSuccessRate,\r\n    avgLatencyLast24h: avgLatency,\r\n    totalVolumeLast24h: undefined, // TODO: Get from volume service\r\n  };\r\n}\r\n\r\n/**\r\n * Map confidence to trust tier\r\n */\r\nfunction mapConfidenceToTier(confidence: 'high' | 'medium' | 'low' | 'none'): 'high' | 'medium' | 'low' | 'unknown' {\r\n  switch (confidence) {\r\n    case 'high':\r\n      return 'high';\r\n    case 'medium':\r\n      return 'medium';\r\n    case 'low':\r\n      return 'low';\r\n    case 'none':\r\n      return 'unknown';\r\n  }\r\n}\r\n\r\n/**\r\n * Create empty world state for error cases\r\n */\r\nfunction createEmptyWorldState(): WorldState {\r\n  return {\r\n    timestamp: new Date(),\r\n    facilitators: [],\r\n    pendingFacilitators: [],\r\n    riskAnomalies: [],\r\n    aggregates: {\r\n      totalRoutesLast24h: 0,\r\n      successRateLast24h: 0,\r\n      avgLatencyLast24h: 0,\r\n    },\r\n    recentDecisions: [],\r\n  };\r\n}\r\n\r\n","// =============================================================================\r\n// ROUTING EXPERIMENTS DATABASE\r\n// =============================================================================\r\n// Persistence layer for bandit shadow routing experiments\r\n\r\nimport { getDb } from './client';\r\nimport { createLogger } from '@/lib/logger';\r\nimport type {\r\n  RoutingExperiment,\r\n  BanditContext,\r\n  BanditReward,\r\n  BanditArmState,\r\n} from '@/agents/types';\r\n\r\nconst logger = createLogger({ component: 'RoutingExperimentsDB' });\r\n\r\n// =============================================================================\r\n// EXPERIMENT OPERATIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Check if an experiment already exists for a route+algorithm+version\r\n * Used for idempotency\r\n */\r\nexport async function checkExperimentExists(\r\n  routeId: string,\r\n  algorithm: string,\r\n  algorithmVersion: string\r\n): Promise<boolean> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  const query = isPostgres\r\n    ? `SELECT 1 FROM routing_experiments \r\n       WHERE route_id = $1 AND algorithm = $2 AND algorithm_version = $3 \r\n       LIMIT 1`\r\n    : `SELECT 1 FROM routing_experiments \r\n       WHERE route_id = ? AND algorithm = ? AND algorithm_version = ? \r\n       LIMIT 1`;\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, [routeId, algorithm, algorithmVersion]);\r\n    return result.rows.length > 0;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    const row = stmt.get(routeId, algorithm, algorithmVersion);\r\n    return !!row;\r\n  }\r\n}\r\n\r\n/**\r\n * Create a routing experiment record\r\n * Now includes explicit success, latency_ms, cost_bps columns for v2 analytics\r\n */\r\nexport async function createRoutingExperiment(\r\n  experiment: Omit<RoutingExperiment, 'id'>\r\n): Promise<RoutingExperiment> {\r\n  const db = getDb();\r\n  const id = crypto.randomUUID();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  const record: RoutingExperiment = { id, ...experiment };\r\n  \r\n  // Extract explicit metrics from actualReward (v2 columns)\r\n  const success = experiment.actualReward.success === 1;\r\n  const latencyMs = experiment.actualReward.latencyMs ?? null;\r\n  const costBps = experiment.actualReward.costBps ?? null;\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `INSERT INTO routing_experiments (\r\n        id, route_id, timestamp, context, context_hash, available_facilitators,\r\n        actual_facilitator, actual_reward,\r\n        bandit_chosen_facilitator, bandit_estimated_reward, is_counterfactual,\r\n        algorithm, algorithm_version, algorithm_state,\r\n        success, latency_ms, cost_bps\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)\r\n      ON CONFLICT (route_id, algorithm, algorithm_version) DO NOTHING`,\r\n      [\r\n        id,\r\n        experiment.routeId || null,\r\n        experiment.timestamp.toISOString(),\r\n        JSON.stringify(experiment.context),\r\n        experiment.contextHash,\r\n        JSON.stringify(experiment.availableFacilitators),\r\n        experiment.actualFacilitator,\r\n        JSON.stringify(experiment.actualReward),\r\n        experiment.banditChosenFacilitator,\r\n        experiment.banditEstimatedReward,\r\n        experiment.isCounterfactual || false,\r\n        experiment.algorithm,\r\n        experiment.algorithmVersion,\r\n        experiment.algorithmState ? JSON.stringify(experiment.algorithmState) : null,\r\n        success,\r\n        latencyMs,\r\n        costBps,\r\n      ]\r\n    );\r\n  } else {\r\n    const stmt = (db as any).prepare(`\r\n      INSERT OR IGNORE INTO routing_experiments (\r\n        id, route_id, timestamp, context, context_hash, available_facilitators,\r\n        actual_facilitator, actual_reward,\r\n        bandit_chosen_facilitator, bandit_estimated_reward, is_counterfactual,\r\n        algorithm, algorithm_version, algorithm_state,\r\n        success, latency_ms, cost_bps\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      id,\r\n      experiment.routeId || null,\r\n      experiment.timestamp.toISOString(),\r\n      JSON.stringify(experiment.context),\r\n      experiment.contextHash,\r\n      JSON.stringify(experiment.availableFacilitators),\r\n      experiment.actualFacilitator,\r\n      JSON.stringify(experiment.actualReward),\r\n      experiment.banditChosenFacilitator,\r\n      experiment.banditEstimatedReward,\r\n      experiment.isCounterfactual ? 1 : 0,\r\n      experiment.algorithm,\r\n      experiment.algorithmVersion,\r\n      experiment.algorithmState ? JSON.stringify(experiment.algorithmState) : null,\r\n      success ? 1 : 0,\r\n      latencyMs,\r\n      costBps,\r\n    );\r\n  }\r\n\r\n  return record;\r\n}\r\n\r\n/**\r\n * Create multiple experiments in batch\r\n */\r\nexport async function createRoutingExperiments(\r\n  experiments: Omit<RoutingExperiment, 'id'>[]\r\n): Promise<number> {\r\n  let count = 0;\r\n  for (const exp of experiments) {\r\n    await createRoutingExperiment(exp);\r\n    count++;\r\n  }\r\n  return count;\r\n}\r\n\r\n/**\r\n * Get experiments for analysis\r\n */\r\nexport async function getRoutingExperiments(params: {\r\n  algorithm?: string;\r\n  algorithmVersion?: string;\r\n  fromTimestamp?: Date;\r\n  toTimestamp?: Date;\r\n  limit?: number;\r\n}): Promise<RoutingExperiment[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let query = 'SELECT * FROM routing_experiments WHERE 1=1';\r\n  const queryParams: any[] = [];\r\n  let paramIndex = 1;\r\n\r\n  if (params.algorithm) {\r\n    query += isPostgres ? ` AND algorithm = $${paramIndex++}` : ' AND algorithm = ?';\r\n    queryParams.push(params.algorithm);\r\n  }\r\n\r\n  if (params.algorithmVersion) {\r\n    query += isPostgres ? ` AND algorithm_version = $${paramIndex++}` : ' AND algorithm_version = ?';\r\n    queryParams.push(params.algorithmVersion);\r\n  }\r\n\r\n  if (params.fromTimestamp) {\r\n    query += isPostgres ? ` AND timestamp >= $${paramIndex++}` : ' AND timestamp >= ?';\r\n    queryParams.push(params.fromTimestamp.toISOString());\r\n  }\r\n\r\n  if (params.toTimestamp) {\r\n    query += isPostgres ? ` AND timestamp < $${paramIndex++}` : ' AND timestamp < ?';\r\n    queryParams.push(params.toTimestamp.toISOString());\r\n  }\r\n\r\n  query += ' ORDER BY timestamp DESC';\r\n\r\n  if (params.limit) {\r\n    query += isPostgres ? ` LIMIT $${paramIndex++}` : ' LIMIT ?';\r\n    queryParams.push(params.limit);\r\n  }\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, queryParams);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all(...queryParams);\r\n  }\r\n\r\n  return rows.map(rowToExperiment);\r\n}\r\n\r\n/**\r\n * Prune old experiments\r\n */\r\nexport async function pruneOldExperiments(cutoffDate: Date): Promise<number> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `DELETE FROM routing_experiments WHERE created_at < $1`,\r\n      [cutoffDate.toISOString()]\r\n    );\r\n    return result.rowCount || 0;\r\n  } else {\r\n    const stmt = (db as any).prepare('DELETE FROM routing_experiments WHERE created_at < ?');\r\n    const info = stmt.run(cutoffDate.toISOString());\r\n    return info.changes || 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Get bandit performance summary\r\n */\r\nexport async function getBanditPerformanceSummary(params: {\r\n  algorithm: string;\r\n  algorithmVersion: string;\r\n  fromTimestamp: Date;\r\n  toTimestamp: Date;\r\n}): Promise<{\r\n  totalExperiments: number;\r\n  banditMatchedRate: number;\r\n  counterfactualRate: number;\r\n  avgActualReward: number;\r\n  avgBanditEstimatedReward: number;\r\n  facilitatorStats: Array<{\r\n    facilitatorId: string;\r\n    actualPicks: number;\r\n    banditPicks: number;\r\n    avgActualReward: number;\r\n  }>;\r\n}> {\r\n  // Get all experiments in window\r\n  const experiments = await getRoutingExperiments({\r\n    algorithm: params.algorithm,\r\n    algorithmVersion: params.algorithmVersion,\r\n    fromTimestamp: params.fromTimestamp,\r\n    toTimestamp: params.toTimestamp,\r\n  });\r\n\r\n  if (experiments.length === 0) {\r\n    return {\r\n      totalExperiments: 0,\r\n      banditMatchedRate: 0,\r\n      counterfactualRate: 0,\r\n      avgActualReward: 0,\r\n      avgBanditEstimatedReward: 0,\r\n      facilitatorStats: [],\r\n    };\r\n  }\r\n\r\n  // Compute stats\r\n  let matchedCount = 0;\r\n  let counterfactualCount = 0;\r\n  let totalActualReward = 0;\r\n  let totalEstimatedReward = 0;\r\n  let estimatedCount = 0;\r\n  \r\n  const facilitatorMap = new Map<string, {\r\n    actualPicks: number;\r\n    banditPicks: number;\r\n    totalReward: number;\r\n  }>();\r\n\r\n  for (const exp of experiments) {\r\n    if (exp.isCounterfactual) {\r\n      counterfactualCount++;\r\n    } else {\r\n      matchedCount++;\r\n    }\r\n\r\n    totalActualReward += exp.actualReward.combined;\r\n    if (exp.banditEstimatedReward !== null) {\r\n      totalEstimatedReward += exp.banditEstimatedReward;\r\n      estimatedCount++;\r\n    }\r\n\r\n    // Actual facilitator stats\r\n    const actualStats = facilitatorMap.get(exp.actualFacilitator) || {\r\n      actualPicks: 0,\r\n      banditPicks: 0,\r\n      totalReward: 0,\r\n    };\r\n    actualStats.actualPicks++;\r\n    actualStats.totalReward += exp.actualReward.combined;\r\n    facilitatorMap.set(exp.actualFacilitator, actualStats);\r\n\r\n    // Bandit pick stats\r\n    const banditStats = facilitatorMap.get(exp.banditChosenFacilitator) || {\r\n      actualPicks: 0,\r\n      banditPicks: 0,\r\n      totalReward: 0,\r\n    };\r\n    banditStats.banditPicks++;\r\n    facilitatorMap.set(exp.banditChosenFacilitator, banditStats);\r\n  }\r\n\r\n  const facilitatorStats = Array.from(facilitatorMap.entries()).map(([id, stats]) => ({\r\n    facilitatorId: id,\r\n    actualPicks: stats.actualPicks,\r\n    banditPicks: stats.banditPicks,\r\n    avgActualReward: stats.actualPicks > 0 ? stats.totalReward / stats.actualPicks : 0,\r\n  }));\r\n\r\n  return {\r\n    totalExperiments: experiments.length,\r\n    banditMatchedRate: matchedCount / experiments.length,\r\n    counterfactualRate: counterfactualCount / experiments.length,\r\n    avgActualReward: totalActualReward / experiments.length,\r\n    avgBanditEstimatedReward: estimatedCount > 0 ? totalEstimatedReward / estimatedCount : 0,\r\n    facilitatorStats,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// BANDIT STATE PERSISTENCE\r\n// =============================================================================\r\n\r\n/**\r\n * Extended arm state with success/failure tracking (v2)\r\n */\r\nexport interface BanditArmStateExtended extends BanditArmState {\r\n  successCount?: number;\r\n  failureCount?: number;\r\n}\r\n\r\n/**\r\n * Save bandit arm state (for resuming learner)\r\n * v2: Now includes success_count and failure_count for failure rate analytics\r\n */\r\nexport async function saveBanditArmState(\r\n  algorithm: string,\r\n  algorithmVersion: string,\r\n  contextHash: string,\r\n  arm: BanditArmStateExtended\r\n): Promise<void> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  const now = new Date().toISOString();\r\n\r\n  if (isPostgres) {\r\n    await (db as any).pool.query(\r\n      `INSERT INTO bandit_arm_states (\r\n        algorithm, algorithm_version, context_hash, facilitator_id,\r\n        pulls, total_reward, avg_reward, last_pulled, updated_at,\r\n        success_count, failure_count\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)\r\n      ON CONFLICT (algorithm, algorithm_version, context_hash, facilitator_id)\r\n      DO UPDATE SET\r\n        pulls = EXCLUDED.pulls,\r\n        total_reward = EXCLUDED.total_reward,\r\n        avg_reward = EXCLUDED.avg_reward,\r\n        last_pulled = EXCLUDED.last_pulled,\r\n        updated_at = EXCLUDED.updated_at,\r\n        success_count = EXCLUDED.success_count,\r\n        failure_count = EXCLUDED.failure_count`,\r\n      [\r\n        algorithm,\r\n        algorithmVersion,\r\n        contextHash,\r\n        arm.facilitatorId,\r\n        arm.pulls,\r\n        arm.totalReward,\r\n        arm.avgReward,\r\n        arm.lastPulled?.toISOString() || null,\r\n        now,\r\n        arm.successCount ?? 0,\r\n        arm.failureCount ?? 0,\r\n      ]\r\n    );\r\n  } else {\r\n    // SQLite - use INSERT OR REPLACE\r\n    const stmt = (db as any).prepare(`\r\n      INSERT OR REPLACE INTO bandit_arm_states (\r\n        algorithm, algorithm_version, context_hash, facilitator_id,\r\n        pulls, total_reward, avg_reward, last_pulled, updated_at,\r\n        success_count, failure_count\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n    `);\r\n    stmt.run(\r\n      algorithm,\r\n      algorithmVersion,\r\n      contextHash,\r\n      arm.facilitatorId,\r\n      arm.pulls,\r\n      arm.totalReward,\r\n      arm.avgReward,\r\n      arm.lastPulled?.toISOString() || null,\r\n      now,\r\n      arm.successCount ?? 0,\r\n      arm.failureCount ?? 0,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Load bandit arm states for an algorithm\r\n */\r\nexport async function loadBanditArmStates(\r\n  algorithm: string,\r\n  algorithmVersion: string,\r\n  contextHash?: string\r\n): Promise<Map<string, BanditArmState>> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let query: string;\r\n  const params: any[] = [algorithm, algorithmVersion];\r\n\r\n  if (isPostgres) {\r\n    query = 'SELECT * FROM bandit_arm_states WHERE algorithm = $1 AND algorithm_version = $2';\r\n    if (contextHash) {\r\n      query += ' AND context_hash = $3';\r\n      params.push(contextHash);\r\n    }\r\n  } else {\r\n    query = 'SELECT * FROM bandit_arm_states WHERE algorithm = ? AND algorithm_version = ?';\r\n    if (contextHash) {\r\n      query += ' AND context_hash = ?';\r\n      params.push(contextHash);\r\n    }\r\n  }\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, params);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all(...params);\r\n  }\r\n\r\n  const arms = new Map<string, BanditArmState>();\r\n  for (const row of rows) {\r\n    const key = `${row.context_hash}-${row.facilitator_id}`;\r\n    arms.set(key, {\r\n      facilitatorId: row.facilitator_id,\r\n      pulls: row.pulls,\r\n      totalReward: parseFloat(row.total_reward),\r\n      avgReward: parseFloat(row.avg_reward),\r\n      lastPulled: row.last_pulled ? new Date(row.last_pulled) : undefined,\r\n    });\r\n  }\r\n\r\n  return arms;\r\n}\r\n\r\n// =============================================================================\r\n// AGGREGATION FUNCTIONS FOR SAMPLE THRESHOLDS\r\n// =============================================================================\r\n\r\n/**\r\n * Per-context facilitator statistics for bandit decisions\r\n */\r\nexport interface ContextFacilitatorStats {\r\n  contextHash: string;\r\n  facilitatorId: string;\r\n  realDecisionCount: number; // Rows where is_counterfactual = false AND bandit_chosen = facilitator\r\n  meanCombined: number;\r\n  failureRate: number;\r\n  successCount: number;\r\n  failureCount: number;\r\n  avgLatencyMs: number | null;\r\n}\r\n\r\n/**\r\n * Get per-context, per-facilitator statistics for bandit decisions\r\n * Used to determine if we have enough samples to trust bandit estimates\r\n */\r\nexport async function getContextFacilitatorStats(\r\n  algorithm: string,\r\n  algorithmVersion: string,\r\n  contextHash?: string\r\n): Promise<ContextFacilitatorStats[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let query: string;\r\n  const params: any[] = [algorithm, algorithmVersion];\r\n\r\n  if (isPostgres) {\r\n    query = `\r\n      SELECT \r\n        context_hash,\r\n        bandit_chosen_facilitator as facilitator_id,\r\n        COUNT(*) FILTER (WHERE is_counterfactual = false) as real_decision_count,\r\n        AVG((actual_reward->>'combined')::numeric) as mean_combined,\r\n        COUNT(*) FILTER (WHERE success = false) as failure_count,\r\n        COUNT(*) FILTER (WHERE success = true) as success_count,\r\n        CASE \r\n          WHEN COUNT(*) > 0 \r\n          THEN COUNT(*) FILTER (WHERE success = false)::numeric / COUNT(*)::numeric \r\n          ELSE 0 \r\n        END as failure_rate,\r\n        AVG(latency_ms) as avg_latency_ms\r\n      FROM routing_experiments\r\n      WHERE algorithm = $1 AND algorithm_version = $2\r\n    `;\r\n    if (contextHash) {\r\n      query += ` AND context_hash = $3`;\r\n      params.push(contextHash);\r\n    }\r\n    query += ` GROUP BY context_hash, bandit_chosen_facilitator`;\r\n  } else {\r\n    query = `\r\n      SELECT \r\n        context_hash,\r\n        bandit_chosen_facilitator as facilitator_id,\r\n        SUM(CASE WHEN is_counterfactual = 0 THEN 1 ELSE 0 END) as real_decision_count,\r\n        AVG(json_extract(actual_reward, '$.combined')) as mean_combined,\r\n        SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) as failure_count,\r\n        SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as success_count,\r\n        CASE \r\n          WHEN COUNT(*) > 0 \r\n          THEN CAST(SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) \r\n          ELSE 0 \r\n        END as failure_rate,\r\n        AVG(latency_ms) as avg_latency_ms\r\n      FROM routing_experiments\r\n      WHERE algorithm = ? AND algorithm_version = ?\r\n    `;\r\n    if (contextHash) {\r\n      query += ` AND context_hash = ?`;\r\n      params.push(contextHash);\r\n    }\r\n    query += ` GROUP BY context_hash, bandit_chosen_facilitator`;\r\n  }\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, params);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all(...params);\r\n  }\r\n\r\n  return rows.map((row) => ({\r\n    contextHash: row.context_hash,\r\n    facilitatorId: row.facilitator_id,\r\n    realDecisionCount: parseInt(row.real_decision_count, 10) || 0,\r\n    meanCombined: parseFloat(row.mean_combined) || 0,\r\n    failureRate: parseFloat(row.failure_rate) || 0,\r\n    successCount: parseInt(row.success_count, 10) || 0,\r\n    failureCount: parseInt(row.failure_count, 10) || 0,\r\n    avgLatencyMs: row.avg_latency_ms ? parseFloat(row.avg_latency_ms) : null,\r\n  }));\r\n}\r\n\r\n/**\r\n * Check if all facilitators for a context have enough real decisions\r\n */\r\nexport async function hasEnoughSamplesForContext(\r\n  algorithm: string,\r\n  algorithmVersion: string,\r\n  contextHash: string,\r\n  availableFacilitators: string[],\r\n  minRealDecisions: number\r\n): Promise<{\r\n  hasEnough: boolean;\r\n  facilitatorCounts: Map<string, number>;\r\n  minCount: number;\r\n}> {\r\n  const stats = await getContextFacilitatorStats(algorithm, algorithmVersion, contextHash);\r\n  \r\n  const facilitatorCounts = new Map<string, number>();\r\n  for (const f of availableFacilitators) {\r\n    facilitatorCounts.set(f, 0);\r\n  }\r\n  for (const stat of stats) {\r\n    if (availableFacilitators.includes(stat.facilitatorId)) {\r\n      facilitatorCounts.set(stat.facilitatorId, stat.realDecisionCount);\r\n    }\r\n  }\r\n  \r\n  const counts = Array.from(facilitatorCounts.values());\r\n  const minCount = counts.length > 0 ? Math.min(...counts) : 0;\r\n  \r\n  return {\r\n    hasEnough: counts.every(c => c >= minRealDecisions),\r\n    facilitatorCounts,\r\n    minCount,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// HELPERS\r\n// =============================================================================\r\n\r\nfunction rowToExperiment(row: any): RoutingExperiment {\r\n  return {\r\n    id: row.id,\r\n    routeId: row.route_id || undefined,\r\n    timestamp: new Date(row.timestamp),\r\n    context: typeof row.context === 'string' ? JSON.parse(row.context) : row.context,\r\n    contextHash: row.context_hash,\r\n    availableFacilitators:\r\n      typeof row.available_facilitators === 'string'\r\n        ? JSON.parse(row.available_facilitators)\r\n        : row.available_facilitators,\r\n    actualFacilitator: row.actual_facilitator,\r\n    actualReward:\r\n      typeof row.actual_reward === 'string'\r\n        ? JSON.parse(row.actual_reward)\r\n        : row.actual_reward,\r\n    banditChosenFacilitator: row.bandit_chosen_facilitator,\r\n    banditEstimatedReward: row.bandit_estimated_reward !== null\r\n      ? parseFloat(row.bandit_estimated_reward)\r\n      : null,\r\n    isCounterfactual: row.is_counterfactual === true || row.is_counterfactual === 1,\r\n    algorithm: row.algorithm,\r\n    algorithmVersion: row.algorithm_version,\r\n    algorithmState: row.algorithm_state\r\n      ? typeof row.algorithm_state === 'string'\r\n        ? JSON.parse(row.algorithm_state)\r\n        : row.algorithm_state\r\n      : undefined,\r\n  };\r\n}\r\n","// =============================================================================\r\n// BANDIT SHADOW ROUTING\r\n// =============================================================================\r\n// Contextual bandit for shadow routing experiments\r\n// Does NOT affect live routing - only simulates and logs decisions\r\n//\r\n// Algorithms implemented:\r\n// - -greedy: Explore with probability , exploit otherwise\r\n// - UCB1: Upper Confidence Bound for exploration/exploitation balance\r\n//\r\n// IMPORTANT: This is an OFFLINE simulation. For each historical event:\r\n// 1. FIRST, compute what bandit would choose given current state\r\n// 2. THEN, update bandit state with observed outcome\r\n// This ensures proper offline policy evaluation semantics.\r\n\r\nimport { createLogger } from '@/lib/logger';\r\nimport { getDb } from '@/db/client';\r\nimport {\r\n  createRoutingExperiment,\r\n  saveBanditArmState,\r\n  loadBanditArmStates,\r\n  checkExperimentExists,\r\n  pruneOldExperiments,\r\n  hasEnoughSamplesForContext,\r\n  getContextFacilitatorStats,\r\n  type BanditArmStateExtended,\r\n} from '@/db/routing-experiments';\r\nimport type {\r\n  BanditContext,\r\n  BanditReward,\r\n  BanditArmState,\r\n  RoutingExperiment,\r\n} from './types';\r\n\r\nconst logger = createLogger({ component: 'BanditRouting' });\r\n\r\n// =============================================================================\r\n// CONFIGURATION (can be overridden via env vars)\r\n// =============================================================================\r\n\r\nexport const BANDIT_CONFIG = {\r\n  // -greedy parameters\r\n  epsilon: parseFloat(process.env.BANDIT_EPSILON || '0.1'), // 10% exploration rate\r\n  \r\n  // UCB1 parameters\r\n  explorationBonus: parseFloat(process.env.BANDIT_UCB_BONUS || '2.0'), // Exploration bonus coefficient\r\n  \r\n  // Reward computation - NEW v2 formula makes failures \"louder\"\r\n  // Success base: ~0.6, Failure base: ~-0.15, Range: [-0.3, 0.7]\r\n  rewardBase: {\r\n    success: parseFloat(process.env.BANDIT_REWARD_SUCCESS || '0.6'),   // Base reward for success\r\n    failure: parseFloat(process.env.BANDIT_REWARD_FAILURE || '-0.15'), // Base penalty for failure (loud!)\r\n  },\r\n  \r\n  // Penalty weights applied to both success and failure cases\r\n  penaltyWeights: {\r\n    latency: parseFloat(process.env.BANDIT_PENALTY_LATENCY || '0.08'),\r\n    cost: parseFloat(process.env.BANDIT_PENALTY_COST || '0.02'),\r\n  },\r\n  \r\n  // Latency normalization\r\n  maxLatencyMs: parseInt(process.env.BANDIT_MAX_LATENCY_MS || '5000', 10),\r\n  \r\n  // Cost normalization\r\n  maxFeeBps: parseInt(process.env.BANDIT_MAX_FEE_BPS || '100', 10),\r\n  \r\n  // Safety limits\r\n  maxBanditHours: parseInt(process.env.BANDIT_MAX_HOURS || '24', 10), // Max replay window\r\n  \r\n  // Algorithm version (increment when changing algorithm behavior)\r\n  // v2: Loud failures, explicit metrics columns\r\n  algorithmVersion: process.env.BANDIT_ALGORITHM_VERSION || 'v2',\r\n  \r\n  // Pruning settings\r\n  experimentRetentionDays: parseInt(process.env.BANDIT_RETENTION_DAYS || '30', 10),\r\n  \r\n  // Sample thresholds for bandit decisions\r\n  // If a facilitator has fewer than this many real decisions, use SMF priors\r\n  minRealDecisions: parseInt(process.env.BANDIT_MIN_REAL_DECISIONS || '20', 10),\r\n  \r\n  // Minimum exploration probability when using priors (prevents starving arms)\r\n  minExplorationProbability: parseFloat(process.env.BANDIT_MIN_EXPLORE_PROB || '0.05'),\r\n};\r\n\r\n// =============================================================================\r\n// CONTEXT HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Discretize amount into buckets\r\n * Handles both decimal strings (e.g., \"0.05\") and wei/smallest unit strings\r\n */\r\nfunction getAmountBucket(amountStr: string): BanditContext['amountBucket'] {\r\n  // Try parsing as a decimal first (e.g., \"0.05\", \"100.50\")\r\n  const amountFloat = parseFloat(amountStr);\r\n  \r\n  if (!isNaN(amountFloat)) {\r\n    // Interpret as USD value\r\n    if (amountFloat < 1) return 'micro';\r\n    if (amountFloat < 100) return 'small';\r\n    if (amountFloat < 10000) return 'medium';\r\n    return 'large';\r\n  }\r\n  \r\n  // Fallback: try as BigInt (smallest units like wei)\r\n  try {\r\n    const amount = BigInt(amountStr);\r\n    const oneDollar = BigInt('1000000'); // 1 USDC in 6 decimals\r\n    \r\n    if (amount < oneDollar) return 'micro';\r\n    if (amount < oneDollar * BigInt(100)) return 'small';\r\n    if (amount < oneDollar * BigInt(10000)) return 'medium';\r\n    return 'large';\r\n  } catch {\r\n    // If all else fails, default to small\r\n    return 'small';\r\n  }\r\n}\r\n\r\n/**\r\n * Get time of day bucket\r\n */\r\nfunction getTimeOfDay(timestamp: Date): BanditContext['timeOfDay'] {\r\n  const hour = timestamp.getUTCHours();\r\n  if (hour >= 5 && hour < 12) return 'morning';\r\n  if (hour >= 12 && hour < 17) return 'afternoon';\r\n  if (hour >= 17 && hour < 21) return 'evening';\r\n  return 'night';\r\n}\r\n\r\n/**\r\n * Get day of week bucket\r\n */\r\nfunction getDayOfWeek(timestamp: Date): BanditContext['dayOfWeek'] {\r\n  const day = timestamp.getUTCDay();\r\n  return day === 0 || day === 6 ? 'weekend' : 'weekday';\r\n}\r\n\r\n/**\r\n * Build context from route data\r\n */\r\nexport function buildContext(\r\n  network: string,\r\n  asset: string,\r\n  amount: string,\r\n  timestamp: Date\r\n): BanditContext {\r\n  return {\r\n    network,\r\n    asset,\r\n    amountBucket: getAmountBucket(amount),\r\n    timeOfDay: getTimeOfDay(timestamp),\r\n    dayOfWeek: getDayOfWeek(timestamp),\r\n  };\r\n}\r\n\r\n/**\r\n * Create a hash key for context (for arm state lookup)\r\n */\r\nexport function hashContext(context: BanditContext): string {\r\n  return `${context.network}|${context.asset}|${context.amountBucket}|${context.timeOfDay}|${context.dayOfWeek}`;\r\n}\r\n\r\n// =============================================================================\r\n// REWARD COMPUTATION\r\n// =============================================================================\r\n\r\n/**\r\n * Extended reward with explicit metrics for analytics\r\n */\r\nexport interface BanditRewardExtended extends BanditReward {\r\n  latencyMs: number;\r\n  costBps: number;\r\n}\r\n\r\n/**\r\n * Compute reward from outcome\r\n * \r\n * NEW v2 FORMULA - Makes failures \"louder\":\r\n * - Success: base_success (0.6) - latencyPenalty - costPenalty  ~0.5-0.6\r\n * - Failure: base_failure (-0.15) - latencyPenalty - costPenalty  ~-0.15 to -0.25\r\n * \r\n * This creates clear separation between success/failure in bandit learning.\r\n * Range is approximately [-0.3, 0.7]\r\n */\r\nexport function computeReward(\r\n  success: boolean,\r\n  latencyMs: number,\r\n  feeBps: number\r\n): BanditRewardExtended {\r\n  const successValue = success ? 1 : 0;\r\n  \r\n  // Latency penalty: 0 = instant, 1 = very slow\r\n  const latencyPenalty = Math.min(1, latencyMs / BANDIT_CONFIG.maxLatencyMs);\r\n  \r\n  // Cost penalty: 0 = free, 1 = expensive\r\n  const costPenalty = Math.min(1, feeBps / BANDIT_CONFIG.maxFeeBps);\r\n  \r\n  // NEW v2: Use different base rewards for success vs failure\r\n  // This makes failures significantly more negative than before\r\n  const baseReward = success \r\n    ? BANDIT_CONFIG.rewardBase.success   // +0.6 for success\r\n    : BANDIT_CONFIG.rewardBase.failure;  // -0.15 for failure (LOUD!)\r\n  \r\n  // Apply latency and cost penalties (same for both success/failure)\r\n  const combined = baseReward \r\n    - BANDIT_CONFIG.penaltyWeights.latency * latencyPenalty \r\n    - BANDIT_CONFIG.penaltyWeights.cost * costPenalty;\r\n\r\n  return {\r\n    success: successValue,\r\n    latencyPenalty,\r\n    costPenalty,\r\n    combined,\r\n    // NEW: Explicit metrics for analytics (not hidden in JSON only)\r\n    latencyMs,\r\n    costBps: feeBps,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// BANDIT ALGORITHMS\r\n// =============================================================================\r\n\r\n/**\r\n * -greedy algorithm\r\n * - With probability , choose randomly (explore)\r\n * - Otherwise, choose the arm with highest average reward (exploit)\r\n */\r\nexport function epsilonGreedySelect(\r\n  contextHash: string,\r\n  availableFacilitators: string[],\r\n  arms: Map<string, BanditArmState>,\r\n  epsilon: number = BANDIT_CONFIG.epsilon\r\n): { chosen: string; estimated: number; isExplore: boolean } {\r\n  if (availableFacilitators.length === 0) {\r\n    throw new Error('No available facilitators');\r\n  }\r\n\r\n  // Explore with probability epsilon\r\n  if (Math.random() < epsilon) {\r\n    const randomIdx = Math.floor(Math.random() * availableFacilitators.length);\r\n    const chosen = availableFacilitators[randomIdx];\r\n    const armKey = `${contextHash}-${chosen}`;\r\n    const arm = arms.get(armKey);\r\n    return {\r\n      chosen,\r\n      estimated: arm?.avgReward || 0,\r\n      isExplore: true,\r\n    };\r\n  }\r\n\r\n  // Exploit: choose best arm\r\n  let bestFacilitator = availableFacilitators[0];\r\n  let bestAvgReward = -Infinity;\r\n\r\n  for (const facilitatorId of availableFacilitators) {\r\n    const armKey = `${contextHash}-${facilitatorId}`;\r\n    const arm = arms.get(armKey);\r\n    const avgReward = arm?.avgReward || 0;\r\n\r\n    if (avgReward > bestAvgReward) {\r\n      bestAvgReward = avgReward;\r\n      bestFacilitator = facilitatorId;\r\n    }\r\n  }\r\n\r\n  return {\r\n    chosen: bestFacilitator,\r\n    estimated: bestAvgReward === -Infinity ? 0 : bestAvgReward,\r\n    isExplore: false,\r\n  };\r\n}\r\n\r\n/**\r\n * UCB1 algorithm\r\n * Choose arm that maximizes: avgReward + c * sqrt(ln(totalPulls) / armPulls)\r\n * This balances exploitation (avgReward) with exploration (bonus for less-pulled arms)\r\n */\r\nexport function ucb1Select(\r\n  contextHash: string,\r\n  availableFacilitators: string[],\r\n  arms: Map<string, BanditArmState>,\r\n  totalPulls: number,\r\n  explorationBonus: number = BANDIT_CONFIG.explorationBonus\r\n): { chosen: string; estimated: number; ucbScore: number } {\r\n  if (availableFacilitators.length === 0) {\r\n    throw new Error('No available facilitators');\r\n  }\r\n\r\n  // If we haven't tried all arms, pick an untried one\r\n  for (const facilitatorId of availableFacilitators) {\r\n    const armKey = `${contextHash}-${facilitatorId}`;\r\n    const arm = arms.get(armKey);\r\n    if (!arm || arm.pulls === 0) {\r\n      return {\r\n        chosen: facilitatorId,\r\n        estimated: 0,\r\n        ucbScore: Infinity, // Always try untried arms first\r\n      };\r\n    }\r\n  }\r\n\r\n  // All arms have been tried at least once - use UCB formula\r\n  let bestFacilitator = availableFacilitators[0];\r\n  let bestUcbScore = -Infinity;\r\n  let bestEstimated = 0;\r\n\r\n  const logTotalPulls = Math.log(Math.max(1, totalPulls));\r\n\r\n  for (const facilitatorId of availableFacilitators) {\r\n    const armKey = `${contextHash}-${facilitatorId}`;\r\n    const arm = arms.get(armKey);\r\n    \r\n    if (!arm) continue;\r\n\r\n    const avgReward = arm.avgReward;\r\n    const explorationTerm = explorationBonus * Math.sqrt(logTotalPulls / arm.pulls);\r\n    const ucbScore = avgReward + explorationTerm;\r\n\r\n    if (ucbScore > bestUcbScore) {\r\n      bestUcbScore = ucbScore;\r\n      bestFacilitator = facilitatorId;\r\n      bestEstimated = avgReward;\r\n    }\r\n  }\r\n\r\n  return {\r\n    chosen: bestFacilitator,\r\n    estimated: bestEstimated,\r\n    ucbScore: bestUcbScore === -Infinity ? 0 : bestUcbScore,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// SMF PRIORS INTEGRATION\r\n// =============================================================================\r\n\r\n/**\r\n * SMF prior scores from external sources (x402scan, Scattering)\r\n * Used when bandit doesn't have enough samples\r\n */\r\nexport interface SMFPrior {\r\n  facilitatorId: string;\r\n  score: number; // 0-100 composite score\r\n  successRate: number; // 0-1\r\n  avgLatencyMs: number;\r\n  volume24h?: number;\r\n  trustTier: 'high' | 'medium' | 'low' | 'unknown';\r\n}\r\n\r\n/**\r\n * Default SMF priors for known facilitators\r\n * These are used as fallback when external data isn't available\r\n * Based on historical x402scan data\r\n */\r\nexport function getDefaultSMFPriors(): SMFPrior[] {\r\n  return [\r\n    {\r\n      facilitatorId: 'cdp',\r\n      score: 95,\r\n      successRate: 0.998,\r\n      avgLatencyMs: 450,\r\n      trustTier: 'high',\r\n    },\r\n    {\r\n      facilitatorId: 'x402rs',\r\n      score: 88,\r\n      successRate: 0.992,\r\n      avgLatencyMs: 380,\r\n      trustTier: 'high',\r\n    },\r\n    {\r\n      facilitatorId: 'payai',\r\n      score: 82,\r\n      successRate: 0.985,\r\n      avgLatencyMs: 520,\r\n      trustTier: 'medium',\r\n    },\r\n    {\r\n      facilitatorId: 'dexter',\r\n      score: 78,\r\n      successRate: 0.975,\r\n      avgLatencyMs: 600,\r\n      trustTier: 'medium',\r\n    },\r\n  ];\r\n}\r\n\r\n/**\r\n * Convert SMF prior to estimated reward (for blending with bandit estimates)\r\n * Maps 0-100 score to approximately [0, 0.6] range\r\n */\r\nfunction priorToEstimatedReward(prior: SMFPrior): number {\r\n  // Base from success rate (0-0.6)\r\n  const successComponent = prior.successRate * BANDIT_CONFIG.rewardBase.success;\r\n  \r\n  // Latency penalty (0-0.08)\r\n  const latencyPenalty = Math.min(1, prior.avgLatencyMs / BANDIT_CONFIG.maxLatencyMs) \r\n    * BANDIT_CONFIG.penaltyWeights.latency;\r\n  \r\n  return successComponent - latencyPenalty;\r\n}\r\n\r\n/**\r\n * Selection result with metadata about decision source\r\n */\r\nexport interface SelectionResult {\r\n  chosen: string;\r\n  estimated: number;\r\n  isExplore: boolean;\r\n  usedPriors: boolean; // True if decision was primarily based on SMF priors\r\n  sampleCounts?: Map<string, number>; // Per-facilitator sample counts\r\n}\r\n\r\n/**\r\n * -greedy with sample threshold and SMF priors\r\n * \r\n * Behavior:\r\n * 1. If ANY facilitator has < MIN_REAL_DECISIONS samples for this context:\r\n *    - Use SMF priors as base ordering\r\n *    - Still explore with , but clamp minimum probability\r\n * 2. Once ALL facilitators have >= MIN_REAL_DECISIONS:\r\n *    - Use pure -greedy on bandit estimates\r\n *    - SMF priors only as tie-breaker\r\n */\r\nexport async function epsilonGreedyWithPriors(\r\n  contextHash: string,\r\n  availableFacilitators: string[],\r\n  arms: Map<string, BanditArmState>,\r\n  options: {\r\n    epsilon?: number;\r\n    minRealDecisions?: number;\r\n    smfPriors?: SMFPrior[];\r\n    algorithm?: string;\r\n    algorithmVersion?: string;\r\n  } = {}\r\n): Promise<SelectionResult> {\r\n  const epsilon = options.epsilon ?? BANDIT_CONFIG.epsilon;\r\n  const minRealDecisions = options.minRealDecisions ?? BANDIT_CONFIG.minRealDecisions;\r\n  const smfPriors = options.smfPriors ?? getDefaultSMFPriors();\r\n  const algorithm = options.algorithm ?? 'epsilon_greedy';\r\n  const algorithmVersion = options.algorithmVersion ?? BANDIT_CONFIG.algorithmVersion;\r\n\r\n  if (availableFacilitators.length === 0) {\r\n    throw new Error('No available facilitators');\r\n  }\r\n\r\n  // Check if we have enough samples for all facilitators\r\n  const sampleInfo = await hasEnoughSamplesForContext(\r\n    algorithm,\r\n    algorithmVersion,\r\n    contextHash,\r\n    availableFacilitators,\r\n    minRealDecisions\r\n  );\r\n\r\n  // Build prior map for quick lookup\r\n  const priorMap = new Map<string, SMFPrior>();\r\n  for (const prior of smfPriors) {\r\n    priorMap.set(prior.facilitatorId, prior);\r\n  }\r\n\r\n  // ===================================================================\r\n  // CASE 1: Not enough samples - use SMF priors with exploration\r\n  // ===================================================================\r\n  if (!sampleInfo.hasEnough) {\r\n    logger.debug({\r\n      contextHash,\r\n      minCount: sampleInfo.minCount,\r\n      minRequired: minRealDecisions,\r\n      msg: 'Using SMF priors (insufficient samples)',\r\n    });\r\n\r\n    // Sort facilitators by SMF prior score\r\n    const sortedByPrior = [...availableFacilitators].sort((a, b) => {\r\n      const priorA = priorMap.get(a)?.score ?? 50;\r\n      const priorB = priorMap.get(b)?.score ?? 50;\r\n      return priorB - priorA; // Higher score first\r\n    });\r\n\r\n    // Explore with probability epsilon\r\n    if (Math.random() < epsilon) {\r\n      const randomIdx = Math.floor(Math.random() * availableFacilitators.length);\r\n      const chosen = availableFacilitators[randomIdx];\r\n      const prior = priorMap.get(chosen);\r\n      return {\r\n        chosen,\r\n        estimated: prior ? priorToEstimatedReward(prior) : 0,\r\n        isExplore: true,\r\n        usedPriors: true,\r\n        sampleCounts: sampleInfo.facilitatorCounts,\r\n      };\r\n    }\r\n\r\n    // Exploit: use best by SMF prior\r\n    const chosen = sortedByPrior[0];\r\n    const prior = priorMap.get(chosen);\r\n    return {\r\n      chosen,\r\n      estimated: prior ? priorToEstimatedReward(prior) : 0,\r\n      isExplore: false,\r\n      usedPriors: true,\r\n      sampleCounts: sampleInfo.facilitatorCounts,\r\n    };\r\n  }\r\n\r\n  // ===================================================================\r\n  // CASE 2: Enough samples - use pure -greedy on bandit estimates\r\n  // ===================================================================\r\n  \r\n  // Explore with probability epsilon\r\n  if (Math.random() < epsilon) {\r\n    const randomIdx = Math.floor(Math.random() * availableFacilitators.length);\r\n    const chosen = availableFacilitators[randomIdx];\r\n    const armKey = `${contextHash}-${chosen}`;\r\n    const arm = arms.get(armKey);\r\n    return {\r\n      chosen,\r\n      estimated: arm?.avgReward ?? 0,\r\n      isExplore: true,\r\n      usedPriors: false,\r\n      sampleCounts: sampleInfo.facilitatorCounts,\r\n    };\r\n  }\r\n\r\n  // Exploit: choose best arm by bandit estimate\r\n  // Use SMF prior as tie-breaker\r\n  let bestFacilitator = availableFacilitators[0];\r\n  let bestAvgReward = -Infinity;\r\n  let bestPriorScore = -Infinity;\r\n\r\n  for (const facilitatorId of availableFacilitators) {\r\n    const armKey = `${contextHash}-${facilitatorId}`;\r\n    const arm = arms.get(armKey);\r\n    const avgReward = arm?.avgReward ?? 0;\r\n    const priorScore = priorMap.get(facilitatorId)?.score ?? 50;\r\n\r\n    // Primary: avgReward, Secondary: priorScore (tie-breaker)\r\n    if (avgReward > bestAvgReward || \r\n        (avgReward === bestAvgReward && priorScore > bestPriorScore)) {\r\n      bestAvgReward = avgReward;\r\n      bestPriorScore = priorScore;\r\n      bestFacilitator = facilitatorId;\r\n    }\r\n  }\r\n\r\n  return {\r\n    chosen: bestFacilitator,\r\n    estimated: bestAvgReward === -Infinity ? 0 : bestAvgReward,\r\n    isExplore: false,\r\n    usedPriors: false,\r\n    sampleCounts: sampleInfo.facilitatorCounts,\r\n  };\r\n}\r\n\r\n/**\r\n * Main facilitator selection function with configurable algorithm\r\n * This is the primary entry point for live routing decisions\r\n */\r\nexport async function selectFacilitatorForContext(params: {\r\n  contextHash: string;\r\n  availableFacilitators: string[];\r\n  banditState: Map<string, BanditArmState>;\r\n  algorithm?: 'epsilon_greedy' | 'epsilon_greedy_with_priors' | 'ucb1';\r\n  smfPriors?: SMFPrior[];\r\n}): Promise<SelectionResult> {\r\n  const algorithm = params.algorithm ?? 'epsilon_greedy_with_priors';\r\n\r\n  switch (algorithm) {\r\n    case 'epsilon_greedy':\r\n      const egResult = epsilonGreedySelect(\r\n        params.contextHash,\r\n        params.availableFacilitators,\r\n        params.banditState\r\n      );\r\n      return {\r\n        ...egResult,\r\n        usedPriors: false,\r\n      };\r\n\r\n    case 'epsilon_greedy_with_priors':\r\n      return epsilonGreedyWithPriors(\r\n        params.contextHash,\r\n        params.availableFacilitators,\r\n        params.banditState,\r\n        { smfPriors: params.smfPriors }\r\n      );\r\n\r\n    case 'ucb1':\r\n      const totalPulls = Array.from(params.banditState.values())\r\n        .reduce((sum, arm) => sum + arm.pulls, 0);\r\n      const ucbResult = ucb1Select(\r\n        params.contextHash,\r\n        params.availableFacilitators,\r\n        params.banditState,\r\n        totalPulls\r\n      );\r\n      return {\r\n        chosen: ucbResult.chosen,\r\n        estimated: ucbResult.estimated,\r\n        isExplore: ucbResult.ucbScore === Infinity, // Untried arm\r\n        usedPriors: false,\r\n      };\r\n\r\n    default:\r\n      throw new Error(`Unknown algorithm: ${algorithm}`);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// SHADOW SIMULATION\r\n// =============================================================================\r\n\r\n/**\r\n * Historical route data from route_attempts joined with routes\r\n */\r\ninterface HistoricalRoute {\r\n  routeId: string;\r\n  timestamp: Date;\r\n  network: string;\r\n  token: string;\r\n  amount: string;\r\n  facilitatorId: string;\r\n  result: 'success' | 'failure' | 'timeout' | 'rate_limited' | 'insufficient_liquidity' | 'invalid_request' | 'network_error';\r\n  latencyMs: number;\r\n  feeBps: number;\r\n}\r\n\r\n/**\r\n * Get historical routes for simulation\r\n */\r\nasync function getHistoricalRoutes(\r\n  fromTimestamp: Date,\r\n  toTimestamp: Date\r\n): Promise<HistoricalRoute[]> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  // Query routes with their attempts\r\n  // Only include non-probe attempts\r\n  const query = isPostgres\r\n    ? `\r\n      SELECT \r\n        r.id as route_id,\r\n        r.created_at as timestamp,\r\n        r.network,\r\n        r.token,\r\n        r.amount,\r\n        ra.facilitator_id,\r\n        ra.result,\r\n        ra.latency_ms\r\n      FROM routes r\r\n      JOIN route_attempts ra ON r.id = ra.route_id\r\n      WHERE r.created_at >= $1 \r\n        AND r.created_at < $2\r\n        AND ra.is_probe = false\r\n        AND ra.phase = 'verify'\r\n      ORDER BY r.created_at ASC\r\n    `\r\n    : `\r\n      SELECT \r\n        r.id as route_id,\r\n        r.created_at as timestamp,\r\n        r.network,\r\n        r.token,\r\n        r.amount,\r\n        ra.facilitator_id,\r\n        ra.result,\r\n        ra.latency_ms\r\n      FROM routes r\r\n      JOIN route_attempts ra ON r.id = ra.route_id\r\n      WHERE r.created_at >= ?\r\n        AND r.created_at < ?\r\n        AND ra.is_probe = 0\r\n        AND ra.phase = 'verify'\r\n      ORDER BY r.created_at ASC\r\n    `;\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, [\r\n      fromTimestamp.toISOString(),\r\n      toTimestamp.toISOString(),\r\n    ]);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all(fromTimestamp.toISOString(), toTimestamp.toISOString());\r\n  }\r\n\r\n  return rows.map((row) => ({\r\n    routeId: row.route_id,\r\n    timestamp: new Date(row.timestamp),\r\n    network: row.network,\r\n    token: row.token,\r\n    amount: row.amount,\r\n    facilitatorId: row.facilitator_id,\r\n    result: row.result,\r\n    latencyMs: row.latency_ms,\r\n    feeBps: 0, // TODO: Get from facilitator capabilities table\r\n  }));\r\n}\r\n\r\n/**\r\n * Get list of available facilitators for a network/token\r\n * TODO: Query facilitator registry/capabilities for actual available facilitators\r\n */\r\nfunction getAvailableFacilitators(network: string, token: string): string[] {\r\n  // For now, use hardcoded list\r\n  // In production, this should query the facilitator registry\r\n  return ['cdp', 'payai', 'x402rs', 'dexter'];\r\n}\r\n\r\n/**\r\n * Run bandit shadow simulation on historical data\r\n * \r\n * OFFLINE SIMULATION SEMANTICS:\r\n * For each historical route, we:\r\n * 1. FIRST compute what bandit would choose (before seeing this outcome)\r\n * 2. THEN update bandit state with the observed outcome\r\n * \r\n * This ensures proper offline policy evaluation.\r\n * \r\n * COLD-START BEHAVIOR:\r\n * When no historical routes are found in the time window (routesProcessed = 0),\r\n * this is a \"cold start\" scenario. The bandit cannot compute rewards or \r\n * counterfactuals without data. In this case:\r\n * - banditColdStart = true is returned\r\n * - The system should use deterministic routing until traffic populates history\r\n * - This is intentional and expected for new deployments or quiet periods\r\n */\r\nexport async function runBanditShadowSimulation(params: {\r\n  fromTimestamp: Date;\r\n  toTimestamp: Date;\r\n  algorithm?: 'epsilon_greedy' | 'ucb1';\r\n}): Promise<{\r\n  experimentsCreated: number;\r\n  experimentsSkipped: number; // Duplicates\r\n  routesProcessed: number;\r\n  banditCorrectRate: number;\r\n  counterfactualCount: number;\r\n  durationMs: number;\r\n  banditColdStart: boolean; // True when no historical data available\r\n}> {\r\n  const startTime = Date.now();\r\n  const algorithm = params.algorithm || 'epsilon_greedy';\r\n  const algorithmVersion = BANDIT_CONFIG.algorithmVersion;\r\n\r\n  // Validate time window\r\n  const windowHours = (params.toTimestamp.getTime() - params.fromTimestamp.getTime()) / (1000 * 60 * 60);\r\n  if (windowHours > BANDIT_CONFIG.maxBanditHours) {\r\n    throw new Error(\r\n      `Bandit time window ${windowHours.toFixed(1)}h exceeds maximum ${BANDIT_CONFIG.maxBanditHours}h. ` +\r\n      `Use smaller windows or adjust BANDIT_MAX_HOURS env var.`\r\n    );\r\n  }\r\n\r\n  logger.info({\r\n    fromTimestamp: params.fromTimestamp.toISOString(),\r\n    toTimestamp: params.toTimestamp.toISOString(),\r\n    algorithm,\r\n    algorithmVersion,\r\n    windowHours: windowHours.toFixed(2),\r\n    msg: 'Starting bandit shadow simulation',\r\n  });\r\n\r\n  // 1. Load existing arm states\r\n  const arms = await loadBanditArmStates(algorithm, algorithmVersion);\r\n  let totalPulls = Array.from(arms.values()).reduce((sum, arm) => sum + arm.pulls, 0);\r\n\r\n  // 2. Get historical routes\r\n  const routes = await getHistoricalRoutes(params.fromTimestamp, params.toTimestamp);\r\n\r\n  // Cold-start detection: no historical data means we cannot compute bandit rewards\r\n  // or counterfactuals. This is expected for new deployments or quiet traffic periods.\r\n  // The system should fall back to deterministic routing until data accumulates.\r\n  if (routes.length === 0) {\r\n    logger.info({\r\n      fromTimestamp: params.fromTimestamp.toISOString(),\r\n      toTimestamp: params.toTimestamp.toISOString(),\r\n      algorithm,\r\n      banditColdStart: true,\r\n      msg: 'No historical routes found in time window - bandit in cold start mode',\r\n    });\r\n    return {\r\n      experimentsCreated: 0,\r\n      experimentsSkipped: 0,\r\n      routesProcessed: 0,\r\n      banditCorrectRate: 0,\r\n      counterfactualCount: 0,\r\n      durationMs: Date.now() - startTime,\r\n      banditColdStart: true,\r\n    };\r\n  }\r\n\r\n  // 3. Process each route\r\n  let experimentsCreated = 0;\r\n  let experimentsSkipped = 0;\r\n  let banditCorrectCount = 0;\r\n  let counterfactualCount = 0;\r\n  const armsToSave: Map<string, { contextHash: string; arm: BanditArmStateExtended }> = new Map();\r\n\r\n  for (const route of routes) {\r\n    // Check for duplicate (idempotency)\r\n    const exists = await checkExperimentExists(route.routeId, algorithm, algorithmVersion);\r\n    if (exists) {\r\n      experimentsSkipped++;\r\n      continue;\r\n    }\r\n\r\n    // Build context\r\n    const context = buildContext(\r\n      route.network,\r\n      route.token,\r\n      route.amount,\r\n      route.timestamp\r\n    );\r\n    const contextHash = hashContext(context);\r\n\r\n    // Get available facilitators\r\n    const availableFacilitators = getAvailableFacilitators(route.network, route.token);\r\n\r\n    // Skip if actual facilitator not in available list (edge case)\r\n    if (!availableFacilitators.includes(route.facilitatorId)) {\r\n      continue;\r\n    }\r\n\r\n    // =====================================================\r\n    // STEP 1: Compute what bandit would choose BEFORE update\r\n    // This is the key offline simulation semantic\r\n    // =====================================================\r\n    let banditChoice: { chosen: string; estimated: number };\r\n    if (algorithm === 'epsilon_greedy') {\r\n      banditChoice = epsilonGreedySelect(contextHash, availableFacilitators, arms);\r\n    } else {\r\n      banditChoice = ucb1Select(contextHash, availableFacilitators, arms, totalPulls);\r\n    }\r\n\r\n    // Check if bandit chose the same as actual\r\n    const isCounterfactual = banditChoice.chosen !== route.facilitatorId;\r\n    if (isCounterfactual) {\r\n      counterfactualCount++;\r\n    } else {\r\n      banditCorrectCount++;\r\n    }\r\n\r\n    // Compute actual reward from observed outcome\r\n    const success = route.result === 'success';\r\n    const actualReward = computeReward(success, route.latencyMs, route.feeBps);\r\n\r\n    // For counterfactual: we don't have observed reward for bandit's choice\r\n    // We can only estimate based on historical avg for that arm\r\n    const banditEstimatedReward = isCounterfactual\r\n      ? null // Explicitly null for counterfactual\r\n      : actualReward.combined; // Same as actual when matched\r\n\r\n    // Create experiment record\r\n    const experiment: Omit<RoutingExperiment, 'id'> = {\r\n      routeId: route.routeId,\r\n      timestamp: route.timestamp,\r\n      context,\r\n      contextHash,\r\n      availableFacilitators,\r\n      actualFacilitator: route.facilitatorId,\r\n      actualReward,\r\n      banditChosenFacilitator: banditChoice.chosen,\r\n      banditEstimatedReward,\r\n      isCounterfactual,\r\n      algorithm,\r\n      algorithmVersion,\r\n    };\r\n\r\n    await createRoutingExperiment(experiment);\r\n    experimentsCreated++;\r\n\r\n    // =====================================================\r\n    // STEP 2: Update arm state with actual observed outcome\r\n    // We update the arm that was ACTUALLY used, not bandit's choice\r\n    // v2: Now tracks success/failure counts for failure rate analytics\r\n    // =====================================================\r\n    const armKey = `${contextHash}-${route.facilitatorId}`;\r\n    const existingArm = arms.get(armKey) as BanditArmStateExtended | undefined;\r\n    \r\n    const updatedArm: BanditArmStateExtended = {\r\n      facilitatorId: route.facilitatorId,\r\n      pulls: (existingArm?.pulls || 0) + 1,\r\n      totalReward: (existingArm?.totalReward || 0) + actualReward.combined,\r\n      avgReward: 0, // Will be computed below\r\n      lastPulled: route.timestamp,\r\n      // v2: Track success/failure counts\r\n      successCount: (existingArm?.successCount || 0) + (success ? 1 : 0),\r\n      failureCount: (existingArm?.failureCount || 0) + (success ? 0 : 1),\r\n    };\r\n    updatedArm.avgReward = updatedArm.totalReward / updatedArm.pulls;\r\n\r\n    arms.set(armKey, updatedArm);\r\n    totalPulls++;\r\n\r\n    // Queue arm for batch save\r\n    armsToSave.set(armKey, { contextHash, arm: updatedArm });\r\n\r\n    // Batch save every 100 records\r\n    if (armsToSave.size >= 100) {\r\n      await batchSaveArms(algorithm, algorithmVersion, armsToSave);\r\n      armsToSave.clear();\r\n    }\r\n  }\r\n\r\n  // 4. Final persist of remaining arm states\r\n  if (armsToSave.size > 0) {\r\n    await batchSaveArms(algorithm, algorithmVersion, armsToSave);\r\n  }\r\n\r\n  const durationMs = Date.now() - startTime;\r\n  const processedCount = routes.length - experimentsSkipped;\r\n  const banditCorrectRate = processedCount > 0 ? banditCorrectCount / processedCount : 0;\r\n\r\n  logger.info({\r\n    experimentsCreated,\r\n    experimentsSkipped,\r\n    routesProcessed: routes.length,\r\n    banditCorrectRate: banditCorrectRate.toFixed(4),\r\n    counterfactualCount,\r\n    banditColdStart: false,\r\n    durationMs,\r\n    msg: 'Bandit shadow simulation completed',\r\n  });\r\n\r\n  return {\r\n    experimentsCreated,\r\n    experimentsSkipped,\r\n    routesProcessed: routes.length,\r\n    banditCorrectRate,\r\n    counterfactualCount,\r\n    durationMs,\r\n    banditColdStart: false,\r\n  };\r\n}\r\n\r\n/**\r\n * Batch save arm states\r\n */\r\nasync function batchSaveArms(\r\n  algorithm: string,\r\n  algorithmVersion: string,\r\n  arms: Map<string, { contextHash: string; arm: BanditArmStateExtended }>\r\n): Promise<void> {\r\n  for (const [, { contextHash, arm }] of arms) {\r\n    await saveBanditArmState(algorithm, algorithmVersion, contextHash, arm);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// ANALYSIS & MAINTENANCE\r\n// =============================================================================\r\n\r\n/**\r\n * Get bandit arm statistics for a context\r\n */\r\nexport async function getBanditArmStats(\r\n  algorithm: string,\r\n  algorithmVersion?: string,\r\n  contextHash?: string\r\n): Promise<Map<string, BanditArmState>> {\r\n  return loadBanditArmStates(algorithm, algorithmVersion || BANDIT_CONFIG.algorithmVersion, contextHash);\r\n}\r\n\r\n/**\r\n * Compare bandit vs actual routing performance\r\n */\r\nexport async function compareBanditPerformance(params: {\r\n  algorithm: string;\r\n  algorithmVersion?: string;\r\n  fromTimestamp: Date;\r\n  toTimestamp: Date;\r\n}): Promise<{\r\n  totalRoutes: number;\r\n  banditMatched: number;\r\n  counterfactual: number;\r\n  avgActualReward: number;\r\n  avgBanditEstimatedReward: number;\r\n  facilitatorStats: Array<{\r\n    facilitatorId: string;\r\n    actualPicks: number;\r\n    banditPicks: number;\r\n    avgActualReward: number;\r\n  }>;\r\n}> {\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n  const version = params.algorithmVersion || BANDIT_CONFIG.algorithmVersion;\r\n\r\n  const query = isPostgres\r\n    ? `\r\n      SELECT \r\n        actual_facilitator,\r\n        bandit_chosen_facilitator,\r\n        actual_reward,\r\n        bandit_estimated_reward,\r\n        is_counterfactual\r\n      FROM routing_experiments\r\n      WHERE algorithm = $1\r\n        AND algorithm_version = $2\r\n        AND timestamp >= $3\r\n        AND timestamp < $4\r\n    `\r\n    : `\r\n      SELECT \r\n        actual_facilitator,\r\n        bandit_chosen_facilitator,\r\n        actual_reward,\r\n        bandit_estimated_reward,\r\n        is_counterfactual\r\n      FROM routing_experiments\r\n      WHERE algorithm = ?\r\n        AND algorithm_version = ?\r\n        AND timestamp >= ?\r\n        AND timestamp < ?\r\n    `;\r\n\r\n  let rows: any[];\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(query, [\r\n      params.algorithm,\r\n      version,\r\n      params.fromTimestamp.toISOString(),\r\n      params.toTimestamp.toISOString(),\r\n    ]);\r\n    rows = result.rows;\r\n  } else {\r\n    const stmt = (db as any).prepare(query);\r\n    rows = stmt.all(\r\n      params.algorithm,\r\n      version,\r\n      params.fromTimestamp.toISOString(),\r\n      params.toTimestamp.toISOString()\r\n    );\r\n  }\r\n\r\n  let matched = 0;\r\n  let counterfactual = 0;\r\n  let totalActualReward = 0;\r\n  let totalEstimatedReward = 0;\r\n  let estimatedCount = 0;\r\n  const facilitatorMap = new Map<string, {\r\n    actualPicks: number;\r\n    banditPicks: number;\r\n    totalReward: number;\r\n  }>();\r\n\r\n  for (const row of rows) {\r\n    const actualReward = typeof row.actual_reward === 'string'\r\n      ? JSON.parse(row.actual_reward).combined\r\n      : row.actual_reward.combined;\r\n    const estimatedReward = row.bandit_estimated_reward !== null\r\n      ? parseFloat(row.bandit_estimated_reward)\r\n      : null;\r\n\r\n    totalActualReward += actualReward;\r\n    if (estimatedReward !== null) {\r\n      totalEstimatedReward += estimatedReward;\r\n      estimatedCount++;\r\n    }\r\n\r\n    if (row.is_counterfactual) {\r\n      counterfactual++;\r\n    } else {\r\n      matched++;\r\n    }\r\n\r\n    // Actual facilitator stats\r\n    const actualStats = facilitatorMap.get(row.actual_facilitator) || {\r\n      actualPicks: 0,\r\n      banditPicks: 0,\r\n      totalReward: 0,\r\n    };\r\n    actualStats.actualPicks++;\r\n    actualStats.totalReward += actualReward;\r\n    facilitatorMap.set(row.actual_facilitator, actualStats);\r\n\r\n    // Bandit pick stats\r\n    if (row.bandit_chosen_facilitator !== row.actual_facilitator) {\r\n      const banditStats = facilitatorMap.get(row.bandit_chosen_facilitator) || {\r\n        actualPicks: 0,\r\n        banditPicks: 0,\r\n        totalReward: 0,\r\n      };\r\n      banditStats.banditPicks++;\r\n      facilitatorMap.set(row.bandit_chosen_facilitator, banditStats);\r\n    } else {\r\n      const stats = facilitatorMap.get(row.actual_facilitator)!;\r\n      stats.banditPicks++;\r\n    }\r\n  }\r\n\r\n  const facilitatorStats = Array.from(facilitatorMap.entries()).map(([id, stats]) => ({\r\n    facilitatorId: id,\r\n    actualPicks: stats.actualPicks,\r\n    banditPicks: stats.banditPicks,\r\n    avgActualReward: stats.actualPicks > 0 ? stats.totalReward / stats.actualPicks : 0,\r\n  }));\r\n\r\n  return {\r\n    totalRoutes: rows.length,\r\n    banditMatched: matched,\r\n    counterfactual,\r\n    avgActualReward: rows.length > 0 ? totalActualReward / rows.length : 0,\r\n    avgBanditEstimatedReward: estimatedCount > 0 ? totalEstimatedReward / estimatedCount : 0,\r\n    facilitatorStats,\r\n  };\r\n}\r\n\r\n/**\r\n * Prune old experiments to control table size\r\n * Should be called periodically (e.g., daily) via cron\r\n */\r\nexport async function pruneOldBanditData(retentionDays?: number): Promise<{\r\n  experimentsDeleted: number;\r\n  armStatesDeleted: number;\r\n}> {\r\n  const days = retentionDays || BANDIT_CONFIG.experimentRetentionDays;\r\n  const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);\r\n\r\n  logger.info({\r\n    retentionDays: days,\r\n    cutoffDate: cutoffDate.toISOString(),\r\n    msg: 'Pruning old bandit data',\r\n  });\r\n\r\n  const experimentsDeleted = await pruneOldExperiments(cutoffDate);\r\n\r\n  // Prune arm states that haven't been updated in retention period\r\n  const db = getDb();\r\n  const isPostgres = 'pool' in db || typeof (db as any).pool?.query === 'function';\r\n\r\n  let armStatesDeleted = 0;\r\n  if (isPostgres) {\r\n    const result = await (db as any).pool.query(\r\n      `DELETE FROM bandit_arm_states WHERE updated_at < $1`,\r\n      [cutoffDate.toISOString()]\r\n    );\r\n    armStatesDeleted = result.rowCount || 0;\r\n  } else {\r\n    const stmt = (db as any).prepare('DELETE FROM bandit_arm_states WHERE updated_at < ?');\r\n    const info = stmt.run(cutoffDate.toISOString());\r\n    armStatesDeleted = info.changes || 0;\r\n  }\r\n\r\n  logger.info({\r\n    experimentsDeleted,\r\n    armStatesDeleted,\r\n    msg: 'Bandit data pruned',\r\n  });\r\n\r\n  return { experimentsDeleted, armStatesDeleted };\r\n}\r\n","// =============================================================================\r\n// COORDINATOR CRON ENDPOINT\r\n// =============================================================================\r\n// GET /api/cron/coord\r\n//\r\n// Runs the coordinator tick which:\r\n// 1. Builds world state from metrics and services\r\n// 2. Runs routing tuner (proposes facilitator changes)\r\n// 3. Runs pricing tuner (proposes pricing adjustments)\r\n// 4. Runs scout tuner (evaluates new facilitators)\r\n// 5. Persists recommendations to database\r\n// 6. Optionally runs bandit shadow simulation\r\n//\r\n// Query params:\r\n// - bandit=true: Also run bandit shadow simulation\r\n// - banditHours=N: Hours to replay (default: 1, max: 24)\r\n// - banditAlgo=epsilon_greedy|ucb1: Algorithm to use\r\n// - prune=true: Also prune old experiment data\r\n//\r\n// Triggered by Vercel Cron or manual invocation\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport { createLogger } from '@/lib/logger';\r\nimport { withCronJobTracking, type CronJobContext } from '@/lib/cron-job-wrapper';\r\nimport { runCoordinatorTick } from '@/agents/coordinator';\r\nimport { runBanditShadowSimulation, pruneOldBanditData, BANDIT_CONFIG } from '@/agents/bandit-routing';\r\nimport { expirePendingRecommendations } from '@/db/agent-recommendations';\r\n\r\nconst logger = createLogger({ component: 'CoordinatorCron' });\r\n\r\n// =============================================================================\r\n// CRON HANDLER\r\n// =============================================================================\r\n\r\nasync function coordHandler(\r\n  request: NextRequest,\r\n  context: CronJobContext\r\n): Promise<{ ok: boolean; [key: string]: any }> {\r\n  const { runId, requestId } = context;\r\n  const errors: string[] = [];\r\n\r\n  // ==========================================================================\r\n  // 1. Parse and validate query parameters\r\n  // ==========================================================================\r\n  const { searchParams } = new URL(request.url);\r\n  const runBandit = searchParams.get('bandit') === 'true';\r\n  const runPrune = searchParams.get('prune') === 'true';\r\n  const banditHoursParam = parseInt(searchParams.get('banditHours') || '1', 10);\r\n  const banditAlgorithm = (searchParams.get('banditAlgo') || 'epsilon_greedy') as 'epsilon_greedy' | 'ucb1';\r\n\r\n  // Validate bandit hours with sanity limit\r\n  const maxBanditHours = BANDIT_CONFIG.maxBanditHours;\r\n  if (banditHoursParam < 1 || banditHoursParam > maxBanditHours) {\r\n    logger.warn({\r\n      runId,\r\n      requestId,\r\n      banditHoursParam,\r\n      maxBanditHours,\r\n      msg: 'Invalid banditHours parameter',\r\n    });\r\n    return {\r\n      ok: false,\r\n      error: `banditHours must be between 1 and ${maxBanditHours}`,\r\n      code: 'INVALID_PARAM',\r\n    };\r\n  }\r\n\r\n  const banditHours = Math.min(banditHoursParam, maxBanditHours);\r\n\r\n  logger.info({\r\n    runId,\r\n    requestId,\r\n    runBandit,\r\n    runPrune,\r\n    banditHours,\r\n    banditAlgorithm,\r\n    msg: 'Starting coordinator cron',\r\n  });\r\n\r\n  // ==========================================================================\r\n  // 2. Expire old pending recommendations\r\n  // ==========================================================================\r\n  let expiredCount = 0;\r\n  try {\r\n    expiredCount = await expirePendingRecommendations();\r\n    if (expiredCount > 0) {\r\n      logger.info({ runId, requestId, expiredCount, msg: 'Expired old recommendations' });\r\n    }\r\n  } catch (error) {\r\n    const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n    errors.push(`Failed to expire recommendations: ${errorMsg}`);\r\n    logger.warn({ runId, requestId, error: errorMsg, msg: 'Failed to expire recommendations' });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // 3. Run coordinator tick\r\n  // ==========================================================================\r\n  const coordinatorResult = await runCoordinatorTick();\r\n\r\n  logger.info({\r\n    runId,\r\n    requestId,\r\n    coordRunId: coordinatorResult.runId,\r\n    totalRecommendations: coordinatorResult.totalRecommendations,\r\n    routingTunerRecs: coordinatorResult.routingTuner.recommendations.length,\r\n    pricingTunerRecs: coordinatorResult.pricingTuner.recommendations.length,\r\n    scoutTunerRecs: coordinatorResult.scoutTuner.recommendations.length,\r\n    facilitatorCount: coordinatorResult.worldState.facilitators.length,\r\n    routableCount: coordinatorResult.worldState.facilitators.filter(f => f.isRoutable).length,\r\n    riskAnomalyCount: coordinatorResult.worldState.riskAnomalies.length,\r\n    errorCount: coordinatorResult.errors.length,\r\n    msg: 'Coordinator tick completed',\r\n  });\r\n\r\n  // Add coordinator errors to our error list\r\n  errors.push(...coordinatorResult.errors);\r\n\r\n  // ==========================================================================\r\n  // 4. Optionally run bandit shadow simulation\r\n  // ==========================================================================\r\n  let banditResult: {\r\n    experimentsCreated: number;\r\n    experimentsSkipped: number;\r\n    routesProcessed: number;\r\n    banditCorrectRate: number;\r\n    counterfactualCount: number;\r\n    durationMs: number;\r\n    banditColdStart: boolean;\r\n  } | null = null;\r\n  \r\n  let usingDeterministicPolicy = false;\r\n\r\n  if (runBandit) {\r\n    const toTimestamp = new Date();\r\n    const fromTimestamp = new Date(toTimestamp.getTime() - banditHours * 60 * 60 * 1000);\r\n\r\n    try {\r\n      banditResult = await runBanditShadowSimulation({\r\n        fromTimestamp,\r\n        toTimestamp,\r\n        algorithm: banditAlgorithm,\r\n      });\r\n\r\n      const logMsg = banditResult.banditColdStart\r\n        ? 'Bandit in cold start; using deterministic routing'\r\n        : 'Bandit simulation completed';\r\n\r\n      logger.info({\r\n        runId,\r\n        requestId,\r\n        algorithm: banditAlgorithm,\r\n        timeWindowHours: banditHours,\r\n        routesProcessed: banditResult.routesProcessed,\r\n        experimentsCreated: banditResult.experimentsCreated,\r\n        experimentsSkipped: banditResult.experimentsSkipped,\r\n        banditCorrectRate: banditResult.banditCorrectRate.toFixed(4),\r\n        counterfactualCount: banditResult.counterfactualCount,\r\n        banditColdStart: banditResult.banditColdStart,\r\n        durationMs: banditResult.durationMs,\r\n        msg: logMsg,\r\n      });\r\n\r\n      if (banditResult.banditColdStart) {\r\n        usingDeterministicPolicy = true;\r\n        \r\n        logger.info({\r\n          runId,\r\n          requestId,\r\n          topPerformers: coordinatorResult.routingTuner.analysis.topPerformers,\r\n          routableCount: coordinatorResult.worldState.facilitators.filter(f => f.isRoutable).length,\r\n          msg: 'Bandit in cold start; deterministic routing policy in effect',\r\n        });\r\n      }\r\n    } catch (banditError) {\r\n      const errorMsg = banditError instanceof Error ? banditError.message : 'Unknown error';\r\n      errors.push(`Bandit simulation failed: ${errorMsg}`);\r\n      logger.error({\r\n        runId,\r\n        requestId,\r\n        error: errorMsg,\r\n        msg: 'Bandit simulation failed',\r\n      });\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // 5. Optionally prune old data\r\n  // ==========================================================================\r\n  let pruneResult: { experimentsDeleted: number; armStatesDeleted: number } | null = null;\r\n\r\n  if (runPrune) {\r\n    try {\r\n      pruneResult = await pruneOldBanditData();\r\n      logger.info({\r\n        runId,\r\n        requestId,\r\n        experimentsDeleted: pruneResult.experimentsDeleted,\r\n        armStatesDeleted: pruneResult.armStatesDeleted,\r\n        msg: 'Data pruning completed',\r\n      });\r\n    } catch (pruneError) {\r\n      const errorMsg = pruneError instanceof Error ? pruneError.message : 'Unknown error';\r\n      errors.push(`Data pruning failed: ${errorMsg}`);\r\n      logger.error({ runId, requestId, error: errorMsg, msg: 'Data pruning failed' });\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // 6. Build response\r\n  // ==========================================================================\r\n  return {\r\n    ok: errors.length === 0,\r\n    coordRunId: coordinatorResult.runId,\r\n    timestamp: coordinatorResult.completedAt.toISOString(),\r\n    \r\n    coordinator: {\r\n      totalRecommendations: coordinatorResult.totalRecommendations,\r\n      routingTuner: {\r\n        recommendations: coordinatorResult.routingTuner.recommendations.length,\r\n        topPerformers: coordinatorResult.routingTuner.analysis.topPerformers,\r\n        underperformers: coordinatorResult.routingTuner.analysis.underperformers,\r\n      },\r\n      pricingTuner: {\r\n        recommendations: coordinatorResult.pricingTuner.recommendations.length,\r\n        resourcesReviewed: coordinatorResult.pricingTuner.analysis.resourcesReviewed,\r\n      },\r\n      scoutTuner: {\r\n        recommendations: coordinatorResult.scoutTuner.recommendations.length,\r\n        pendingEvaluated: coordinatorResult.scoutTuner.analysis.pendingEvaluated,\r\n        readyForOnboarding: coordinatorResult.scoutTuner.analysis.readyForOnboarding,\r\n      },\r\n      errors: coordinatorResult.errors,\r\n    },\r\n\r\n    worldState: {\r\n      facilitatorCount: coordinatorResult.worldState.facilitators.length,\r\n      routableFacilitatorCount: coordinatorResult.worldState.facilitators.filter(f => f.isRoutable).length,\r\n      pendingFacilitatorCount: coordinatorResult.worldState.pendingFacilitators.length,\r\n      riskAnomalyCount: coordinatorResult.worldState.riskAnomalies.length,\r\n      aggregates: coordinatorResult.worldState.aggregates,\r\n    },\r\n\r\n    bandit: banditResult\r\n      ? {\r\n          algorithm: banditAlgorithm,\r\n          algorithmVersion: BANDIT_CONFIG.algorithmVersion,\r\n          timeWindowHours: banditHours,\r\n          routesProcessed: banditResult.routesProcessed,\r\n          experimentsCreated: banditResult.experimentsCreated,\r\n          experimentsSkipped: banditResult.experimentsSkipped,\r\n          banditCorrectRate: banditResult.banditCorrectRate,\r\n          counterfactualCount: banditResult.counterfactualCount,\r\n          banditColdStart: banditResult.banditColdStart,\r\n          usingDeterministicPolicy,\r\n          durationMs: banditResult.durationMs,\r\n        }\r\n      : null,\r\n\r\n    prune: pruneResult\r\n      ? {\r\n          experimentsDeleted: pruneResult.experimentsDeleted,\r\n          armStatesDeleted: pruneResult.armStatesDeleted,\r\n        }\r\n      : null,\r\n\r\n    expiredRecommendations: expiredCount,\r\n    errors: errors.length > 0 ? errors : undefined,\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// EXPORTS\r\n// =============================================================================\r\n\r\nexport const dynamic = 'force-dynamic';\r\nexport const maxDuration = 60;\r\n\r\nexport const GET = withCronJobTracking(coordHandler, {\r\n  jobId: 'coord',\r\n  timeout: 55000, // 55s (leave buffer for wrapper overhead)\r\n  minInterval: 110 * 60 * 1000, // 110 minutes (schedule is every 2 hours)\r\n});\r\n\r\n// POST handler also uses the wrapper\r\nexport const POST = withCronJobTracking(coordHandler, {\r\n  jobId: 'coord',\r\n  timeout: 55000,\r\n  minInterval: 110 * 60 * 1000,\r\n  skipRateLimit: true, // Allow manual POST triggers to bypass rate limit\r\n});\r\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n"],"names":["AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","addRequestMeta","getRequestMeta","getTracer","SpanKind","setReferenceManifestsSingleton","createServerModuleMap","normalizeAppPath","NodeNextRequest","NodeNextResponse","NextRequestAdapter","signalFromNodeResponse","BaseServerSpan","getRevalidateReason","sendResponse","fromNodeOutgoingHttpHeaders","toNodeOutgoingHttpHeaders","getCacheControlHeader","INFINITE_CACHE","NEXT_CACHE_TAGS_HEADER","NoFallbackError","CachedRouteKind","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks","handler","req","res","ctx","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","params","nextConfig","parsedUrl","isDraftMode","prerenderManifest","routerServerContext","isOnDemandRevalidate","revalidateOnlyGenerated","resolvedPathname","clientReferenceManifest","serverActionsManifest","normalizedSrcPage","isIsr","Boolean","dynamicRoutes","routes","render404","isPrerendered","prerenderInfo","fallback","experimental","adapterPath","cacheKey","supportsDynamicResponse","isStaticGeneration","serverModuleMap","method","tracer","activeSpan","getActiveScopeSpan","context","renderOpts","authInterrupts","cacheComponents","incrementalCache","cacheLifeProfiles","cacheLife","onClose","cb","on","onAfterTaskError","undefined","onInstrumentationRequestError","error","_request","errorContext","onRequestError","sharedContext","nodeNextReq","nodeNextRes","nextReq","fromNodeNextRequest","invokeRouteModule","span","handle","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","isMinimalMode","MINIMAL_MODE","handleResponse","currentSpan","cacheEntry","responseGenerator","previousCacheEntry","setHeader","response","fetchMetrics","pendingWaitUntil","cacheTags","collectedTags","blob","headers","type","revalidate","collectedRevalidate","expire","collectedExpire","value","status","body","Buffer","from","arrayBuffer","cacheControl","err","isStale","routerKind","routePath","routeType","revalidateReason","routeKind","isFallback","isRoutePPREnabled","Error","isMiss","delete","getHeader","set","Response","withPropagatedContext","trace","spanName","SERVER","attributes","url"],"mappings":"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","ignoreList":[7]}