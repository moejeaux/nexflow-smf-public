module.exports=[72817,e=>{"use strict";async function t(e){let t=Date.now(),r=e.timeout||3e4;try{let s={};e.headers.forEach((e,t)=>{let r=t.toLowerCase();"host"!==r&&"connection"!==r&&"x-payment"!==r&&"x-forwarded-host"!==r&&(s[t]=e)}),s["X-Forwarded-For"]=e.headers.get("x-forwarded-for")||"unknown",s["X-Forwarded-Proto"]=e.headers.get("x-forwarded-proto")||"https";let a=new AbortController,o=setTimeout(()=>a.abort(),r);try{let r=await fetch(e.upstreamUrl,{method:e.method,headers:s,body:e.body||void 0,signal:a.signal});clearTimeout(o);let n=await r.text(),i={};r.headers.forEach((e,t)=>{i[t]=e});let d=Date.now()-t;return{success:r.ok,statusCode:r.status,headers:i,body:n,responseTime:d}}catch(e){throw clearTimeout(o),e}}catch(r){let e=Date.now()-t;if(r instanceof Error&&"AbortError"===r.name)return{success:!1,statusCode:504,headers:{},body:JSON.stringify({error:"Upstream timeout"}),responseTime:e,error:"Request timeout"};return{success:!1,statusCode:502,headers:{},body:JSON.stringify({error:"Upstream error",details:r instanceof Error?r.message:"Unknown error"}),responseTime:e,error:r instanceof Error?r.message:"Unknown error"}}}e.s(["proxyRequest",()=>t])},18976,e=>{"use strict";let t=(0,e.i(50377).createLogger)({component:"UpstreamProxy"}),r=new Map,s=5,a=6e4;function o(e){let a=r.get(e);a?(a.failures++,a.lastFailureTime=Date.now(),"half-open"===a.state?(a.state="open",t.warn("Circuit breaker opened after failure in half-open state",{upstreamUrl:e,failures:a.failures})):a.failures>=s&&(a.state="open",t.warn("Circuit breaker opened due to failure threshold",{upstreamUrl:e,failures:a.failures}))):r.set(e,{failures:1,lastFailureTime:Date.now(),state:"closed"})}function n(e){return new Promise(t=>setTimeout(t,e))}function i(e,t){return Math.min(t*Math.pow(2,e),1e4)}async function d(e){let{upstreamUrl:s,method:d,headers:l,body:u,timeout:c=3e4,maxRetries:p=3,retryDelay:m=1e3,retryableStatusCodes:h=[502,503,504,408,429]}=e;if(!function(e){let s=r.get(e);if(!s)return r.set(e,{failures:0,lastFailureTime:0,state:"closed"}),!0;let o=Date.now();switch(s.state){case"closed":case"half-open":default:return!0;case"open":if(o-s.lastFailureTime>a)return s.state="half-open",t.info("Circuit breaker transitioning to half-open",{upstreamUrl:e}),!0;return!1}}(s))return t.warn("Circuit breaker is open, rejecting request",{upstreamUrl:s}),{success:!1,statusCode:503,headers:{},body:JSON.stringify({error:"Service temporarily unavailable",code:"CIRCUIT_BREAKER_OPEN",details:"Upstream service is experiencing issues"}),responseTime:0,error:"Circuit breaker is open"};let f=null,g=null;for(let e=0;e<=p;e++){let a=Date.now();try{let o={};l.forEach((e,t)=>{let r=t.toLowerCase();"host"!==r&&"connection"!==r&&"x-payment"!==r&&"x-forwarded-host"!==r&&(o[t]=e)}),o["X-Forwarded-For"]=l.get("x-forwarded-for")||"unknown",o["X-Forwarded-Proto"]=l.get("x-forwarded-proto")||"https";let f=new AbortController,w=setTimeout(()=>f.abort(),c);try{let l=await fetch(s,{method:d,headers:o,body:u||void 0,signal:f.signal});clearTimeout(w);let c=await l.text(),y={};l.headers.forEach((e,t)=>{y[t]=e});let E=Date.now()-a,x={success:l.ok,statusCode:l.status,headers:y,body:c,responseTime:E,retries:e};if(!l.ok&&h.includes(l.status)&&e<p){let r=i(e,m);t.warn("Upstream returned retryable error, retrying",{upstreamUrl:s,statusCode:l.status,attempt:e+1,maxRetries:p,backoffDelay:r}),await n(r),g=x;continue}return!function(e){let s=r.get(e);s&&("half-open"===s.state?(s.state="closed",s.failures=0,t.info("Circuit breaker closed after successful request",{upstreamUrl:e})):s.failures=0)}(s),x}catch(e){throw clearTimeout(w),e}}catch(d){let r=Date.now()-a;if(f=d instanceof Error?d:Error("Unknown error"),(d instanceof Error&&"AbortError"===d.name||d instanceof TypeError&&d.message.includes("fetch"))&&e<p){let r=i(e,m);t.warn("Upstream request failed, retrying",{upstreamUrl:s,error:f.message,attempt:e+1,maxRetries:p,backoffDelay:r}),await n(r);continue}if(o(s),"AbortError"===f.name)return{success:!1,statusCode:504,headers:{},body:JSON.stringify({error:"Upstream timeout"}),responseTime:r,error:"Request timeout",retries:e};return{success:!1,statusCode:502,headers:{},body:JSON.stringify({error:"Upstream error",details:f.message}),responseTime:r,error:f.message,retries:e}}}return o(s),{success:!1,statusCode:g?.statusCode||502,headers:g?.headers||{},body:g?.body||JSON.stringify({error:"Upstream error after retries",details:f?.message||"Unknown error"}),responseTime:g?.responseTime||0,error:f?.message||"Unknown error",retries:p}}e.s(["proxyRequestWithRetry",()=>d])},72990,e=>{"use strict";var t=e.i(89171),r=e.i(20525);async function s(e,s){let a=`https://nexflowapp.app/api/v1/metered/${s.id}`,o=await (0,r.createDiscoveryMetadata)(s),n=String(s.price),i=(s.network||"base").toLowerCase(),d=[];return d.push({scheme:"exact",network:"base"===i?"base":i,maxAmountRequired:n,asset:s.tokenAddress,payTo:s.recipientAddress,resource:a,description:s.description||s.name||"Metered API endpoint",mimeType:"application/json",maxTimeoutSeconds:300,outputSchema:{input:{type:"http",method:"POST",bodyType:"json"},output:{type:"object",properties:{data:{type:"object",description:"Response data from upstream service",additionalProperties:!0},timestamp:{type:"string",format:"date-time",description:"Response timestamp"}}}},extra:{bazaar:o.bazaar}}),t.NextResponse.json({x402Version:1,error:"X-PAYMENT header is required",accepts:d},{status:402})}(0,e.i(50377).createLogger)({component:"X402NextJSAdapter"}),e.s(["create402Response",()=>s])},53361,37273,38949,e=>{"use strict";var t=e.i(50377);let r=(0,t.createLogger)({component:"WalletSession"});class s{sessions=new Map;walletSessions=new Map;createSession(e){let t=this.generateSessionId(),s=Math.floor(Date.now()/1e3),a={id:t,walletAddress:e.walletAddress.toLowerCase(),authorizedAmount:e.authorizedAmount,spentAmount:"0",validUntil:e.validUntil,validFrom:e.validFrom||s,network:e.network,asset:e.asset,reusable:!1!==e.reusable,nonce:e.nonce,signature:e.signature,authorization:e.authorization,endpointId:e.endpointId,agentId:e.agentId,createdAt:s,lastUsedAt:s,usageCount:0};this.sessions.set(t,a);let o=a.walletAddress;return this.walletSessions.has(o)||this.walletSessions.set(o,new Set),this.walletSessions.get(o).add(t),r.info({sessionId:t,walletAddress:a.walletAddress,authorizedAmount:a.authorizedAmount,validUntil:a.validUntil},"Wallet session created"),a}validateSession(e){let t=this.sessions.get(e);if(!t)return{valid:!1,error:"Session not found"};let r=Math.floor(Date.now()/1e3);if(r>t.validUntil)return this.sessions.delete(e),this.walletSessions.get(t.walletAddress)?.delete(e),{valid:!1,error:"Session expired"};if(r<t.validFrom)return{valid:!1,error:"Session not yet valid"};let s=BigInt(t.authorizedAmount),a=BigInt(t.spentAmount);return{valid:!0,session:t,remainingAmount:(s>a?s-a:BigInt(0)).toString()}}useSession(e,t){let s=this.validateSession(e);if(!s.valid||!s.session)return s;let a=s.session,o=BigInt(t),n=BigInt(s.remainingAmount||"0");if(o>n)return{valid:!1,session:a,error:"Insufficient session balance",remainingAmount:n.toString()};let i=BigInt(a.spentAmount)+o;a.spentAmount=i.toString(),a.lastUsedAt=Math.floor(Date.now()/1e3),a.usageCount+=1;let d=n-o;return r.info({sessionId:e,amount:t,remainingAmount:d.toString(),usageCount:a.usageCount},"Session used"),{valid:!0,session:a,remainingAmount:d.toString()}}getWalletSessions(e){let t=e.toLowerCase(),r=this.walletSessions.get(t)||new Set,s=[];for(let e of r){let t=this.sessions.get(e);if(t){let e=Math.floor(Date.now()/1e3);e<=t.validUntil&&e>=t.validFrom&&s.push(t)}}return s}getSession(e){return this.sessions.get(e)}revokeSession(e){let t=this.sessions.get(e);return!!t&&(this.sessions.delete(e),this.walletSessions.get(t.walletAddress)?.delete(e),r.info({sessionId:e},"Session revoked"),!0)}cleanupExpiredSessions(){let e=Math.floor(Date.now()/1e3),t=0;for(let[r,s]of this.sessions.entries())e>s.validUntil&&(this.sessions.delete(r),this.walletSessions.get(s.walletAddress)?.delete(r),t++);return t>0&&r.info({cleaned:t},"Expired sessions cleaned up"),t}generateSessionId(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,e=>{let t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)})}}let a=null;function o(){return a||(a=new s,setInterval(()=>{a?.cleanupExpiredSessions()},3e5)),a}e.s(["getWalletSessionManager",()=>o],53361);let n=(0,t.createLogger)({component:"SessionTokens"});class i{secret;constructor(e){this.secret=e||process.env.SESSION_TOKEN_SECRET||"change-me-in-production","change-me-in-production"===this.secret&&n.warn("Using default session token secret - set SESSION_TOKEN_SECRET in production!")}generateToken(e){let t=Math.floor(Date.now()/1e3),r=Math.min(e.validUntil,t+86400),s={sessionId:e.id,walletAddress:e.walletAddress,endpointId:e.endpointId,agentId:e.agentId,iat:t,exp:r},a=this.encodeToken(s);return n.debug({sessionId:e.id,walletAddress:e.walletAddress,expiresAt:r},"Session token generated"),{token:a,expiresAt:r,sessionId:e.id}}validateToken(e){try{let t=this.decodeToken(e);if(!t)return{valid:!1,error:"Invalid token format"};let r=Math.floor(Date.now()/1e3);if(t.exp<r)return{valid:!1,error:"Token expired"};return{valid:!0,payload:t}}catch(e){return{valid:!1,error:e instanceof Error?e.message:"Token validation failed"}}}encodeToken(t){let r=JSON.stringify(t),s=Buffer.from(r).toString("base64url"),a=e.r(54799).createHmac("sha256",this.secret);a.update(s);let o=a.digest("base64url");return`${s}.${o}`}decodeToken(t){try{let r=t.split(".");if(2!==r.length)return null;let[s,a]=r,o=e.r(54799).createHmac("sha256",this.secret);o.update(s);let i=o.digest("base64url");if(a!==i)return n.warn("Token signature mismatch"),null;let d=Buffer.from(s,"base64url").toString("utf-8");return JSON.parse(d)}catch(e){return n.error({error:e},"Failed to decode token"),null}}}let d=null;function l(){return d||(d=new i),d}e.s(["getSessionTokenManager",()=>l],37273);let u=(0,t.createLogger)({component:"SessionMiddleware"});function c(e){let t=e.headers.get("x-session-token")||e.headers.get("authorization")?.replace("Bearer ","");if(!t)return{hasSession:!1};let r=l().validateToken(t);if(!r.valid||!r.payload)return{hasSession:!0,valid:!1,error:r.error||"Invalid session token"};let s=r.payload,a=o().validateSession(s.sessionId);return a.valid&&a.session?{hasSession:!0,sessionId:s.sessionId,walletAddress:s.walletAddress,valid:!0,remainingAmount:a.remainingAmount}:{hasSession:!0,sessionId:s.sessionId,walletAddress:s.walletAddress,valid:!1,error:a.error||"Session invalid"}}function p(e,t){let r=o().useSession(e,t);return r.valid?{success:!0,remainingAmount:r.remainingAmount}:{success:!1,error:r.error,remainingAmount:r.remainingAmount}}async function m(t,r,s){try{let{parseAndVerifyPaymentHeader:a}=await e.A(5371),n=await a(t);if(!n.valid||!n.payment)return{success:!1,error:n.error||"Invalid payment header"};let i=n.payment,d=o().createSession({walletAddress:i.authorization.from,authorizedAmount:i.authorization.value,validUntil:parseInt(i.authorization.validBefore),validFrom:parseInt(i.authorization.validAfter||Math.floor(Date.now()/1e3).toString()),network:i.network,asset:i.authorization.to,nonce:i.authorization.nonce,signature:i.signature,authorization:i.authorization,endpointId:r,agentId:s,reusable:!0}),c=l().generateToken(d);return u.info({sessionId:d.id,walletAddress:d.walletAddress,endpointId:r},"Session created from payment"),{success:!0,sessionId:d.id,token:c.token,expiresAt:c.expiresAt}}catch(e){return u.error({error:e},"Failed to create session from payment"),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}e.s(["checkSessionToken",()=>c,"createSessionFromPayment",()=>m,"useSessionForPayment",()=>p],38949)},56796,e=>{"use strict";e.i(53361);var t=e.i(50377);(0,t.createLogger)({component:"SubscriptionManager"}),(0,t.createLogger)({component:"SessionCache"}),e.i(37273),e.i(38949),e.s([],56796)},88258,e=>{"use strict";var t=e.i(98696),r=e.i(81784);function s(e){let s=function(e){let s=(0,t.getChainRegistry)();if("string"==typeof e&&e.includes(":")&&(0,r.validateCAIPNetwork)(e)){let t=(0,r.parseCAIPNetwork)(e),a=s.get(e);return{detected:!0,network:e,legacyName:a?.name,chainId:t?.chainId||void 0,isEVM:t?.namespace==="eip155",isSolana:t?.namespace==="solana"}}if("string"==typeof e){let t=(0,r.networkToCAIP)(e);if(t){let a=(0,r.parseCAIPNetwork)(t);return s.get(t),{detected:!0,network:t,legacyName:e.toLowerCase(),chainId:a?.chainId||void 0,isEVM:a?.namespace==="eip155",isSolana:a?.namespace==="solana"}}}if("number"==typeof e){let t=s.getAll().find(t=>t.chainId===e);if(t)return{detected:!0,network:t.caip,legacyName:t.name,chainId:e,isEVM:t.isEVM,isSolana:t.isSolana}}return{detected:!1,error:`Could not detect chain from input: ${e}`}}(e);return s.detected&&s.network||null}e.s(["normalizeToCAIP",()=>s])},85059,e=>{"use strict";let t=(0,e.i(50377).createLogger)({component:"ConcurrentRequestLimiter"}),r=new Map;function s(e,s){let a,o,n,i,d,l=(a=e.windowMs||6e4,o=Date.now(),n=e.identifier,(i=r.get(n))||(i={count:0,lastReset:o,activeRequests:new Set},r.set(n,i)),o-i.lastReset>a&&(i.count=0,i.lastReset=o,i.activeRequests.clear()),{allowed:(d=i.activeRequests.size)<e.maxConcurrent,current:d,limit:e.maxConcurrent,identifier:n});if(!l.allowed)return t.warn("Concurrent request limit exceeded",{identifier:e.identifier,current:l.current,limit:l.limit,requestId:s}),{success:!1,release:()=>{},current:l.current,limit:l.limit};let u=r.get(e.identifier);return u.activeRequests.add(s),u.count++,t.debug("Concurrent request slot acquired",{identifier:e.identifier,current:u.activeRequests.size,limit:e.maxConcurrent,requestId:s}),{success:!0,release:()=>{let t=r.get(e.identifier);t&&t.activeRequests.delete(s)},current:u.activeRequests.size,limit:e.maxConcurrent}}function a(){return{global:parseInt(process.env.MAX_CONCURRENT_REQUESTS_GLOBAL||"50",10),endpoint:parseInt(process.env.MAX_CONCURRENT_REQUESTS_ENDPOINT||"20",10),user:parseInt(process.env.MAX_CONCURRENT_REQUESTS_USER||"30",10)}}function o(e){return`global:ip:${e}`}function n(e,t){return`endpoint:${e}:ip:${t}`}function i(e){return`user:${e}`}setInterval(()=>{let e=Date.now(),t=[];r.forEach((r,s)=>{0===r.activeRequests.size&&e-r.lastReset>3e5&&t.push(s)}),t.forEach(e=>r.delete(e))},3e5),e.s(["acquireConcurrentSlot",()=>s,"createEndpointIdentifier",()=>n,"createGlobalIdentifier",()=>o,"createUserIdentifier",()=>i,"getConcurrentLimits",()=>a])},796,e=>e.a(async(t,r)=>{try{var s=e.i(89171),a=e.i(64001),o=e.i(72817),n=e.i(18976),i=e.i(97697),d=e.i(34006),l=e.i(72990),u=e.i(34597),c=e.i(31081),p=e.i(84170);e.i(56796);var m=e.i(38949),h=e.i(81784),f=e.i(88258),g=e.i(91086),w=e.i(19585),y=e.i(92688),E=e.i(19561),x=e.i(21198),I=e.i(85059),v=t([a,p,w,E,x]);[a,p,w,E,x]=v.then?(await v)():v;let S=parseInt(process.env.MAX_REQUEST_BODY_SIZE||"10485760",10);async function R(t,{params:r}){let v=(0,i.getOrCreateRequestId)(t),R=(0,i.createRequestLogger)(v),{endpointId:A}=await r,T=Date.now(),C=t.headers.get("x-conversation-id")||t.headers.get("x-request-id")||v,k=t.headers.get("x-agent-id")||void 0,N=t.ip||t.headers.get("x-forwarded-for")?.split(",")[0]?.trim()||"unknown",U=t.headers.get("authorization"),D=U?.startsWith("Bearer ")?U.substring(7).trim():U?.trim()||null,P=D?D.substring(0,16):null,_=t.headers.get("content-length");if(_){let e=parseInt(_,10);if(e>S)return R.warn("Request body too large",{bodySize:e,maxSize:S,endpointId:A,ip:N}),s.NextResponse.json({error:"Request body too large",code:"REQUEST_TOO_LARGE",maxSize:S,receivedSize:e},{status:413})}let b=(0,I.getConcurrentLimits)(),O=null,M=(0,I.acquireConcurrentSlot)({maxConcurrent:b.global,identifier:(0,I.createGlobalIdentifier)(N)},v);if(!M.success)return R.warn("Global concurrent request limit exceeded",{ip:N,current:M.current,limit:M.limit,endpointId:A}),s.NextResponse.json({error:"Too many concurrent requests",code:"CONCURRENT_LIMIT_EXCEEDED",message:`Maximum ${M.limit} concurrent requests allowed per IP`,retryAfter:60},{status:429});let q=(0,I.acquireConcurrentSlot)({maxConcurrent:b.endpoint,identifier:(0,I.createEndpointIdentifier)(A,N)},v);if(!q.success)return M.release(),R.warn("Endpoint concurrent request limit exceeded",{endpointId:A,ip:N,current:q.current,limit:q.limit}),s.NextResponse.json({error:"Too many concurrent requests for this endpoint",code:"ENDPOINT_CONCURRENT_LIMIT_EXCEEDED",message:`Maximum ${q.limit} concurrent requests allowed per endpoint per IP`,retryAfter:60},{status:429});if(P){let e=(0,I.acquireConcurrentSlot)({maxConcurrent:b.user,identifier:(0,I.createUserIdentifier)(P)},v);if(!e.success)return M.release(),q.release(),R.warn("User concurrent request limit exceeded",{apiKeyHash:P,current:e.current,limit:e.limit}),s.NextResponse.json({error:"Too many concurrent requests for this API key",code:"USER_CONCURRENT_LIMIT_EXCEEDED",message:`Maximum ${e.limit} concurrent requests allowed per API key`,retryAfter:60},{status:429});O=e}else O=q;let H=()=>{M.release(),q.release(),O&&O!==q&&O.release()};try{let r,I,U,D=(0,c.validateEndpointId)(A);if(!D.valid)return R.warn("Invalid endpoint ID",{endpointId:A,errors:D.errors}),s.NextResponse.json({error:"Invalid endpoint ID",code:"INVALID_ENDPOINT_ID",details:D.errors},{status:400});let _=await (0,a.getEndpoint)(A);if(!_)return s.NextResponse.json({error:"Endpoint not found",code:"NOT_FOUND"},{status:404});if("active"!==_.status)return s.NextResponse.json({error:"Endpoint is not active",code:"ENDPOINT_INACTIVE",status:_.status},{status:403});let b=(0,m.checkSessionToken)(t),O=!1,M=!1;if(b.hasSession&&b.valid&&b.sessionId){let e=(0,m.useSessionForPayment)(b.sessionId,_.price);if(!e.success||!e.remainingAmount)return s.NextResponse.json({error:"Insufficient session balance",code:"INSUFFICIENT_SESSION_BALANCE",remainingAmount:e.remainingAmount,details:e.error},{status:402});O=!0,M=!0,R.info("Payment via session",{sessionId:b.sessionId,walletAddress:b.walletAddress,amount:_.price,remainingAmount:e.remainingAmount})}let q=process.env.X402_VERIFY_MODE?.toLowerCase(),L=t.headers.get(g.TEST_TOKEN_HEADER)||t.headers.get(g.TEST_TOKEN_HEADER.toUpperCase()),F="test"===q;if(!O&&F&&L===g.TEST_TOKEN_VALUE){let e=(0,g.verifyPaymentTestOnly)(t);if(e.success){O=!0,r=e.x402TxHash,R.info("Payment bypassed via test token (test mode)",{testToken:L,facilitator:e.facilitator});let s=Date.now()-T;try{let r=(0,y.normalizeNetwork)(_.network).split(":")[1]||"8453";await (0,w.logX402Call)({customerId:C||null,endpointId:_.id,agentId:k,facilitator:e.facilitator||"TEST_FACILITATOR",chainId:r,asset:_.tokenAddress||"USDC",amount:_.price,status:"success",x402TxHash:e.x402TxHash,latencyMs:s,resource:`${t.headers.get("host")||"localhost:3001"}${t.nextUrl.pathname}`})}catch(e){R.error("Failed to log test mode success",{error:e})}if(e.x402TxHash){R.info("Creating test mode payment entry",{txHash:e.x402TxHash,endpointId:_.id,testModeEnabled:F,testToken:L||"missing"});try{let r=t.headers.get("x-test-from-address")||"0x0000000000000000000000000000000000000000";R.info("Calling createPayment",{endpointId:_.id,txHash:e.x402TxHash,fromAddress:r,toAddress:_.recipientAddress,amount:_.price,tokenAddress:_.tokenAddress,network:_.network});let s=await (0,a.createPayment)({endpointId:_.id,txHash:e.x402TxHash,fromAddress:r,toAddress:_.recipientAddress,amount:_.price,tokenAddress:_.tokenAddress,network:_.network,kytStatus:"passed",ofacStatus:"passed",facilitator:(e.facilitator||"TEST_FACILITATOR").toLowerCase()});I=s.id,console.log("[TEST MODE] Payment created:",{paymentId:s.id,endpointId:_.id,txHash:e.x402TxHash}),U={valid:!0,success:!0,transactionHash:e.x402TxHash,facilitatorId:(e.facilitator||"TEST_FACILITATOR").toLowerCase(),verifiedAt:new Date().toISOString(),kytStatus:"passed",ofacStatus:"passed",facilitatorUsed:e.facilitator||"TEST_FACILITATOR",routingReason:"Test mode - bypass verification",alternativesConsidered:0},R.info("Test mode payment entry created successfully",{paymentId:s.id,txHash:e.x402TxHash,endpointId:_.id})}catch(s){let t=s instanceof Error?s.message:String(s),r=s instanceof Error?s.stack:void 0;R.error("Failed to create test mode payment entry",{error:t,stack:r,endpointId:_.id,txHash:e.x402TxHash}),console.error("[TEST MODE] Payment creation ERROR:",t),r&&console.error("[TEST MODE] Stack:",r)}}else R.warn("Test mode payment not created - no x402TxHash",{testResult:e,endpointId:_.id})}}let z=t.headers.get("x-payment")||t.headers.get("X-Payment");if(!O&&!z){let e=Date.now()-T;try{let r=(0,y.normalizeNetwork)(_.network).split(":")[1]||"8453";await (0,w.logX402Call)({customerId:C||null,endpointId:_.id,agentId:k,facilitator:"NONE",chainId:r,asset:_.tokenAddress||"USDC",amount:_.price,status:"failed",errorCode:"PAYMENT_REQUIRED",latencyMs:e,resource:`${t.headers.get("host")||"localhost:3001"}${t.nextUrl.pathname}`})}catch(e){R.error("Failed to log 402 response",{error:e})}return(0,u.getX402ResourceServer)(),await (0,l.create402Response)(t,_)}if(!O&&z){let o=(0,c.validatePaymentHeader)(z);if(!o.valid)return R.warn("Invalid payment header",{errors:o.errors}),s.NextResponse.json({error:"Invalid payment header",code:"INVALID_PAYMENT_HEADER",details:o.errors},{status:400});let n=o.sanitized||z,{parseX402Header:i}=await e.A(5371),d=i(n);if(!d.valid||!d.parsed)return s.NextResponse.json({error:"Invalid payment header",code:"INVALID_PAYMENT_HEADER",details:d.error},{status:400});let l=d.parsed,u=(0,p.getMetaFacilitator)(),g=`https://nexflowapp.app/api/v1/metered/${_.id}`,E=(0,h.networkToCAIP)(_.network)||(0,f.normalizeToCAIP)(_.network),A=(0,h.tokenToCAIP)(_.network,_.tokenAddress),S=t.headers.get("x-preferred-networks")?.split(",").map(e=>e.trim())||[],N=S.map(e=>(0,f.normalizeToCAIP)(e)).filter(e=>null!==e),D=S.filter(e=>!e.includes(":")),b=t.headers.get("x-preferred-assets")?.split(",").map(e=>e.trim())||[],M=b.filter(e=>e.includes("/")),q=b.filter(e=>!e.includes("/")),H=t.headers.get("x-avoid-networks")?.split(",").map(e=>e.trim())||[],L=H.map(e=>(0,f.normalizeToCAIP)(e)).filter(e=>null!==e),F=H.filter(e=>!e.includes(":")),$=t.headers.get("x-routing-priority"),j={scheme:"exact",network:_.network,networks:E?[E]:void 0,maxAmountRequired:_.price,resource:g,description:_.description||_.name,mimeType:"application/json",payTo:_.recipientAddress,maxTimeoutSeconds:300,asset:_.tokenAddress,assets:A?[A]:void 0};R.debug("Calling meta-facilitator.verifyPayment",{hasPaymentHeader:!!n,paymentRequirements:{scheme:j.scheme,network:j.network,payTo:j.payTo,maxAmountRequired:j.maxAmountRequired,resource:j.resource}});try{U=await u.verifyPayment(n,j,{preferredNetworks:D.length>0?D:void 0,preferredNetworksCAIP:N.length>0?N:void 0,preferredAssets:q.length>0?q:void 0,preferredAssetsCAIP:M.length>0?M:void 0,avoidNetworks:F.length>0?F:void 0,avoidNetworksCAIP:L.length>0?L:void 0,priority:$,requireCompliance:!0},{requireHealthCheck:!0,preferCheapest:"cost"===$,requireKYC:!1},{requestId:v,correlationId:C,clientId:P,agentId:k})}catch(e){throw R.error("Meta-facilitator verification threw error",{error:e,stack:e instanceof Error?e.stack:void 0}),e}if(!U.valid||!U.success){let e=U.facilitatorUsed||"CDP";R.error("Payment verification failed",{error:U.error,errorDetails:U.errorDetails,kytStatus:U.kytStatus,ofacStatus:U.ofacStatus,facilitatorUsed:e,routingReason:U.routingReason});let r=Date.now()-T;try{let s=(0,y.normalizeNetwork)(_.network).split(":")[1]||"8453";await (0,w.logX402Call)({customerId:C||null,endpointId:_.id,agentId:k,facilitator:e,chainId:s,asset:_.tokenAddress||"USDC",amount:_.price,status:"failed",errorCode:U.error||"VERIFICATION_FAILED",latencyMs:r,resource:`${t.headers.get("host")||"localhost:3001"}${t.nextUrl.pathname}`})}catch(e){R.error("Failed to log CDP verification failure",{error:e})}return s.NextResponse.json({error:"Payment verification failed",code:U.error||"VERIFICATION_FAILED",details:U.error,errorDetails:U.errorDetails,kytStatus:U.kytStatus,ofacStatus:U.ofacStatus},{status:400})}if("blocked"===U.kytStatus||"blocked"===U.ofacStatus)return s.NextResponse.json({error:"Payment blocked by compliance check",code:"COMPLIANCE_BLOCKED",kytStatus:U.kytStatus,ofacStatus:U.ofacStatus},{status:403});let X=BigInt(l.authorization.value),B=BigInt(_.price);if(X<B)return s.NextResponse.json({error:"Insufficient payment",code:"INSUFFICIENT_PAYMENT",required:_.price,paid:l.authorization.value},{status:400});if("true"===t.headers.get("x-create-session")){let e=await (0,m.createSessionFromPayment)(n,_.id,k);e.success&&e.token&&R.info("Session created from payment",{sessionId:e.sessionId,walletAddress:l.authorization.from})}O=!0,r=U.transactionHash;let K=U.facilitatorUsed||"CDP";R.info("Payment verified via meta-facilitator",{facilitator:K,transactionHash:U.transactionHash,kytStatus:U.kytStatus,ofacStatus:U.ofacStatus});let V=Date.now()-T;try{let e=(0,y.normalizeNetwork)(_.network).split(":")[1]||"8453";await (0,w.logX402Call)({customerId:C||null,endpointId:_.id,agentId:k,facilitator:K,chainId:e,asset:_.tokenAddress||"USDC",amount:_.price,status:"success",x402TxHash:U.transactionHash||void 0,latencyMs:V,resource:`${t.headers.get("host")||"localhost:3001"}${t.nextUrl.pathname}`})}catch(e){R.error("Failed to log CDP verification success",{error:e})}if(U.transactionHash)try{let e=await (0,a.createPayment)({endpointId:_.id,txHash:U.transactionHash,fromAddress:l.authorization.from,toAddress:l.authorization.to,amount:l.authorization.value,tokenAddress:_.tokenAddress,network:_.network,kytStatus:U.kytStatus,ofacStatus:U.ofacStatus,facilitator:K.toLowerCase()});I=e.id,await (0,x.triggerWebhook)("payment.verified",{paymentId:e.id,endpointId:_.id,txHash:U.transactionHash,amount:l.authorization.value,tokenAddress:_.tokenAddress,network:_.network,facilitator:K.toLowerCase(),fromAddress:l.authorization.from,toAddress:l.authorization.to},_.id)}catch(e){R.error("Failed to record payment",{error:e})}}if(!O)return s.NextResponse.json({error:"Payment required",code:"PAYMENT_REQUIRED"},{status:402});let $=null;try{let e=await t.text(),r=new TextEncoder().encode(e).length;if(r>S)return R.warn("Request body too large (after reading)",{bodySize:r,maxSize:S,endpointId:A,ip:N}),H(),s.NextResponse.json({error:"Request body too large",code:"REQUEST_TOO_LARGE",maxSize:S,receivedSize:r},{status:413});$=e||null}catch(e){$=null}let j="false"!==process.env.USE_ENHANCED_PROXY?await (0,n.proxyRequestWithRetry)({upstreamUrl:_.upstreamUrl,method:t.method,headers:t.headers,body:$,timeout:3e4,maxRetries:3,retryDelay:1e3,retryableStatusCodes:[502,503,504,408,429]}):await (0,o.proxyRequest)({upstreamUrl:_.upstreamUrl,method:t.method,headers:t.headers,body:$,timeout:3e4}),X=r||void 0,B=j.statusCode>=400?`HTTP_${j.statusCode}`:void 0;try{let e=await (0,a.createUsageLog)({endpointId:_.id,paymentId:I,method:t.method,path:new URL(t.url).pathname,statusCode:j.statusCode,responseTime:j.responseTime,units:1,ipAddress:t.headers.get("x-forwarded-for")||t.headers.get("x-real-ip")||void 0,userAgent:t.headers.get("user-agent")||void 0,conversationId:C,agentId:k,x402TxHash:X,failureCode:B});await (0,x.triggerWebhook)("usage.recorded",{usageLogId:e.id,endpointId:_.id,paymentId:I,method:t.method,statusCode:j.statusCode,responseTime:j.responseTime,units:1},_.id)}catch(e){R.error("Failed to log usage",{error:e})}let K={...j.headers,"X-x402-Verified":"true","X-x402-Payment-Method":M?"session":"payment"};!M&&r&&(K["X-x402-TxHash"]=r);let V=new s.NextResponse(j.body,{status:j.statusCode,headers:K});(0,i.addRequestIdToResponse)(V,v);let W=await (0,d.getRateLimitHeaders)(t,A);W&&(0,d.addRateLimitHeaders)(V,W);let Y=Date.now()-T;return R.info("Request completed successfully",{responseTime:Y,statusCode:j.statusCode}),(0,E.recordRequestMetric)(`/api/v1/metered/${A}`,t.method,j.statusCode,Y,{endpointId:A,paymentMethod:M?"session":"payment"}).catch(e=>R.error("Failed to record request metric",{error:e})),O&&r&&U&&(0,E.recordPaymentMetric)(A,U.facilitatorUsed||"UNKNOWN",_.price,!0,Y).catch(e=>R.error("Failed to record payment metric",{error:e})),V}catch(m){let e=process.env.X402_VERIFY_MODE?.toLowerCase(),r="cdp"===e?"CDP":"UNKNOWN",o="cdp"===e?"CDP_INTERNAL_ERROR":"INTERNAL_ERROR",n=m instanceof Error?m.message:"Unknown error",d=o;if("cdp"===e&&m instanceof Error){let e=m.message.toLowerCase();e.includes("invalidreason")||e.includes("invalid_reason")?d=m.message.includes("CDP_")?m.message:"CDP_VERIFICATION_ERROR":e.includes("network")||e.includes("fetch")?d="CDP_NETWORK_ERROR":e.includes("timeout")&&(d="CDP_REQUEST_TIMEOUT")}try{let e=await (0,a.getEndpoint)(A).catch(()=>null);if(e){await (0,a.createUsageLog)({endpointId:e.id,method:t.method,path:new URL(t.url).pathname,statusCode:500,responseTime:Date.now()-T,units:0,conversationId:C,agentId:k,failureCode:d});let s=Date.now()-T,o=(0,y.normalizeNetwork)(e.network).split(":")[1]||"8453";await (0,w.logX402Call)({customerId:C||null,endpointId:e.id,agentId:k,facilitator:r,chainId:o,asset:e.tokenAddress||"USDC",amount:e.price,status:"failed",errorCode:d,latencyMs:s,resource:`${t.headers.get("host")||"localhost:3001"}${t.nextUrl.pathname}`})}}catch(e){R.error("Failed to log error",{logError:e})}let l=Date.now()-T,u=t.ip||t.headers.get("x-forwarded-for")?.split(",")[0]?.trim()||"unknown",c=t.headers.get("user-agent")||void 0;R.error("Metered endpoint error",{error:m,responseTime:l,failureCode:o,stack:m instanceof Error?m.stack:void 0,endpointId:A,method:t.method,path:new URL(t.url).pathname,ip:u,userAgent:c,conversationId:C,agentId:k,facilitator:r,component:"metered-endpoint"}),(0,E.recordErrorMetric)(o,A,{endpointId:A,method:t.method}).catch(e=>R.error("Failed to record error metric",{error:e})),(0,E.recordRequestMetric)(`/api/v1/metered/${A}`,t.method,500,l,{endpointId:A,error:o});let p=s.NextResponse.json({error:"Internal server error",code:o,details:n,requestId:v},{status:500});return(0,i.addRequestIdToResponse)(p,v),H(),p}finally{try{H()}catch(e){R.error("Failed to release concurrent slots",{error:e})}}}async function A(e,{params:t}){let{endpointId:r}=await t,o=await (0,a.getEndpoint)(r);return o?s.NextResponse.json({endpointId:o.id,name:o.name,description:o.description,paymentRequired:!0,scheme:"x402",network:o.network,chainId:o.chainId,token:o.tokenSymbol,tokenAddress:o.tokenAddress,recipientAddress:o.recipientAddress,price:o.price,status:o.status}):s.NextResponse.json({error:"Endpoint not found",code:"NOT_FOUND"},{status:404})}e.s(["GET",()=>A,"POST",()=>R]),r()}catch(e){r(e)}},!1),45124,e=>e.a(async(t,r)=>{try{var s=e.i(47909),a=e.i(74017),o=e.i(96250),n=e.i(59756),i=e.i(61916),d=e.i(14444),l=e.i(37092),u=e.i(69741),c=e.i(16795),p=e.i(87718),m=e.i(95169),h=e.i(47587),f=e.i(66012),g=e.i(70101),w=e.i(26937),y=e.i(10372),E=e.i(93695);e.i(52474);var x=e.i(220),I=e.i(796),v=t([I]);[I]=v.then?(await v)():v;let S=new s.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/api/v1/metered/[endpointId]/route",pathname:"/api/v1/metered/[endpointId]",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/v1/metered/[endpointId]/route.ts",nextConfigOutput:"standalone",userland:I}),{workAsyncStorage:T,workUnitAsyncStorage:C,serverHooks:k}=S;function R(){return(0,o.patchFetch)({workAsyncStorage:T,workUnitAsyncStorage:C})}async function A(e,t,r){S.isDev&&(0,n.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let s="/api/v1/metered/[endpointId]/route";s=s.replace(/\/index$/,"")||"/";let o=await S.prepare(e,t,{srcPage:s,multiZoneDraftMode:!1});if(!o)return t.statusCode=400,t.end("Bad Request"),null==r.waitUntil||r.waitUntil.call(r,Promise.resolve()),null;let{buildId:I,params:v,nextConfig:R,parsedUrl:A,isDraftMode:T,prerenderManifest:C,routerServerContext:k,isOnDemandRevalidate:N,revalidateOnlyGenerated:U,resolvedPathname:D,clientReferenceManifest:P,serverActionsManifest:_}=o,b=(0,u.normalizeAppPath)(s),O=!!(C.dynamicRoutes[b]||C.routes[D]),M=async()=>((null==k?void 0:k.render404)?await k.render404(e,t,A,!1):t.end("This page could not be found"),null);if(O&&!T){let e=!!C.routes[D],t=C.dynamicRoutes[b];if(t&&!1===t.fallback&&!e){if(R.experimental.adapterPath)return await M();throw new E.NoFallbackError}}let q=null;!O||S.isDev||T||(q=D,q="/index"===q?"/":q);let H=!0===S.isDev||!O,L=O&&!H;_&&P&&(0,d.setReferenceManifestsSingleton)({page:s,clientReferenceManifest:P,serverActionsManifest:_,serverModuleMap:(0,l.createServerModuleMap)({serverActionsManifest:_})});let F=e.method||"GET",z=(0,i.getTracer)(),$=z.getActiveScopeSpan(),j={params:v,prerenderManifest:C,renderOpts:{experimental:{authInterrupts:!!R.experimental.authInterrupts},cacheComponents:!!R.cacheComponents,supportsDynamicResponse:H,incrementalCache:(0,n.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:R.cacheLife,waitUntil:r.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,s)=>S.onRequestError(e,t,s,k)},sharedContext:{buildId:I}},X=new c.NodeNextRequest(e),B=new c.NodeNextResponse(t),K=p.NextRequestAdapter.fromNodeNextRequest(X,(0,p.signalFromNodeResponse)(t));try{let o=async e=>S.handle(K,j).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=z.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==m.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let a=r.get("next.route");if(a){let t=`${F} ${a}`;e.setAttributes({"next.route":a,"http.route":a,"next.span_name":t}),e.updateName(t)}else e.updateName(`${F} ${s}`)}),d=!!(0,n.getRequestMeta)(e,"minimalMode"),l=async n=>{var i,l;let u=async({previousCacheEntry:a})=>{try{if(!d&&N&&U&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let s=await o(n);e.fetchMetrics=j.renderOpts.fetchMetrics;let i=j.renderOpts.pendingWaitUntil;i&&r.waitUntil&&(r.waitUntil(i),i=void 0);let l=j.renderOpts.collectedTags;if(!O)return await (0,f.sendResponse)(X,B,s,j.renderOpts.pendingWaitUntil),null;{let e=await s.blob(),t=(0,g.toNodeOutgoingHttpHeaders)(s.headers);l&&(t[y.NEXT_CACHE_TAGS_HEADER]=l),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==j.renderOpts.collectedRevalidate&&!(j.renderOpts.collectedRevalidate>=y.INFINITE_CACHE)&&j.renderOpts.collectedRevalidate,a=void 0===j.renderOpts.collectedExpire||j.renderOpts.collectedExpire>=y.INFINITE_CACHE?void 0:j.renderOpts.collectedExpire;return{value:{kind:x.CachedRouteKind.APP_ROUTE,status:s.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:a}}}}catch(t){throw(null==a?void 0:a.isStale)&&await S.onRequestError(e,t,{routerKind:"App Router",routePath:s,routeType:"route",revalidateReason:(0,h.getRevalidateReason)({isStaticGeneration:L,isOnDemandRevalidate:N})},k),t}},c=await S.handleResponse({req:e,nextConfig:R,cacheKey:q,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:C,isRoutePPREnabled:!1,isOnDemandRevalidate:N,revalidateOnlyGenerated:U,responseGenerator:u,waitUntil:r.waitUntil,isMinimalMode:d});if(!O)return null;if((null==c||null==(i=c.value)?void 0:i.kind)!==x.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==c||null==(l=c.value)?void 0:l.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});d||t.setHeader("x-nextjs-cache",N?"REVALIDATED":c.isMiss?"MISS":c.isStale?"STALE":"HIT"),T&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let p=(0,g.fromNodeOutgoingHttpHeaders)(c.value.headers);return d&&O||p.delete(y.NEXT_CACHE_TAGS_HEADER),!c.cacheControl||t.getHeader("Cache-Control")||p.get("Cache-Control")||p.set("Cache-Control",(0,w.getCacheControlHeader)(c.cacheControl)),await (0,f.sendResponse)(X,B,new Response(c.value.body,{headers:p,status:c.value.status||200})),null};$?await l($):await z.withPropagatedContext(e.headers,()=>z.trace(m.BaseServerSpan.handleRequest,{spanName:`${F} ${s}`,kind:i.SpanKind.SERVER,attributes:{"http.method":F,"http.target":e.url}},l))}catch(t){if(t instanceof E.NoFallbackError||await S.onRequestError(e,t,{routerKind:"App Router",routePath:b,routeType:"route",revalidateReason:(0,h.getRevalidateReason)({isStaticGeneration:L,isOnDemandRevalidate:N})}),O)throw t;return await (0,f.sendResponse)(X,B,new Response(null,{status:500})),null}}e.s(["handler",()=>A,"patchFetch",()=>R,"routeModule",()=>S,"serverHooks",()=>k,"workAsyncStorage",()=>T,"workUnitAsyncStorage",()=>C]),r()}catch(e){r(e)}},!1)];

//# sourceMappingURL=_5d0f134c._.js.map