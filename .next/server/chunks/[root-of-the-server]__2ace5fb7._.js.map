{"version":3,"sources":["turbopack:///[project]/node_modules/thread-stream/package.json","../../../src/lib/request-id.ts","../../../node_modules/uncrypto/dist/crypto.node.mjs","../../../node_modules/viem/utils/signature/verifyTypedData.ts","../../../node_modules/viem/utils/signature/recoverTypedDataAddress.ts","../../../src/db/metered-endpoints.ts","../../../src/integrations/x402/x402-call-log.ts","../../../src/integrations/x402/payment-header-parser.ts","../../../src/integrations/x402/test-verification.ts"],"sourcesContent":["{\"name\":\"thread-stream\",\"version\":\"3.1.0\",\"description\":\"A streaming way to send data to a Node.js Worker Thread\",\"main\":\"index.js\",\"types\":\"index.d.ts\",\"dependencies\":{\"real-require\":\"^0.2.0\"},\"devDependencies\":{\"@types/node\":\"^20.1.0\",\"@types/tap\":\"^15.0.0\",\"@yao-pkg/pkg\":\"^5.11.5\",\"desm\":\"^1.3.0\",\"fastbench\":\"^1.0.1\",\"husky\":\"^9.0.6\",\"pino-elasticsearch\":\"^8.0.0\",\"sonic-boom\":\"^4.0.1\",\"standard\":\"^17.0.0\",\"tap\":\"^16.2.0\",\"ts-node\":\"^10.8.0\",\"typescript\":\"^5.3.2\",\"why-is-node-running\":\"^2.2.2\"},\"scripts\":{\"build\":\"tsc --noEmit\",\"test\":\"standard && npm run build && npm run transpile && tap \\\"test/**/*.test.*js\\\" && tap --ts test/*.test.*ts\",\"test:ci\":\"standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts\",\"test:ci:js\":\"tap --no-check-coverage --timeout=120 --coverage-report=lcovonly \\\"test/**/*.test.*js\\\"\",\"test:ci:ts\":\"tap --ts --no-check-coverage --coverage-report=lcovonly \\\"test/**/*.test.*ts\\\"\",\"test:yarn\":\"npm run transpile && tap \\\"test/**/*.test.js\\\" --no-check-coverage\",\"transpile\":\"sh ./test/ts/transpile.sh\",\"prepare\":\"husky install\"},\"standard\":{\"ignore\":[\"test/ts/**/*\",\"test/syntax-error.mjs\"]},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/mcollina/thread-stream.git\"},\"keywords\":[\"worker\",\"thread\",\"threads\",\"stream\"],\"author\":\"Matteo Collina <hello@matteocollina.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/mcollina/thread-stream/issues\"},\"homepage\":\"https://github.com/mcollina/thread-stream#readme\"}","// =============================================================================\r\n// Request ID Tracking\r\n// =============================================================================\r\n// Generates and tracks request IDs for request correlation\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { createLogger, type LogContext } from './logger';\r\n\r\nconst REQUEST_ID_HEADER = 'x-request-id';\r\nconst REQUEST_ID_CONTEXT_KEY = 'requestId';\r\n\r\n/**\r\n * Generate a unique request ID (UUID v4 format)\r\n * Edge-compatible using Web Crypto API\r\n */\r\nexport function generateRequestId(): string {\r\n  // Generate UUID v4 format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\r\n  const array = new Uint8Array(16);\r\n  crypto.getRandomValues(array);\r\n  \r\n  // Set version (4) and variant bits\r\n  array[6] = (array[6] & 0x0f) | 0x40; // Version 4\r\n  array[8] = (array[8] & 0x3f) | 0x80; // Variant 10\r\n  \r\n  // Convert to UUID string format\r\n  const hex = Array.from(array)\r\n    .map(b => b.toString(16).padStart(2, '0'))\r\n    .join('');\r\n  \r\n  return [\r\n    hex.substring(0, 8),\r\n    hex.substring(8, 12),\r\n    hex.substring(12, 16),\r\n    hex.substring(16, 20),\r\n    hex.substring(20, 32),\r\n  ].join('-');\r\n}\r\n\r\n/**\r\n * Extract request ID from headers or generate a new one\r\n * \r\n * Trusts x-request-id from trusted sources (configurable via TRUSTED_REQUEST_ID_SOURCES env var)\r\n * Default: trusts all sources (can be restricted to specific IPs/domains)\r\n */\r\nexport function getOrCreateRequestId(request: NextRequest): string {\r\n  const existingId = request.headers.get(REQUEST_ID_HEADER);\r\n  \r\n  if (existingId) {\r\n    // Check if we should trust this request ID\r\n    const trustedSources = process.env.TRUSTED_REQUEST_ID_SOURCES?.split(',') || [];\r\n    const shouldTrust = trustedSources.length === 0 || \r\n      trustedSources.some(source => {\r\n        const origin = request.headers.get('origin') || '';\r\n        const referer = request.headers.get('referer') || '';\r\n        return origin.includes(source) || referer.includes(source);\r\n      });\r\n    \r\n    if (shouldTrust) {\r\n      return existingId;\r\n    }\r\n  }\r\n  \r\n  return generateRequestId();\r\n}\r\n\r\n/**\r\n * Add request ID to response headers\r\n */\r\nexport function addRequestIdToResponse(\r\n  response: NextResponse,\r\n  requestId: string\r\n): NextResponse {\r\n  response.headers.set(REQUEST_ID_HEADER, requestId);\r\n  return response;\r\n}\r\n\r\n/**\r\n * Get request ID from AsyncLocalStorage (if available)\r\n */\r\nexport function getRequestId(): string | undefined {\r\n  // In Next.js, we'll use headers instead of AsyncLocalStorage\r\n  // This is simpler and works with the serverless model\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Create a logger with request ID context\r\n * Uses full Pino logger for structured logging\r\n * Works in both Node.js and Edge runtime (Pino handles Edge compatibility)\r\n */\r\nexport function createRequestLogger(requestId: string, additionalContext?: Record<string, any>) {\r\n  const context: LogContext = { requestId, ...additionalContext };\r\n  const logger = createLogger(context);\r\n  \r\n  return {\r\n    info: (message: string, meta?: LogContext) => {\r\n      logger.info({ ...context, ...meta }, message);\r\n    },\r\n    warn: (message: string, meta?: LogContext) => {\r\n      logger.warn({ ...context, ...meta }, message);\r\n    },\r\n    error: (message: string, meta?: LogContext) => {\r\n      logger.error({ ...context, ...meta }, message);\r\n    },\r\n    debug: (message: string, meta?: LogContext) => {\r\n      logger.debug({ ...context, ...meta }, message);\r\n    },\r\n  };\r\n}\r\n\r\n","import nodeCrypto from 'node:crypto';\n\nconst subtle = nodeCrypto.webcrypto?.subtle || {};\nconst randomUUID = () => {\n  return nodeCrypto.randomUUID();\n};\nconst getRandomValues = (array) => {\n  return nodeCrypto.webcrypto.getRandomValues(array);\n};\nconst _crypto = {\n  randomUUID,\n  getRandomValues,\n  subtle\n};\n\nexport { _crypto as default, getRandomValues, randomUUID, subtle };\n","import type { Address, TypedData } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport { type GetAddressErrorType, getAddress } from '../address/getAddress.js'\nimport {\n  type IsAddressEqualErrorType,\n  isAddressEqual,\n} from '../address/isAddressEqual.js'\nimport {\n  type RecoverTypedDataAddressParameters,\n  recoverTypedDataAddress,\n} from './recoverTypedDataAddress.js'\n\nexport type VerifyTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType> & {\n  /** The address to verify the typed data for. */\n  address: Address\n  /** The signature to verify */\n  signature: Hex | ByteArray | Signature\n}\n\nexport type VerifyTypedDataReturnType = boolean\n\nexport type VerifyTypedDataErrorType =\n  | IsAddressEqualErrorType\n  | GetAddressErrorType\n  | RecoverTypedDataAddressParameters\n  | ErrorType\n\n/**\n * Verify that typed data was signed by the provided address.\n *\n * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.\n *        It is highly recommended to use `publicClient.verifyTypedData` instead to ensure\n *        wallet interoperability.\n *\n * - Docs {@link https://viem.sh/docs/utilities/verifyTypedData}\n *\n * @param parameters - {@link VerifyTypedDataParameters}\n * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}\n */\nexport async function verifyTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: VerifyTypedDataParameters<typedData, primaryType>,\n): Promise<VerifyTypedDataReturnType> {\n  const { address, domain, message, primaryType, signature, types } =\n    parameters as unknown as VerifyTypedDataParameters\n  return isAddressEqual(\n    getAddress(address),\n    await recoverTypedDataAddress({\n      domain,\n      message,\n      primaryType,\n      signature,\n      types,\n    } as RecoverTypedDataAddressParameters),\n  )\n}\n","import type { Address, TypedData } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport { type HashTypedDataErrorType, hashTypedData } from './hashTypedData.js'\nimport {\n  type RecoverAddressErrorType,\n  recoverAddress,\n} from './recoverAddress.js'\n\nexport type RecoverTypedDataAddressParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType> & {\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverTypedDataAddressReturnType = Address\n\nexport type RecoverTypedDataAddressErrorType =\n  | RecoverAddressErrorType\n  | HashTypedDataErrorType\n  | ErrorType\n\nexport async function recoverTypedDataAddress<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: RecoverTypedDataAddressParameters<typedData, primaryType>,\n): Promise<RecoverTypedDataAddressReturnType> {\n  const { domain, message, primaryType, signature, types } =\n    parameters as unknown as RecoverTypedDataAddressParameters\n  return recoverAddress({\n    hash: hashTypedData({\n      domain,\n      message,\n      primaryType,\n      types,\n    }),\n    signature,\n  })\n}\n","// =============================================================================\r\n// METERED ENDPOINTS DATABASE\r\n// =============================================================================\r\n// Database layer for metered endpoints, payments, and usage tracking\r\n// Uses adapter pattern: SQLite (dev) or PostgreSQL (prod)\r\n\r\nimport { getDb } from './client';\r\nimport type { DatabaseAdapter } from './adapters/base-adapter';\r\n\r\n// Types\r\nexport interface MeteredEndpoint {\r\n  id: string;\r\n  name: string;\r\n  description?: string;\r\n  upstreamUrl: string;\r\n  price: string; // Price in smallest unit (e.g., 1000000 for 1 USDC)\r\n  network: string; // 'base', 'base-sepolia', etc.\r\n  tokenAddress: string; // USDC address\r\n  tokenSymbol: string; // 'USDC'\r\n  chainId: number;\r\n  recipientAddress: string; // Address that receives payments (must not be blacklisted)\r\n  status: 'active' | 'paused' | 'deleted';\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  createdBy?: string; // User/API key that created it\r\n}\r\n\r\nexport interface Payment {\r\n  id: string;\r\n  endpointId: string;\r\n  txHash: string;\r\n  fromAddress: string;\r\n  toAddress: string;\r\n  amount: string;\r\n  tokenAddress: string;\r\n  network: string;\r\n  verifiedAt: string;\r\n  kytStatus?: 'passed' | 'flagged' | 'blocked';\r\n  ofacStatus?: 'passed' | 'flagged' | 'blocked';\r\n  facilitator: string; // 'cdp', 'payai', etc.\r\n}\r\n\r\nexport interface UsageLog {\r\n  id: string;\r\n  endpointId: string;\r\n  paymentId?: string; // Link to payment if payment was required\r\n  timestamp: string;\r\n  method: string; // HTTP method\r\n  path: string;\r\n  statusCode: number;\r\n  responseTime: number; // milliseconds\r\n  units: number; // Usage units (could be 1 per call, or based on response size, etc.)\r\n  ipAddress?: string;\r\n  userAgent?: string;\r\n  // Observability fields\r\n  conversationId?: string; // Conversation/request ID for tracing\r\n  agentId?: string; // Agent ID that made the request\r\n  x402TxHash?: string; // x402 transaction hash\r\n  failureCode?: string; // Error code if request failed\r\n}\r\n\r\n// =============================================================================\r\n// ENDPOINTS CRUD\r\n// =============================================================================\r\n\r\nexport async function createEndpoint(\r\n  endpoint: Omit<MeteredEndpoint, 'id' | 'createdAt' | 'updatedAt'> & { id?: string }\r\n): Promise<MeteredEndpoint> {\r\n  const db = getDb();\r\n  return await db.createEndpoint(endpoint);\r\n}\r\n\r\nexport async function getEndpoint(endpointId: string): Promise<MeteredEndpoint | null> {\r\n  const db = getDb();\r\n  return await db.getEndpoint(endpointId);\r\n}\r\n\r\nexport async function listEndpoints(filters?: { status?: string; createdBy?: string }): Promise<MeteredEndpoint[]> {\r\n  const db = getDb();\r\n  return await db.listEndpoints(filters);\r\n}\r\n\r\nexport async function updateEndpoint(\r\n  endpointId: string,\r\n  updates: Partial<MeteredEndpoint>\r\n): Promise<MeteredEndpoint | null> {\r\n  const db = getDb();\r\n  return await db.updateEndpoint(endpointId, updates);\r\n}\r\n\r\nexport async function deleteEndpoint(endpointId: string): Promise<boolean> {\r\n  const db = getDb();\r\n  return await db.deleteEndpoint(endpointId);\r\n}\r\n\r\n// =============================================================================\r\n// PAYMENTS CRUD\r\n// =============================================================================\r\n\r\nexport async function createPayment(payment: Omit<Payment, 'id' | 'verifiedAt'>): Promise<Payment> {\r\n  const db = getDb();\r\n  return await db.createPayment(payment);\r\n}\r\n\r\nexport async function getPayment(paymentId: string): Promise<Payment | null> {\r\n  const db = getDb();\r\n  return await db.getPayment(paymentId);\r\n}\r\n\r\nexport async function getPaymentByTxHash(txHash: string): Promise<Payment | null> {\r\n  const db = getDb();\r\n  return await db.getPaymentByTxHash(txHash);\r\n}\r\n\r\nexport async function listPayments(filters?: { endpointId?: string; fromAddress?: string }): Promise<Payment[]> {\r\n  const db = getDb();\r\n  return await db.listPayments(filters);\r\n}\r\n\r\nexport async function getPaymentsForEndpoint(endpointId: string, limit: number = 100): Promise<Payment[]> {\r\n  const db = getDb();\r\n  return await db.getPaymentsForEndpoint(endpointId, limit);\r\n}\r\n\r\n// =============================================================================\r\n// USAGE LOGS CRUD\r\n// =============================================================================\r\n\r\nexport async function createUsageLog(log: Omit<UsageLog, 'id' | 'timestamp'>): Promise<UsageLog> {\r\n  const db = getDb();\r\n  return await db.createUsageLog(log);\r\n}\r\n\r\nexport async function listUsageLogs(filters?: { endpointId?: string; paymentId?: string }): Promise<UsageLog[]> {\r\n  const db = getDb();\r\n  return await db.listUsageLogs(filters);\r\n}\r\n\r\nexport async function getUsageStats(\r\n  endpointId: string,\r\n  startDate?: string,\r\n  endDate?: string\r\n): Promise<{\r\n  totalRequests: number;\r\n  totalPayments: number;\r\n  totalRevenue: string;\r\n  averageResponseTime: number;\r\n}> {\r\n  const db = getDb();\r\n  return await db.getUsageStats(endpointId, startDate, endDate);\r\n}\r\n","// =============================================================================\n// X402 CALL LOG\n// =============================================================================\n// Canonical x402 log event interface and logging utilities\n// Maps to UsageLog in database for persistence\n\nimport { createUsageLog, listUsageLogs, type UsageLog } from '@/db/metered-endpoints';\nimport { createLogger } from '@/lib/logger';\n\nconst logger = createLogger({ component: 'X402CallLog' });\n\n/**\n * Canonical x402 call log event\n * This interface represents the complete x402 payment flow for a single API call\n */\nexport interface X402CallLog {\n  id: string;\n  timestamp: string;\n  customerId: string | null;\n  endpointId: string;\n  agentId: string | null;\n  facilitator: string;\n  chainId: string;\n  asset: string;\n  amount: string;\n  status: 'success' | 'failed';\n  errorCode?: string;\n  x402TxHash?: string;\n  latencyMs: number;\n  resource: string;\n}\n\n/**\n * Convert X402CallLog to UsageLog for database persistence\n */\nfunction x402CallLogToUsageLog(x402Log: Omit<X402CallLog, 'id' | 'timestamp'>): Omit<UsageLog, 'id' | 'timestamp'> {\n  return {\n    endpointId: x402Log.endpointId,\n    method: 'POST', // Default for metered endpoints\n    path: new URL(x402Log.resource).pathname,\n    statusCode: x402Log.status === 'success' ? 200 : (x402Log.errorCode === 'PAYMENT_REQUIRED' ? 402 : 400),\n    responseTime: x402Log.latencyMs,\n    units: 1, // 1 unit per call\n    conversationId: x402Log.customerId || undefined,\n    agentId: x402Log.agentId || undefined,\n    x402TxHash: x402Log.x402TxHash || undefined,\n    failureCode: x402Log.status === 'failed' ? (x402Log.errorCode || 'UNKNOWN_ERROR') : undefined,\n  };\n}\n\n/**\n * Convert UsageLog back to X402CallLog for retrieval\n * This reconstructs the X402CallLog from the stored UsageLog\n */\nexport function usageLogToX402CallLog(usageLog: UsageLog, metadata?: {\n  facilitator?: string;\n  chainId?: string;\n  asset?: string;\n  amount?: string;\n  resource?: string;\n}): X402CallLog {\n  // Determine status from statusCode and failureCode\n  const status: 'success' | 'failed' = usageLog.statusCode === 200 && !usageLog.failureCode ? 'success' : 'failed';\n  \n  // Reconstruct resource URL from path\n  const appUrl = process.env.NEXT_PUBLIC_APP_URL;\n  const baseUrl = appUrl || (process.env.NODE_ENV === 'production' ? '' : 'http://localhost:3001');\n  // Ensure path starts with / (fix for paths like \"3001/api/...\" that should be \"/api/...\")\n  const normalizedPath = usageLog.path.startsWith('/') ? usageLog.path : `/${usageLog.path.replace(/^\\d+\\//, '')}`;\n  const resource = metadata?.resource || `${baseUrl}${normalizedPath}`;\n  \n  // Infer facilitator from verify mode if not provided in metadata\n  // This handles cases where facilitator wasn't stored in the database\n  let facilitator = metadata?.facilitator;\n  if (!facilitator) {\n    const verifyMode = process.env.X402_VERIFY_MODE?.toLowerCase();\n    if (verifyMode === 'cdp') {\n      facilitator = 'CDP';\n    } else if (verifyMode === 'test') {\n      facilitator = 'TEST_FACILITATOR';\n    } else {\n      facilitator = 'UNKNOWN';\n    }\n  }\n  \n  return {\n    id: usageLog.id,\n    timestamp: usageLog.timestamp,\n    customerId: usageLog.conversationId || null,\n    endpointId: usageLog.endpointId,\n    agentId: usageLog.agentId || null,\n    facilitator,\n    chainId: metadata?.chainId || 'eip155:8453',\n    asset: metadata?.asset || 'USDC_TEST',\n    amount: metadata?.amount || '10000',\n    status,\n    errorCode: usageLog.failureCode,\n    x402TxHash: usageLog.x402TxHash,\n    latencyMs: usageLog.responseTime,\n    resource,\n  };\n}\n\n/**\n * Query X402CallLog entries from the database\n * Filters by endpointId and optionally limits results\n */\nexport async function getX402CallLogs(\n  endpointId: string,\n  options?: {\n    limit?: number;\n    startDate?: string;\n    endDate?: string;\n  }\n): Promise<X402CallLog[]> {\n  try {\n    const usageLogs = await listUsageLogs({ endpointId });\n    \n    // Sort by timestamp descending (most recent first)\n    usageLogs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n    \n    // Apply date filters if provided\n    let filtered = usageLogs;\n    if (options?.startDate) {\n      filtered = filtered.filter(log => log.timestamp >= options.startDate!);\n    }\n    if (options?.endDate) {\n      filtered = filtered.filter(log => log.timestamp <= options.endDate!);\n    }\n    \n    // Apply limit\n    if (options?.limit) {\n      filtered = filtered.slice(0, options.limit);\n    }\n    \n    // Convert to X402CallLog\n    // Note: We lose some metadata (facilitator, chainId, asset, amount, resource) when converting back\n    // In a production system, we'd store these in the UsageLog or a separate metadata table\n    // For now, we use verify mode and heuristics to reconstruct:\n    // - Infer from X402_VERIFY_MODE first (most reliable) - ALWAYS use this when set\n    // - Test facilitator: if x402TxHash starts with 'TEST_'\n    // - CDP facilitator: if x402TxHash is a real transaction hash (starts with '0x')\n    // - Unknown: only if we can't determine from verify mode or txHash\n    const verifyMode = process.env.X402_VERIFY_MODE?.toLowerCase();\n    return filtered.map(log => {\n      let facilitator: string | undefined;\n      \n      // ALWAYS infer from verify mode first (most reliable)\n      // This ensures that when X402_VERIFY_MODE=cdp, all logs show facilitator: \"CDP\"\n      // even if there's no txHash (e.g., on errors)\n      if (verifyMode === 'cdp') {\n        facilitator = 'CDP';\n      } else if (verifyMode === 'test') {\n        facilitator = 'TEST_FACILITATOR';\n      }\n      \n      // If verify mode didn't set it, use heuristics from txHash as fallback\n      // (This handles cases where verify mode isn't set but we can infer from txHash)\n      if (!facilitator && log.x402TxHash) {\n        if (log.x402TxHash.startsWith('TEST_')) {\n          facilitator = 'TEST_FACILITATOR';\n        } else if (log.x402TxHash.startsWith('0x')) {\n          facilitator = 'CDP';\n        }\n      }\n      \n      // If still not set, usageLogToX402CallLog will infer from verify mode\n      // But we should have set it above if verify mode is configured\n      \n      return usageLogToX402CallLog(log, {\n        facilitator,\n        chainId: 'eip155:8453',\n        asset: 'USDC_TEST',\n        amount: '10000',\n        resource: (() => {\n          const appUrl = process.env.NEXT_PUBLIC_APP_URL;\n          const baseUrl = appUrl || (process.env.NODE_ENV === 'production' ? '' : 'http://localhost:3001');\n          const normalizedPath = log.path.startsWith('/') ? log.path : `/${log.path.replace(/^\\d+\\//, '')}`;\n          return `${baseUrl}${normalizedPath}`;\n        })(),\n      });\n    });\n  } catch (error) {\n    logger.error('Error querying x402 call logs', { error, endpointId });\n    throw error;\n  }\n}\n\n/**\n * Log an x402 call event to the database and structured logger\n * This is the canonical way to record x402 payment flows\n */\nexport async function logX402Call(x402Log: Omit<X402CallLog, 'id' | 'timestamp'>): Promise<X402CallLog> {\n  const timestamp = new Date().toISOString();\n  \n  // Log to structured logger (Pino)\n  logger.info('x402 call', {\n    endpointId: x402Log.endpointId,\n    facilitator: x402Log.facilitator,\n    chainId: x402Log.chainId,\n    asset: x402Log.asset,\n    amount: x402Log.amount,\n    status: x402Log.status,\n    errorCode: x402Log.errorCode,\n    x402TxHash: x402Log.x402TxHash,\n    latencyMs: x402Log.latencyMs,\n    resource: x402Log.resource,\n    customerId: x402Log.customerId,\n    agentId: x402Log.agentId,\n  });\n\n  // Persist to database via UsageLog\n  try {\n    const usageLogData = x402CallLogToUsageLog(x402Log);\n    console.log('X402_LOG_DEBUG', JSON.stringify(usageLogData, null, 2));\n    const usageLog = await createUsageLog(usageLogData);\n    \n    return {\n      id: usageLog.id,\n      timestamp: usageLog.timestamp,\n      customerId: x402Log.customerId,\n      endpointId: x402Log.endpointId,\n      agentId: x402Log.agentId,\n      facilitator: x402Log.facilitator,\n      chainId: x402Log.chainId,\n      asset: x402Log.asset,\n      amount: x402Log.amount,\n      status: x402Log.status,\n      errorCode: x402Log.errorCode,\n      x402TxHash: x402Log.x402TxHash,\n      latencyMs: x402Log.latencyMs,\n      resource: x402Log.resource,\n    };\n  } catch (error) {\n    // Log error but don't fail the request\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const errorDetails = error instanceof Error ? { \n      message: error.message, \n      stack: error.stack,\n      name: error.name \n    } : { error };\n    \n    console.error('X402_LOG_DB_ERROR', {\n      error: errorMessage,\n      errorDetails,\n      x402Log: {\n        endpointId: x402Log.endpointId,\n        status: x402Log.status,\n        facilitator: x402Log.facilitator,\n      }\n    });\n    \n    logger.error('Failed to persist x402 call log', { \n      error: errorMessage,\n      errorDetails,\n      x402Log: {\n        endpointId: x402Log.endpointId,\n        status: x402Log.status,\n        facilitator: x402Log.facilitator,\n      }\n    });\n    \n    // Return log with generated ID (for consistency, even if DB write failed)\n    return {\n      id: `temp-${Date.now()}`,\n      timestamp,\n      ...x402Log,\n    };\n  }\n}\n","import { getCDPFacilitator, type CDPVerifyRequest } from './cdp-facilitator';\r\nimport type { PaymentAuthorization } from './signature-verifier';\r\n\r\n/**\r\n * Parsed x402 payment header structure\r\n */\r\nexport interface ParsedPaymentHeader {\r\n  invoiceId: string;\r\n  txHash?: string;\r\n  signature: string;\r\n  authorization: PaymentAuthorization;\r\n  network?: string;\r\n}\r\n\r\n/**\r\n * Parse x402 payment header from HTTP header value\r\n * \r\n * x402 payment headers are typically base64-encoded JSON containing:\r\n * - signature: EIP-712 signature\r\n * - authorization: Payment authorization object\r\n * - network: Blockchain network identifier\r\n * \r\n * Format: x402 <base64-encoded-json>\r\n */\r\nexport function parseX402Header(headerValue: string): {\r\n  valid: boolean;\r\n  parsed?: ParsedPaymentHeader;\r\n  error?: string;\r\n} {\r\n  try {\r\n    // Validate header is not empty\r\n    if (!headerValue || headerValue.trim().length === 0) {\r\n      return { valid: false, error: 'Payment header is empty' };\r\n    }\r\n\r\n    // Check for placeholder values\r\n    if (headerValue.includes('<your_payment_header>') || headerValue.includes('<placeholder>')) {\r\n      return { valid: false, error: 'Payment header contains placeholder value. Please provide a real x402 payment header.' };\r\n    }\r\n\r\n    // Remove 'x402 ' prefix if present\r\n    const cleanHeader = headerValue.startsWith('x402 ')\r\n      ? headerValue.slice(5).trim()\r\n      : headerValue.trim();\r\n\r\n    if (cleanHeader.length === 0) {\r\n      return { valid: false, error: 'Payment header value is empty after removing prefix' };\r\n    }\r\n\r\n    // Decode base64 (works in both Node.js and browser environments)\r\n    let decoded: string;\r\n    try {\r\n      decoded = typeof window === 'undefined'\r\n        ? Buffer.from(cleanHeader, 'base64').toString('utf-8')\r\n        : atob(cleanHeader);\r\n    } catch (base64Error) {\r\n      return { \r\n        valid: false, \r\n        error: `Invalid base64 encoding: ${base64Error instanceof Error ? base64Error.message : 'Failed to decode base64'}` \r\n      };\r\n    }\r\n\r\n    // Parse JSON\r\n    let payload: {\r\n      signature?: string;\r\n      authorization?: {\r\n        from?: string;\r\n        to?: string;\r\n        value?: string;\r\n        validAfter?: string;\r\n        validBefore?: string;\r\n        nonce?: string;\r\n      };\r\n      network?: string;\r\n      invoiceId?: string;\r\n      txHash?: string;\r\n    };\r\n    \r\n    try {\r\n      payload = JSON.parse(decoded);\r\n    } catch (jsonError) {\r\n      return { \r\n        valid: false, \r\n        error: `Invalid JSON in payment header: ${jsonError instanceof Error ? jsonError.message : 'Failed to parse JSON'}. Decoded value: ${decoded.substring(0, 100)}` \r\n      };\r\n    }\r\n\r\n    // Validate required fields\r\n    if (!payload.signature) {\r\n      return { valid: false, error: 'Missing signature in payment header' };\r\n    }\r\n\r\n    if (!payload.authorization) {\r\n      return { valid: false, error: 'Missing authorization in payment header' };\r\n    }\r\n\r\n    const auth = payload.authorization;\r\n    if (!auth.from || !auth.to || !auth.value || !auth.nonce) {\r\n      return { valid: false, error: 'Incomplete authorization fields' };\r\n    }\r\n\r\n    return {\r\n      valid: true,\r\n      parsed: {\r\n        invoiceId: payload.invoiceId || auth.nonce,\r\n        txHash: payload.txHash,\r\n        signature: payload.signature,\r\n        authorization: {\r\n          from: auth.from as `0x${string}`,\r\n          to: auth.to as `0x${string}`,\r\n          value: auth.value,\r\n          validAfter: auth.validAfter || Math.floor(Date.now() / 1000).toString(),\r\n          validBefore: auth.validBefore || (Math.floor(Date.now() / 1000) + 300).toString(),\r\n          nonce: auth.nonce,\r\n        },\r\n        network: payload.network || 'base',\r\n      },\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      valid: false,\r\n      error: error instanceof Error ? error.message : 'Failed to parse payment header',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Parse and verify x402 payment header with CDP facilitator\r\n * \r\n * This function:\r\n * 1. Parses the payment header\r\n * 2. Verifies the payment with CDP\r\n * 3. Returns the verification result\r\n */\r\nexport async function parseAndVerifyPaymentHeader(\r\n  headerValue: string\r\n): Promise<{\r\n  valid: boolean;\r\n  payment?: ParsedPaymentHeader;\r\n  transactionHash?: string;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    // Parse the header\r\n    const parseResult = parseX402Header(headerValue);\r\n    if (!parseResult.valid || !parseResult.parsed) {\r\n      return {\r\n        valid: false,\r\n        error: parseResult.error || 'Invalid payment header format',\r\n      };\r\n    }\r\n\r\n    const parsed = parseResult.parsed;\r\n\r\n    // Create CDP verify request\r\n    const verifyRequest: CDPVerifyRequest = {\r\n      payment: headerValue,\r\n      paymentPayload: {\r\n        x402Version: 1,\r\n        scheme: 'x402',\r\n        network: parsed.network || 'base',\r\n        payload: {\r\n          signature: parsed.signature,\r\n          authorization: parsed.authorization,\r\n        },\r\n      },\r\n    };\r\n\r\n    // Verify with CDP\r\n    const cdp = getCDPFacilitator();\r\n    const verifyResult = await cdp.verifyPayment(verifyRequest);\r\n\r\n    if (!verifyResult.valid || !verifyResult.success) {\r\n      return {\r\n        valid: false,\r\n        error: verifyResult.error || 'Payment verification failed',\r\n      };\r\n    }\r\n\r\n    return {\r\n      valid: true,\r\n      payment: parsed,\r\n      transactionHash: verifyResult.transactionHash,\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      valid: false,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    };\r\n  }\r\n}\r\n\r\n","// =============================================================================\r\n// TEST-ONLY X402 VERIFICATION\r\n// =============================================================================\r\n// Fake x402 verification helper for safe testing without real funds\r\n// DO NOT USE IN PRODUCTION - This bypasses all real payment verification\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport { createLogger } from '@/lib/logger';\r\n\r\nconst logger = createLogger({ component: 'TestX402Verification' });\r\n\r\n/**\r\n * Test-only verification result\r\n */\r\nexport interface TestVerificationResult {\r\n  success: boolean;\r\n  x402TxHash?: string;\r\n  facilitator?: string;\r\n  errorCode?: string;\r\n}\r\n\r\n/**\r\n * Test token header name\r\n */\r\nexport const TEST_TOKEN_HEADER = 'x-easepay-test-token';\r\n\r\n/**\r\n * Test token value that enables fake verification\r\n */\r\nexport const TEST_TOKEN_VALUE = 'demo-ok';\r\n\r\n/**\r\n * Verify payment in test mode only\r\n * \r\n * Checks for test header or config flag and returns fake success\r\n * DO NOT call real CDP/x402 verify in this path\r\n * \r\n * @param request - Next.js request object\r\n * @returns Test verification result\r\n */\r\nexport function verifyPaymentTestOnly(request: NextRequest): TestVerificationResult {\r\n  // Check for test token header\r\n  const testToken = request.headers.get(TEST_TOKEN_HEADER) || \r\n                    request.headers.get(TEST_TOKEN_HEADER.toUpperCase());\r\n  \r\n  // Check for config flag (environment variable)\r\n  const testModeEnabled = process.env.X402_TEST_MODE === 'true' || \r\n                         process.env.EASEPAY_TEST_MODE === 'true';\r\n  \r\n  if (testToken === TEST_TOKEN_VALUE || testModeEnabled) {\r\n    logger.info('Test payment verification passed', {\r\n      testToken: testToken === TEST_TOKEN_VALUE ? 'present' : 'missing',\r\n      testModeEnabled,\r\n    });\r\n    \r\n    return {\r\n      success: true,\r\n      x402TxHash: 'TEST_TX_HASH',\r\n      facilitator: 'TEST_FACILITATOR',\r\n    };\r\n  }\r\n  \r\n  // No test token or flag - payment required\r\n  logger.info('Test payment verification failed - no test token', {\r\n    testToken: testToken || 'missing',\r\n    testModeEnabled,\r\n  });\r\n  \r\n  return {\r\n    success: false,\r\n    errorCode: 'PAYMENT_REQUIRED',\r\n  };\r\n}\r\n\r\n/**\r\n * Check if test mode is enabled\r\n */\r\nexport function isTestModeEnabled(): boolean {\r\n  return process.env.X402_TEST_MODE === 'true' || \r\n         process.env.EASEPAY_TEST_MODE === 'true';\r\n}\r\n\r\n\r\n"],"names":[],"mappings":"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","ignoreList":[2,3,4]}